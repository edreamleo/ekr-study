<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20241212164559.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735803000000302e3271067d7107580b0000005f5f626f6f6b6d61726b7371087d7109580700000069735f64757065710a4930300a73735803000000302e34710b7d710c5808000000616e6e6f74617465710d7d710e2858080000007072696f72697479710f4d0f27580a000000707269736574646174657110580a000000323032312d30332d333071117573752e"><vh>Startup</vh>
<v t="ekr.20241212164559.3" descendentVnodeUnknownAttributes="7d710058010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a7373732e"><vh>@settings</vh>
<v t="ekr.20241212164559.5"><vh>@bool check-python-code-on-write = True</vh></v>
<v t="ekr.20241212164559.305"><vh>@data history-list</vh></v>
<v t="ekr.20241224161542.1"><vh>@int qweb-view-font-size = 16</vh></v>
<v t="ekr.20241212164559.306"><vh>@string qt-layout-name = horizontal-thirds</vh></v>
<v t="ekr.20241212164559.217"><vh>Buttons &amp; commands</vh>
<v t="ekr.20241212164559.223"><vh>@button backup</vh></v>
<v t="ekr.20241217065902.1"><vh>@button close-figures</vh></v>
<v t="ekr.20241212164526.14"><vh>@button exec-py-file</vh></v>
<v t="ekr.20241212164526.17"><vh>@command import-ipynb</vh></v>
<v t="ekr.20241218050405.3"><vh>@command toggle-plot-tab</vh>
<v t="ekr.20241218050659.1"><vh>&lt;&lt; PlotWindow imports &gt;&gt;</vh></v>
<v t="ekr.20241218050405.2"><vh>class PlotWindow</vh></v>
</v>
</v>
<v t="ekr.20241212164559.117"><vh>Coloring settings</vh>
<v t="ekr.20241212164559.118"><vh>@bool color-doc-parts-as-rest = True</vh></v>
<v t="ekr.20241212164559.119"><vh>@bool use-pygments = False</vh></v>
<v t="ekr.20241212164559.120"><vh>@bool use-pygments-styles = False</vh></v>
<v t="ekr.20241212164559.121"><vh>@color head-bg = @mistyrose2</vh></v>
<v t="ekr.20241212164559.122"><vh>@string pygments-style-name = leonine</vh></v>
<v t="ekr.20241212164559.302"><vh>@string target-language = python</vh></v>
</v>
<v t="ekr.20241212164559.204"><vh>Syntax coloring settings</vh>
<v t="ekr.20241212164559.205"><vh>@@color rest.keyword2 = red</vh></v>
<v t="ekr.20241212164559.206"><vh>@@color rest.keyword4 = blue</vh></v>
<v t="ekr.20241212164559.207"><vh>@@color rest.leokeyword = green</vh></v>
<v t="ekr.20241212164559.208"><vh>@color forth.keyword3 = black</vh></v>
<v t="ekr.20241212164559.209"><vh>@color python.name = @solarized-yellow</vh></v>
<v t="ekr.20241212164559.210"><vh>@font rest.comment1</vh></v>
</v>
</v>
<v t="ekr.20241212164559.217"></v>
<v t="ekr.20241212164559.270" descendentVnodeUnknownAttributes="7d710058010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a7373732e"><vh>Scripts</vh>
<v t="ekr.20241212164559.303"><vh> Recursive import script</vh></v>
</v>
<v t="ekr.20241212164559.305"></v>
<v t="ekr.20241212164559.307" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032312d30332d333071077573732e"><vh>@enabled-plugins</vh></v>
<v t="ekr.20241224161542.1"></v>
<v t="ekr.20241212164559.306"></v>
<v t="ekr.20241212164559.302"></v>
</v>
<v t="ekr.20241212171838.1"><vh>Files</vh>
<v t="ekr.20241218004929.1"><vh>--- Converted ipynb files</vh>
<v t="ekr.20241218004929.2"><vh>CH01</vh>
<v t="ekr.20241212122548.3"><vh>@file Python/CH01/CH01_SEC02.py</vh></v>
<v t="ekr.20241212100513.9"><vh>@file Python/CH01/CH01_SEC03_Rotation.py</vh></v>
<v t="ekr.20241212100513.14"><vh>@file Python/CH01\CH01_SEC04_1_Linear.py</vh></v>
<v t="ekr.20241212100513.18"><vh>@file Python/CH01\CH01_SEC04_2_Cement.py</vh></v>
<v t="ekr.20241212100513.23"><vh>@file Python/CH01\CH01_SEC04_3_Housing.py</vh></v>
<v t="ekr.20241212100513.27"><vh>@file Python/CH01\CH01_SEC05_1_PCAGaussian.py</vh></v>
<v t="ekr.20241212100513.31"><vh>@file Python/CH01\CH01_SEC05_2_OvarianCancer.py</vh></v>
<v t="ekr.20241212100513.35"><vh>@file Python/CH01\CH01_SEC06_1.py</vh></v>
<v t="ekr.20241212100513.39"><vh>@file Python/CH01\CH01_SEC06_2_3_4.py</vh></v>
<v t="ekr.20241212100513.45"><vh>@file Python/CH01\CH01_SEC07_1.py</vh></v>
<v t="ekr.20241212100514.1"><vh>@file Python/CH01\CH01_SEC07_2.py</vh></v>
<v t="ekr.20241212100514.8"><vh>@file Python/CH01\CH01_SEC07_3.py</vh></v>
<v t="ekr.20241212100514.13"><vh>@file Python/CH01\CH01_SEC08_RSVD.py</vh></v>
<v t="ekr.20241212100514.21"><vh>@@@file Python/CH01\CH01_SEC09_Tensor.py</vh>
<v t="ekr.20241212100514.23"><vh>animation</vh></v>
<v t="ekr.20241212100514.24"><vh>plot 1</vh></v>
<v t="ekr.20241212100514.25"><vh>plot 2</vh></v>
</v>
</v>
<v t="ekr.20241218004929.80"><vh>CH02</vh>
<v t="ekr.20241218004929.81"><vh># @file CH02\CH02_SEC01_0_InnerProduct.py</vh>
<v t="ekr.20241218004929.83"><vh>import numpy as np</vh></v>
</v>
<v t="ekr.20241218004929.84"><vh># @file CH02\CH02_SEC01_1_FourierSines.py</vh>
<v t="ekr.20241218004929.86"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004929.87"><vh># Plot amplitudes</vh></v>
<v t="ekr.20241218004929.88"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241218004929.89"><vh># @file CH02\CH02_SEC01_2_Gibbs.py</vh>
<v t="ekr.20241218004929.91"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004929.92"><vh>Cell 2</vh></v>
<v t="ekr.20241218004929.93"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241218004929.94"><vh># @file CH02\CH02_SEC01_2_Gibbs_Movie.py</vh>
<v t="ekr.20241218004929.96"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004929.97"><vh>Cell 2</vh></v>
<v t="ekr.20241218004929.98"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241218004929.99"><vh># @file CH02\CH02_SEC02_1_DFT.py</vh>
<v t="ekr.20241218004929.101"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004929.102"><vh>DFT = np.zeros((n,n))</vh></v>
<v t="ekr.20241218004929.103"><vh>Fast</vh></v>
<v t="ekr.20241218004929.104"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241218004929.105"><vh># @file CH02\CH02_SEC02_2_Denoise.py</vh>
<v t="ekr.20241218004929.107"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004929.108"><vh># Compute the Fast Fourier Transform</vh></v>
<v t="ekr.20241218004929.109"><vh># Use the PSD to filter out noise</vh></v>
<v t="ekr.20241218004929.110"><vh># Plots</vh></v>
</v>
<v t="ekr.20241218004929.111"><vh># @file CH02\CH02_SEC02_3_SpectralDerivative.py</vh>
<v t="ekr.20241218004929.113"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004929.114"><vh># Approximate derivative using finite</vh></v>
<v t="ekr.20241218004929.115"><vh># Derivative using FFT (spectral</vh></v>
<v t="ekr.20241218004929.116"><vh># Plots</vh></v>
<v t="ekr.20241218004929.117"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241218004929.118"><vh># @file CH02\CH02_SEC03_1_FFTHeat.py</vh>
<v t="ekr.20241218004929.120"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004929.121"><vh>Cell 2</vh></v>
</v>
<v t="ekr.20241218004929.122"><vh># @file CH02\CH02_SEC03_2_FFTWave.py</vh>
<v t="ekr.20241218004929.124"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004929.125"><vh>Cell 2</vh></v>
</v>
<v t="ekr.20241218004930.1"><vh># @file CH02\CH02_SEC03_3_FFTBurgers.py</vh>
<v t="ekr.20241218004930.3"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.4"><vh>Cell 2</vh></v>
</v>
<v t="ekr.20241218004930.5"><vh># @file CH02\CH02_SEC04_1_SpectrogramChirp.py</vh>
<v t="ekr.20241218004930.7"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.8"><vh>Cell 2</vh></v>
<v t="ekr.20241218004930.9"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241218004930.10"><vh># @file CH02\CH02_SEC05_HAAR.py</vh>
<v t="ekr.20241218004930.12"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.13"><vh>x = np.arange(-5,5,0.001)</vh></v>
<v t="ekr.20241218004930.14"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241218004930.15"><vh># @file CH02\CH02_SEC06_1_2DFFT.py</vh>
<v t="ekr.20241218004930.17"><vh>from matplotlib.image import imread</vh></v>
<v t="ekr.20241218004930.18"><vh>Cell 2</vh></v>
</v>
<v t="ekr.20241218004930.19"><vh># @file CH02\CH02_SEC06_2_Compress.py</vh>
<v t="ekr.20241218004930.21"><vh>from matplotlib.image import imread</vh></v>
<v t="ekr.20241218004930.22"><vh>Cell 2</vh></v>
<v t="ekr.20241218004930.23"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241218004930.24"><vh># @file CH02\CH02_SEC06_3_Denoise.py</vh>
<v t="ekr.20241218004930.26"><vh>from matplotlib.image import imread</vh></v>
<v t="ekr.20241218004930.27"><vh># Denoise</vh></v>
</v>
<v t="ekr.20241218004930.28"><vh># @file CH02\CH02_SEC06_4_Wavelet.py</vh>
<v t="ekr.20241218004930.30"><vh>Using the PyWavelets module, available</vh></v>
<v t="ekr.20241218004930.31"><vh># Wavelet decomposition (2 level)</vh></v>
</v>
<v t="ekr.20241218004930.32"><vh># @file CH02\CH02_SEC06_5_WaveletCompress.py</vh>
<v t="ekr.20241218004930.34"><vh>Using the PyWavelets module, available</vh></v>
<v t="ekr.20241218004930.35"><vh># Wavelet Compression</vh></v>
</v>
</v>
<v t="ekr.20241218004930.36"><vh>CH03</vh>
<v t="ekr.20241218004930.37"><vh># @file CH03\CH03_SEC01_Compress.py</vh>
<v t="ekr.20241218004930.39"><vh>from matplotlib.image import imread</vh></v>
<v t="ekr.20241218004930.40"><vh># Compute FFT of image using fft2</vh></v>
<v t="ekr.20241218004930.41"><vh># Zero out all small coefficients and</vh></v>
<v t="ekr.20241218004930.42"><vh># Plot Reconstruction</vh></v>
<v t="ekr.20241218004930.43"><vh>plt.rcParams['figure.figsize'] = [16, 8]</vh></v>
<v t="ekr.20241218004930.44"><vh>Cell 6</vh></v>
<v t="ekr.20241218004930.45"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241218004930.46"><vh># @file CH03\CH03_SEC03_1_Underdetermined.py</vh>
<v t="ekr.20241218004930.48"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.49"><vh>L2 Minimum norm solution s_L2</vh></v>
<v t="ekr.20241218004930.50"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241218004930.51"><vh>Cell 4</vh></v>
<v t="ekr.20241218004930.52"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241218004930.53"><vh># @file CH03\CH03_SEC03_2_AudioCS.py</vh>
<v t="ekr.20241218004930.55"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.56"><vh># Generate signal, DCT of signal</vh></v>
<v t="ekr.20241218004930.57"><vh># Randomly sample signal</vh></v>
<v t="ekr.20241218004930.58"><vh># Solve compressed sensing problem</vh></v>
<v t="ekr.20241218004930.59"><vh># Plot</vh></v>
<v t="ekr.20241218004930.60"><vh># L1-Minimization using SciPy</vh></v>
<v t="ekr.20241218004930.61"><vh>Theta.shape</vh></v>
<v t="ekr.20241218004930.62"><vh>y.shape</vh></v>
<v t="ekr.20241218004930.63"><vh>Cell 9</vh></v>
</v>
<v t="ekr.20241218004930.64"><vh># @file CH03\CH03_SEC04_Matrices.py</vh>
<v t="ekr.20241218004930.66"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.67"><vh># Plot Psi</vh></v>
<v t="ekr.20241218004930.68"><vh># Plot C</vh></v>
<v t="ekr.20241218004930.69"><vh># Plot Theta</vh></v>
<v t="ekr.20241218004930.70"><vh># Plot s, y</vh></v>
<v t="ekr.20241218004930.71"><vh># L1-Minimization using SciPy</vh></v>
<v t="ekr.20241218004930.72"><vh># Plot C and Theta (2) - Gaussian Random</vh></v>
<v t="ekr.20241218004930.73"><vh>Plot C and Theta (3) - Bernoulli Random</vh></v>
<v t="ekr.20241218004930.74"><vh>Plot C and Theta (4) - Sparse Bernoulli</vh></v>
<v t="ekr.20241218004930.75"><vh>Bad C and Theta (5) - DCT Meas</vh></v>
<v t="ekr.20241218004930.76"><vh>Cell 11</vh></v>
<v t="ekr.20241218004930.77"><vh>Cell 12</vh></v>
<v t="ekr.20241218004930.78"><vh>Cell 13</vh></v>
</v>
<v t="ekr.20241218004930.79"><vh># @file CH03\CH03_SEC05_1_RobustRegression.py</vh>
<v t="ekr.20241218004930.81"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.82"><vh>Random data from [-2,2]</vh></v>
<v t="ekr.20241218004930.83"><vh># L1 optimization to reject outlier</vh></v>
<v t="ekr.20241218004930.84"><vh>Data</vh></v>
<v t="ekr.20241218004930.85"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241218004930.86"><vh># @file CH03\CH03_SEC05_2_LASSO.py</vh>
<v t="ekr.20241218004930.88"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.89"><vh>Matrix of possible predictors</vh></v>
<v t="ekr.20241218004930.90"><vh>reg = linear_model.LassoCV(cv=10).fit(A,</vh></v>
<v t="ekr.20241218004930.91"><vh>XL1 = linear_model.Lasso(alpha=clf.best_</vh></v>
<v t="ekr.20241218004930.92"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241218004930.93"><vh># @file CH03\CH03_SEC06_SparseRepresentation.py</vh>
<v t="ekr.20241218004930.95"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.96"><vh># Build Training and Test sets</vh></v>
<v t="ekr.20241218004930.97"><vh># Downsample Training Images (Build</vh></v>
<v t="ekr.20241218004930.98"><vh># Renormalize Columns of Theta</vh></v>
<v t="ekr.20241218004930.99"><vh># Occlude Test Image (Test[:,125] = test</vh></v>
<v t="ekr.20241218004930.100"><vh># Downsample Test Images</vh></v>
<v t="ekr.20241218004930.101"><vh># L1 Search, Testclean</vh></v>
<v t="ekr.20241218004930.102"><vh>plt.figure()</vh></v>
<v t="ekr.20241218004930.103"><vh># L1 Search, Mustache</vh></v>
<v t="ekr.20241218004930.104"><vh>plt.figure()</vh></v>
<v t="ekr.20241218004930.105"><vh># L1 Search, Occlusion</vh></v>
<v t="ekr.20241218004930.106"><vh>plt.figure()</vh></v>
<v t="ekr.20241218004930.107"><vh># L1 Search, Noise</vh></v>
<v t="ekr.20241218004930.108"><vh>plt.figure()</vh></v>
<v t="ekr.20241218004930.109"><vh># Least Squares Is No Good</vh></v>
<v t="ekr.20241218004930.110"><vh>Cell 16</vh></v>
<v t="ekr.20241218004930.111"><vh>Cell 17</vh></v>
</v>
<v t="ekr.20241218004930.112"><vh># @file CH03\CH03_SEC07_RPCA.py</vh>
<v t="ekr.20241218004930.114"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.115"><vh># Function Definitions</vh></v>
<v t="ekr.20241218004930.116"><vh>X = faces[:,:nfaces[0]]</vh></v>
<v t="ekr.20241218004930.117"><vh>inds = (3,4,14,15,17,18,19,20,21,32,43)</vh></v>
<v t="ekr.20241218004930.118"><vh>Cell 5</vh></v>
<v t="ekr.20241218004930.119"><vh>Cell 6</vh></v>
</v>
</v>
<v t="ekr.20241218004930.120"><vh>CH04</vh>
<v t="ekr.20241218004930.121"><vh># @file CH04\CH04_SEC01_LinearRegression.py</vh>
<v t="ekr.20241218004930.123"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.124"><vh>The data</vh></v>
<v t="ekr.20241218004930.125"><vh>x = np.arange(1,11)</vh></v>
<v t="ekr.20241218004930.126"><vh>Cell 4</vh></v>
<v t="ekr.20241218004930.127"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241218004930.128"><vh># @file CH04\CH04_SEC02_1_GradientDescent.py</vh>
<v t="ekr.20241218004930.130"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.131"><vh>h = 0.5</vh></v>
<v t="ekr.20241218004930.132"><vh>rcParams['figure.figsize'] = [16, 8]</vh></v>
<v t="ekr.20241218004930.133"><vh>rcParams['figure.figsize'] = [16, 16]</vh></v>
<v t="ekr.20241218004930.134"><vh># Gradient Descent</vh></v>
<v t="ekr.20241218004930.135"><vh>fig,ax = plt.subplots(1,1,subplot_kw={'p</vh></v>
<v t="ekr.20241218004930.136"><vh># Computing the gradient descent with</vh></v>
<v t="ekr.20241218004930.137"><vh>rcParams['figure.figsize'] = [12, 8]</vh></v>
<v t="ekr.20241218004930.138"><vh>fig,ax = plt.subplots(1,1,subplot_kw={'p</vh></v>
<v t="ekr.20241218004930.139"><vh># Alternating Descent</vh></v>
<v t="ekr.20241218004930.140"><vh>rcParams['figure.figsize'] = [12, 8]</vh></v>
<v t="ekr.20241218004930.141"><vh>fig,ax = plt.subplots(1,1,subplot_kw={'p</vh></v>
<v t="ekr.20241218004930.142"><vh>Cell 13</vh></v>
</v>
<v t="ekr.20241218004930.143"><vh># @file CH04\CH04_SEC03_1_OverUnderDetermined.py</vh>
<v t="ekr.20241218004930.145"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.146"><vh>Underdetermined</vh></v>
<v t="ekr.20241218004930.147"><vh>plt.rcParams['figure.figsize'] = [12, 8]</vh></v>
<v t="ekr.20241218004930.148"><vh>Overdetermined</vh></v>
<v t="ekr.20241218004930.149"><vh># Matrix Overdetermined System</vh></v>
<v t="ekr.20241218004930.150"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241218004930.151"><vh># @file CH04\CH04_SEC04_1_CompareRegression.py</vh>
<v t="ekr.20241218004930.153"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.154"><vh>n = 100</vh></v>
<v t="ekr.20241218004930.155"><vh># Different regressions</vh></v>
<v t="ekr.20241218004930.156"><vh>plt.rcParams['figure.figsize'] = [12,</vh></v>
<v t="ekr.20241218004930.157"><vh>M = 10</vh></v>
<v t="ekr.20241218004930.158"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241218004930.159"><vh># @file CH04\CH04_SEC05_0_Fig4p16_Pareto.py</vh>
<v t="ekr.20241218004930.161"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.162"><vh>fig,ax = plt.subplots(1)</vh></v>
<v t="ekr.20241218004930.163"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241218004930.164"><vh># @file CH04\CH04_SEC05_1_CrossValidate.py</vh>
<v t="ekr.20241218004930.166"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.167"><vh>n = 200</vh></v>
<v t="ekr.20241218004930.168"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241218004930.169"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241218004930.170"><vh># @file CH04\CH04_SEC06_1_kFoldValidation.py</vh>
<v t="ekr.20241218004930.172"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.173"><vh>n = 100</vh></v>
<v t="ekr.20241218004930.174"><vh>plt.rcParams['figure.figsize'] = [8,8]</vh></v>
<v t="ekr.20241218004930.175"><vh>n = 200</vh></v>
<v t="ekr.20241218004930.176"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241218004930.177"><vh># @file CH04\CH04_SEC07_1_ModelValidation.py</vh>
<v t="ekr.20241218004930.179"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.180"><vh>n = 10000</vh></v>
<v t="ekr.20241218004930.181"><vh>generate PDFs</vh></v>
<v t="ekr.20241218004930.182"><vh>Compute integrand</vh></v>
<v t="ekr.20241218004930.183"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241218004930.184"><vh># @file CH04\CH04_SEC07_2_RegressAIC_BIC.py</vh>
<v t="ekr.20241218004930.186"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.187"><vh>for random data reproducibility</vh></v>
<v t="ekr.20241218004930.188"><vh>Cell 3</vh></v>
</v>
</v>
<v t="ekr.20241218004930.189"><vh>CH05</vh>
<v t="ekr.20241218004930.190"><vh># @file CH05\CH05_SEC01_1_FischerExtraction.py</vh>
<v t="ekr.20241218004930.192"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.193"><vh>fisheriris_mat = io.loadmat(os.path.join</vh></v>
<v t="ekr.20241218004930.194"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241218004930.195"><vh>dogdata_mat = io.loadmat(os.path.join('.</vh></v>
<v t="ekr.20241218004930.196"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241218004930.197"><vh>fig,axs = plt.subplots(4,1)</vh></v>
<v t="ekr.20241218004930.198"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241218004930.199"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241218004930.200"><vh>fig,axs = plt.subplots(4,1)</vh></v>
<v t="ekr.20241218004930.201"><vh>xbin = np.linspace(-0.25,0.25,20)</vh></v>
<v t="ekr.20241218004930.202"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241218004930.203"><vh>master = np.zeros((32*5,32*4))</vh></v>
<v t="ekr.20241218004930.204"><vh>master = np.zeros((32*5,32*4))</vh></v>
<v t="ekr.20241218004930.205"><vh>Cell 14</vh></v>
</v>
<v t="ekr.20241218004930.206"><vh># @file CH05\CH05_SEC02_1_Fig5p7_Fig5p8.py</vh>
<v t="ekr.20241218004930.208"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.209"><vh>Training and test set sizes</vh></v>
<v t="ekr.20241218004930.210"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241218004930.211"><vh>training set size</vh></v>
<v t="ekr.20241218004930.212"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241218004930.213"><vh># @file CH05\CH05_SEC03_1_Kmeans.py</vh>
<v t="ekr.20241218004930.215"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.216"><vh>Training and testing set sizes</vh></v>
<v t="ekr.20241218004930.217"><vh>plt.figure()</vh></v>
<v t="ekr.20241218004930.218"><vh>Training set: first 200 of 240 points</vh></v>
<v t="ekr.20241218004930.219"><vh>Initial guess</vh></v>
<v t="ekr.20241218004930.220"><vh>kmeans code</vh></v>
<v t="ekr.20241218004930.221"><vh>midx = (c[0,0]+c[1,0])/2</vh></v>
<v t="ekr.20241218004930.222"><vh># Dendrograms</vh></v>
<v t="ekr.20241218004930.223"><vh>plt.bar(range(100),dn['leaves'])</vh></v>
<v t="ekr.20241218004930.224"><vh>Cell 10</vh></v>
</v>
<v t="ekr.20241218004930.225"><vh># @file CH05\CH05_SEC04_1_Dendrogram.py</vh>
<v t="ekr.20241218004930.227"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.228"><vh>Training and testing set sizes</vh></v>
<v t="ekr.20241218004930.229"><vh>plt.figure()</vh></v>
<v t="ekr.20241218004930.230"><vh>Training set: first 200 of 240 points</vh></v>
<v t="ekr.20241218004930.231"><vh># Dendrograms</vh></v>
<v t="ekr.20241218004930.232"><vh>plt.bar(range(100),dn['leaves'])</vh></v>
<v t="ekr.20241218004930.233"><vh>thresh = 0.25*np.max(Z[:,2])</vh></v>
<v t="ekr.20241218004930.234"><vh>Cell 8</vh></v>
<v t="ekr.20241218004930.235"><vh>Cell 9</vh></v>
</v>
<v t="ekr.20241218004930.236"><vh># @file CH05\CH05_SEC05_1_GaussianMixtureModels.py</vh>
<v t="ekr.20241218004930.238"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004930.239"><vh>dogdata_w_mat = io.loadmat(os.path.join(</vh></v>
<v t="ekr.20241218004930.240"><vh>dogcat = v[:,(1,3)]</vh></v>
<v t="ekr.20241218004930.241"><vh>ax = plt.axes(projection='3d')</vh></v>
<v t="ekr.20241218004930.242"><vh># AIC Scores</vh></v>
<v t="ekr.20241218004930.243"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241218004931.1"><vh># @file CH05\CH05_SEC06_1_LDA_Classify.py</vh>
<v t="ekr.20241218004931.3"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.4"><vh>dogdata_w_mat = io.loadmat(os.path.join(</vh></v>
<v t="ekr.20241218004931.5"><vh>xtrain = np.concatenate((v[:60,np.array(</vh></v>
<v t="ekr.20241218004931.6"><vh>plt.rcParams['figure.figsize'] = [8,4]</vh></v>
<v t="ekr.20241218004931.7"><vh>dogdata_mat = io.loadmat(os.path.join('.</vh></v>
<v t="ekr.20241218004931.8"><vh>plt.rcParams['figure.figsize'] = [12,</vh></v>
<v t="ekr.20241218004931.9"><vh># Cross-validate</vh></v>
<v t="ekr.20241218004931.10"><vh>dogdata_w_mat = io.loadmat(os.path.join(</vh></v>
<v t="ekr.20241218004931.11"><vh>plt.rcParams['figure.figsize'] = [12, 6]</vh></v>
<v t="ekr.20241218004931.12"><vh>Cell 10</vh></v>
</v>
<v t="ekr.20241218004931.13"><vh># @file CH05\CH05_SEC07_1_SVM.py</vh>
<v t="ekr.20241218004931.15"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.16"><vh>Random ellipse 1</vh></v>
<v t="ekr.20241218004931.17"><vh>z1 = np.power(x1,2) * y1</vh></v>
<v t="ekr.20241218004931.18"><vh>r = 7 + np.random.randn(n1)</vh></v>
<v t="ekr.20241218004931.19"><vh>Classify dogs vs. cats</vh></v>
<v t="ekr.20241218004931.20"><vh>features = np.arange(1,21)</vh></v>
<v t="ekr.20241218004931.21"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241218004931.22"><vh># @file CH05\CH05_SEC08_1_Trees.py</vh>
<v t="ekr.20241218004931.24"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.25"><vh>fisheriris_mat = io.loadmat(os.path.join</vh></v>
<v t="ekr.20241218004931.26"><vh>setosa</vh></v>
<v t="ekr.20241218004931.27"><vh>dogs vs. cats</vh></v>
<v t="ekr.20241218004931.28"><vh># Census Data</vh></v>
<v t="ekr.20241218004931.29"><vh># Splitting Procedure</vh></v>
<v t="ekr.20241218004931.30"><vh>plt.plot(x1[:,0],x1[:,1],'o',markerfacec</vh></v>
<v t="ekr.20241218004931.31"><vh>Cell 8</vh></v>
</v>
</v>
<v t="ekr.20241218004931.32"><vh>CH06</vh>
<v t="ekr.20241218004931.33"><vh># @file CH06\CH06_SEC01_1_NN.py</vh>
<v t="ekr.20241218004931.35"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.36"><vh>dogs vs. cats</vh></v>
<v t="ekr.20241218004931.37"><vh>lasso =</vh></v>
<v t="ekr.20241218004931.38"><vh>fig,axs = plt.subplots(4,1)</vh></v>
<v t="ekr.20241218004931.39"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241218004931.40"><vh># To be implemented: Python version of</vh></v>
<v t="ekr.20241218004931.41"><vh>Cell 7</vh></v>
<v t="ekr.20241218004931.42"><vh>Cell 8</vh></v>
</v>
<v t="ekr.20241218004931.43"><vh># @file CH06\CH06_SEC04_1_StochasticGradientDescent.py</vh>
<v t="ekr.20241218004931.45"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.46"><vh>iterMax = 100</vh></v>
<v t="ekr.20241218004931.47"><vh>plt.figure()</vh></v>
<v t="ekr.20241218004931.48"><vh>fig,ax = plt.subplots(1,1,subplot_kw={'p</vh></v>
<v t="ekr.20241218004931.49"><vh>Cell 5</vh></v>
<v t="ekr.20241218004931.50"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241218004931.51"><vh># @file CH06\CH06_SEC05_1_DeepCNN.py</vh>
<v t="ekr.20241218004931.53"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.54"><vh>letters_train_mat = io.loadmat(os.path.j</vh></v>
<v t="ekr.20241218004931.55"><vh>classes = np.unique(TTrain)</vh></v>
<v t="ekr.20241218004931.56"><vh>create model</vh></v>
<v t="ekr.20241218004931.57"><vh>YPredict =</vh></v>
<v t="ekr.20241218004931.58"><vh>Cell 6</vh></v>
<v t="ekr.20241218004931.59"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241218004931.60"><vh># @file CH06\CH06_SEC06_1_NNLorenz.py</vh>
<v t="ekr.20241218004931.62"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.63"><vh># Simulate the Lorenz System</vh></v>
<v t="ekr.20241218004931.64"><vh># Neural Net</vh></v>
<v t="ekr.20241218004931.65"><vh>nn_input.shape</vh></v>
<v t="ekr.20241218004931.66"><vh>Cell 5</vh></v>
</v>
</v>
<v t="ekr.20241218004931.67"><vh>CH07</vh>
<v t="ekr.20241218004931.68"><vh># @file CH07\CH07_SEC01_SimulateLogistic.py</vh>
<v t="ekr.20241218004931.70"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.71"><vh>startval = 1</vh></v>
<v t="ekr.20241218004931.72"><vh>plt.plot(xvals[1,:],xvals[0,:],'.',ms=0.</vh></v>
<v t="ekr.20241218004931.73"><vh>plt.plot(xvals[1,:],xvals[0,:],'.',ms=0.</vh></v>
<v t="ekr.20241218004931.74"><vh>Cell 5</vh></v>
</v>
<v t="ekr.20241218004931.75"><vh># @file CH07\CH07_SEC01_SimulateLorenz.py</vh>
<v t="ekr.20241218004931.77"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.78"><vh># Simulate the Lorenz System</vh></v>
<v t="ekr.20241218004931.79"><vh>Cell 3</vh></v>
<v t="ekr.20241218004931.80"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241218004931.81"><vh># @file CH07\CH07_SEC02_DMD_Cylinder.py</vh>
<v t="ekr.20241218004931.83"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.84"><vh>vortall_mat = io.loadmat(os.path.join('.</vh></v>
<v t="ekr.20241218004931.85"><vh>def DMD(X,Xprime,r):</vh></v>
<v t="ekr.20241218004931.86"><vh>Phi, Lambda, b =</vh></v>
<v t="ekr.20241218004931.87"><vh># Plot Mode 2</vh></v>
<v t="ekr.20241218004931.88"><vh>V2 =</vh></v>
<v t="ekr.20241218004931.89"><vh>Cell 7</vh></v>
<v t="ekr.20241218004931.90"><vh>Cell 8</vh></v>
</v>
<v t="ekr.20241218004931.91"><vh># @file CH07\CH07_SEC03_SINDY_Lorenz.py</vh>
<v t="ekr.20241218004931.93"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.94"><vh># Simulate the Lorenz System</vh></v>
<v t="ekr.20241218004931.95"><vh># Compute Derivative</vh></v>
<v t="ekr.20241218004931.96"><vh># SINDy Function Definitions</vh></v>
<v t="ekr.20241218004931.97"><vh>Up to third order polynomials</vh></v>
<v t="ekr.20241218004931.98"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241218004931.99"><vh># @file CH07\CH07_SEC04_Koopman.py</vh>
<v t="ekr.20241218004931.101"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.102"><vh>mu = -0.05</vh></v>
<v t="ekr.20241218004931.103"><vh># Integrate Koopman trajectories</vh></v>
<v t="ekr.20241218004931.104"><vh># Plot invariant surfaces</vh></v>
<v t="ekr.20241218004931.105"><vh>Cell 5</vh></v>
<v t="ekr.20241218004931.106"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241218004931.107"><vh># @file CH07\CH07_SEC05_HAVOK_Lorenz.py</vh>
<v t="ekr.20241218004931.109"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.110"><vh># Simulate the Lorenz System</vh></v>
<v t="ekr.20241218004931.111"><vh># Eigen-time delay coordinates</vh></v>
<v t="ekr.20241218004931.112"><vh># Compute Derivatives (4th Order Central</vh></v>
<v t="ekr.20241218004931.113"><vh># Build HAVOK Regression Model on Time</vh></v>
<v t="ekr.20241218004931.114"><vh>print(1/2/3)</vh></v>
<v t="ekr.20241218004931.115"><vh>Cell 7</vh></v>
</v>
</v>
<v t="ekr.20241218004931.116"><vh>CH08</vh>
<v t="ekr.20241218004931.117"><vh># @file CH08\CH08_SEC01_CruiseControl.py</vh>
<v t="ekr.20241218004931.119"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.120"><vh>time</vh></v>
<v t="ekr.20241218004931.121"><vh>plt.plot(t,wr,'k',linewidth=2,label='Ref</vh></v>
<v t="ekr.20241218004931.122"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241218004931.123"><vh># @file CH08\CH08_SEC07_1_LQR.py</vh>
<v t="ekr.20241218004931.125"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.126"><vh>m = 1</vh></v>
<v t="ekr.20241218004931.127"><vh># Design LQR Controller</vh></v>
<v t="ekr.20241218004931.128"><vh># ODE RHS Function Definition</vh></v>
<v t="ekr.20241218004931.129"><vh># Simulate closed-loop system</vh></v>
<v t="ekr.20241218004931.130"><vh>for k in range(np.floor(len(t)/100)):</vh></v>
<v t="ekr.20241218004931.131"><vh>fig,ax = plt.subplots()</vh></v>
<v t="ekr.20241218004931.132"><vh>plot_labels = ('x','v','theta','omega')</vh></v>
<v t="ekr.20241218004931.133"><vh># Compare with many examples of Pole</vh></v>
<v t="ekr.20241218004931.134"><vh># Plots</vh></v>
<v t="ekr.20241218004931.135"><vh>for count in range(100):</vh></v>
</v>
<v t="ekr.20241218004931.136"><vh># @file CH08\CH08_SEC07_2b_Obsv.py</vh>
<v t="ekr.20241218004931.138"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.139"><vh>m = 1</vh></v>
<v t="ekr.20241218004931.140"><vh># Which measurements are best if we omit</vh></v>
<v t="ekr.20241218004931.141"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241218004931.142"><vh># @file CH08\CH08_SEC07_2_KalmanFilter.py</vh>
<v t="ekr.20241218004931.144"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.145"><vh>m = 1</vh></v>
<v t="ekr.20241218004931.146"><vh>Kalman estimator design</vh></v>
<v t="ekr.20241218004931.147"><vh># Specify disturbance and noise</vh></v>
<v t="ekr.20241218004931.148"><vh># Augment system with additional inputs</vh></v>
<v t="ekr.20241218004931.149"><vh># Estimate linearized system in "down"</vh></v>
<v t="ekr.20241218004931.150"><vh>plt.plot(t,y,color=(0.5,0.5,0.5),label='</vh></v>
<v t="ekr.20241218004931.151"><vh>x_labels = ('x','v','theta','omega')</vh></v>
<v t="ekr.20241218004931.152"><vh>Cell 9</vh></v>
</v>
<v t="ekr.20241218004931.153"><vh># @file CH08\CH08_SEC08_1_TransferFunction.py</vh>
<v t="ekr.20241218004931.155"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.156"><vh>s = tf(np.array([1,0]),np.array([0,1]))</vh></v>
<v t="ekr.20241218004931.157"><vh>A = np.array([[0,1],[-2,-1]])</vh></v>
<v t="ekr.20241218004931.158"><vh>Cell 4</vh></v>
</v>
<v t="ekr.20241218004931.159"><vh># @file CH08\CH08_SEC08_2_SandT.py</vh>
<v t="ekr.20241218004931.161"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.162"><vh>s = tf(np.array([1,0]),np.array([0,1]))</vh></v>
<v t="ekr.20241218004931.163"><vh>Cell 3</vh></v>
</v>
<v t="ekr.20241218004931.164"><vh># @file CH08\CH08_SEC08_3_PlantInversion.py</vh>
<v t="ekr.20241218004931.166"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.167"><vh>s = tf(np.array([1,0]),np.array([0,1]))</vh></v>
<v t="ekr.20241218004931.168"><vh>Cell 3</vh></v>
<v t="ekr.20241218004931.169"><vh>Cell 4</vh></v>
</v>
</v>
<v t="ekr.20241218004931.170"><vh>CH09</vh>
<v t="ekr.20241218004931.171"><vh># @file CH09\CH09_SEC02_1_GramianPlot.py</vh>
<v t="ekr.20241218004931.173"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.174"><vh>A = np.array([[-0.75,1],[-0.3,-0.75]])</vh></v>
<v t="ekr.20241218004931.175"><vh>Manually compute transform matrix for</vh></v>
<v t="ekr.20241218004931.176"><vh># Plot Gramians</vh></v>
<v t="ekr.20241218004931.177"><vh>plt.plot(xc,yc,'k--',linewidth=2)</vh></v>
<v t="ekr.20241218004931.178"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241218004931.179"><vh># @file CH09\CH09_SEC02_2_BalancedTruncation.py</vh>
<v t="ekr.20241218004931.181"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004931.182"><vh>testSys_mat = io.loadmat(os.path.join('.</vh></v>
<v t="ekr.20241218004931.183"><vh># Plot Hankel Singular Values</vh></v>
<v t="ekr.20241218004931.184"><vh>Balanced truncation</vh></v>
<v t="ekr.20241218004931.185"><vh>Compute BPOD</vh></v>
<v t="ekr.20241218004931.186"><vh># Plot impulse responses for all methods</vh></v>
<v t="ekr.20241218004931.187"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241218004931.188"><vh># @file CH09\CH09_SEC03_ERA_OKID.py</vh>
<v t="ekr.20241218004932.2"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.3"><vh>Number of inputs</vh></v>
<v t="ekr.20241218004932.4"><vh>yFull = np.zeros((r*5+2,p,q))</vh></v>
<v t="ekr.20241218004932.5"><vh># ERA and OKID Function Definitions</vh></v>
<v t="ekr.20241218004932.6"><vh># Compute ERA from impulse response</vh></v>
<v t="ekr.20241218004932.7"><vh># Compute random input simulation for</vh></v>
<v t="ekr.20241218004932.8"><vh># Compute OKID and then ERA</vh></v>
<v t="ekr.20241218004932.9"><vh># Plot impulse responses for all methods</vh></v>
<v t="ekr.20241218004932.10"><vh># Plot input/output pair for OKID</vh></v>
<v t="ekr.20241218004932.11"><vh>uRandom.shape</vh></v>
<v t="ekr.20241218004932.12"><vh>Cell 11</vh></v>
</v>
<v t="ekr.20241218004932.13"><vh># @file CH09\CH09_SEC03_Fig9p5.py</vh>
<v t="ekr.20241218004932.15"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.16"><vh>Number of inputs</vh></v>
<v t="ekr.20241218004932.17"><vh># Figure 1 = simple impulse response</vh></v>
<v t="ekr.20241218004932.18"><vh>plt.step(t,u,'k',linewidth=1.5)</vh></v>
<v t="ekr.20241218004932.19"><vh>plt.step(t,y,'k',linewidth=1.5)</vh></v>
<v t="ekr.20241218004932.20"><vh># FIgure 2 - OKID response</vh></v>
<v t="ekr.20241218004932.21"><vh>plt.step(t,u,'k',linewidth=1.5)</vh></v>
<v t="ekr.20241218004932.22"><vh>plt.step(t,y,'k',linewidth=1.5)</vh></v>
</v>
</v>
<v t="ekr.20241218004932.23"><vh>CH10</vh>
<v t="ekr.20241218004932.24"><vh># @file CH10\CH10_SEC03_ESCfixed.py</vh>
<v t="ekr.20241218004932.26"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.27"><vh>J = lambda u,t: (25-np.power((5-u),2))</vh></v>
<v t="ekr.20241218004932.28"><vh># Extremum Seeking Control Parameters</vh></v>
<v t="ekr.20241218004932.29"><vh># High pass filter (Butterworth filter)</vh></v>
<v t="ekr.20241218004932.30"><vh># Figures</vh></v>
<v t="ekr.20241218004932.31"><vh>Cell 6</vh></v>
<v t="ekr.20241218004932.32"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241218004932.33"><vh># @file CH10\CH10_SEC03_ESCsinusoidal.py</vh>
<v t="ekr.20241218004932.35"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.36"><vh>J = lambda u,t:</vh></v>
<v t="ekr.20241218004932.37"><vh># Extremum Seeking Control Parameters</vh></v>
<v t="ekr.20241218004932.38"><vh># High pass filter (Butterworth filter)</vh></v>
<v t="ekr.20241218004932.39"><vh># Figures</vh></v>
<v t="ekr.20241218004932.40"><vh>Cell 6</vh></v>
</v>
</v>
<v t="ekr.20241218004932.41"><vh>CH11</vh>
<v t="ekr.20241218004932.42"><vh># @file CH11\CH11_SEC01_1_Fig11p1.py</vh>
<v t="ekr.20241218004932.44"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.45"><vh>L = 20</vh></v>
<v t="ekr.20241218004932.46"><vh>fig,axs = plt.subplots(1,2)</vh></v>
<v t="ekr.20241218004932.47"><vh>ut21 = np.zeros(n,dtype='complex_')</vh></v>
<v t="ekr.20241218004932.48"><vh>plt.semilogy(erx,er3,'b',linewidth=2)</vh></v>
<v t="ekr.20241218004932.49"><vh>Cell 6</vh></v>
</v>
<v t="ekr.20241218004932.50"><vh># @file CH11\CH11_SEC02_1_HarmonicOscillator.py</vh>
<v t="ekr.20241218004932.52"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.53"><vh>L = 30</vh></v>
<v t="ekr.20241218004932.54"><vh>def harm_rhs(ut_split,t,k=k,V=V,n=n):</vh></v>
<v t="ekr.20241218004932.55"><vh>initial conditions</vh></v>
<v t="ekr.20241218004932.56"><vh>initial conditions</vh></v>
<v t="ekr.20241218004932.57"><vh>ax = Axes3D(plt.figure())</vh></v>
<v t="ekr.20241218004932.58"><vh>ax = Axes3D(plt.figure())</vh></v>
<v t="ekr.20241218004932.59"><vh>usol3 = np.zeros_like(usol)</vh></v>
<v t="ekr.20241218004932.60"><vh>plt.plot(100*S/np.sum(S),'ko',linewidth=</vh></v>
<v t="ekr.20241218004932.61"><vh>plt.plot(100*S2/np.sum(S2),'ko',linewidt</vh></v>
<v t="ekr.20241218004932.62"><vh>fig,axs = plt.subplots(3,1)</vh></v>
<v t="ekr.20241218004932.63"><vh>Cell 12</vh></v>
</v>
<v t="ekr.20241218004932.64"><vh># @file CH11\CH11_SEC03_1_NonlinearSchrodinger.py</vh>
<v t="ekr.20241218004932.66"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.67"><vh>L = 40</vh></v>
<v t="ekr.20241218004932.68"><vh>def nls_rhs(ut_split,t,k=k):</vh></v>
<v t="ekr.20241218004932.69"><vh>N = 1</vh></v>
<v t="ekr.20241218004932.70"><vh>N = 2</vh></v>
<v t="ekr.20241218004932.71"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241218004932.72"><vh>U,S,VT = np.linalg.svd(usol.T)</vh></v>
<v t="ekr.20241218004932.73"><vh>plt.rcParams['figure.figsize'] = [12, 6]</vh></v>
<v t="ekr.20241218004932.74"><vh>color_list = ['b','g','r']</vh></v>
<v t="ekr.20241218004932.75"><vh>for jj in range(3):</vh></v>
<v t="ekr.20241218004932.76"><vh>Cell 11</vh></v>
</v>
<v t="ekr.20241218004932.77"><vh># @file CH11\CH11_SEC05_1_Invariance.py</vh>
<v t="ekr.20241218004932.79"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.80"><vh>L = 20</vh></v>
<v t="ekr.20241218004932.81"><vh>U,S,VT =</vh></v>
<v t="ekr.20241218004932.82"><vh>fig, axs = plt.subplots(2,1)</vh></v>
<v t="ekr.20241218004932.83"><vh>plt.rcParams['figure.figsize'] = [12,</vh></v>
<v t="ekr.20241218004932.84"><vh>u = np.tanh(np.sqrt(np.power(X,2)+np.pow</vh></v>
<v t="ekr.20241218004932.85"><vh># Translation</vh></v>
<v t="ekr.20241218004932.86"><vh>plt.rcParams['figure.figsize'] = [12,12]</vh></v>
<v t="ekr.20241218004932.87"><vh>U2,S2,V2T = np.linalg.svd(X)</vh></v>
<v t="ekr.20241218004932.88"><vh>Cell 10</vh></v>
</v>
</v>
<v t="ekr.20241218004932.89"><vh>CH12</vh>
<v t="ekr.20241218004932.90"><vh># @file CH12\CH12_SEC01_1_GAPPY.py</vh>
<v t="ekr.20241218004932.92"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.93"><vh>define domain</vh></v>
<v t="ekr.20241218004932.94"><vh>plt.rcParams['figure.figsize'] = [12,12]</vh></v>
<v t="ekr.20241218004932.95"><vh>plt.rcParams['figure.figsize'] = [12,12]</vh></v>
<v t="ekr.20241218004932.96"><vh>fig,axs = plt.subplots(2,2)</vh></v>
<v t="ekr.20241218004932.97"><vh>plt.rcParams['figure.figsize'] = [12,6]</vh></v>
<v t="ekr.20241218004932.98"><vh>Cell 7</vh></v>
</v>
<v t="ekr.20241218004932.99"><vh># @file CH12\CH12_SEC02_1_GAPPY.py</vh>
<v t="ekr.20241218004932.101"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.102"><vh>define domain</vh></v>
<v t="ekr.20241218004932.103"><vh>n = len(x)</vh></v>
<v t="ekr.20241218004932.104"><vh># Test Random trials with P% of</vh></v>
<v t="ekr.20241218004932.105"><vh>fig,axs = plt.subplots(2,1)</vh></v>
<v t="ekr.20241218004932.106"><vh># For 20% measurements, sort great from</vh></v>
<v t="ekr.20241218004932.107"><vh>fig,axs = plt.subplots(3,1)</vh></v>
<v t="ekr.20241218004932.108"><vh>fig, ax = plt.subplots(1,1)</vh></v>
<v t="ekr.20241218004932.109"><vh>jloc = np.argsort(co)</vh></v>
<v t="ekr.20241218004932.110"><vh>m = 30</vh></v>
<v t="ekr.20241218004932.111"><vh>Cell 11</vh></v>
</v>
<v t="ekr.20241218004932.112"><vh># @file CH12\CH12_SEC03_1_GAPPY_ConditionNumber.py</vh>
<v t="ekr.20241218004932.114"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.115"><vh>define domain</vh></v>
<v t="ekr.20241218004932.116"><vh># Method 1 -- Condition Number</vh></v>
<v t="ekr.20241218004932.117"><vh>plt.rcParams['figure.figsize'] = [12,10]</vh></v>
<v t="ekr.20241218004932.118"><vh>titer = np.arange(1,21)</vh></v>
<v t="ekr.20241218004932.119"><vh>plt.rcParams['figure.figsize'] = [12,6]</vh></v>
<v t="ekr.20241218004932.120"><vh># Method 2 -- Max Diagonal vs. Off-</vh></v>
<v t="ekr.20241218004932.121"><vh>plt.rcParams['figure.figsize'] = [12,10]</vh></v>
<v t="ekr.20241218004932.122"><vh># Method 1 -- First 4 Condition Number</vh></v>
<v t="ekr.20241218004932.123"><vh>Cell 10</vh></v>
</v>
<v t="ekr.20241218004932.124"><vh># @file CH12\CH12_SEC04_1_GAPPY_Variance.py</vh>
<v t="ekr.20241218004932.126"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.127"><vh>define domain</vh></v>
<v t="ekr.20241218004932.128"><vh># Method 1 -- Start with max of each</vh></v>
<v t="ekr.20241218004932.129"><vh># Method 2 -- Start with max and mins of</vh></v>
<v t="ekr.20241218004932.130"><vh># Method 3 -- Search for extrema, then</vh></v>
<v t="ekr.20241218004932.131"><vh># select random 20 - shuffle</vh></v>
<v t="ekr.20241218004932.132"><vh># Method to compare -- Willcox condition</vh></v>
<v t="ekr.20241218004932.133"><vh>fig,axs = plt.subplots(3,1)</vh></v>
<v t="ekr.20241218004932.134"><vh>titer = np.arange(1,21)</vh></v>
<v t="ekr.20241218004932.135"><vh>plt.rcParams['figure.figsize'] = [12,6]</vh></v>
<v t="ekr.20241218004932.136"><vh>Cell 11</vh></v>
</v>
<v t="ekr.20241218004932.137"><vh># @file CH12\CH12_SEC06_1_DEIM.py</vh>
<v t="ekr.20241218004932.139"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.140"><vh>spatial discretization</vh></v>
<v t="ekr.20241218004932.141"><vh>def ch_pod_sol_rhs(ut_split,t,k=k):</vh></v>
<v t="ekr.20241218004932.142"><vh>N = 2</vh></v>
<v t="ekr.20241218004932.143"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241218004932.144"><vh>data matrix X</vh></v>
<v t="ekr.20241218004932.145"><vh>NL = (1j)*np.power(np.abs(X),2)*X</vh></v>
<v t="ekr.20241218004932.146"><vh>nonlinear projection</vh></v>
<v t="ekr.20241218004932.147"><vh>def rom_deim_rhs(a_split,tspan,P_NL=P_NL</vh></v>
<v t="ekr.20241218004932.148"><vh>Separate real/complex pieces</vh></v>
<v t="ekr.20241218004932.149"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241218004932.150"><vh># QR DEIM</vh></v>
<v t="ekr.20241218004932.151"><vh>Cell 13</vh></v>
<v t="ekr.20241218004932.152"><vh>Cell 14</vh></v>
</v>
<v t="ekr.20241218004932.153"><vh># @file CH12\CH12_SEC06_2_DEIM.py</vh>
<v t="ekr.20241218004932.155"><vh>import numpy as np</vh></v>
<v t="ekr.20241218004932.156"><vh>spatial discretization</vh></v>
<v t="ekr.20241218004932.157"><vh>def ch_pod_sol_rhs(ut_split,t,k=k):</vh></v>
<v t="ekr.20241218004932.158"><vh>N = 2</vh></v>
<v t="ekr.20241218004932.159"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241218004932.160"><vh>data matrix X</vh></v>
<v t="ekr.20241218004932.161"><vh>NL = (1j)*np.power(np.abs(X),2)*X</vh></v>
<v t="ekr.20241218004932.162"><vh>nonlinear projection</vh></v>
<v t="ekr.20241218004932.163"><vh>def rom_deim_rhs(a_split,tspan,P_NL=P_NL</vh></v>
<v t="ekr.20241218004932.164"><vh>Separate real/complex pieces</vh></v>
<v t="ekr.20241218004932.165"><vh>fig = plt.figure()</vh></v>
<v t="ekr.20241218004932.166"><vh>plt.plot(x,-np.real(Psi[:,:3]))</vh></v>
<v t="ekr.20241218004932.167"><vh># QR compare</vh></v>
<v t="ekr.20241218004932.168"><vh>Cell 14</vh></v>
</v>
</v>
</v>
<v t="ekr.20241212071918.1"><vh>@file weather.py</vh></v>
<v t="ekr.20241218043342.1"><vh>@edit readme.md</vh></v>
<v t="ekr.20241218044150.1"><vh>@file ekr_style.py</vh></v>
</v>
<v t="ekr.20241223024937.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3171017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735807000000302e312e302e3071067d7107580b0000005f5f626f6f6b6d61726b7371087d7109580700000069735f64757065710a4930300a7373752e"><vh>Projects</vh>
<v t="ekr.20241217150611.1"><vh>Plt scripts: Use execute-script!</vh>
<v t="ekr.20241217063500.1"><vh>Pyplot: graph parabola with slopes</vh></v>
<v t="ekr.20241217092849.1"><vh>Pyplot: graph parabola and table of x-intercepts</vh></v>
<v t="ekr.20241217093836.1"><vh>Pyplot: graph table of x-intercepts</vh></v>
</v>
<v t="ekr.20241223020730.7" descendentVnodeUnknownAttributes="7d71002858010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735805000000302e302e3071067d7107580b0000005f5f626f6f6b6d61726b7371087d7109580700000069735f64757065710a4930300a7373752e"><vh>VR examples</vh>
<v t="ekr.20241223020730.8" descendentVnodeUnknownAttributes="7d71005803000000302e3071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a7373732e"><vh>at-html tests</vh>
<v t="ekr.20241223020730.9" descendentVnodeUnknownAttributes="7d710058010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a7373732e"><vh>@html sphinx Link</vh></v>
<v t="ekr.20241223020730.10"><vh>@html display Leo tree (cool)</vh></v>
<v t="ekr.20241223020730.11"><vh>@html Leo's home page</vh></v>
</v>
<v t="ekr.20241223020730.12"><vh>at-image tests</vh>
<v t="ekr.20241223020730.13"><vh>@image LeoSplash (works, but very large)</vh></v>
<v t="ekr.20241223020730.14"><vh>@path C:\Repos\leo-editor\leo\Icons</vh>
<v t="ekr.20241223020730.15"><vh>@image LeoSplash (test: using @path)</vh></v>
</v>
</v>
<v t="ekr.20241223020730.16"><vh>at-pyplot tests</vh>
<v t="ekr.20241223020730.17"><vh>@pyplot barchar_demo</vh></v>
<v t="ekr.20241223020730.18"><vh>@pyplot basic_example 1</vh></v>
<v t="ekr.20241223020730.19"><vh>@pyplot basic_example 2</vh></v>
<v t="ekr.20241223020730.20"><vh>@pyplot matplotlib animate_decay</vh>
<v t="ekr.20241223020730.21"><vh>data_gen</vh></v>
<v t="ekr.20241223020730.22"><vh>init</vh></v>
<v t="ekr.20241223020730.23"><vh>run</vh></v>
</v>
<v t="ekr.20241223020730.24"><vh>@pyplot two graphs in same window</vh></v>
</v>
<v t="ekr.20241223020730.25"><vh>at-svg tests</vh>
<v t="ekr.20241223020730.26"><vh>@svg bubbles sources</vh></v>
<v t="ekr.20241223020730.27"><vh>@svg bubbles.svg</vh></v>
</v>
<v t="ekr.20241223020730.28"><vh>docstring test</vh></v>
<v t="ekr.20241231191937.1"><vh>katex test</vh></v>
<v t="ekr.20241225053337.1"><vh>html tests (mathjax)</vh></v>
<v t="ekr.20241223020730.29"><vh>markdown tests</vh>
<v t="ekr.20241223020730.30"><vh>markdown test (including url)</vh></v>
<v t="ekr.20241223020730.32"><vh>markdown test (link)</vh></v>
</v>
<v t="ekr.20241227063213.1"><vh>mathjax tests</vh>
<v t="ekr.20241224065831.1"><vh>Mathjax: hidden layer</vh></v>
<v t="ekr.20241225091600.1"><vh>Mathjax equations</vh></v>
<v t="ekr.20241226055452.1"><vh>Mathjax example</vh></v>
</v>
<v t="ekr.20241226180843.1"><vh>pdf tests</vh>
<v t="ekr.20241226013008.1"><vh>@pdf temp</vh></v>
<v t="ekr.20250102052459.1"><vh>@pdf test</vh></v>
</v>
<v t="ekr.20241223020730.33"><vh>rst tests</vh>
<v t="ekr.20241223020730.34"><vh>rst test (including url)</vh></v>
<v t="ekr.20241223020730.37"><vh>python code block in rst</vh></v>
</v>
<v t="ekr.20241231172240.1"><vh>typst test</vh></v>
<v t="ekr.20241223020730.38"><vh>URLs tests</vh>
<v t="ekr.20241223020730.39"><vh>@url Leo's home page (md)</vh></v>
<v t="ekr.20241223020730.40"><vh>@url Leo's home page (rST)</vh></v>
<v t="ekr.20241223020730.41"><vh>@url mail (rst)</vh></v>
<v t="ekr.20241223020730.42"><vh>@url weather (md)</vh></v>
</v>
</v>
</v>
<v t="ekr.20241225032316.1"><vh>Math problems</vh>
<v t="ekr.20241214073404.1"><vh>Problem set 1</vh>
<v t="ekr.20241214073548.1"><vh>1-1</vh></v>
<v t="ekr.20241214074032.1"><vh>1-2</vh></v>
<v t="ekr.20241214074032.2"><vh>1-3</vh></v>
<v t="ekr.20241214074033.1"><vh>1-4</vh></v>
</v>
</v>
<v t="ekr.20241224172245.1"><vh>Math notes</vh>
<v t="ekr.20241224174349.1"><vh>Special characters </vh></v>
<v t="ekr.20241225033647.1"><vh>Math symbols</vh></v>
<v t="ekr.20241224173005.1"><vh>Point-slope form of lines</vh></v>
<v t="ekr.20241224173158.1"><vh>Exponentials</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20241212100514.21">import matplotlib.pyplot as plt
import numpy as np
#### import os
from matplotlib import animation  ###, rc
from IPython.display import HTML
# Tensor factorization method requires the TensorLy module,
# available at http://tensorly.org/stable/installation.html
from tensorly.decomposition import parafac

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241212100514.23"># # %matplotlib inline

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})
plt.rcParams['animation.html'] = 'jshtml'

x = np.arange(-5, 5.01, 0.1)
y = np.arange(-6, 6.01, 0.1)
t = np.arange(0, 10 * np.pi + 0.1, 0.1)

X, Y, T = np.meshgrid(x, y, t)

A = np.exp(-(X ** 2 + 0.5 * Y ** 2)) * np.cos(2 * T) + \
    (np.divide(np.ones_like(X), np.cosh(X)) * np.tanh(X) * np.exp(-0.2 * Y ** 2)) * np.sin(T)

fig = plt.figure()

# ValueError: For X (102) and Y (122) with flat shading,
# A should have shape (121, 101, 3) or (121, 101, 4) or (121, 101) or (12221,), not (0,)

pcm = plt.pcolormesh(X[:,:, 0], Y[:,:, 0], A[:,:, 0], vmin=-1, vmax=1)
    # , shading='interp')

def init():
    pcm.set_array(np.array([]))
    return pcm

def animate(iter):
    pcm.set_array(A[: -1, : -1, iter].ravel())
    return pcm

anim = animation.FuncAnimation(fig, animate,
    init_func=init,
    frames=len(t),
    interval=50, blit=False,
    repeat=False)

HTML(anim.to_jshtml())
</t>
<t tx="ekr.20241212100514.24">plt.rcParams['figure.figsize'] = [16, 10]

fig, axs = plt.subplots(2, 4)
axs = axs.reshape(-1)

for j in range(8):
    plt.sca(axs[j])
    plt.pcolormesh(X[:,:, 0], Y[:,:, 0], A[:, :, 8 * (j + 1) - 3], vmin=-1, vmax=1, shading='interp')
    axs[j].axis('off')
    plt.set_cmap('hot')

</t>
<t tx="ekr.20241212100514.25">
plt.rcParams['figure.figsize'] = [12, 12]

A1, A2, A3 = parafac(A, 2)

fig, axs = plt.subplots(3, 1)
axs[0].plot(y, A1, linewidth=2)
axs[1].plot(x, A2, linewidth=2)
axs[2].plot(t, A3, linewidth=2)
plt.show()

</t>
<t tx="ekr.20241212164526.14">g.cls()
import os

# Must execute the script in the Python folder.
ekr_math_dir = os.path.dirname(c.fileName())
python_dir = os.path.join(ekr_math_dir, 'Python')
os.chdir(python_dir)

# All the sections have a common naming convention.
if p.isAnyAtFileNode():
    path = c.fullPath(p)
    # No need to hang Leo.
    g.execute_shell_commands(f"&amp;python {path}")
else:
    print(f"Not an @file node: {p.h}")
</t>
<t tx="ekr.20241212164526.17">g.cls()
import glob
import os

def is_pure_python(p) -&gt; bool:
    return not any(
        line.startswith('# %% [markdown]')
        for p2 in p.self_and_subtree()
        for line in g.splitLines(p2.b)
    )

last = c.lastTopLevel()
last = last.insertAfter()
last.h = '--- Converted ipynb files'
base_path = os.path.dirname(c.fileName())
dirs = [z for z in glob.glob(f"{base_path}/Python/*") if os.path.isdir(z)]
for dir_ in dirs:
    files = [z for z in glob.glob(f"{dir_}{os.sep}*.ipynb")]
    if not files:
        continue
    dir_s = os.path.basename(dir_)
    print(f"Importing {dir_s}...")
    short_files = [g.shortFileName(z) for z in files]
    parent = last.insertAsLastChild()
    parent.h = dir_s
    for the_file in files:
        p = parent.insertAsLastChild()
        p.h = f"@jupytext {the_file}"
        c.selectPosition(p)
        c.refreshFromDisk()
        if 0:  # Retain the full file name.
            new_fn = the_file.replace('.ipynb', '.py')
            p.h = f"# @file {new_fn}"
        else:  # Rely on @path
            new_fn = os.path.basename(the_file).replace('.ipynb', '.py')
            p.h = f"# @file {dir_s}{os.sep}{new_fn}"
        if 1:
            for child in p.children():
                if child.h == g.angleBrackets(' prefix '):
                    child.doDelete()
                    break
            p.b = p.b.replace(g.angleBrackets(' prefix ') + '\n', '')
        if is_pure_python(p):
            p.b = p.b.replace('@language jupytext', '@language python')
            for child in p.children():
                child.b = child.b.replace('# %%\n\n', '').replace('# %%\n', '')
c.contractAllHeadlines()
c.selectPosition(last)
last.expand()
c.redraw()</t>
<t tx="ekr.20241212164559.1"></t>
<t tx="ekr.20241212164559.117"></t>
<t tx="ekr.20241212164559.118"></t>
<t tx="ekr.20241212164559.119">@language rest
@wrap

See #3456.

</t>
<t tx="ekr.20241212164559.120"></t>
<t tx="ekr.20241212164559.121"></t>
<t tx="ekr.20241212164559.122"># leonine</t>
<t tx="ekr.20241212164559.204">Only difference from myLeoSettings.leo

Note: EKRWinowsDark.leo defines comment1_font

All three @color settings work.
The @font setting does not work.
</t>
<t tx="ekr.20241212164559.205">Bold</t>
<t tx="ekr.20241212164559.206">Italics</t>
<t tx="ekr.20241212164559.207"></t>
<t tx="ekr.20241212164559.208"># bold keywords defined in forth-bold-words</t>
<t tx="ekr.20241212164559.209"></t>
<t tx="ekr.20241212164559.210"># Note: the default font size is 12.
rest_comment1_family = None
rest_comment1_size = 12pt
rest_comment1_slant = italic
rest_comment1_weight = None
</t>
<t tx="ekr.20241212164559.217">@language python
</t>
<t tx="ekr.20241212164559.223">"""
Back up this .leo file.

os.environ['LEO_BACKUP'] must be the path to an existing (writable) directory.
"""
c.backup_helper(sub_dir='Math')
</t>
<t tx="ekr.20241212164559.270" __bookmarks="7d7100580700000069735f6475706571014930300a732e"></t>
<t tx="ekr.20241212164559.3" __bookmarks="7d7100580700000069735f6475706571014930300a732e">@language rest
@wrap

The @settings tree contains all active settings. 

Settings outside this tree have no effect.</t>
<t tx="ekr.20241212164559.302"></t>
<t tx="ekr.20241212164559.303">"""Recursively import all python files in a directory and clean the result."""
@language python
@tabwidth -4 # For a better match.
g.cls()
# dir_ = r'C:\Python\Python3.12\Lib\site-packages\micrograd'
dir_ = r'C:\Repos\manim'
c.recursiveImport(
    dir_=dir_,
    kind = '@clean', # '@auto', '@clean', '@nosent','@file',
    recursive = True,
    safe_at_file = True,
    theTypes = ['.py',],
    verbose = True,
)
if 1:
    last = c.lastTopLevel()
    last.expand()
    if last.hasChildren():
        last.firstChild().expand()
    c.redraw(last)
print('Done')</t>
<t tx="ekr.20241212164559.305">micrograd
vr-toggle

# exec-py-file
#close-figures

# render-latex
# backup
# ctrl-click-at-cursor
# import-ipynb
# exec-py-file
</t>
<t tx="ekr.20241212164559.306"># legacy: (default) Leo's legacy layout
# big-tree: replaces @bool big-outline-pane
# horizontal-thirds: VR &amp; VR3 panes at bottom.</t>
<t tx="ekr.20241212164559.307" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032312d30332d33307103752e">@language python

# Recommended plugins, from leoSettings.leo:

plugins_menu.py
# contextmenu.py      # Required by the vim.py and xemacs.py plugins.
mod_scripting.py
nav_qt.py
# Both VR plugins may be enabled.
viewrendered.py
# viewrendered3.py
</t>
<t tx="ekr.20241212164559.5"></t>
<t tx="ekr.20241212171838.1"></t>
<t tx="ekr.20241214073404.1">@language mathjax

&lt;!--
http://faculty.washington.edu/sbrunton/me564/hw/2022_564hw1.pdf
https://www.overleaf.com/project/675d9303d9ec3ac6df5baf7c
--&gt;


</t>
<t tx="ekr.20241214073548.1">@language rest
@wrap

Compute derivative of following functions:

(a) f(x) = cos(x3)
(b) f(x) = x^x
(c) f(x) = e^(sin(2x)) cos(x)
(d) f x, y) = cos(x2 + y2) with respect to t,
    assuming that x(t) and y(t) vary with time.
    Write the solution in terms of dx/dt and dy/dt (EKR: xdot and ydot.)</t>
<t tx="ekr.20241214074032.1">@language rest
@wrap

A given mass x of a radioactive element obeys the following differential equation
in time:

x = x

where  is a constant describing the rate of decay.

(a) Write down the solution x(t) to the differential equation.

(b) Plot the solution for an initial condition x(0) = 2 from time t = 0 to t = 5 for  =
5, 1, 0, 0.01, 0.1.

Plot these all on the same figure using the hold on command
in Matlab. Label your axes (&gt;&gt; doc xlabel, &gt;&gt; doc ylabel) and include a legend (e.g.,
legend(lambda 1,lambda 2,lambda 3, ...)).

(c) The half-life T is defined as the time it takes for the material to be reduced to half of its mass through radioactive decay. The half-life of uranium-238 is 4.468 billion years.

What is the corresponding value of ?

(d) If you start with 100kg of uranium-238, how long until you have 5kg left?
</t>
<t tx="ekr.20241214074032.2">@language rest
@wrap

Compute the Taylor series expansion by hand for f (x).

(a) f (x) = sin(x)/x.
(b) f (x) = 3x.

For each function, plot f (x) and the three-term expansion (i.e., the first three nonzero terms) from x = 5 to x = 5.


</t>
<t tx="ekr.20241214074033.1">@language rest
@wrap

Compute an analytic expression, by hand, for the real and imaginary parts
of the following complex functions.

Plot these in Matlab for t=0:.01:10.

(a) f (t) = eit,
(b) f (t) = e(1i)t,
(c) f (t) = e1it.
(d) f (t) = e(.2+3i)t.</t>
<t tx="ekr.20241217063500.1"># https://stackoverflow.com/questions/4971269 Using colors.

import matplotlib.pyplot as plt
import numpy as np

plt.rcParams["font.family"] = 'DejaVu Sans Mono'

a, b = [], []
for x in range(-50,50):
    y=x**2
    a.append(x)
    b.append(y)

title = 'Parabola, Tangents and x-intercepts'
fig = plt.figure(num=title)
fig.suptitle(title)
axes=fig.add_subplot()
axes.set_title('Parabola and Tangents')
axes.plot(a, b)

# Show the axes.
plt.axhline(y=0)
plt.axvline(x=0)

# Show the tangent lines, cutting them off at y = 0
plt.ylim(bottom=0)
color = iter(plt.cm.rainbow(np.linspace(0, 1, 6)))
for x in (-50, -30, -10, 10, 20, 30):
    y = x**2
    slope = 2 * x
    x_y_s = f"({x:3}, {y})"
    label = f"{x_y_s:&lt;11} slope: {slope:4}, x-intercept: {x - y/slope:&gt;5}"
    plt.axline((x, y), slope=slope, label=label, c=next(color))
axes.legend()

fig.canvas.manager.window.move(50,50)
plt.show()  # Generates a warning.
# g.cls()
</t>
<t tx="ekr.20241217065902.1">g.cls()
import matplotlib.pyplot as plt
plt.close('all') # close all figures
print('close-figures: done')
</t>
<t tx="ekr.20241217092849.1"># https://matplotlib.org/stable/api/_as_gen/matplotlib.figure.Figure.add_subplot.html

import matplotlib.pyplot as plt
import numpy as np

plt.rcParams["font.family"] = 'DejaVu Sans Mono'

a, b = [], []
for x in range(-50,50):
    y=x**2
    a.append(x)
    b.append(y)

fig, (axes, table) = plt.subplots(2, 1)
fig.suptitle('Parabola, Tangents and x-intercepts')
axes.set_title('Parabola and Tangents')
table.set_title('x intercepts')

# https://matplotlib.org/stable/api/_as_gen/matplotlib.axes.Axes.plot.html
axes.plot(a,b)

# Show the axes.
plt.axhline(y=0)
plt.axvline(x=0)

# Show the tangent lines, cutting them off at y = 0
plt.ylim(bottom=0)
for x in (-50, -30, -10, 10, 20, 30):
    y = x**2
    slope = 2 * x
    x_y_s = f"({x:3}, {y})"
    label = f"{x_y_s:&lt;11} slope: {slope:4}, x-intercept: {x - y/slope:&gt;5}"
    plt.axline((x, y), slope=slope)

fig.canvas.manager.window.move(50,50)  # Works for Qt. May not always work.
plt.show()  # Generates a warning: The event loop is already running

# g.cls()
</t>
<t tx="ekr.20241217093836.1"># https://matplotlib.org/stable/api/_as_gen/matplotlib.figure.Figure.add_subplot.html

import matplotlib.pyplot as plt

plt.rcParams["font.family"] = 'DejaVu Sans Mono'

title = 'x-intercepts'
fig, ax = plt.subplots(num=title)
fig.suptitle(title)
# fig.patch.set_visible(False)
ax.axis('off')
cell_text = []
for x in (-50, -30, -10, 10, 20, 30):
    y = x**2
    slope = 2 * x
    x_y_s = f"({x:3}, {y})"
    s = f"{x_y_s:&lt;11} slope: {slope:4}, x-intercept: {x - y/slope:&gt;5}"
    cell_text.append([s])
    
table = ax.table(cellText=cell_text,
    cellLoc='left',
    loc='top',
    edges = 'open',
)
table.scale(xscale=1, yscale=2)
fig.tight_layout()

fig.canvas.manager.window.move(50,50)  # Works for Qt. May not always work.
plt.show()  # Generates a warning: The event loop is already running

# g.cls()
</t>
<t tx="ekr.20241217150611.1">
# Try plotnine.
</t>
<t tx="ekr.20241218004929.1"></t>
<t tx="ekr.20241218004929.101">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

n = 256
w = np.exp(-1j * 2 * np.pi / n)

</t>
<t tx="ekr.20241218004929.102">DFT = np.zeros((n,n))

# Slow
for i in range(n):
    for k in range(n):
        DFT[i,k] = w**(i*k)
        
DFT = np.real(DFT)
        
plt.imshow(DFT)
plt.show()

</t>
<t tx="ekr.20241218004929.103"># Fast
J,K = np.meshgrid(np.arange(n),np.arange(n))
DFT = np.power(w,J*K)
DFT = np.real(DFT)
       
plt.imshow(DFT)
plt.show()

</t>
<t tx="ekr.20241218004929.104"></t>
<t tx="ekr.20241218004929.105">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004929.107">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [16, 12]
plt.rcParams.update({'font.size': 18})

# Create a simple signal with two frequencies
dt = 0.001
t = np.arange(0,1,dt)
f = np.sin(2*np.pi*50*t) + np.sin(2*np.pi*120*t) # Sum of 2 frequencies
f_clean = f
f = f + 2.5*np.random.randn(len(t))              # Add some noise

</t>
<t tx="ekr.20241218004929.108">## Compute the Fast Fourier Transform (FFT)

n = len(t)
fhat = np.fft.fft(f,n)                     # Compute the FFT
PSD = fhat * np.conj(fhat) / n             # Power spectrum (power per freq)
freq = (1/(dt*n)) * np.arange(n)           # Create x-axis of frequencies in Hz
L = np.arange(1,np.floor(n/2),dtype='int') # Only plot the first half of freqs


</t>
<t tx="ekr.20241218004929.109">## Use the PSD to filter out noise
indices = PSD &gt; 100       # Find all freqs with large power
PSDclean = PSD * indices  # Zero out all others
fhat = indices * fhat     # Zero out small Fourier coeffs. in Y
ffilt = np.fft.ifft(fhat) # Inverse FFT for filtered time signal

</t>
<t tx="ekr.20241218004929.110">## Plots
fig,axs = plt.subplots(3,1)

plt.sca(axs[0])
plt.plot(t,f,color='r',linewidth=1.5,label='Noisy')
plt.plot(t,f_clean,color='k',linewidth=2,label='Clean')
plt.xlim(t[0],t[-1])
plt.legend()

plt.sca(axs[1])
plt.plot(t,f_clean,color='k',linewidth=1.5,label='Clean')
plt.plot(t,ffilt,color='b',linewidth=2,label='Filtered')
plt.xlim(t[0],t[-1])
plt.legend()

plt.sca(axs[2])
plt.plot(freq[L],PSD[L],color='r',linewidth=2,label='Noisy')
plt.plot(freq[L],PSDclean[L],color='b',linewidth=1.5,label='Filtered')
plt.xlim(freq[L[0]],freq[L[-1]])
plt.legend()

plt.show()
</t>
<t tx="ekr.20241218004929.111">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004929.113">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})


n = 128
L = 30
dx = L/n
x = np.arange(-L/2,L/2,dx,dtype='complex_')
f = np.cos(x) * np.exp(-np.power(x,2)/25) # Function
df = -(np.sin(x) * np.exp(-np.power(x,2)/25) + (2/25)*x*f) # Derivative

</t>
<t tx="ekr.20241218004929.114">## Approximate derivative using finite difference
dfFD = np.zeros(len(df),dtype='complex_')
for kappa in range(len(df)-1):
    dfFD[kappa] = (f[kappa+1]-f[kappa])/dx
    
dfFD[-1] = dfFD[-2]

</t>
<t tx="ekr.20241218004929.115">## Derivative using FFT (spectral derivative)
fhat = np.fft.fft(f)
kappa = (2*np.pi/L)*np.arange(-n/2,n/2)
kappa = np.fft.fftshift(kappa) # Re-order fft frequencies
dfhat = kappa * fhat * (1j)
dfFFT = np.real(np.fft.ifft(dfhat))


</t>
<t tx="ekr.20241218004929.116">## Plots
plt.plot(x,df.real,color='k',linewidth=2,label='True Derivative')
plt.plot(x,dfFD.real,'--',color='b',linewidth=1.5,label='Finite Diff.')
plt.plot(x,dfFFT.real,'--',color='r',linewidth=1.5,label='FFT Derivative')
plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004929.117"></t>
<t tx="ekr.20241218004929.118">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004929.120">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import axes3d
plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

a = 1    # Thermal diffusivity constant
L = 100  # Length of domain
N = 1000 # Number of discretization points
dx = L/N
x = np.arange(-L/2,L/2,dx) # Define x domain

# Define discrete wavenumbers
kappa = 2*np.pi*np.fft.fftfreq(N, d=dx)

# Initial condition
u0 = np.zeros_like(x)
u0[int((L/2 - L/10)/dx):int((L/2 + L/10)/dx)] = 1
u0hat = np.fft.fft(u0)

# SciPy's odeint function doesn't play well with complex numbers, so we recast 
# the state u0hat from an N-element complex vector to a 2N-element real vector
u0hat_ri = np.concatenate((u0hat.real,u0hat.imag))

# Simulate in Fourier frequency domain
dt = 0.1
t = np.arange(0,10,dt)

def rhsHeat(uhat_ri,t,kappa,a):
    uhat = uhat_ri[:N] + (1j) * uhat_ri[N:]
    d_uhat = -a**2 * (np.power(kappa,2)) * uhat
    d_uhat_ri = np.concatenate((d_uhat.real,d_uhat.imag)).astype('float64')
    return d_uhat_ri

uhat_ri = odeint(rhsHeat, u0hat_ri, t, args=(kappa,a))

uhat = uhat_ri[:,:N] + (1j) * uhat_ri[:,N:]

u = np.zeros_like(uhat)

for k in range(len(t)):
    u[k,:] = np.fft.ifft(uhat[k,:])

u = u.real    

# Waterfall plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

u_plot = u[0:-1:10,:]
for j in range(u_plot.shape[0]):
    ys = j*np.ones(u_plot.shape[1])
    ax.plot(x,ys,u_plot[j,:])
    
# Image plot
plt.figure()
plt.imshow(np.flipud(u), aspect=8)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004929.121"></t>
<t tx="ekr.20241218004929.122">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004929.124">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import axes3d
plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

c = 2    # Wave speed
L = 20   # Length of domain
N = 1000 # Number of discretization points
dx = L/N
x = np.arange(-L/2,L/2,dx) # Define x domain

# Define discrete wavenumbers
kappa = 2*np.pi*np.fft.fftfreq(N, d=dx)

# Initial condition
u0 = 1/np.cosh(x)
u0hat = np.fft.fft(u0)

# SciPy's odeint function doesn't play well with complex numbers, so we recast 
# the state u0hat from an N-element complex vector to a 2N-element real vector
u0hat_ri = np.concatenate((u0hat.real,u0hat.imag))

# Simulate in Fourier frequency domain
dt = 0.025
t = np.arange(0,100*dt,dt)

def rhsWave(uhat_ri,t,kappa,c):
    uhat = uhat_ri[:N] + (1j) * uhat_ri[N:]
    d_uhat = -c*(1j)*kappa*uhat
    d_uhat_ri = np.concatenate((d_uhat.real,d_uhat.imag)).astype('float64')
    return d_uhat_ri

uhat_ri = odeint(rhsWave, u0hat_ri, t, args=(kappa,c))
uhat = uhat_ri[:,:N] + (1j) * uhat_ri[:,N:]

# Alternatively, simulate in spatial domain
def rhsWaveSpatial(u,t,kappa,c):
    uhat = np.fft.fft(u)
    d_uhat = (1j)*kappa*uhat
    d_u = np.fft.ifft(d_uhat).real
    du_dt = -c*d_u
    return du_dt

u = odeint(rhsWaveSpatial,u0,t,args=(kappa,c))

# Inverse FFT to bring back to spatial domain
u = np.zeros_like(uhat)

for k in range(len(t)):
    u[k,:] = np.fft.ifft(uhat[k,:])

u = u.real   


# Waterfall plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

u_plot = u[0:-1:10,:]
for j in range(u_plot.shape[0]):
    ys = j*np.ones(u_plot.shape[1])
    ax.plot(x,ys,u_plot[j,:])
    
# Image plot
plt.figure()
plt.imshow(np.flipud(u), aspect=8)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004929.125"></t>
<t tx="ekr.20241218004929.2"></t>
<t tx="ekr.20241218004929.80"></t>
<t tx="ekr.20241218004929.81">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004929.83">import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


f = np.array([0, 0, .1, .2, .25, .2, .25, .3, .35, .43, .45, .5, .55, .5, .4, .425, .45, .425, .4, .35, .3, .25, .225, .2, .1, 0, 0])
g = np.array([0, 0, .025, .1, .2, .175, .2, .25, .25, .3, .32, .35, .375, .325, .3, .275, .275, .25, .225, .225, .2, .175, .15, .15, .05, 0, 0])
g = g - 0.025 * np.ones_like(g)

x = 0.1 * np.arange(1,len(f)+1)
xf = np.arange(0.1,x[-1],0.01)

f_interp = interpolate.interp1d(x, f, kind='cubic')
g_interp = interpolate.interp1d(x, g, kind='cubic')

ff = f_interp(xf)  
gf = g_interp(xf)

plt.plot(xf[10:-10],ff[10:-10],color='k',linewidth=2)
plt.plot(x[1:-2],f[1:-2],'o',color='b')

plt.plot(xf[10:-10],gf[10:-10],color='k',linewidth=2)
plt.plot(x[1:-2],g[1:-2],'o',color='r')

plt.show()

</t>
<t tx="ekr.20241218004929.84">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004929.86">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.cm import get_cmap

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

# Define domain
dx = 0.001
L = np.pi
x = L * np.arange(-1+dx,1+dx,dx)
n = len(x)
nquart = int(np.floor(n/4))

# Define hat function
f = np.zeros_like(x)
f[nquart:2*nquart] = (4/n)*np.arange(1,nquart+1)
f[2*nquart:3*nquart] = np.ones(nquart) - (4/n)*np.arange(0,nquart)

fig, ax = plt.subplots()
ax.plot(x,f,'-',color='k',linewidth=2)

# Compute Fourier series
name = "Accent"
cmap = get_cmap('tab10')
colors = cmap.colors
ax.set_prop_cycle(color=colors)

A0 = np.sum(f * np.ones_like(x)) * dx
fFS = A0/2

A = np.zeros(20)
B = np.zeros(20)
for k in range(20):
    A[k] = np.sum(f * np.cos(np.pi*(k+1)*x/L)) * dx # Inner product
    B[k] = np.sum(f * np.sin(np.pi*(k+1)*x/L)) * dx
    fFS = fFS + A[k]*np.cos((k+1)*np.pi*x/L) + B[k]*np.sin((k+1)*np.pi*x/L)
    ax.plot(x,fFS,'-')

</t>
<t tx="ekr.20241218004929.87">## Plot amplitudes

fFS = (A0/2) * np.ones_like(f)
kmax = 100
A = np.zeros(kmax)
B = np.zeros(kmax)
ERR = np.zeros(kmax)

A[0] = A0/2
ERR[0] = np.linalg.norm(f-fFS)/np.linalg.norm(f)

for k in range(1,kmax):
    A[k] = np.sum(f * np.cos(np.pi*k*x/L)) * dx
    B[k] = np.sum(f * np.sin(np.pi*k*x/L)) * dx
    fFS = fFS + A[k] * np.cos(k*np.pi*x/L) + B[k] * np.sin(k*np.pi*x/L)
    ERR[k] = np.linalg.norm(f-fFS)/np.linalg.norm(f)
    
thresh = np.median(ERR) * np.sqrt(kmax) * (4/np.sqrt(3))
r = np.max(np.where(ERR &gt; thresh))

fig, axs = plt.subplots(2,1)
axs[0].semilogy(np.arange(kmax),A,color='k',linewidth=2)
axs[0].semilogy(r,A[r],'o',color='b',markersize=10)
plt.sca(axs[0])
plt.title('Fourier Coefficients')

axs[1].semilogy(np.arange(kmax),ERR,color='k',linewidth=2)
axs[1].semilogy(r,ERR[r],'o',color='b',markersize=10)
plt.sca(axs[1])
plt.title('Error')

plt.show()

</t>
<t tx="ekr.20241218004929.88"></t>
<t tx="ekr.20241218004929.89">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004929.91">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

dx = 0.01
L = 2*np.pi
x = np.arange(0,L+dx,dx)
n = len(x)
nquart = int(np.floor(n/4))

f = np.zeros_like(x)
f[nquart:3*nquart] = 1

A0 = np.sum(f * np.ones_like(x)) * dx * 2 / L
fFS = A0/2 * np.ones_like(f)

for k in range(1,101):
    Ak = np.sum(f * np.cos(2*np.pi*k*x/L)) * dx * 2 / L
    Bk = np.sum(f * np.sin(2*np.pi*k*x/L)) * dx * 2 / L
    fFS = fFS + Ak*np.cos(2*k*np.pi*x/L) + Bk*np.sin(2*k*np.pi*x/L)
    
plt.plot(x,f,color='k',linewidth=2)
plt.plot(x,fFS,'-',color='r',linewidth=1.5)
plt.show()

</t>
<t tx="ekr.20241218004929.92"></t>
<t tx="ekr.20241218004929.93"></t>
<t tx="ekr.20241218004929.94">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004929.96">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import animation, rc
from IPython.display import HTML
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})
plt.rcParams['animation.html'] = 'jshtml'


dx = 0.01
L = 10
x = np.arange(0,L+dx,dx)
n = len(x)
nquart = int(np.floor(n/4))

f = np.zeros_like(x)
f[nquart:3*nquart] = 1

A0 = np.sum(f * np.ones_like(x)) * dx * 2 / L
fFS = A0/2 * np.ones_like(f)

fig,ax = plt.subplots()
plt.plot(x,f,color='k',linewidth=2)
fFS_plot, = plt.plot([],[],color='r',linewidth=2)

all_fFS = np.zeros((len(fFS),101))
all_fFS[:,0] = fFS

for k in range(1,101):
    Ak = np.sum(f * np.cos(2*np.pi*k*x/L)) * dx * 2 / L
    Bk = np.sum(f * np.sin(2*np.pi*k*x/L)) * dx * 2 / L
    fFS = fFS + Ak*np.cos(2*k*np.pi*x/L) + Bk*np.sin(2*k*np.pi*x/L)
    all_fFS[:,k] = fFS

def init():
    ax.set_xlim(x[0],x[-1])
    ax.set_ylim(-0.2, 1.2)
    return fFS

def animate(iter):
    fFS_plot.set_data(x,all_fFS[:,iter])
    return fFS_plot

anim = animation.FuncAnimation(fig,animate,init_func=init,frames=101,interval=50,blit=False,repeat=False)
HTML(anim.to_jshtml())

</t>
<t tx="ekr.20241218004929.97"></t>
<t tx="ekr.20241218004929.98"></t>
<t tx="ekr.20241218004929.99">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.1">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.10">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.100">## Downsample Test Images
X = np.zeros((x1.shape[0],4))
X[:,0] = x1
X[:,1] = x2
X[:,2] = x3
X[:,3] = x4

Y = np.zeros((120,4))
for k in range(4):
    temp = np.reshape(np.copy(X[:,k]),(m,n))
    tempSmall = resize(temp, (10, 12), anti_aliasing=True)
    Y[:,k] = np.reshape(tempSmall,120,1)

</t>
<t tx="ekr.20241218004930.101">## L1 Search, Testclean
y1 = np.copy(Y[:,0])
eps = 0.01

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'ineq', 'fun': lambda x:  eps - np.linalg.norm(Theta @ x - y1,2)})
x0 = np.linalg.pinv(Theta) @ y1 # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s1 = res.x

</t>
<t tx="ekr.20241218004930.102">plt.figure()
plt.plot(s1)
plt.figure()
plt.imshow(np.reshape(Train @ (s1/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x1 - Train @ (s1/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x1-Train[:,L] @ (s1[L]/normTheta[L]))/np.linalg.norm(x1)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()


</t>
<t tx="ekr.20241218004930.103">## L1 Search, Mustache
y2 = np.copy(Y[:,1])
eps = 500

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'ineq', 'fun': lambda x:  eps - np.linalg.norm(Theta @ x - y2,2)})
x0 = np.linalg.pinv(Theta) @ y2 # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s2 = res.x

</t>
<t tx="ekr.20241218004930.104">plt.figure()
plt.plot(s2)
plt.figure()
plt.imshow(np.reshape(Train @ (s2/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x2 - Train @ (s2/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x2-Train[:,L] @ (s2[L]/normTheta[L]))/np.linalg.norm(x2)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()

</t>
<t tx="ekr.20241218004930.105">## L1 Search, Occlusion
y3 = np.copy(Y[:,2])
eps = 1000

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'ineq', 'fun': lambda x:  eps - np.linalg.norm(Theta @ x - y3,2)})
x0 = np.linalg.pinv(Theta) @ y3 # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s3 = res.x

</t>
<t tx="ekr.20241218004930.106">plt.figure()
plt.plot(s3)
plt.figure()
plt.imshow(np.reshape(Train @ (s3/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x3 - Train @ (s3/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x3-Train[:,L] @ (s3[L]/normTheta[L]))/np.linalg.norm(x3)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()

</t>
<t tx="ekr.20241218004930.107">## L1 Search, Noise
y4 = np.copy(Y[:,3])
eps = 10

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'ineq', 'fun': lambda x:  eps - np.linalg.norm(Theta @ x - y4,2)})
x0 = np.linalg.pinv(Theta) @ y4 # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s4 = res.x

</t>
<t tx="ekr.20241218004930.108">plt.figure()
plt.plot(s4)
plt.figure()
plt.imshow(np.reshape(Train @ (s4/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x4 - Train @ (s4/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x4-Train[:,L] @ (s4[L]/normTheta[L]))/np.linalg.norm(x4)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()

</t>
<t tx="ekr.20241218004930.109">## Least Squares Is No Good
s4L2 = np.linalg.pinv(Train) @ x4
plt.figure()
plt.plot(s4L2)
plt.figure()
plt.imshow(np.reshape(Train @ (s4L2/normTheta),(m,n)).T,cmap='gray')
plt.figure()
plt.imshow(np.reshape(x4 - Train @ (s4L2/normTheta),(m,n)).T,cmap='gray')

binErr = np.zeros(nPeople)
for k in range(nPeople):
    L = range(k*nTrain,(k+1)*nTrain)
    binErr[k] = np.linalg.norm(x4-Train[:,L] @ (s4L2[L]/normTheta[L]))/np.linalg.norm(x4)
    
plt.figure()
plt.bar(range(nPeople),binErr)
plt.show()

</t>
<t tx="ekr.20241218004930.110"></t>
<t tx="ekr.20241218004930.111"></t>
<t tx="ekr.20241218004930.112">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.114">import numpy as np
import matplotlib.pyplot as plt
import os
import scipy.io

plt.rcParams['figure.figsize'] = [7, 7]
plt.rcParams.update({'font.size': 18})

mat = scipy.io.loadmat(os.path.join('..','DATA','allFaces.mat'))
faces = mat['faces']
nfaces = mat['nfaces'].reshape(-1)


</t>
<t tx="ekr.20241218004930.115">## Function Definitions

def shrink(X,tau):
    Y = np.abs(X)-tau
    return np.sign(X) * np.maximum(Y,np.zeros_like(Y))
def SVT(X,tau):
    U,S,VT = np.linalg.svd(X,full_matrices=0)
    out = U @ np.diag(shrink(S,tau)) @ VT
    return out
def RPCA(X):
    n1,n2 = X.shape
    mu = n1*n2/(4*np.sum(np.abs(X.reshape(-1))))
    lambd = 1/np.sqrt(np.maximum(n1,n2))
    thresh = 10**(-7) * np.linalg.norm(X)
    
    S = np.zeros_like(X)
    Y = np.zeros_like(X)
    L = np.zeros_like(X)
    count = 0
    while (np.linalg.norm(X-L-S) &gt; thresh) and (count &lt; 1000):
        L = SVT(X-S+(1/mu)*Y,1/mu)
        S = shrink(X-L+(1/mu)*Y,lambd/mu)
        Y = Y + mu*(X-L-S)
        count += 1
    return L,S


</t>
<t tx="ekr.20241218004930.116">X = faces[:,:nfaces[0]]
L,S = RPCA(X)

</t>
<t tx="ekr.20241218004930.117">inds = (3,4,14,15,17,18,19,20,21,32,43)

for k in inds:
    fig,axs = plt.subplots(2,2)
    axs = axs.reshape(-1)
    axs[0].imshow(np.reshape(X[:,k-1],(168,192)).T,cmap='gray')
    axs[0].set_title('X')
    axs[1].imshow(np.reshape(L[:,k-1],(168,192)).T,cmap='gray')
    axs[1].set_title('L')
    axs[2].imshow(np.reshape(S[:,k-1],(168,192)).T,cmap='gray')
    axs[2].set_title('S')
    for ax in axs:
        ax.axis('off')

</t>
<t tx="ekr.20241218004930.118"></t>
<t tx="ekr.20241218004930.119"></t>
<t tx="ekr.20241218004930.12">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})


x = np.arange(0,1,0.001)
n = len(x)
n2 = int(np.floor(n/2))
n4 = int(np.floor(n/4))

f10 = np.zeros_like(x)
f10[:n2] = 1
f10[n2:] = -1

f21 = np.zeros_like(x)
f21[:n4] = 1
f21[n4:n2] = -1
f21 = f21 * np.sqrt(2)

f22 = np.zeros_like(x)
f22[n2:(n2+n4)] = 1
f22[(n2+n4):] = -1
f22 = f22 * np.sqrt(2)

# x = np.concatenate((-1, 0, x, 1, 2))
x = np.append([-1,0],x)
x = np.append(x,[1,2])

f10 = np.pad(f10, (2, 2), 'constant')
f21 = np.pad(f21, (2, 2), 'constant')
f22 = np.pad(f22, (2, 2), 'constant')

fig,axs = plt.subplots(3,1)
axs[0].plot(x,f10,color='k',linewidth=2)
axs[0].set_xlim(-0.2,1.2)
axs[0].set_ylim(-1.75,1.75)
axs[1].plot(x,f21,color='k',linewidth=2)
axs[1].set_xlim(-0.2,1.2)
axs[1].set_ylim(-1.75,1.75)
axs[2].plot(x,f22,color='k',linewidth=2)
axs[2].set_xlim(-0.2,1.2)
axs[2].set_ylim(-1.75,1.75)
plt.show()

</t>
<t tx="ekr.20241218004930.120"></t>
<t tx="ekr.20241218004930.121">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.123">import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize
from matplotlib import rcParams
rcParams['figure.figsize'] = [12, 8]
rcParams.update({'font.size': 18})


# Function definitions
def fit1(x0,t):
    x,y=t
    return np.max(np.abs(x0[0]*x + x0[1]-y))
def fit2(x0,t):
    x,y=t
    return np.sum(np.abs(x0[0]*x + x0[1]-y))
def fit3(x0,t):
    x,y=t
    return np.sum(np.power(np.abs(x0[0]*x + x0[1]-y),2))


</t>
<t tx="ekr.20241218004930.124"># The data
x = np.arange(1,11)
y = np.array([0.2,0.5,0.3,3.5,1.0,1.5,1.8,2.0,2.3,2.2])
t = (x,y)

x0 = np.array([1,1])
p1 = scipy.optimize.fmin(fit1,x0,args=(t,));
p2 = scipy.optimize.fmin(fit2,x0,args=(t,));
p3 = scipy.optimize.fmin(fit3,x0,args=(t,));

xf = np.arange(0,11,0.1)
y1 = np.polyval(p1,xf)
y2 = np.polyval(p2,xf)
y3 = np.polyval(p3,xf)

plt.figure()
plt.plot(xf,y1,color='k',label='E_\infty')
plt.plot(xf,y2,'--',color='k',linewidth=2,label='E_1')
plt.plot(xf,y3,color='k',linewidth=2,label='E_2')
plt.plot(x,y,'o',color='r',linewidth=2)

plt.ylim(0,4)
plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004930.125">x = np.arange(1,11)
y = np.array([0.2,0.5,0.3,0.7,1.0,1.5,1.8,2.0,2.3,2.2])
t = (x,y)

x0 = np.array([1,1])
p1 = scipy.optimize.fmin(fit1,x0,args=(t,));
p2 = scipy.optimize.fmin(fit2,x0,args=(t,));
p3 = scipy.optimize.fmin(fit3,x0,args=(t,));

xf = np.arange(0,11,0.1)
y1 = np.polyval(p1,xf)
y2 = np.polyval(p2,xf)
y3 = np.polyval(p3,xf)

plt.figure()
plt.plot(xf,y1,color='k',label='E_\infty')
plt.plot(xf,y2,'--',color='k',linewidth=2,label='E_1')
plt.plot(xf,y3,color='k',linewidth=2,label='E_2')
plt.plot(x,y,'o',color='r',linewidth=2)

plt.ylim(0,4)
plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004930.126"></t>
<t tx="ekr.20241218004930.127"></t>
<t tx="ekr.20241218004930.128">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.13">x = np.arange(-5,5,0.001)
fMexHat = (1-np.power(x,2)) * np.exp(-np.power(x,2)/2)
plt.plot(x,fMexHat,color='k',linewidth=2)
plt.show()

</t>
<t tx="ekr.20241218004930.130">import numpy as np
import matplotlib.pyplot as plt
import scipy.optimize
import scipy.interpolate
from matplotlib import rcParams
from matplotlib import cm
from mpl_toolkits.mplot3d import Axes3D
rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241218004930.131">h = 0.5
x = np.arange(-6,6+h,h)
y = np.arange(-6,6+h,h)

X,Y = np.meshgrid(x,y)
F0 = 1.5 - 1.0*np.exp(-0.03*(3*np.power(X,2)+np.power(Y,2)))
F = 1.5 - 1.6*np.exp(-0.05*(3*np.power(X,2)+np.power(Y+3,2)))
F2 = F + (0.5 - 1.0*np.exp(-0.1*(3*np.power(X-3,2)+np.power(Y-3,2))))

# dF0x,dF0y = np.gradient(F0,h,h) 
# dF2x,dF2y = np.gradient(F2,h,h) 

dF0y,dF0x = np.gradient(F0,h,h) 
dF2y,dF2x = np.gradient(F2,h,h) 

</t>
<t tx="ekr.20241218004930.132">rcParams['figure.figsize'] = [16, 8]
fig,axs = plt.subplots(1,2,subplot_kw={'projection': '3d'})
axs[0].plot_surface(X, Y, F0, cmap='gray',linewidth=0, antialiased=False)
axs[0].contour(X, Y, F0, zdir='z', offset=axs[0].get_zlim()[0], cmap='gray')
axs[1].plot_surface(X, Y, F2, cmap='gray',linewidth=0, antialiased=False)
axs[1].contour(X, Y, F2, zdir='z', offset=axs[0].get_zlim()[0], cmap='gray')

plt.show()

</t>
<t tx="ekr.20241218004930.133">rcParams['figure.figsize'] = [16, 16]
fig,axs = plt.subplots(2,2,subplot_kw={'projection': '3d'})
axs = axs.reshape(-1)
axs[0].plot_surface(X, Y, dF0x, cmap='gray',linewidth=0, antialiased=False)
axs[2].plot_surface(X, Y, dF0y, cmap='gray',linewidth=0, antialiased=False)
axs[1].plot_surface(X, Y, dF2x, cmap='gray',linewidth=0, antialiased=False)
axs[3].plot_surface(X, Y, dF2y, cmap='gray',linewidth=0, antialiased=False)

plt.show()

</t>
<t tx="ekr.20241218004930.134">## Gradient Descent
x = np.zeros(10)
y = np.zeros(10)
f = np.zeros(10)

Fquad = np.power(X,2) + 3*np.power(Y,2)

x[0] = 3  # Initial guess
y[0] = 2 

f[0] = x[0]**2 + 3*y[0]**2 # Initial function value

for j in range(len(x)-1):
    Del = (x[j]**2 + 9*y[j]**2)/(2*x[j]**2 + 54*y[j]**2)
    x[j+1] = (1 - 2*Del)*x[j] # update values
    y[j+1] = (1 - 6*Del)*y[j]
    f[j+1] = x[j+1]**2 + 3*y[j+1]**2
    
    if np.abs(f[j+1]-f[j]) &lt; 10**(-6): # check convergence
        x = x[:j+2]
        y = y[:j+2]
        f = f[:j+2]
        break

</t>
<t tx="ekr.20241218004930.135">fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})
ax.plot_surface(X, Y, Fquad,linewidth=0,color='k',alpha=0.3)
ax.scatter(x,y,f,'o',color='r',s=200)
ax.plot(x,y,f,':',color='k',linewidth=3)
ax.contour(X, Y, Fquad, zdir='z', offset=ax.get_zlim()[0], cmap='gray')
ax.view_init(elev=40, azim=-140)
plt.show()

</t>
<t tx="ekr.20241218004930.136">## Computing the gradient descent with fmin

h = 0.1
x = np.arange(-6,6+h,h)
y = np.arange(-6,6+h,h)
X,Y = np.meshgrid(x,y)

F1 = 1.5 - 1.6*np.exp(-0.05*(3*np.power(X+3,2)+np.power(Y+3,2)))
F = F1 + 0.5 - np.exp(-0.1*(3*np.power(X-3,2)+np.power(Y-3,2)))

dFy,dFx = np.gradient(F,h,h)

F_interp = scipy.interpolate.RectBivariateSpline(x,y,F)
dFx_interp = scipy.interpolate.RectBivariateSpline(x,y,dFx)
dFy_interp = scipy.interpolate.RectBivariateSpline(x,y,dFy)


x0 = np.array([4,0,-5])
y0 = np.array([0,-5,2])

def delsearch(Del,t):
    x,y,dfx,dfy,X,Y,F = t
    x0 = x-Del*dfx
    y0 = y-Del*dfy
    return F_interp(x0,y0)


for jj in range(3):
    x = np.zeros(10)
    y = np.zeros(10)
    f = np.zeros(10)
    x[0] = x0[jj]
    y[0] = y0[jj]
    f[0] = F_interp(x[0],y[0])
    dfx = dFx_interp(x[0],y[0])
    dfy = dFy_interp(x[0],y[0])
    for j in range(len(x)-1):
        t = x[j],y[j],dfx,dfy,X,Y,F
        Del = scipy.optimize.fmin(delsearch,0.2,args=(t,),disp=False);
        x[j+1] = x[j]-Del*dfx # Update x, y, and f
        y[j+1] = y[j]-Del*dfy
        f[j+1] = F_interp(x[j+1],y[j+1])
        dfx = dFx_interp(x[j+1],y[j+1])
        dfy = dFy_interp(x[j+1],y[j+1])
        
        if np.abs(f[j+1]-f[j]) &lt; 10**(-6):
            x = x[:j+2]
            y = y[:j+2]
            f = f[:j+2]
            break
    
    if jj == 0:
        x1 = x
        y1 = y
        f1 = f
    if jj == 1:
        x2 = x
        y2 = y
        f2 = f
    if jj == 2:
        x3 = x
        y3 = y
        f3 = f

</t>
<t tx="ekr.20241218004930.137">rcParams['figure.figsize'] = [12, 8]
plt.figure()
plt.contour(X,Y,F-1,10,cmap='binary')
plt.plot(x1,y1,'o',color='r')
plt.plot(x1,y1,':',color='k')
plt.plot(x2,y2,'o',color='m')
plt.plot(x2,y2,':',color='k')
plt.plot(x3,y3,'o',color='b')
plt.plot(x3,y3,':',color='k')
plt.show()

</t>
<t tx="ekr.20241218004930.138">fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})
ax.plot_surface(X, Y, F-0.2,cmap='binary',alpha=0.5)
ax.plot(x1,y1,f1,'o',color='r',markersize=10)
ax.plot(x1,y1,f1,':',color='k')
ax.plot(x2,y2,f2,'o',color='m',markersize=10)
ax.plot(x2,y2,f2,':',color='k')
ax.plot(x3,y3,f3,'o',color='b',markersize=10)
ax.plot(x3,y3,f3,':',color='k')
ax.view_init(elev=40, azim=-100)
plt.show()

</t>
<t tx="ekr.20241218004930.139">## Alternating Descent
h = 0.1
x = np.arange(-6,6+h,h)
y = np.arange(-6,6+h,h)
X,Y = np.meshgrid(x,y)

F1 = 1.5 - 1.6*np.exp(-0.05*(3*np.power(X+3,2)+np.power(Y+3,2)))
F = F1 + 0.5 - np.exp(-0.1*(3*np.power(X-3,2)+np.power(Y-3,2)))

F_interp = scipy.interpolate.RectBivariateSpline(x,y,F)

x0 = np.array([4,0,-5])
y0 = np.array([0,-5,2])

for jj in range(3):
    xa = np.zeros(5)
    ya = np.zeros(5)
    f = np.zeros(5)
    xa[0] = x0[jj]
    ya[0] = y0[jj]
    f[0] = F_interp(xa[0],ya[0])
    
    fx = F_interp(xa[0],y)
    xa[1]=xa[0]
    ya[1]=y[np.argmin(fx)]
    
    fy = F_interp(x,ya[1])
    ya[2]=ya[1]
    xa[2]=x[np.argmin(fy)]
    
    fx = F_interp(xa[2],y)
    xa[3]=xa[2]
    ya[3]=y[np.argmin(fx)]
    
    fy = F_interp(x,ya[3])
    ya[4]=ya[3]
    xa[4]=x[np.argmin(fy)]
    
    for j in range(1,5):
        f[j] = F_interp(xa[j],ya[j])
    
    if jj == 0:
        x1 = xa
        y1 = ya
        f1 = f
    if jj == 1:
        x2 = xa
        y2 = ya
        f2 = f
    if jj == 2:
        x3 = xa
        y3 = ya
        f3 = f

</t>
<t tx="ekr.20241218004930.14"></t>
<t tx="ekr.20241218004930.140">rcParams['figure.figsize'] = [12, 8]
plt.figure()
plt.contour(X,Y,F-1,10,cmap='binary')
plt.plot(x1,y1,'o',color='r')
plt.plot(x1,y1,':',color='k')
plt.plot(x2,y2,'o',color='m')
plt.plot(x2,y2,':',color='k')
plt.plot(x3,y3,'o',color='b')
plt.plot(x3,y3,':',color='k')
plt.show()

</t>
<t tx="ekr.20241218004930.141">fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})
ax.plot_surface(X, Y, F-0.2,cmap='binary',alpha=0.5)
ax.plot(x1,y1,f1,'o',color='r',markersize=10)
ax.plot(x1,y1,f1,':',color='k')
ax.plot(x2,y2,f2,'o',color='m',markersize=10)
ax.plot(x2,y2,f2,':',color='k')
ax.plot(x3,y3,f3,'o',color='b',markersize=10)
ax.plot(x3,y3,f3,':',color='k')
ax.view_init(elev=40, azim=-100)
plt.show()

</t>
<t tx="ekr.20241218004930.142"></t>
<t tx="ekr.20241218004930.143">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.145">import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize
from scipy.optimize import fmin
from matplotlib import rcParams
rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004930.146"># Underdetermined
n = 20
m = 100
A = np.random.rand(n,m)
b = np.random.rand(n)

def two_norm(x):
    return np.linalg.norm(x,ord=2)

constr = ({'type': 'eq', 'fun': lambda x:  A @ x - b})
x0 = np.random.rand(m)
res = minimize(two_norm, x0, method='SLSQP',constraints=constr)
x2 = res.x

def one_norm(x):
    return np.linalg.norm(x,ord=1)

res = minimize(one_norm, x0, method='SLSQP',constraints=constr)
x1 = res.x

</t>
<t tx="ekr.20241218004930.147">plt.rcParams['figure.figsize'] = [12, 8]
fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[0].bar(range(m),x2)
axs[0].set_title('x2')
axs[1].bar(range(m),x1)
axs[1].set_title('x1')

axs[2].hist(x2,40)
axs[3].hist(x1,40)


plt.show()

</t>
<t tx="ekr.20241218004930.148"># Overdetermined
n = 500
m = 100
A = np.random.rand(n,m)
b = np.random.rand(n)

xdag = np.linalg.pinv(A)@b

lam = np.array([0, 0.1, 0.5])



def reg_norm(x,A,b,lam):
    return np.linalg.norm(A@x-b,ord=2) + lam*np.linalg.norm(x,ord=1)

fig,axs = plt.subplots(len(lam),2)
for j in range(len(lam)):
    res = minimize(reg_norm,args=(A,b,lam[j]),x0=xdag)
    x = res.x
    axs[j,0].bar(range(m),x)
    axs[j,0].set_ylabel('lam='+str(lam[j]))
    axs[j,1].hist(x,20)
    axs[j,1].set_xlim(-0.15,0.15)


</t>
<t tx="ekr.20241218004930.149">## Matrix Overdetermined System
plt.rcParams['figure.figsize'] = [12, 12]

# overdetermined
n = 300
m = 60
p = 20
A = np.random.rand(n,m)
b = np.random.rand(n,p)
lam = np.array([0,0.1])

xdag = np.linalg.pinv(A)@b
xdag = xdag.reshape(-1)

def reg_norm_2d(x,A,b,lam,m,p):
    # scipy minimize() does not accept multidimensional x
    # To get around this, we pass x as a vector and reshape it
    x = np.reshape(x,(m,p))
    return np.linalg.norm(A@x-b,ord=2) + lam*np.linalg.norm(x,ord=1)


fig,axs = plt.subplots(len(lam),1)
for j in range(len(lam)):
    res = minimize(reg_norm_2d,args=(A,b,lam[j],m,p),x0=xdag)
    x = res.x
    x = x.reshape(m,p)
    x_pcolor = axs[j].pcolor(x.T,cmap='hot')
    fig.colorbar(x_pcolor, ax=axs[j])
    axs[j].set_ylabel('lam='+str(lam[j]))
    
plt.show()

</t>
<t tx="ekr.20241218004930.15">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.150"></t>
<t tx="ekr.20241218004930.151">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.153">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from sklearn import linear_model

rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004930.154">n = 100
L = 4
x = np.linspace(0,L,n)
f = np.power(x,2) # Parabola with 100 data points

M = 20 # Polynomial degree

phi = np.zeros((n,M))
for j in range(M):
    phi[:,j] = np.power(x,j) # Build matrix A
    
plt.figure()
plt.plot(x,f,color='k')
    
fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

for j in range(4):
    fn = np.power(x,2) + 0.1*np.random.randn(*x.shape)
    an = np.linalg.pinv(phi) @ fn # Least-square fit
    fna = phi @ an 
    En = np.linalg.norm(f-fna,ord=2)/np.linalg.norm(f,ord=2)
    axs[j].bar(range(len(an)),an)

plt.show()

</t>
<t tx="ekr.20241218004930.155">## Different regressions
plt.figure()
plt.plot(x,f,color='k')

lam = 0.1
phi2 = phi[:,1:]
E1 = np.zeros(100)
E2 = np.zeros(100)
E3 = np.zeros(100)
E4 = np.zeros(100)
E5 = np.zeros(100)
E6 = np.zeros(100)

A1 = np.zeros((M,100))
A2 = np.zeros((M,100))
A3 = np.zeros((M,100))
A4 = np.zeros((M,100))
A5 = np.zeros((M,100))
A6 = np.zeros((M,100))

for jj in range(100):
# for jj in range(10):
    f = np.power(x,2)+0.2*np.random.randn(n)
    
    a1 = np.linalg.pinv(phi) @ f
    f1 = phi @ a1
    E1[jj] = np.linalg.norm(f-f1,ord=2)/np.linalg.norm(f,ord=2)
    
    a2 = np.linalg.lstsq(phi,f,rcond=None)[0]
    f2 = phi @ a2
    E2[jj] = np.linalg.norm(f-f2,ord=2)/np.linalg.norm(f,ord=2)
    
    regr3 = linear_model.ElasticNet(alpha=1.0, copy_X=True, l1_ratio=lam, max_iter=10**5,random_state=0)
    regr3.fit(phi, f)  
    a3 = regr3.coef_
    f3 = phi @ a3
    E3[jj] = np.linalg.norm(f-f3,ord=2)/np.linalg.norm(f,ord=2)
    
    regr4 = linear_model.ElasticNet(alpha=0.8, copy_X=True, l1_ratio=lam, max_iter=10**5,random_state=0)
    regr4.fit(phi, f)  
    a4 = regr4.coef_
    f4 = phi @ a4
    E4[jj] = np.linalg.norm(f-f4,ord=2)/np.linalg.norm(f,ord=2)
    
    huber = linear_model.HuberRegressor().fit(phi, f) # matlab's robustfit() does not have an exact sklearn analogue
    a5 = huber.coef_
    f5 = phi @ a5
    E5[jj] = np.linalg.norm(f-f5,ord=2)/np.linalg.norm(f,ord=2)

    ridge = linear_model.Ridge(alpha=1.0).fit(phi,f)
    a6 = ridge.coef_
    f6 = phi @ a6
    E6[jj] = np.linalg.norm(f-f6,ord=2)/np.linalg.norm(f,ord=2)

    
    A1[:,jj] = a1
    A2[:,jj] = a2
    A3[:,jj] = a3
    A4[:,jj] = a4
    A5[:,jj] = a5
    A6[:,jj] = a6

    plt.plot(x,f)
    
Err = np.column_stack((E1,E2,E3,E4,E5,E6))
Err2 = np.column_stack((E1,E2,E3,E4,E5))

</t>
<t tx="ekr.20241218004930.156">plt.rcParams['figure.figsize'] = [12, 18]
rcParams.update({'font.size': 14})
fig,axs = plt.subplots(3,2)
axs = axs.reshape(-1)

axs[0].boxplot(A1.T)
axs[0].set_title('pinv')
axs[1].boxplot(A2.T)
axs[1].set_title('lstsq')
axs[2].boxplot(A3.T)
axs[2].set_title('elastic (alpha=1)')
axs[3].boxplot(A4.T)
axs[3].set_title('elastic (alpha=0.8)')
axs[4].boxplot(A5.T)
axs[4].set_title('huber')
axs[5].boxplot(A6.T)
axs[5].set_title('ridge')

for ax in axs:
    ax.set_xlim(0,M)
    
plt.rcParams['figure.figsize'] = [8, 8]

plt.figure()
plt.boxplot(Err)

plt.show()

</t>
<t tx="ekr.20241218004930.157">M = 10
En = np.zeros((100,M))
phi = np.zeros((len(x),M))
for jj in range(M):
    for j in range(jj):
        phi[:,j] = np.power(x,j)
    f = np.power(x,2)
    for j in range(100):
        fn = np.power(x,2) + 0.1*np.random.randn(n)
        an = np.linalg.pinv(phi) @ fn
        fna = phi @ an
        En[j,jj] = np.linalg.norm(f-fna,ord=2)/np.linalg.norm(f,ord=2)
        
plt.boxplot(En)

plt.show()

</t>
<t tx="ekr.20241218004930.158"></t>
<t tx="ekr.20241218004930.159">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.161">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib import rcParams
rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [8,8]


</t>
<t tx="ekr.20241218004930.162">fig,ax = plt.subplots(1)
x = np.arange(0.2,5,0.1)
y = np.divide(1,x)

x2 = np.copy(x)
n = len(x2)
y2 = np.divide(1,x2) + 0.5*np.random.randn(n)

y3 = (np.tile(y2,(5,1)) + 2*np.random.rand(5,n) + 1)
y3 = np.reshape(y3,-1)
x3 = np.tile(x,(1,5)).reshape(-1)

plt.plot(x,y,color='k',linewidth=2)

rect = Rectangle((0.5,0.4), 0.9, 1.6,linewidth=1,edgecolor='k',facecolor='grey',alpha=0.6) 
ax.add_patch(rect)

plt.scatter(x2,y2,100,color='magenta',edgecolors='k')
plt.scatter(x3,y3,100,color='lime',edgecolors='k')


plt.xlim(0.2,4)
plt.ylim(0,5.5)

plt.show()

</t>
<t tx="ekr.20241218004930.163"></t>
<t tx="ekr.20241218004930.164">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.166">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.patches import Rectangle
from matplotlib import rcParams
rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [8,8]


</t>
<t tx="ekr.20241218004930.167">n = 200
L = 8
x = np.linspace(0,L,n)
x1 = x[:100]    # Train
x2 = x[100:200] # Test
n1 = len(x1)
n2 = len(x2)
ftrain = np.power(x1,2) # Train parabola x = [0,4]
ftest = np.power(x2,2)  # Test parabola x = [4,8]

plt.plot(x1,ftrain,color='r',linewidth=2)
plt.plot(x2,ftest,color='b',linewidth=2)
plt.show()
M = 30 # number of model terms
Eni = np.zeros((100,M))
Ene = np.zeros((100,M))
for jj in range(M):
    phi_i = np.zeros((n1,jj+1))
    phi_e = np.zeros((n2,jj+1))
    for j in range(jj):
        phi_i[:,j] = np.power(x1,j) # interpolation key
        phi_e[:,j] = np.power(x2,j) # extrapolation key
    
    f = np.power(x,2)
    for j in range(100):
        fni = np.power(x1,2) + 0.1*np.random.randn(n1) # interpolation
        fne = np.power(x2,2) + 0.1*np.random.randn(n2) # extrapolation
        
        ani = np.linalg.pinv(phi_i) @ fni
        fnai = phi_i @ ani
        Eni[j,jj] = np.linalg.norm(ftrain-fnai,ord=2)/np.linalg.norm(ftrain,ord=2)
        
        fnae = phi_e @ ani # use loadings from x in [0,4]
        Ene[j,jj] = np.linalg.norm(ftest-fnae,ord=2)/np.linalg.norm(ftest,ord=2)
        
        

</t>
<t tx="ekr.20241218004930.168">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[0].boxplot(Eni)
axs[0].set_ylim(0,0.7)
axs[1].boxplot(Eni)
axs[1].set_ylim(0,0.02)
axs[2].boxplot(Ene)
axs[3].boxplot(np.log(Ene+1))
axs[3].set_ylim(0,30)

for ax in axs:
    ax.set_xticks((1,5,10,15,20,25,30))
    ax.set_xticklabels((1,5,10,15,20,25,30))

plt.show()


</t>
<t tx="ekr.20241218004930.169"></t>
<t tx="ekr.20241218004930.17">from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

fig,axs = plt.subplots(1,3)

# Plot image
img = axs[0].imshow(B)
img.set_cmap('gray')
axs[0].axis('off')

# Compute row-wise FFT

Cshift = np.zeros_like(B,dtype='complex_')
C = np.zeros_like(B,dtype='complex_')

for j in range(B.shape[0]):
    Cshift[j,:] = np.fft.fftshift(np.fft.fft(B[j,:]))
    C[j,:] = np.fft.fft(B[j,:])
    
img = axs[1].imshow(np.log(np.abs(Cshift)))
img.set_cmap('gray')
axs[1].axis('off')

# Compute column-wise FFT

D = np.zeros_like(C)
for j in range(C.shape[1]):
    D[:,j] = np.fft.fft(C[:,j])

img = axs[2].imshow(np.fft.fftshift(np.log(np.abs(D))))
img.set_cmap('gray')
axs[2].axis('off')

plt.show()

# Much more efficient to use fft2
D = np.fft.fft2(B)

</t>
<t tx="ekr.20241218004930.170">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.172">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from sklearn import linear_model
from mpl_toolkits.mplot3d import Axes3D 


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]


</t>
<t tx="ekr.20241218004930.173">n = 100
L = 4
x = np.linspace(0,L,n)
f = np.power(x,2) # parabola with 100 data points

M = 21 # Polynomial degree
phi = np.zeros((n,M))
for j in range(M):
    phi[:,j] = np.power(x,j) # build matrix A
    
trials = np.array([2, 10, 100])

fig,axs = plt.subplots(3,3)

for j in range(len(trials)):
    trial = trials[j]
    E1 = np.zeros(trial)
    E2 = np.zeros(trial)
    E3 = np.zeros(trial)
    
    A1 = np.zeros((M,trial))
    A2 = np.zeros((M,trial))
    A3 = np.zeros((M,trial))

    
    for jj in range(trial):
        f = np.power(x,2) + 0.2*np.random.randn(n)
        a1 = np.linalg.pinv(np.copy(phi)) @ np.copy(f)
        f1 = phi @ a1
        E1[jj] = np.linalg.norm(f-f1,ord=2)/np.linalg.norm(f,ord=2)
        
        a2 = np.linalg.lstsq(np.copy(phi),np.copy(f),rcond=None)[0]
        f2 = phi @ a2
        E2[jj] = np.linalg.norm(f-f2,ord=2)/np.linalg.norm(f,ord=2)
        
#         regr3 = linear_model.ElasticNet(alpha=1.0, copy_X=True, l1_ratio=0.1, max_iter=10**5,random_state=0)
        regr3 = linear_model.Lasso(alpha=1)
        regr3.fit(phi, f)  
        a3 = regr3.coef_
        f3 = phi @ a3
        E3[jj] = np.linalg.norm(f-f3,ord=2)/np.linalg.norm(f,ord=2)
        
        A1[:,jj] = a1
        A2[:,jj] = a2
        A3[:,jj] = a3
        
    A1m = np.mean(A1,axis=1)
    A2m = np.mean(A2,axis=1)
    A3m = np.mean(A3,axis=1)
    
    Err = np.column_stack((E1,E2,E3))
    
    axs[0,j].bar(range(M),A1m)
    axs[1,j].bar(range(M),A2m)
    axs[2,j].bar(range(M),A3m)
    
plt.show()

</t>
<t tx="ekr.20241218004930.174">plt.rcParams['figure.figsize'] = [8,8]

Atot = np.column_stack((A1m,A2m,A3m)) # Average loadings of three methods
Atot2 = (Atot&gt;0.2) * Atot # threshold
Atot3 = np.column_stack((Atot,Atot2)) # combine both thresholded and not

for j in range(3):
    plt.bar(np.arange(Atot.shape[0])*4+j,Atot[:,j],label='A'+str(j+1)+'m')
    
plt.xlim(0,4*M)
plt.title('Unthresholded')
plt.legend()

plt.figure()
for j in range(3):
    plt.bar(np.arange(Atot2.shape[0])*8+j,Atot[:,j],label='A'+str(j+1)+'m')
    
plt.title('Thresholded')
plt.xlim(0,4*M)
plt.legend()

plt.show()



</t>
<t tx="ekr.20241218004930.175">n = 200
L = 8
x = np.linspace(0,L,n)
x1 = x[:100]    # Train
x2 = x[100:200] # Test
n1 = len(x1)
n2 = len(x2)
ftrain = np.power(x1,2) # Train parabola x = [0,4]
ftest = np.power(x2,2)  # Test parabola x = [4,8]

phi_i = np.zeros((n1,M))
phi_e = np.zeros((n2,M))

for j in range(M):
    phi_i[:,j] = np.power(x1,j) # interpolation key
    phi_e[:,j] = np.power(x2,j) # extrapolation key
    
Eni = np.zeros(6)
Ene = np.zeros(6)
for jj in range(6): # compute inter/extra-polation scores
    ani = Atot3[:,jj]
    fnai = phi_i @ ani
    Eni[jj] = np.linalg.norm(ftrain-fnai,ord=2)/np.linalg.norm(ftrain,ord=2)
    fnae = phi_e @ ani
    Ene[jj] = np.linalg.norm(ftest-fnae,ord=2)/np.linalg.norm(ftest,ord=2)
    
fig,axs = plt.subplots(2,2)
axs[0,0].bar(range(6),Eni)
axs[0,1].bar(range(6),Ene)
axs[1,0].bar(range(6),Eni)
axs[1,0].set_xlim(-0.5,6.5)
axs[1,0].set_ylim(0,0.01)
axs[1,1].bar(range(6),Ene)
axs[1,1].set_xlim(-0.5,6.5)
axs[1,1].set_ylim(0,0.1)

plt.show()

</t>
<t tx="ekr.20241218004930.176"></t>
<t tx="ekr.20241218004930.177">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.179">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004930.18"></t>
<t tx="ekr.20241218004930.180">n = 10000
x1 = np.random.randn(n) # "truth" model (data)
x2 = 0.8 * np.random.randn(n) + 1 # model 1
x3 = 0.5 * np.random.randn(n) - 1 # model 3 components
x4 = 0.7 * np.random.randn(n) - 3
x5 = 5.0 * np.random.rand(n) - 0.5 

x = np.arange(-6,6.01,0.01) # range for data
x_bincenters = np.arange(-6.005,6.01,0.01)


</t>
<t tx="ekr.20241218004930.181">f = np.histogram(x1,bins=x_bincenters)[0] + 0.01 # generate PDFs
g1 = np.histogram(x2,bins=x_bincenters)[0] + 0.01
g2a = np.histogram(x3,bins=x_bincenters)[0]
g2b = np.histogram(x4,bins=x_bincenters)[0]
g2 = g2a + 0.3*g2b + 0.01
g3 = np.histogram(x5,bins=x_bincenters)[0] + 0.01

f = f/np.trapz(f,x) # normalize data
g1 = g1/np.trapz(g1,x)
g2 = g2/np.trapz(g2,x)
g3 = g3/np.trapz(g3,x)

plt.figure()
plt.plot(x,f,linewidth=2,label='f')
plt.plot(x,g1,linewidth=2,label='g1')
plt.plot(x,g2,linewidth=2,label='g2')
plt.plot(x,g3,linewidth=2,label='g3')
plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004930.182"># Compute integrand
Int1 = f * np.log(np.divide(f,g1))
Int2 = f * np.log(np.divide(f,g2))
Int3 = f * np.log(np.divide(f,g3))

# KL divergence
I1 = np.trapz(Int1,x)
I2 = np.trapz(Int2,x)
I3 = np.trapz(Int3,x)

</t>
<t tx="ekr.20241218004930.183"></t>
<t tx="ekr.20241218004930.184">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.186">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from statsmodels.tsa import arima_process, arima_model
# Using the StatsModels module available at
# https://www.statsmodels.org/dev/install.html


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]


</t>
<t tx="ekr.20241218004930.187">np.random.seed(123) # for random data reproducibility
T = 100 # Sample size
# DGP = sm.ARIMA(x,order=(0,0,0))
# arparams = np.array([.2, 0.5])
# maparams = np.array([-4])
# arparams = np.r_[1, arparams]

arparams = np.array([-4, .2, 0.5])
maparams = np.array([1])



arma_process = sm.tsa.arima_process.ArmaProcess(arparams, maparams)
y = arma_process.generate_sample(T,scale=2)

logL = np.zeros(3) # log likelihood vector
aic = np.zeros(3)  # AIC vector
bic = np.zeros(3)  # BIC vector

for j in range(2):
    model_res = sm.tsa.arima_model.ARMA(y, (0,0)).fit(trend='c', disp=0,start_ar_lags=j+1,method='mle')
    logL[j] = model_res.llf
    aic[j] = model_res.aic
    bic[j] = model_res.bic

print('AIC: {:}'.format(aic))
print('BIC: {:}'.format(bic))

</t>
<t tx="ekr.20241218004930.188"></t>
<t tx="ekr.20241218004930.189"></t>
<t tx="ekr.20241218004930.19">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.190">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.192">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from mpl_toolkits.mplot3d import Axes3D

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004930.193">fisheriris_mat = io.loadmat(os.path.join('..','DATA','fisheriris.mat'))
meas = fisheriris_mat['meas']

x1 = meas[:50,:] # setosa
x2 = meas[50:100,:] # versicolor
x3 = meas[100:,:] # virginica

</t>
<t tx="ekr.20241218004930.194">fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')
ax.scatter(x1[:,0], x1[:,1], x1[:,3], c='g', marker='o')
ax.scatter(x2[:,0], x2[:,1], x2[:,3], c='m', marker='o')
ax.scatter(x3[:,0], x3[:,1], x3[:,3], c='r', marker='o')

plt.show()

</t>
<t tx="ekr.20241218004930.195">dogdata_mat = io.loadmat(os.path.join('..','DATA','dogData.mat'))
catdata_mat = io.loadmat(os.path.join('..','DATA','catData.mat'))

dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog = dogdata_mat['dog']
cat = catdata_mat['cat']

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog,cat),axis=1)
CD2 = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
u2,s2,vT2 = np.linalg.svd(CD2-np.mean(CD2),full_matrices=0)

</t>
<t tx="ekr.20241218004930.196">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
for j in range(4):
    U = np.flipud(np.reshape(u[:,j],(64,64)))
    U2 = U[::2,::2]
    axs[j].pcolor(np.rot90(U2),cmap='hot')
    axs[j].axis('off')

</t>
<t tx="ekr.20241218004930.197">fig,axs = plt.subplots(4,1)
axs = axs.reshape(-1)
for j in range(4):
    axs[j].bar(range(len(s)),vT[j,:])

</t>
<t tx="ekr.20241218004930.198">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
for j in range(4):
    Xd = np.flipud(np.reshape(dog_wave[:,j],(32,32)))
    axs[j].pcolor(np.rot90(Xd),cmap='hot')
    axs[j].axis('off')

</t>
<t tx="ekr.20241218004930.199">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
for j in range(4):
    U3 = np.flipud(np.reshape(u2[:,j],(32,32)))
    axs[j].pcolor(np.rot90(U3),cmap='hot')
    axs[j].axis('off')

</t>
<t tx="ekr.20241218004930.200">fig,axs = plt.subplots(4,1)
axs = axs.reshape(-1)
for j in range(4):
    axs[j].bar(range(len(s2)),vT2[j,:])

</t>
<t tx="ekr.20241218004930.201">xbin = np.linspace(-0.25,0.25,20)
xbin_edges = np.append(xbin,xbin[-1]+(xbin[1]-xbin[0])) - (xbin[1]-xbin[0])/2
fig,axs = plt.subplots(4,2)
for j in range(4):
    pdf1 = np.histogram(vT[j,:80],bins=xbin_edges)[0]
    pdf2 = np.histogram(vT[j,80:],bins=xbin_edges)[0]
    axs[j,0].plot(xbin,pdf1)
    axs[j,0].plot(xbin,pdf2)
    
    pdf1 = np.histogram(vT2[j,:80],bins=xbin_edges)[0]
    pdf2 = np.histogram(vT2[j,80:],bins=xbin_edges)[0]
    axs[j,1].plot(xbin,pdf1)
    axs[j,1].plot(xbin,pdf2)

</t>
<t tx="ekr.20241218004930.202">fig = plt.figure()
ax1 = fig.add_subplot(211, projection='3d')
ax1.scatter(vT[0,:80],vT[1,:80],vT[2,:80],c='r',marker='o',s=20)
ax1.scatter(vT[0,80:],vT[1,80:],vT[2,80:],c='b',marker='o',s=20)

ax2 = fig.add_subplot(212, projection='3d')
ax2.scatter(vT2[0,:80],vT2[1,:80],vT2[2,:80],c='r',marker='o',s=20)
ax2.scatter(vT2[0,80:],vT2[1,80:],vT2[2,80:],c='b',marker='o',s=20)

plt.show()

</t>
<t tx="ekr.20241218004930.203">master = np.zeros((32*5,32*4))
count = 0

for jj in range(4):
    for j in range(5):
        T2 = np.flipud(np.reshape(dog[:,count],(64,64)))
        T = T2[::2,::2]
        master[32*j:32*(j+1),32*jj:32*(jj+1)] = T
        count += 1
        
plt.figure()
plt.pcolor(np.rot90(master),cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.204">master = np.zeros((32*5,32*4))
count = 0

for jj in range(4):
    for j in range(5):
        T2 = np.flipud(np.reshape(cat[:,count],(64,64)))
        T = T2[::2,::2]
        master[32*j:32*(j+1),32*jj:32*(jj+1)] = T
        count += 1
        
plt.figure()
plt.pcolor(np.rot90(master),cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.205"></t>
<t tx="ekr.20241218004930.206">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.208">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004930.209"># Training and test set sizes
n1 = 100 # Training set size
n2 = 50  # Test set size

# Random ellipse 1 centered at (-2,0)
x = np.random.randn(n1+n2) - 2
y = 0.5*np.random.randn(n1+n2)

# Random ellipse 5 centered at (1,0)
x5 = 2*np.random.randn(n1+n2) + 1
y5 = 0.5*np.random.randn(n1+n2)

# Random ellipse 2 centered at (2,-2)
x2 = np.random.randn(n1+n2) + 2
y2 = 0.2*np.random.randn(n1+n2) - 2

# Rotate ellipse 2 by theta
theta = np.pi/4
A = np.zeros((2,2))
A[0,0] = np.cos(theta)
A[0,1] = -np.sin(theta)
A[1,0] = np.sin(theta)
A[1,1] = np.cos(theta)

x3 = A[0,0]*x2 + A[0,1]*y2
y3 = A[1,0]*x2 + A[1,1]*y2

</t>
<t tx="ekr.20241218004930.21">from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

Bt = np.fft.fft2(B)
Btsort = np.sort(np.abs(Bt.reshape(-1))) # sort by magnitude

# Zero out all small coefficients and inverse transform
for keep in (0.1, 0.05, 0.01, 0.002):
    thresh = Btsort[int(np.floor((1-keep)*len(Btsort)))]
    ind = np.abs(Bt)&gt;thresh          # Find small indices
    Atlow = Bt * ind                 # Threshold small indices
    Alow = np.fft.ifft2(Atlow).real  # Compressed image
    plt.figure()
    plt.imshow(Alow,cmap='gray')
    plt.axis('off')
    plt.title('Compressed image: keep = ' + str(keep))

</t>
<t tx="ekr.20241218004930.210">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[0].plot(x[:n1],y[:n1],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[0].plot(x3[:n1],y3[:n1],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)


axs[1].plot(x[:70],y[:70],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[1].plot(x3[:70],y3[:70],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[1].plot(x[70:100],y[70:100],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=15)
axs[1].plot(x3[70:100],y3[70:100],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=15)

axs[2].plot(x5[:n1],y5[:n1],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[2].plot(x3[:n1],y3[:n1],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)

axs[3].plot(x5[:70],y5[:70],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[3].plot(x3[:70],y3[:70],'o',markerfacecolor=(0.8,0.8,0.8),markeredgecolor='k',ms=15)
axs[3].plot(x5[70:100],y5[70:100],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=15)
axs[3].plot(x3[70:100],y3[70:100],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=15)

for ax in axs:
    ax.set_xlim(-6,6)
    ax.set_ylim(-2,2)

plt.show()

</t>
<t tx="ekr.20241218004930.211">n1 = 300 # training set size
x1 = 1.5*np.random.randn(n1)-1.5
y1 = 1.2*np.random.randn(n1)+np.power(x1+1.5,2)-7
x2 = 1.5*np.random.randn(n1)+1.5
y2 = 1.2*np.random.randn(n1)-np.power(x2-1.5,2)+7

fig,axs = plt.subplots(2)
axs[0].plot(x1,y1,'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=15)
axs[0].plot(x2,y2,'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=15)
axs[0].set_xlim(-6,6)
axs[0].set_ylim(-12,12)

r = 7 + np.random.randn(n1)
th = 2*np.pi*np.random.randn(n1)
xr = r * np.cos(th)
yr = r * np.sin(th)

x5 = np.random.randn(n1)
y5 = np.random.randn(n1)

axs[1].plot(xr,yr,'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=15)
axs[1].plot(x5,y5,'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=15)
axs[1].set_xlim(-10,10)
axs[1].set_ylim(-10,10)

plt.show()

</t>
<t tx="ekr.20241218004930.212"></t>
<t tx="ekr.20241218004930.213">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.215">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from sklearn.cluster import KMeans
from scipy.cluster import hierarchy
from scipy.spatial.distance import pdist

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004930.216"># Training and testing set sizes
n1 = 100 # Train
n2 = 50  # Test

# Random ellipse 1 centered at (0,0)
x = np.random.randn(n1+n2)
y = 0.5*np.random.randn(n1+n2)

# Random ellipse 2 centered at (1,-2)
x2 = np.random.randn(n1+n2) + 1
y2 = 0.2*np.random.randn(n1+n2) - 2

# Rotate ellipse 2 by theta
theta = np.pi/4
A = np.zeros((2,2))
A[0,0] = np.cos(theta)
A[0,1] = -np.sin(theta)
A[1,0] = np.sin(theta)
A[1,1] = np.cos(theta)

x3 = A[0,0]*x2 + A[0,1]*y2
y3 = A[1,0]*x2 + A[1,1]*y2

</t>
<t tx="ekr.20241218004930.217">plt.figure()
plt.plot(x[:n1],y[:n1],'ro')
plt.plot(x3[:n1],y3[:n1],'bo')
plt.show()

</t>
<t tx="ekr.20241218004930.218"># Training set: first 200 of 240 points
X1 = np.column_stack((x3[:n1],y3[:n1]))
X2 = np.column_stack((x[:n1],y[:n1]))

Y = np.concatenate((X1,X2))
Z = np.column_stack((np.ones(n1),2*np.ones(n1)))

# Test set: remaining 40 points
x1test = np.column_stack((x3[n1:],y3[n1:]))
x2test = np.column_stack((x[n1:],y[n1:]))


</t>
<t tx="ekr.20241218004930.219">g1 = np.array([-1, 0]) # Initial guess
g2 = np.array([1, 0])
fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
for j in range(4):
    class1 = np.zeros((1,2))
    class2 = np.zeros((1,2))
    for jj in range(Y.shape[0]):
        d1 = np.linalg.norm(g1-Y[jj,:],ord=2)
        d2 = np.linalg.norm(g2-Y[jj,:],ord=2)
        if d1&lt;d2:
            class1 = np.append(class1,Y[jj,:].reshape((1,2)),axis=0)
        else:
            class2 = np.append(class2,Y[jj,:].reshape((1,2)),axis=0)
    class1 = np.delete(class1, (0), axis=0) # remove zeros used to initialize
    class2 = np.delete(class2, (0), axis=0)
    
    axs[j].plot(class1[:,0],class1[:,1],'ro',ms=5)
    axs[j].plot(class2[:,0],class2[:,1],'bo',ms=5)
    axs[j].plot(g1[0],g1[1],'k*',ms=30)
    axs[j].plot(g2[0],g2[1],'k*',ms=30)
    
    g1 = np.array([np.mean(class1[:,0]),np.mean(class1[:,1])])
    g2 = np.array([np.mean(class2[:,0]),np.mean(class2[:,1])])
    
plt.show()

</t>
<t tx="ekr.20241218004930.22"></t>
<t tx="ekr.20241218004930.220"># kmeans code
kmeans = KMeans(n_clusters=2, random_state=0).fit(Y)
c = kmeans.cluster_centers_
ind = kmeans.labels_

# result from previous section
plt.plot(g1[0],g1[1],'ko',ms=20)
plt.plot(g2[0],g2[1],'ko',ms=20)

# kmeans result
plt.plot(c[0,0],c[0,1],'k*',ms=20)
plt.plot(c[1,0],c[1,1],'k*',ms=20)

plt.show()

</t>
<t tx="ekr.20241218004930.221">midx = (c[0,0]+c[1,0])/2
midy = (c[0,1]+c[1,1])/2
slope = (c[1,1]-c[0,1])/(c[1,0]-c[0,0]) # rise/run
b = midy+(1/slope)*midx
xsep = np.arange(-1,2,0.1)
ysep = -(1/slope)*xsep+b

fig,axs = plt.subplots(2)
axs[0].plot(x[:n1],y[:n1],'ro')
axs[0].plot(x3[:n1],y3[:n1],'bo')
axs[0].plot(xsep,ysep,c='k',linewidth=2)
axs[0].set_xlim(-2,4)
axs[0].set_ylim(-3,2)

# error on test data

axs[1].plot(x[n1:],y[n1:],'ro')
axs[1].plot(x3[n1:],y3[n1:],'bo')
axs[1].plot(xsep,ysep,c='k',linewidth=2)
axs[1].set_xlim(-2,4)
axs[1].set_ylim(-3,2)

plt.show()

</t>
<t tx="ekr.20241218004930.222">## Dendrograms

Y3 = np.concatenate((X1[:50,:],X2[:50,:]))

Y2 = pdist(Y3,metric='euclidean')
Z = hierarchy.linkage(Y2,method='average')
thresh = 0.85*np.max(Z[:,2])

plt.figure()
dn = hierarchy.dendrogram(Z,p=100,color_threshold=thresh)

plt.show()

</t>
<t tx="ekr.20241218004930.223">plt.bar(range(100),dn['leaves'])
plt.plot(np.array([0, 100]),np.array([50, 50]),'r:',linewidth=2)
plt.plot(np.array([50.5, 50.5]),np.array([0, 100]),'r:',linewidth=2)

plt.show()

</t>
<t tx="ekr.20241218004930.224"></t>
<t tx="ekr.20241218004930.225">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.227">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy.cluster import hierarchy
from scipy.spatial.distance import pdist

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004930.228"># Training and testing set sizes
n1 = 100 # Train
n2 = 50  # Test

# Random ellipse 1 centered at (0,0)
x = np.random.randn(n1+n2)
y = 0.5*np.random.randn(n1+n2)

# Random ellipse 2 centered at (1,-2)
x2 = np.random.randn(n1+n2) + 1
y2 = 0.2*np.random.randn(n1+n2) - 2

# Rotate ellipse 2 by theta
theta = np.pi/4
A = np.zeros((2,2))
A[0,0] = np.cos(theta)
A[0,1] = -np.sin(theta)
A[1,0] = np.sin(theta)
A[1,1] = np.cos(theta)

x3 = A[0,0]*x2 + A[0,1]*y2
y3 = A[1,0]*x2 + A[1,1]*y2

</t>
<t tx="ekr.20241218004930.229">plt.figure()
plt.plot(x[:n1],y[:n1],'ro')
plt.plot(x3[:n1],y3[:n1],'bo')
plt.show()

</t>
<t tx="ekr.20241218004930.23"></t>
<t tx="ekr.20241218004930.230"># Training set: first 200 of 240 points
X1 = np.column_stack((x3[:n1],y3[:n1]))
X2 = np.column_stack((x[:n1],y[:n1]))

Y = np.concatenate((X1,X2))
Z = np.column_stack((np.ones(n1),2*np.ones(n1)))

# Test set: remaining 40 points
x1test = np.column_stack((x3[n1:],y3[n1:]))
x2test = np.column_stack((x[n1:],y[n1:]))


</t>
<t tx="ekr.20241218004930.231">## Dendrograms

Y3 = np.concatenate((X1[:50,:],X2[:50,:]))

Y2 = pdist(Y3,metric='euclidean')
Z = hierarchy.linkage(Y2,method='average')
thresh = 0.85*np.max(Z[:,2])

plt.figure()
dn = hierarchy.dendrogram(Z,p=100,color_threshold=thresh)
plt.axis('off')

plt.show()

</t>
<t tx="ekr.20241218004930.232">plt.bar(range(100),dn['leaves'])
plt.plot(np.array([0, 100]),np.array([50, 50]),'r:',linewidth=2)
plt.plot(np.array([50.5, 50.5]),np.array([0, 100]),'r:',linewidth=2)

plt.show()

</t>
<t tx="ekr.20241218004930.233">thresh = 0.25*np.max(Z[:,2])

plt.figure()
dn = hierarchy.dendrogram(Z,p=100,color_threshold=thresh)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.234"></t>
<t tx="ekr.20241218004930.235"></t>
<t tx="ekr.20241218004930.236">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.238">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
from sklearn.mixture import GaussianMixture
import os
from mpl_toolkits import mplot3d

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004930.239">dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241218004930.24">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.240">dogcat = v[:,(1,3)]
GMModel = GaussianMixture(n_components=2).fit(dogcat)
AIC = GMModel.aic(dogcat)

plt.plot(v[:80,1],v[:80,3],'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
plt.plot(v[80:,1],v[80:,3],'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

x = np.linspace(-0.15, 0.25)
y = np.linspace(-0.25, 0.2)
X, Y = np.meshgrid(x, y)
XX = np.array([X.ravel(), Y.ravel()]).T
Z = np.exp(GMModel.score_samples(XX))
Z = Z.reshape(X.shape)

CS = plt.contour(X, Y, Z,levels=np.arange(3,32,4),colors='k',linestyles='solid')

plt.show()

</t>
<t tx="ekr.20241218004930.241">ax = plt.axes(projection='3d')
ax.plot_wireframe(X, Y, Z, color='black')
ax.view_init(30, -20)
plt.show()

</t>
<t tx="ekr.20241218004930.242">## AIC Scores
AIC = np.zeros(4)
GMModels = [GaussianMixture(k+1,covariance_type='diag',max_iter=500).fit(dogcat)
          for k in range(4)]

fig,axs = plt.subplots(2,2,subplot_kw={'projection': '3d'})
axs = axs.reshape(-1)

for j in range(len(axs)):
    Z = np.exp(GMModels[j].score_samples(XX))
    Z = Z.reshape(X.shape)
    AIC[j] = GMModels[j].aic(dogcat)
    axs[j].plot_wireframe(X, Y, Z, color='black')
    axs[j].view_init(30, -20)
    axs[j].set_title('AIC = {:.4}'.format(AIC[j]))


</t>
<t tx="ekr.20241218004930.243"></t>
<t tx="ekr.20241218004930.26">from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
plt.rcParams['figure.figsize'] = [16, 16]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

</t>
<t tx="ekr.20241218004930.27">## Denoise
Bnoise = B + 200*np.random.randn(*B.shape).astype('uint8') # Add some noise
Bt = np.fft.fft2(Bnoise)
Btshift = np.fft.fftshift(Bt)
F = np.log(np.abs(Btshift)+1) # Put FFT on log scale

fig,axs = plt.subplots(2,2)

axs[0,0].imshow(Bnoise,cmap='gray')
axs[0,0].axis('off')

axs[0,1].imshow(F,cmap='gray')
axs[0,1].axis('off')

nx,ny = B.shape
X,Y = np.meshgrid(np.arange(-ny/2+1,ny/2+1),np.arange(-nx/2+1,nx/2+1))
# xgrid = np.fft.ifftshift(np.arange(-nx/2+1,nx/2+1))
# ygrid = np.fft.ifftshift(np.arange(-ny/2+1,ny/2+1))
# X,Y = np.meshgrid(ygrid,xgrid)
R2 = np.power(X,2) + np.power(Y,2)
ind = R2 &lt; 150**2
Btshiftfilt = Btshift * ind
Ffilt = np.log(np.abs(Btshiftfilt)+1) # Put FFT on log scale

axs[1,1].imshow(Ffilt,cmap='gray')
axs[1,1].axis('off')

Btfilt = np.fft.ifftshift(Btshiftfilt)
Bfilt = np.fft.ifft2(Btfilt).real
axs[1,0].imshow(Bfilt,cmap='gray')
axs[1,0].axis('off')

plt.show()
</t>
<t tx="ekr.20241218004930.28">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.3">import numpy as np
import matplotlib.pyplot as plt
from scipy.integrate import odeint
from mpl_toolkits.mplot3d import axes3d
plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

nu = 0.001 # Diffusion constant
L = 20     # Length of domain
N = 1000   # Number of discretization points
dx = L/N
x = np.arange(-L/2,L/2,dx) # Define x domain

# Define discrete wavenumbers
kappa = 2*np.pi*np.fft.fftfreq(N, d=dx)

# Initial condition
u0 = 1/np.cosh(x)

# Simulate PDE in spatial domain
dt = 0.025
t = np.arange(0,100*dt,dt)

def rhsBurgers(u,t,kappa,nu):
    uhat = np.fft.fft(u)
    d_uhat = (1j)*kappa*uhat
    dd_uhat = -np.power(kappa,2)*uhat
    d_u = np.fft.ifft(d_uhat)
    dd_u = np.fft.ifft(dd_uhat)
    du_dt = -u * d_u + nu*dd_u
    return du_dt.real

u = odeint(rhsBurgers,u0,t,args=(kappa,nu))

# Waterfall plot
fig = plt.figure()
ax = fig.add_subplot(111, projection='3d')

u_plot = u[0:-1:10,:]
for j in range(u_plot.shape[0]):
    ys = j*np.ones(u_plot.shape[1])
    ax.plot(x,ys,u_plot[j,:])
    
# Image plot
plt.figure()
plt.imshow(np.flipud(u), aspect=8)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.30"># Using the PyWavelets module, available at 
# https://pywavelets.readthedocs.io/en/latest/install.html

from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
import pywt
plt.rcParams['figure.figsize'] = [16, 16]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

</t>
<t tx="ekr.20241218004930.31">## Wavelet decomposition (2 level)
n = 2
w = 'db1'
coeffs = pywt.wavedec2(B,wavelet=w,level=n)

# normalize each coefficient array
coeffs[0] /= np.abs(coeffs[0]).max()
for detail_level in range(n):
    coeffs[detail_level + 1] = [d/np.abs(d).max() for d in coeffs[detail_level + 1]]

arr, coeff_slices = pywt.coeffs_to_array(coeffs)



plt.imshow(arr,cmap='gray',vmin=-0.25,vmax=0.75)
plt.show()
</t>
<t tx="ekr.20241218004930.32">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.34"># Using the PyWavelets module, available at 
# https://pywavelets.readthedocs.io/en/latest/install.html

from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
import pywt
plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','dog.jpg'))
B = np.mean(A, -1); # Convert RGB to grayscale

</t>
<t tx="ekr.20241218004930.35">## Wavelet Compression
n = 4
w = 'db1'
coeffs = pywt.wavedec2(B,wavelet=w,level=n)

coeff_arr, coeff_slices = pywt.coeffs_to_array(coeffs)

Csort = np.sort(np.abs(coeff_arr.reshape(-1)))

for keep in (0.1, 0.05, 0.01, 0.005):
    thresh = Csort[int(np.floor((1-keep)*len(Csort)))]
    ind = np.abs(coeff_arr) &gt; thresh
    Cfilt = coeff_arr * ind # Threshold small indices
    
    coeffs_filt = pywt.array_to_coeffs(Cfilt,coeff_slices,output_format='wavedec2')
    
    # Plot reconstruction
    Arecon = pywt.waverec2(coeffs_filt,wavelet=w)
    plt.figure()
    plt.imshow(Arecon.astype('uint8'),cmap='gray')
    plt.axis('off')
    plt.title('keep = ' + str(keep))

</t>
<t tx="ekr.20241218004930.36"></t>
<t tx="ekr.20241218004930.37">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.39">from matplotlib.image import imread
import numpy as np
import matplotlib.pyplot as plt
import os
from mpl_toolkits.mplot3d import Axes3D
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})

A = imread(os.path.join('..','DATA','jelly.jpg'))
Abw = np.mean(A, -1); # Convert RGB to grayscale

plt.imshow(Abw,cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.4"></t>
<t tx="ekr.20241218004930.40">## Compute FFT of image using fft2
At = np.fft.fft2(Abw)
F = np.log(np.abs(np.fft.fftshift(At))+1) # Put FFT on log scale
plt.imshow(F,cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.41">## Zero out all small coefficients and inverse transform
Bt = np.sort(np.abs(np.reshape(At,-1)))
keep = 0.05
thresh = Bt[int(np.floor((1-keep)*len(Bt)))]
ind = np.abs(At) &gt; thresh
Atlow = At * ind
Flow = np.log(np.abs(np.fft.fftshift(Atlow))+1) # Put FFT on log scale

plt.imshow(Flow,cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.42">## Plot Reconstruction
Alow = np.fft.ifft2(Atlow).astype('uint8')

plt.imshow(Alow,cmap='gray')
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.43">plt.rcParams['figure.figsize'] = [16, 8]

fig = plt.figure()
ax1 = fig.add_subplot(1, 2, 1, projection='3d')
ax2 = fig.add_subplot(1, 2, 2, projection='3d')

Anew = Abw[::5,::5]

y = np.arange(Anew.shape[0])
x = np.arange(Anew.shape[1])

X,Y = np.meshgrid(x,y)

surf1 = ax1.plot_surface(X,Y,Anew, rstride=1, cstride=1,cmap='jet',
                       linewidth=1, antialiased=False)
surf2 = ax2.plot_surface(X,Y,Anew, rstride=1, cstride=1,cmap='jet',
                       linewidth=1, antialiased=False)

ax1.view_init(90, 90) 
ax1.axis('off')

ax2.view_init(60, 90) 
ax2.axis('off')

plt.show()

</t>
<t tx="ekr.20241218004930.44"></t>
<t tx="ekr.20241218004930.45"></t>
<t tx="ekr.20241218004930.46">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.48">import numpy as np
import matplotlib.pyplot as plt
import os
from scipy.optimize import minimize
plt.rcParams['figure.figsize'] = [12, 18]
plt.rcParams.update({'font.size': 18})

# Solve y = Theta * s for "s"
n = 1000 # dimension of s
p = 200  # number of measurements, dim(y)
Theta = np.random.randn(p,n)
y = np.random.randn(p)

# L1 Minimum norm solution s_L1
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'eq', 'fun': lambda x:  Theta @ x - y})
x0 = np.linalg.pinv(Theta) @ y # initialize with L2 solution
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s_L1 = res.x

</t>
<t tx="ekr.20241218004930.49"># L2 Minimum norm solution s_L2
s_L2 = np.linalg.pinv(Theta) @ y 

</t>
<t tx="ekr.20241218004930.5">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.50">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
axs[0].plot(s_L1,color='b',linewidth=1.5)
axs[0].set_ylim(-0.2,0.2)
axs[1].plot(s_L2,color='r',linewidth=1.5)
axs[1].set_ylim(-0.2,0.2)
axs[2].hist(s_L1,bins=np.arange(-0.105,0.105,0.01),rwidth=0.9)
axs[3].hist(s_L2,bins=np.arange(-0.105,0.105,0.01),rwidth=0.9)

plt.show()

</t>
<t tx="ekr.20241218004930.51"></t>
<t tx="ekr.20241218004930.52"></t>
<t tx="ekr.20241218004930.53">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.55">import numpy as np
import matplotlib.pyplot as plt
import os
import sys
from scipy.fftpack import dct, idct
from scipy.optimize import minimize
sys.path.append(os.path.join('..','UTILS'))
from cosamp_fn import cosamp
# cosamp function is available at https://github.com/avirmaux/CoSaMP

plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004930.56">## Generate signal, DCT of signal

n = 4096 # points in high resolution signal
t = np.linspace(0,1,n)
x = np.cos(2 * 97 * np.pi * t) + np.cos(2 * 777 * np.pi * t)
xt = np.fft.fft(x) # Fourier transformed signal
PSD = xt * np.conj(xt) / n # Power spectral density

</t>
<t tx="ekr.20241218004930.57">## Randomly sample signal
p = 128 # num. random samples, p = n/32
perm = np.floor(np.random.rand(p) * n).astype(int)
y = x[perm]

</t>
<t tx="ekr.20241218004930.58">## Solve compressed sensing problem
Psi = dct(np.identity(n)) # Build Psi
Theta = Psi[perm,:]       # Measure rows of Psi

s = cosamp(Theta,y,10,epsilon=1.e-10,max_iter=10) # CS via matching pursuit
xrecon = idct(s) # reconstruct full signal

</t>
<t tx="ekr.20241218004930.59">## Plot
time_window = np.array([1024,1280])/4096
freq = np.arange(n)
L = int(np.floor(n/2))


fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[1].plot(freq[:L],PSD[:L],color='k',linewidth=2)
axs[1].set_xlim(0, 1024)
axs[1].set_ylim(0, 1200)

axs[0].plot(t,x,color='k',linewidth=2)
axs[0].plot(perm/n,y,color='r',marker='x',linewidth=0,ms=12,mew=4)
axs[0].set_xlim(time_window[0],time_window[1])
axs[0].set_ylim(-2, 2)

axs[2].plot(t,xrecon,color='r',linewidth=2)
axs[2].set_xlim(time_window[0],time_window[1])
axs[2].set_ylim(-2, 2)

xtrecon = np.fft.fft(xrecon,n) # computes the (fast) discrete fourier transform
PSDrecon = xtrecon * np.conj(xtrecon)/n # Power spectrum (how much power in each freq)

axs[3].plot(freq[:L],PSDrecon[:L],color='r',linewidth=2)
axs[3].set_xlim(0, 1024)
axs[3].set_ylim(0, 1200)

plt.show()


</t>
<t tx="ekr.20241218004930.60">## L1-Minimization using SciPy
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

constr = ({'type': 'eq', 'fun': lambda x:  Theta @ x - y})
x0 = np.linalg.pinv(Theta) @ y 
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s = res.x

</t>
<t tx="ekr.20241218004930.61">Theta.shape

</t>
<t tx="ekr.20241218004930.62">y.shape

</t>
<t tx="ekr.20241218004930.63"></t>
<t tx="ekr.20241218004930.64">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.66">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.colors import ListedColormap, LinearSegmentedColormap
import os
import scipy.io
from scipy.fftpack import dct, idct
from scipy.optimize import minimize


plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

mat = scipy.io.loadmat(os.path.join('..','DATA','CC2.mat'))
CC = mat['CC']
CC_map = ListedColormap(CC)

p = 14
n = 32

</t>
<t tx="ekr.20241218004930.67">## Plot Psi
# def padflip(X):
#     nx,ny = X.shape
#     X = np.flipud(X)
#     Y = np.zeros((nx+1,ny+1))
#     Y[:-1,:-1] = X
#     return Y

Psi = dct(np.identity(n))
plt.pcolor(np.flipud(Psi),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.68">## Plot C
plt.rcParams['figure.figsize'] = [12, 6]
fig,ax = plt.subplots(1,1)
C = np.identity(n)
perm = np.random.permutation(n)[:p]
C = C[perm,:] # compressed measurement
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.grid(True)
plt.xticks(np.arange(n))
plt.yticks(np.arange(len(perm)))
ax.set_xticklabels([])
ax.set_yticklabels([])
plt.show()

</t>
<t tx="ekr.20241218004930.69">## Plot Theta

Theta = C @ Psi
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.7">import numpy as np
import matplotlib.pyplot as plt
plt.rcParams['figure.figsize'] = [12, 8]
plt.rcParams.update({'font.size': 18})

dt = 0.001
t = np.arange(0,2,dt)
f0 = 50
f1 = 250
t1 = 2
x = np.cos(2*np.pi*t*(f0 + (f1-f0)*np.power(t,2)/(3*t1**2)))

plt.specgram(x, NFFT=128, Fs=1/dt, noverlap=120,cmap='jet')
plt.colorbar()
plt.show()

</t>
<t tx="ekr.20241218004930.70">## Plot s, y
s = np.zeros((n,1))
s[2] = 1.4
s[13] = 0.7
s[27] = 2.2
y = C @ Psi @ s

fig,axs = plt.subplots(1,4)
axs[0].pcolor(np.flipud(s),cmap=CC_map)
axs[0].set_xlabel('s')

sL2 = np.linalg.pinv(Theta) @ y
axs[1].pcolor(np.flipud(sL2),cmap=CC_map)
axs[1].set_xlabel('sL2')

sbackslash = np.linalg.lstsq(Theta,y)[0]
axs[2].pcolor(np.flipud(sbackslash),cmap=CC_map)
axs[2].set_xlabel('sbackslash')

axs[3].pcolor(np.flipud(y),cmap=CC_map)
axs[3].set_xlabel('y')

for ax in axs:
    ax.set_xticklabels([])
    ax.set_yticklabels([])

plt.show()


</t>
<t tx="ekr.20241218004930.71">## L1-Minimization using SciPy
def L1_norm(x):
    return np.linalg.norm(x,ord=1)

y = y.reshape(-1)
constr = ({'type': 'eq', 'fun': lambda x:  Theta @ x - y})
x0 = np.linalg.pinv(Theta) @ y
res = minimize(L1_norm, x0, method='SLSQP',constraints=constr)
s2 = res.x

</t>
<t tx="ekr.20241218004930.72">## Plot C and Theta (2) - Gaussian Random
plt.rcParams['figure.figsize'] = [8, 4]

C = np.random.randn(p,n)

plt.figure()
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.axis('off')
plt.show()

Theta = C @ Psi
plt.figure()
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.73"># Plot C and Theta (3) - Bernoulli Random
C = np.random.randn(p,n)
C = C &gt; 0

plt.figure()
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.axis('off')
plt.show()

plt.figure()
Theta = C @ Psi
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.74"># Plot C and Theta (4) - Sparse Bernoulli
C = np.random.randn(p,n)
C = C &gt; 1

plt.figure()
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.axis('off')
plt.show()

plt.figure()
Theta = C @ Psi
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.75"># Bad C and Theta (5) - DCT Meas
C = idct(np.identity(n))
perm = np.arange(n-p,n)
C = C[perm,:] # compressed measurement

plt.figure()
plt.pcolor(np.flipud(C),cmap=CC_map)
plt.axis('off')
plt.show()

plt.figure()
Theta = C @ Psi
plt.pcolor(np.flipud(Theta),cmap=CC_map)
plt.axis('off')
plt.show()

plt.figure()
y = Theta @ s
plt.pcolor(np.flipud(y),cmap=CC_map)
plt.axis('off')
plt.show()

</t>
<t tx="ekr.20241218004930.76"></t>
<t tx="ekr.20241218004930.77"></t>
<t tx="ekr.20241218004930.78"></t>
<t tx="ekr.20241218004930.79">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.8"></t>
<t tx="ekr.20241218004930.81">import numpy as np
import matplotlib.pyplot as plt
import os
from scipy.optimize import minimize


plt.rcParams['figure.figsize'] = [7, 7]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004930.82">x = np.sort(4*(np.random.rand(25,1)-0.5),axis=0) # Random data from [-2,2]
b = 0.9*x + 0.1*np.random.randn(len(x),1)  # Line y = 0.9x with noise
atrue = np.linalg.lstsq(x,b,rcond=None)[0] # Least-squares slope (no outliers)
atrue = atrue.item(0)

b[-1] = -5.5  # Introduce outlier
acorrupt = np.linalg.lstsq(x,b,rcond=None)[0] # New slope
acorrupt = acorrupt.item(0)


</t>
<t tx="ekr.20241218004930.83">## L1 optimization to reject outlier
def L1_norm(a):
    return np.linalg.norm(a*x-b,ord=1)

a0 = acorrupt   # initialize to L2 solution
res = minimize(L1_norm, a0)
aL1 = res.x[0]  # aL1 is robust

</t>
<t tx="ekr.20241218004930.84">plt.plot(x[:-1],b[:-1],'o',color='b',ms=8) # Data
plt.plot(x[-1],b[-1],'o',color='r',ms=8)   # Outlier

xgrid = np.arange(-2,2,0.01)
plt.plot(xgrid,atrue*xgrid,'--',color='k')    # L2 fit (no outlier)
plt.plot(xgrid,acorrupt*xgrid,'--',color='r') # L2 fit (outlier)
plt.plot(xgrid,aL1*xgrid,'--',color='b')      # L1 fit

plt.show()

</t>
<t tx="ekr.20241218004930.85"></t>
<t tx="ekr.20241218004930.86">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.88">import numpy as np
import matplotlib.pyplot as plt
import os
import scipy.io
from sklearn import linear_model
from sklearn import model_selection

plt.rcParams['figure.figsize'] = [7, 7]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004930.89">A = np.random.randn(100,10) # Matrix of possible predictors
x = np.array([0, 0, 1, 0, 0, 0, -1, 0, 0, 0]) #Two nonzero predictors
b = A @ x + 2*np.random.randn(100)

xL2 = np.linalg.pinv(A) @ b

</t>
<t tx="ekr.20241218004930.9"></t>
<t tx="ekr.20241218004930.90">reg = linear_model.LassoCV(cv=10).fit(A, b)

lasso = linear_model.Lasso(random_state=0, max_iter=10000)
alphas = np.logspace(-4, -0.5, 30)

tuned_parameters = [{'alpha': alphas}]

clf = model_selection.GridSearchCV(lasso, tuned_parameters, cv=10, refit=False)
clf.fit(A, b)

scores = clf.cv_results_['mean_test_score']
scores_std = clf.cv_results_['std_test_score']
plt.semilogx(alphas, scores,'r-')

# plot error lines showing +/- std. errors of the scores
std_error = scores_std / np.sqrt(10)

plt.semilogx(alphas, scores + std_error, 'k--')
plt.semilogx(alphas, scores - std_error, 'k--')
plt.fill_between(alphas, scores + std_error, scores - std_error, alpha=0.1,color='k')

plt.ylabel('CV score +/- std error')
plt.xlabel('alpha')
plt.axhline(np.max(scores), linestyle='--', color='.5')
plt.xlim([alphas[-1], alphas[0]])

plt.show()

</t>
<t tx="ekr.20241218004930.91">XL1 = linear_model.Lasso(alpha=clf.best_params_['alpha'])
XL1.fit(A,b)
xL1 = XL1.coef_
xL1DeBiased = np.linalg.pinv(A[:,np.abs(xL1)&gt;0]) @ b

</t>
<t tx="ekr.20241218004930.92"></t>
<t tx="ekr.20241218004930.93">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004930.95">import numpy as np
import matplotlib.pyplot as plt
import os
import scipy.io
from sklearn import linear_model
from sklearn import model_selection
from scipy.optimize import minimize
from skimage.transform import resize
from matplotlib.image import imread


plt.rcParams['figure.figsize'] = [7, 7]
plt.rcParams.update({'font.size': 18})

mustache = imread(os.path.join('..','DATA','mustache.jpg'))
mustache = np.mean(mustache, -1); # Convert RGB to grayscale
mustache = (mustache/255).astype(int)
mustache = mustache.T

mat = scipy.io.loadmat(os.path.join('..','DATA','allFaces.mat'))
X = mat['faces']
nfaces = mat['nfaces'].reshape(-1)
n = mat['n']
n = int(n)
m = mat['m']
m = int(m)

</t>
<t tx="ekr.20241218004930.96">## Build Training and Test sets
nTrain = 30
nTest = 20
nPeople = 20
Train = np.zeros((X.shape[0],nTrain*nPeople))
Test = np.zeros((X.shape[0],nTest*nPeople))

for k in range(nPeople):
    baseind = 0
    if k &gt; 0:
        baseind = np.sum(nfaces[:k])
    inds = range(baseind,baseind+nfaces[k])
    Train[:,k*nTrain:(k+1)*nTrain] = X[:,inds[:nTrain]]
    Test[:,k*nTest:(k+1)*nTest] = X[:,inds[nTrain:(nTrain+nTest)]]

</t>
<t tx="ekr.20241218004930.97">## Downsample Training Images (Build Theta)
M = Train.shape[1]

Theta = np.zeros((120,M))
for k in range(M):
    temp = np.reshape(np.copy(Train[:,k]),(m,n))
    tempSmall = resize(temp, (10, 12), anti_aliasing=True)
    Theta[:,k] = np.reshape(tempSmall,120,1)

</t>
<t tx="ekr.20241218004930.98">## Renormalize Columns of Theta
normTheta = np.zeros(M)
for k in range(M):
    normTheta[k] = np.linalg.norm(Theta[:,k])
    Theta[:,k] = Theta[:,k]/normTheta[k]

</t>
<t tx="ekr.20241218004930.99">## Occlude Test Image (Test[:,125] = test image 6, person 7)
x1 = np.copy(Test[:,125]) # Clean image
x2 = np.copy(Test[:,125]) * mustache.reshape(n*m)
randvec = np.random.permutation(n*m)
first30 = randvec[:int(np.floor(0.3*len(randvec)))]
vals30 = (255*np.random.rand(*first30.shape)).astype(int)
x3 = np.copy(x1)
x3[first30] = vals30 # 30% occluded
x4 = np.copy(x1) + 50*np.random.randn(*x1.shape) # Random noise

</t>
<t tx="ekr.20241218004931.1">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.10">dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241218004931.101">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D
from scipy import integrate


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.102">mu = -0.05
lamb = -1
A = np.array([[mu,0,0],[0,lamb,-lamb],[0,0,2*mu]]) # Koopman linear dynamics
D,T = np.linalg.eig(A)
slope_stab_man = T[2,2]/T[1,2] # slope of stable subspace (green)


</t>
<t tx="ekr.20241218004931.103">## Integrate Koopman trajectories

y0A = np.array([1.5,-1,2.25])
y0B = np.array([1,-1,1])
y0C = np.array([2,-1,4])
tspan = np.arange(0,1000,0.01)

def koopman_deriv(y,t0,A=A):
    return A@y

yA = integrate.odeint(koopman_deriv, y0A, tspan)
yB = integrate.odeint(koopman_deriv, y0B, tspan)
yC = integrate.odeint(koopman_deriv, y0C, tspan)


</t>
<t tx="ekr.20241218004931.104">## Plot invariant surfaces
fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})

# Attracting manifold y_2 = y_1^2  (red manifold)
X,Z = np.meshgrid(np.arange(-2,2,0.01),np.arange(-1,4,0.01))
Y = np.power(X,2)

ax.plot_surface(X,Y,Z,alpha=0.1,color='r',shade=True)

# Invariant set y_3 = y_1^2  (blue manifold)
X1,Y1 = np.meshgrid(np.arange(-2,2,0.01),np.arange(-1,4,0.01))
Z1 = np.power(X1,2)

ax.plot_surface(X1,Y1,Z1,alpha=0.1,color='b',shade=True)

# Stable invariant subspace of Koopman linear system  (green plane)
X2,Y2 = np.meshgrid(np.arange(-2,2,0.01),np.arange(0,4,0.01))
Z2 = slope_stab_man*Y2

ax.plot_surface(X2,Y2,Z2,alpha=0.7,color=(0.3,0.7,0.3),shade=True)

x = np.arange(-2,2,0.1)
# Intersection of green and blue surfaces (below)
ax.plot(x,(1/slope_stab_man)*np.power(x,2),np.power(x,2),color='g',linewidth=2)

# Intersection of red and blue surfaces (below)
ax.plot(x,np.power(x,2),np.power(x,2),'--',color='r',linewidth=2)
ax.plot(x,np.power(x,2),-np.ones_like(x),'--',color='r',linewidth=2)

# Plot Koopman Trajectories
ax.plot(yA[:,0],yA[:,1],-np.ones_like(yA[:,0]),'k-',linewidth=1)
ax.plot(yB[:,0],yB[:,1],-np.ones_like(yB[:,0]),'k-',linewidth=1)
ax.plot(yC[:,0],yC[:,1],-np.ones_like(yC[:,0]),'k-',linewidth=1)

ax.plot(yA[:,0],yA[:,1],yA[:,2],'k-',linewidth=1.5)
ax.plot(yB[:,0],yB[:,1],yB[:,2],'k-',linewidth=1.5)
ax.plot(yC[:,0],yC[:,1],yC[:,2],'k-',linewidth=1.5)

ax.plot(np.array([0,0]),np.array([0,0]),np.array([0,-1]),'ko')

ax.view_init(azim=-105,elev=8)

ax.set_xlim(-4,4)
ax.set_ylim(-1,4)
ax.set_zlim(-1,4)

ax.set_xlabel('y1')
ax.set_ylabel('y2')
ax.set_zlabel('y3')

plt.show()

</t>
<t tx="ekr.20241218004931.105"></t>
<t tx="ekr.20241218004931.106"></t>
<t tx="ekr.20241218004931.107">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.109">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D
from scipy import integrate


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.11">plt.rcParams['figure.figsize'] = [12, 6]
fig,axs = plt.subplots(1,2)
for j in range(2):
    axs[j].plot(v[:80,1],v[:80,3],'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
    axs[j].plot(v[80:,1],v[80:,3],'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

# Linear Discriminant
xtrain = np.concatenate((v[:60,np.array([1,3])],v[80:140,np.array([1,3])]))
test = np.concatenate((v[60:80,np.array([1,3])],v[140:160,np.array([1,3])]))
label = np.repeat(np.array([1,-1]),60)



lda = LinearDiscriminantAnalysis().fit(xtrain, label)
test_class = lda.predict(test)
K = -lda.intercept_[0]
L = -lda.coef_[0]


x = np.arange(-0.15,0.25,0.005)
axs[0].plot(x,-(L[0]*x+K)/L[1],'k',linewidth=2)


# Quadratic Discriminant
qda = QuadraticDiscriminantAnalysis().fit(xtrain, label)
y = np.arange(-0.3,0.25,0.005)
X,Y = np.meshgrid(x,y)

Z = np.zeros_like(X)

for jj in range(len(x)):
    for kk in range(len(y)):
        Z[kk,jj] = qda.predict(np.array([[x[jj],y[kk]]]))

axs[1].contour(X,Y,Z,0,colors='k',linewidths=2)        

plt.show()


</t>
<t tx="ekr.20241218004931.110">## Simulate the Lorenz System

dt = 0.01
T = 50
t = np.arange(0,T+dt,dt)
beta = 8/3
sigma = 10
rho = 28


def lorenz_deriv(x_y_z, t0, sigma=sigma, beta=beta, rho=rho):
    x, y, z = x_y_z
    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]

np.random.seed(123)
x0 = (-8,8,27)

x = integrate.odeint(lorenz_deriv, x0, t,rtol=10**(-12),atol=10**(-12)*np.ones_like(x0))


</t>
<t tx="ekr.20241218004931.111">## Eigen-time delay coordinates
stackmax = 10 # Number of shift-stacked rows
r = 10        # rank of HAVOK model
H = np.zeros((stackmax,x.shape[0]-stackmax))

for k in range(stackmax):
    H[k,:] = x[k:-(stackmax-k),0]
    
U,S,VT = np.linalg.svd(H,full_matrices=0)
V = VT.T

</t>
<t tx="ekr.20241218004931.112">## Compute Derivatives (4th Order Central Difference)
# dV = np.zeros((V.shape[0]-5,r))
# for i in range(2,V.shape[0]-3):
#     for k in range(r):
#         dV[i-1,k] = (1/(12*dt))

dV = (1/(12*dt)) * (-V[4:,:] + 8*V[3:-1,:] - 8*V[1:-3,:] + V[:-4,:])

# trim first and last two that are lost in derivative
V = V[2:-2]

</t>
<t tx="ekr.20241218004931.113">## Build HAVOK Regression Model on Time Delay Coordinates
Xi = np.linalg.lstsq(V,dV,rcond=None)[0]
A = Xi[:(r-1),:(r-1)].T
B = Xi[-1,:(r-1)].T

</t>
<t tx="ekr.20241218004931.114">print(1/2/3)

</t>
<t tx="ekr.20241218004931.115"></t>
<t tx="ekr.20241218004931.116"></t>
<t tx="ekr.20241218004931.117">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.119">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.12"></t>
<t tx="ekr.20241218004931.120">t = np.arange(0,10,0.01)   # time

wr = 60 * np.ones_like(t)  # reference speed
d = 10*np.sin(np.pi*t)     # disturbance

aModel = 1                 # y = aModel*u
aTrue = 0.5                # y = aTrue*u

uOL = wr/aModel            # Open-loop u based on model
yOL = aTrue*uOL + d        # Open-loop response

K = 50                     # control gain, u=K(wr-y)
yCL = (aTrue*K/(1+aTrue*K))*wr + d/(1+aTrue*K)

</t>
<t tx="ekr.20241218004931.121">plt.plot(t,wr,'k',linewidth=2,label='Reference')
plt.plot(t,d,'k--',linewidth=1.5,label='Disturbance')
plt.plot(t,yOL,'r',linewidth=1.5,label='Open Loop')
plt.plot(t,yCL,'b',linewidth=1.5,label='Closed Loop')

plt.xlabel('Time')
plt.ylabel('Speed')

plt.legend(loc="upper left", bbox_to_anchor=(1,1))
plt.show()

</t>
<t tx="ekr.20241218004931.122"></t>
<t tx="ekr.20241218004931.123">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.125">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from matplotlib import animation, rc
from IPython.display import HTML
from control.matlab import *
from control import place
import slycot
from scipy import integrate
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})
plt.rcParams['animation.html'] = 'jshtml'

</t>
<t tx="ekr.20241218004931.126">m = 1
M = 5
L = 2
g = -10
d = 1

b = 1 # pendulum up (b=1)

A = np.array([[0,1,0,0],\
              [0,-d/M,b*m*g/M,0],\
              [0,0,0,1],\
              [0,-b*d/(M*L),-b*(m+M)*g/(M*L),0]])

B = np.array([0,1/M,0,b/(M*L)]).reshape((4,1))

print(np.linalg.eig(A)[0])       # Eigenvalues
print(np.linalg.det(ctrb(A,B)))  # Determinant of controllability matrix

</t>
<t tx="ekr.20241218004931.127">## Design LQR Controller
Q = np.eye(4)
R = 0.0001

K = lqr(A,B,Q,R)[0]


</t>
<t tx="ekr.20241218004931.128">## ODE RHS Function Definition
def pendcart(x,t,m,M,L,g,d,uf):
    u = uf(x) # evaluate anonymous function at x
    Sx = np.sin(x[2])
    Cx = np.cos(x[2])
    D = m*L*L*(M+m*(1-Cx**2))
    
    dx = np.zeros(4)
    dx[0] = x[1]
    dx[1] = (1/D)*(-(m**2)*(L**2)*g*Cx*Sx + m*(L**2)*(m*L*(x[3]**2)*Sx - d*x[1])) + m*L*L*(1/D)*u
    dx[2] = x[3]
    dx[3] = (1/D)*((m+M)*m*g*L*Sx - m*L*Cx*(m*L*(x[3]**2)*Sx - d*x[1])) - m*L*Cx*(1/D)*u;
    
    return dx


</t>
<t tx="ekr.20241218004931.129">## Simulate closed-loop system
tspan = np.arange(0,10,0.001)
x0 = np.array([-1,0,np.pi+0.1,0]) # Initial condition
wr = np.array([1,0,np.pi,0])      # Reference position
u = lambda x: -K@(x-wr)           # Control law

x = integrate.odeint(pendcart,x0,tspan,args=(m,M,L,g,d,u))

</t>
<t tx="ekr.20241218004931.13">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.130">for k in range(np.floor(len(t)/100)):
    plt.plot

</t>
<t tx="ekr.20241218004931.131">fig,ax = plt.subplots()
H = 0.5*np.sqrt(M/5)
p_pend, = plt.plot([],[],'o-',linewidth=2,ms=40,markerfacecolor='r')
p_cart, = plt.plot([],[],'ks',ms=100)

x_plot = x[::100,:]
t_plot = tspan[::100]

def init():
    ax.set_xlim(-5,5)
    ax.set_ylim(-0.5, 2.7)
    return x

def animate(iter):
    x_iter = x_plot[iter,0]
    th_iter = x_plot[iter,2]
    
    p_cart.set_data(x_iter,0.1+H/2)
    p_pend.set_data(x_iter+np.array([0,L*np.sin(th_iter)]),\
                    0.1+H/2+np.array([0,-L*np.cos(th_iter)]))
    return p_pend

anim = animation.FuncAnimation(fig,animate,init_func=init,frames=len(t_plot),interval=50,blit=False,repeat=False)
HTML(anim.to_jshtml())

</t>
<t tx="ekr.20241218004931.132">plot_labels = ('x','v','theta','omega')
[plt.plot(tspan,x[:,j],linewidth=2,label=plot_labels[j]) for j in range(4)]
plt.xlabel('Time')
plt.ylabel('State')

plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004931.133">## Compare with many examples of Pole Placement
JLQR = np.zeros(len(tspan))
for k in range(len(tspan)):
    JLQR[k] = (x[k,:]-wr) @ Q @ (x[k,:]-wr) + (u(x[k,:])**2)*R
    
t_plot = tspan[::50]
all_x_plot = np.zeros((len(t_plot),4,100))
all_J = np.zeros((len(tspan),100))
all_Jz = np.zeros((len(tspan)-1,100))

for count in range(100):
    p = -0.5 - 3*np.random.rand(4)
    K = place(A,B,p)
    u = lambda x: -K@(x-wr)
    
    x = integrate.odeint(pendcart,x0,tspan,args=(m,M,L,g,d,u))
    all_x_plot[:,:,count] = x[::50,:]
    for k in range(len(tspan)):
        all_J[k,count] = (x[k,:]-wr)@Q@(x[k,:]-wr) + (u(x[k,:])**2)*R
    
    all_Jz[:,count] = integrate.cumtrapz(all_J[:,count])


</t>
<t tx="ekr.20241218004931.134">## Plots
for count in range(100):
    plt.plot(t_plot,all_x_plot[:,:,count],linewidth=0.5)
    plt.gca().set_prop_cycle(None) # reset color cycle
    
plt.xlabel('Time')
plt.ylabel('State')
plt.show()

</t>
<t tx="ekr.20241218004931.135">for count in range(100):
    plt.plot(t_plot,all_Jz[::50,count],color=(0.5,0.5,0.5))
    
plt.xlabel('Time')
plt.ylabel('Cost')
plt.show()
</t>
<t tx="ekr.20241218004931.136">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.138">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import integrate
from scipy.linalg import schur
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004931.139">m = 1
M = 5
L = 2
g = -10
d = 1

b = -1 # pendulum down (b = -1)

A = np.array([[0,1,0,0],\
              [0,-d/M,b*m*g/M,0],\
              [0,0,0,1],\
              [0,-b*d/(M*L),-b*(m+M)*g/(M*L),0]])

B = np.array([0,1/M,0,b/(M*L)]).reshape((4,1))

C = np.array([0,0,1,0]) # only observable if x measured... because x can't be

print('Observability matrix:\n{}'.format(obsv(A,C)))
print('Observability matrix determinant: {}'.format(np.linalg.det(obsv(A,C))))


</t>
<t tx="ekr.20241218004931.140">## Which measurements are best if we omit "x"
Ah = A[1:,1:]
Bh = B[1:]
# Ch = np.array([1,0,0])
Ch = np.array([0,1,0])
# Ch = np.array([0,0,1])

print('Observability matrix:\n{}'.format(obsv(Ah,Ch)))

Ch = Ch.reshape((1,len(Ch)))
Dh = np.zeros((Ch.shape[0],Bh.shape[1]))
sys = ss(Ah,Bh,Ch,Dh)
print('Gramian determinant: {}'.format(np.linalg.det(gram(sys,'o'))))


</t>
<t tx="ekr.20241218004931.141"></t>
<t tx="ekr.20241218004931.142">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.144">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import integrate
from scipy.linalg import schur
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004931.145">m = 1
M = 5
L = 2
g = -10
d = 1

b = -1 # pendulum down (b = -1)

A = np.array([[0,1,0,0],\
              [0,-d/M,b*m*g/M,0],\
              [0,0,0,1],\
              [0,-b*d/(M*L),-b*(m+M)*g/(M*L),0]])

B = np.array([0,1/M,0,b/(M*L)]).reshape((4,1))

C = np.array([1,0,0,0]) # measure cart position, x

print('Observability matrix rank: {}'.format(np.linalg.matrix_rank(obsv(A,C))))

D = np.zeros((C.shape[0],B.shape[1]))


</t>
<t tx="ekr.20241218004931.146"># Kalman estimator design

def lqe(a,g,c,q,r):
    r = np.atleast_2d(r)
    nn = np.zeros((q.shape[0],len(r)))
    qg = g @ q @ g.T
    ng = g @ nn
    
    qg = (qg + qg.T)/2
    r = (r + r.T)/2
    u,t = schur(r)
    
    t = np.real(np.diag(t))
    
    if np.min(t) &lt;= 0:
        print('Error: covariance matrix must be positive definite')
    else:
        Nr = (ng@u)*np.diag(np.power(np.sqrt(t),-1))
        Qr = qg - Nr @ Nr.T
        if np.min(np.real(np.linalg.eig(Qr)[0])) &lt; -(10**3)*np.finfo(float).eps:
            print('Warning: The matrix [G*Q*G'' G*N;N''*G'' R] should be nonnegative definite')
    c = np.diag(c)
    r = np.squeeze(r)
    (p,e,k) = care(a.T,c.T,qg)#,R=r,S=ng)
    l = k[0,:]
    
    return (l,p,e)


</t>
<t tx="ekr.20241218004931.147">## Specify disturbance and noise magnitude
Vd = np.eye(4)  # distrubance covariance
Vn = 1          # noise covariance

# Build Kalman filter
Kf, P, E = lqe(A,np.eye(4),C,Vd,Vn)


</t>
<t tx="ekr.20241218004931.148">## Augment system with additional inputs
Baug = np.concatenate((B, np.eye(4),np.zeros_like(B)),axis=1) # [u I*wd 0*wn]
Daug = np.array([0,0,0,0,0,1]) # D matrix passes noise through

sysC = ss(A,Baug,C,Daug) # Single-measurement system

# "True" system w/ full-state output, disturbance, no noise
sysTruth = ss(A,Baug,np.eye(4),np.zeros((4,Baug.shape[1])))

BKf = np.concatenate((B,np.atleast_2d(Kf).T),axis=1)
sysKF = ss(A-np.outer(Kf,C),BKf,np.eye(4),np.zeros_like(BKf))

</t>
<t tx="ekr.20241218004931.149">## Estimate linearized system in "down" position (Gantry crane)
dt = 0.01
t = np.arange(0,50,dt)

uDIST = np.sqrt(Vd) @ np.random.randn(4,len(t)) # random disturbance
uNOISE = np.sqrt(Vn) * np.random.randn(len(t))    # random noise
u = np.zeros_like(t)
u[100] = 20/dt   # positive impulse
u[1500] = -20/dt # negative impulse

# input w/ disturbance and noise:
uAUG = np.concatenate((u.reshape((1,len(u))),uDIST,uNOISE.reshape((1,len(uNOISE))))).T

y,t,_ = lsim(sysC,uAUG,t)                      # noisy measurement
xtrue,t,_ = lsim(sysTruth,uAUG,t)              # true state
xhat,t,_ = lsim(sysKF,np.row_stack((u,y)).T,t) # state estimate

</t>
<t tx="ekr.20241218004931.15">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from sklearn import svm
from sklearn.model_selection import cross_val_score
from mpl_toolkits import mplot3d


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.150">plt.plot(t,y,color=(0.5,0.5,0.5),label='y (measured)')
plt.plot(t,xtrue[:,0],color='k',label='y (no noise)')
plt.plot(t,xhat[:,0],color=(0,0.447,0.741),label='y (KF estimate)')
plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004931.151">x_labels = ('x','v','theta','omega')
[plt.plot(t,xtrue[:,k],linewidth=1.2,label=x_labels[k]) for k in range(4)]
plt.gca().set_prop_cycle(None) # reset color cycle
[plt.plot(t,xhat[:,k],'--',linewidth=2,label=x_labels[k]+'_hat') for k in range(4)]
plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004931.152"></t>
<t tx="ekr.20241218004931.153">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.155">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241218004931.156">s = tf(np.array([1,0]),np.array([0,1]))
G = 1/(s**2 + s + 2)
w, mag, phase = bode(G)

</t>
<t tx="ekr.20241218004931.157">A = np.array([[0,1],[-2,-1]])
B = np.array([0,1]).reshape((2,1))
C = np.array([1,0])
D = 0
G = ss2tf(A,B,C,D)

ia,it = impulse(G)

plt.plot(it[[0,-1]],np.array([0,0]),'k:')
plt.plot(it,ia)
plt.title('Impulse Response')
plt.ylabel('Amplitude')
plt.xlabel('Time')
plt.show()

</t>
<t tx="ekr.20241218004931.158"></t>
<t tx="ekr.20241218004931.159">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.16"># Random ellipse 1

n1 = 300 # Training set size

x1 = 1.5*np.random.randn(n1) - 1.5
y1 = 1.2*np.random.randn(n1) + np.power(x1+1.5,2) - 7
x2 = 1.5*np.random.randn(n1) + 1.5
y2 = 1.2*np.random.randn(n1) - np.power(x2-1.5,2) + 7

plt.plot(x1,y1,'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
plt.plot(x2,y2,'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

plt.show()

</t>
<t tx="ekr.20241218004931.161">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241218004931.162">s = tf(np.array([1,0]),np.array([0,1]))
L = 1/s
S = (1/(1+L))
T = L/(1+L)
_,_,_ = bode(L,label='L')
_,_,_ = bode(S,label='S')
_,_,_ = bode(T,label='T')
plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004931.163"></t>
<t tx="ekr.20241218004931.164">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.166">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241218004931.167">s = tf(np.array([1,0]),np.array([0,1]))
G = (s+1)/(s-2)
Gtrue = (s+0.9)/(s-1.9)

K = 1/G

L = K*Gtrue


fig = plt.figure()
gm, pm, wg, wp = margin(L)
_,_,_ = bode(L)
for ax in fig.axes:
    xl = ax.get_xlim()
    yl = ax.get_ylim()
    ax.plot(wg*np.ones(2),ax.get_ylim(),'k--',linewidth=2)
    ax.plot(wp*np.ones(2),ax.get_ylim(),'k--',linewidth=2)
    ax.plot(ax.get_xlim(),np.zeros(2),'k--',linewidth=2)
    ax.set_xlim(xl)
    ax.set_ylim(yl)
    
CL = feedback(L,1)
CL

</t>
<t tx="ekr.20241218004931.168"></t>
<t tx="ekr.20241218004931.169"></t>
<t tx="ekr.20241218004931.17">z1 = np.power(x1,2) * y1
z2 = np.power(x2,2) * y2

fig = plt.figure()
ax = plt.axes(projection='3d')

ax.plot(x1,y1,z1,'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
ax.plot(x2,y2,z2,'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

ax.view_init(20, -135)

plt.show()

</t>
<t tx="ekr.20241218004931.170"></t>
<t tx="ekr.20241218004931.171">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.173">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal
from scipy.linalg import fractional_matrix_power
# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241218004931.174">A = np.array([[-0.75,1],[-0.3,-0.75]])
B = np.array([2,1]).reshape((2,1))
C = np.array([1,2])
D = 0

sys = ss(A,B,C,D)

Wc = gram(sys,'c') # Controllability Gramian
Wo = gram(sys,'o') # Observability Gramian

sysb = balred(sys,len(B)) # Balance the system

BWc = gram(sysb,'c') # Balanced Gramians
BWo = gram(sysb,'o')

</t>
<t tx="ekr.20241218004931.175"># Manually compute transform matrix for balanced Gramians
_,Tu = np.linalg.eig(Wc@Wo)

# Resolve sign ambiguity of eigenvectors
for j in range(Tu.shape[1]):
    if Tu[0,j] &lt; 0:
        Tu[:,j] = -Tu[:,j]
        
Sig_c = np.linalg.inv(Tu) @ Wc @ np.linalg.inv(Tu).T
Sig_o = Tu.T @ Wo @ Tu
Sig_s = fractional_matrix_power(Sig_c,1/4) @ fractional_matrix_power(Sig_o,-1/4)

T = Tu @ Sig_s
Ti = np.linalg.inv(T)

</t>
<t tx="ekr.20241218004931.176">## Plot Gramians
theta = np.arange(0,2*np.pi,0.01)
xc = np.cos(theta)
yc = np.sin(theta)
CIRC = np.row_stack((xc,yc))

# Off-diagonals should be within machine precision of 0, but
# in case that machine error is negative we manually threshold them:
BWc[BWc&lt;0] = 0
BWo[BWo&lt;0] = 0

ELLIPb = Ti @ np.sqrt(BWc) @ T @ CIRC
ELLIPc = np.sqrt(Wc) @ CIRC
ELLIPo = np.sqrt(Wo) @ CIRC

</t>
<t tx="ekr.20241218004931.177">plt.plot(xc,yc,'k--',linewidth=2)

# Draw controllability Gramian (unbalanced)
plt.plot(ELLIPc[0,:],ELLIPc[1,:],'r',linewidth=2)
plt.fill(ELLIPc[0,:],ELLIPc[1,:],'r',alpha=0.75)

# Draw observability Gramian (unbalanced)
plt.plot(ELLIPo[0,:],ELLIPo[1,:],'b',linewidth=2)
plt.fill(ELLIPo[0,:],ELLIPo[1,:],'b',alpha=0.75)

# Draw balanced Gramians
plt.plot(ELLIPb[0,:],ELLIPb[1,:],color=(0.35,0,0.35),linewidth=2)
plt.fill(ELLIPb[0,:],ELLIPb[1,:],color=(0.5,0,0.5),alpha=0.25)

plt.show()

</t>
<t tx="ekr.20241218004931.178"></t>
<t tx="ekr.20241218004931.179">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.18">r = 7 + np.random.randn(n1)
th = 2 * np.pi * np.random.randn(n1)
xr = r * np.cos(th)
yr = r * np.sin(th)
x5 = np.random.randn(n1)
y5 = np.random.randn(n1)

zr = np.power(xr,2) + np.power(yr,2)
z5 = np.power(x5,2) + np.power(y5,2)

fig = plt.figure()
ax = plt.axes(projection='3d')
ax.view_init(20, -135)

ax.plot(xr,yr,zr+40,'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
ax.plot(x5,y5,z5+40,'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)


x = np.arange(-10,10.5,0.5)
y = x
X,Y = np.meshgrid(x,y)
F3 = 54 + 0*X + 0*Y

ax.plot_surface(X, Y, F3, cmap='gray',linewidth=0, antialiased=True,alpha=0.2)

ax.plot(xr,yr,np.zeros(*xr.shape),'ro',MarkerFaceColor=(179/255,1,179/255),MarkerEdgeColor='k',ms=12)
ax.plot(x5,y5,np.zeros(*x5.shape),'bo',MarkerFaceColor=(240/255,194/255,224/255),MarkerEdgeColor='k',ms=12)

theta = np.linspace(0,2*np.pi,100)
xrr = np.sqrt(14)*np.cos(theta)
yrr = np.sqrt(14)*np.sin(theta)

ax.plot(xrr,yrr,np.zeros(*xrr.shape),'k-',linewidth=2)

plt.show()

</t>
<t tx="ekr.20241218004931.181">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
import os
from scipy import signal, io
from scipy.linalg import fractional_matrix_power

# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241218004931.182">testSys_mat = io.loadmat(os.path.join('..','DATA','testSys_ABCD.mat'))
A = testSys_mat['A']
B = testSys_mat['B']
C = testSys_mat['C']
D = testSys_mat['D']

sysFull = ss(A,B,C,D,1)
r = 10 # Reduced model order

</t>
<t tx="ekr.20241218004931.183">## Plot Hankel Singular Values
# n_stable = np.count_nonzero(np.logical_and(np.linalg.eigvals(sysFull.A).real &gt;= 0, np.linalg.eigvals(sysFull.A).real &lt;= 1))
# sysFull_stable = balred(sysFull,n_stable,method='truncate',alpha=np.array([0,1])) # This is necessary to remove unstable eigenvalues
# hsvs = hsvd(sysFull_stable) # Hankel singular values
hsvs = hsvd(sysFull)

</t>
<t tx="ekr.20241218004931.184"># Balanced truncation
sysBT = balred(sysFull,r)

</t>
<t tx="ekr.20241218004931.185"># Compute BPOD

yFull = np.zeros((r*5+2,p,q))
xFull = np.zeros((r*5+2,n,q))
yAdj = np.zeros_like(yFull)
xAdj = np.zeros_like(xFull)

sysAdj = ss(sysFull.A.T,sysFull.C.T,sysFull.B.T,sysFull.D.T,1)

for qi in range(q):
    yFull[:,:,qi],_,xFull[:,:,qi] = impulse(sysFull,T=np.arange(0,(r*5+2),1),input=qi,return_x=True)
    yAdj[:,:,qi],_,xAdj[:,:,qi] = impulse(sysAdj,T=np.arange(0,(r*5+2),1),input=qi,return_x=True)


# Not the fastest way to compute, but illustrative
# Both xAdj and xFull are size (length of t) * (number of states) * (number of inputs)


HankelOC = np.zeros((q*(r*5+1),q*(r*5+1)))
for i in range(xAdj.shape[0]-1): # start at 1 to avoid the D matrix
    for j in range(xFull.shape[0]-1):
        Ystar = np.swapaxes(np.squeeze(xAdj[i+1,:,:]),0,1);        
        MarkovParameter = Ystar@np.squeeze(xFull[j+1,:,:]);
        HankelOC[np.ix_(range(q*i,q*(i+1)),range(q*j,q*(j+1)))] = MarkovParameter

U,Sig,VT = np.linalg.svd(HankelOC)
Sig = np.diag(Sig)
V = VT.T

Xdata = np.zeros((n,q*(xFull.shape[0]-1)))
Ydata = np.zeros((n,q*(xFull.shape[0]-1)))
for i in range(xFull.shape[0]-1):
    Xdata[:,range(q*i,q*(i+1))] = xFull[i+1,:,:]
    Ydata[:,range(q*i,q*(i+1))] = xAdj[i+1,:,:]
    
Phi = Xdata @ V @ fractional_matrix_power(Sig,-1/2)
Psi = Ydata @ U @ fractional_matrix_power(Sig,-1/2)

Ar = Psi[:,:r].T @ sysFull.A @ Phi[:,:r]
Br = Psi[:,:r].T @ sysFull.B
Cr = sysFull.C @ Phi[:,:r]
Dr = sysFull.D

sysBPOD = ss(Ar,Br,Cr,Dr,1)

</t>
<t tx="ekr.20241218004931.186">## Plot impulse responses for all methods
yout_full,tout_full = impulse(sysFull,np.arange(0,60,1))
yout_BT,tout_BT = impulse(sysBT,np.arange(0,60,1))
yout_BPOD,tout_BPOD = impulse(sysBPOD,np.arange(0,60,1))

plt.plot(tout_full,yout_full,label='Full model, n=100')
plt.plot(tout_BT,yout_BT,label='Balanced truncation, r=10')
plt.plot(tout_BPOD,yout_BPOD,label='Balanced POD, r=10')
plt.show()

</t>
<t tx="ekr.20241218004931.187"></t>
<t tx="ekr.20241218004931.188">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.19"># Classify dogs vs. cats
dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241218004931.20">features = np.arange(1,21)
xtrain = np.concatenate((v[:60,features],v[80:140,features]))
test = np.concatenate((v[60:80,features],v[140:160,features]))

label = np.repeat(np.array([1,-1]),60)
truth = np.repeat(np.array([1,-1]),20)


Mdl = svm.SVC(kernel='rbf',gamma='auto').fit(xtrain,label)
test_labels = Mdl.predict(test)

CMdl = cross_val_score(Mdl, xtrain, label, cv=10) #cross-validate the model
classLoss = 1-np.mean(CMdl) # average error over all cross-validation iterations



</t>
<t tx="ekr.20241218004931.21"></t>
<t tx="ekr.20241218004931.22">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.24">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from sklearn import tree, preprocessing
from sklearn.model_selection import cross_val_score
from IPython.display import Image  
from sklearn.externals.six import StringIO  
import pydotplus
from mpl_toolkits.mplot3d import Axes3D
import pandas as pd

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.25">fisheriris_mat = io.loadmat(os.path.join('..','DATA','fisheriris.mat'))
meas = fisheriris_mat['meas']
species = fisheriris_mat['species']
le = preprocessing.LabelEncoder()
le.fit(species.reshape(-1).tolist())
species_label = le.transform(species.reshape(-1).tolist()) 

decision_tree = tree.DecisionTreeClassifier(max_depth=3).fit(meas,species_label)

dot_data = StringIO()

tree.export_graphviz(decision_tree, out_file=dot_data,  
                filled=True, rounded=True,
                special_characters=True)
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
Image(graph.create_png())

cv = cross_val_score(decision_tree, meas, species_label, cv=10) #cross-validate the model
classError = 1-np.mean(cv) # average error over all cross-validation iterations

</t>
<t tx="ekr.20241218004931.26">x1 = meas[:50,:]     # setosa
x2 = meas[50:100,:]  # versicolor
x3 = meas[100:150,:] # virginica

fig = plt.figure()
ax = plt.subplot(111,projection='3d')
ax.plot(x1[:,0],x1[:,1],x1[:,3],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=12)
ax.plot(x2[:,0],x2[:,1],x2[:,3],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=12)
ax.plot(x3[:,0],x3[:,1],x3[:,3],'o',markerfacecolor=(1,0.64,0.098),markeredgecolor='k',ms=12)

plt.show()

</t>
<t tx="ekr.20241218004931.27"># dogs vs. cats
dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

features = np.arange(1,21)
xtrain = np.concatenate((v[:60,features],v[80:140,features]))
test = np.concatenate((v[60:80,features],v[140:160,features]))

label = np.repeat(np.array([1,-1]),60)
truth = np.repeat(np.array([1,-1]),20)

Mdl = tree.DecisionTreeClassifier(max_depth=2).fit(xtrain,label)
cv = cross_val_score(Mdl, xtrain, label, cv=10) #cross-validate the model
classError = 1-np.mean(cv) # average error over all cross-validation iterations

dot_data = StringIO()

tree.export_graphviz(Mdl, out_file=dot_data,  
                filled=True, rounded=True,
                special_characters=True)
graph = pydotplus.graph_from_dot_data(dot_data.getvalue())  
Image(graph.create_png())

</t>
<t tx="ekr.20241218004931.28">## Census Data
adultdata = pd.read_csv(os.path.join('..','DATA','census1994.csv'))

adultdata = adultdata.loc[:,('age','workClass','education_num','marital_status','race','sex','capital_gain','capital_loss','hours_per_week','salary')]

nFeatures = len(adultdata.columns)-1

# convert categorical variables to one-hot representation
adultdata = pd.get_dummies(adultdata, columns=['workClass', 'marital_status', 'race', 'sex', 'salary'])

adultdata_input = adultdata.drop(['salary_&gt;50K','salary_&lt;=50K'],axis=1)
adultdata_salary = adultdata['salary_&gt;50K']

Mdl = tree.DecisionTreeClassifier(max_features=10).fit(adultdata_input,adultdata_salary)
imp = Mdl.feature_importances_
imp_combine = np.zeros(nFeatures)
imp_combine[:5] = imp[:5]
imp_combine[5] = np.mean(imp[5:14])
imp_combine[6] = np.mean(imp[14:21])
imp_combine[7] = np.mean(imp[21:26])
imp_combine[8] = np.mean(imp[26:28])

plt.bar(range(len(imp_combine)),imp_combine)
infeatures = ['age','workClass','education_num', 'marital_status', 'race', 'sex', 'capital_gain','capital_loss','hours_per_week']
plt.xticks(range(len(infeatures)), infeatures, size='small',rotation=45)
plt.show()

</t>
<t tx="ekr.20241218004931.29">## Splitting Procedure
fisheriris_mat = io.loadmat(os.path.join('..','DATA','fisheriris.mat'))
meas = fisheriris_mat['meas']
species = fisheriris_mat['species']

x1 = meas[:50,:]     # setosa
x2 = meas[50:100,:]  # versicolor
x3 = meas[100:150,:] # virginica

plt.plot(x1[:,2],x1[:,3],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=12)
plt.plot(x2[:,2],x2[:,3],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=12)
plt.plot(x3[:,2],x3[:,3],'o',markerfacecolor=(1,0.64,0.098),markeredgecolor='k',ms=12)

plt.plot(np.array([2.35, 2.35]),np.array([0, 3]),'k:',linewidth=2)
plt.plot(np.array([2.35, 10]),np.array([1.75, 1.75]),'k:',linewidth=2)
plt.plot(np.array([4.95, 4.95]),np.array([0, 1.75]),'k:',linewidth=2)

plt.xlim(0,7)
plt.ylim(0,3)

plt.show()

</t>
<t tx="ekr.20241218004931.3">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from mpl_toolkits import mplot3d
from sklearn.discriminant_analysis import LinearDiscriminantAnalysis
from sklearn.discriminant_analysis import QuadraticDiscriminantAnalysis

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.30">plt.plot(x1[:,0],x1[:,1],'o',markerfacecolor=(0,1,0.2),markeredgecolor='k',ms=12)
plt.plot(x2[:,0],x2[:,1],'o',markerfacecolor=(0.9,0,1),markeredgecolor='k',ms=12)
plt.plot(x3[:,0],x3[:,1],'o',markerfacecolor=(1,0.64,0.098),markeredgecolor='k',ms=12)

plt.xlim(4,8)
plt.ylim(2,6)

plt.show()

</t>
<t tx="ekr.20241218004931.31"></t>
<t tx="ekr.20241218004931.32"></t>
<t tx="ekr.20241218004931.33">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.35">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from sklearn import linear_model


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.36"># dogs vs. cats
dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

train = np.concatenate((dog_wave[:,:60],cat_wave[:,:60]),axis=1)
test = np.concatenate((dog_wave[:,60:80],cat_wave[:,60:80]),axis=1)
label = np.repeat(np.array([1,-1]),60)

A = label @ np.linalg.pinv(train)
test_labels = np.sign(A@test)

</t>
<t tx="ekr.20241218004931.37">lasso = linear_model.Lasso().fit(train.T,label)
A_lasso = lasso.coef_
test_labels_lasso = np.sign(A_lasso@test)

</t>
<t tx="ekr.20241218004931.38">fig,axs = plt.subplots(4,1)
axs[0].bar(range(len(test_labels)),test_labels)
axs[1].bar(range(len(A)),A)
axs[2].bar(range(len(test_labels_lasso)),test_labels_lasso)
axs[3].bar(range(len(A_lasso)),A_lasso)


plt.show()

</t>
<t tx="ekr.20241218004931.39">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
A2 = np.flipud(np.reshape(A,(32,32)))
A2_lasso = np.flipud(np.reshape(A_lasso,(32,32)))
axs[0].pcolor(np.rot90(A2),cmap='gray')
axs[1].pcolor(np.rot90(A2_lasso),cmap='gray')


plt.show()

</t>
<t tx="ekr.20241218004931.4">dogdata_w_mat = io.loadmat(os.path.join('..','DATA','dogData_w.mat'))
catdata_w_mat = io.loadmat(os.path.join('..','DATA','catData_w.mat'))

dog_wave = dogdata_w_mat['dog_wave']
cat_wave = catdata_w_mat['cat_wave']

CD = np.concatenate((dog_wave,cat_wave),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241218004931.40">## To be implemented: Python version of Matlab's patternnet()

</t>
<t tx="ekr.20241218004931.41"></t>
<t tx="ekr.20241218004931.42"></t>
<t tx="ekr.20241218004931.43">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.45">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import interpolate
from mpl_toolkits.mplot3d import Axes3D



rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.46">iterMax = 100
h = 0.1
x_grid = np.arange(-6,6+h,h)
y_grid = np.copy(x_grid)
n = len(x_grid)
X,Y = np.meshgrid(x_grid,y_grid)

F1 = 1.5 - 1.6*np.exp(-0.05*(3*np.power(X+3,2)+np.power(Y+3,2)))
F = F1 + (0.5 - np.exp(-0.1*(3*np.power(X-3,2)+np.power(Y-3,2))))
dFy,dFx = np.gradient(F,h,h)

x0 = np.array([4,0,-5])
y0 = np.array([0,-5,2])

x = np.zeros(iterMax+1)
y = np.copy(x)
f = np.copy(x)

x_out = np.zeros((iterMax+1,3));
y_out = np.copy(x_out)
f_out = np.copy(x_out)

interp_type = 'linear'

for jj in range(3):
    q = np.random.permutation(n)
    i1 = np.sort(q[:10])
    q2 = np.random.permutation(n)
    i2 = np.sort(q2[:10])
    x[0] = x0[jj]
    y[0] = y0[jj]
    
    F_i12 = F[i1[:, np.newaxis],i2]
    dFx_i12 = dFx[i1[:, np.newaxis],i2]
    dFy_i12 = dFy[i1[:, np.newaxis],i2]
    
    F_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], F_i12, kind=interp_type)
    dfx_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], dFx_i12, kind=interp_type)
    dfy_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], dFy_i12, kind=interp_type)
    
    f[0] = F_interp(x[0],y[0])
    dfx = dfx_interp(x[0],y[0])
    dfy = dfy_interp(x[0],y[0])
    
#     tau = 2
    tau = 1.5
    for j in range(iterMax):
        x[j+1] = x[j]-tau*dfx # update x, y, and f
        y[j+1] = y[j]-tau*dfy
        q = np.random.permutation(n)
        i1 = np.sort(q[:10])
#         ind1 = np.sort(q[:10])
        q2 = np.random.permutation(n)
        i2 = np.sort(q2[:10])
#         ind2 = np.sort(q2[:10])
        
        F_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], F_i12, kind=interp_type)
        dfx_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], dFx_i12, kind=interp_type)
        dfy_interp = interpolate.interp2d(x_grid[i1], y_grid[i2], dFy_i12, kind=interp_type)
        
        f[j+1] = F_interp(x[j+1],y[j+1])
        dfx = dfx_interp(x[j+1],y[j+1])
        dfy = dfy_interp(x[j+1],y[j+1])
        
        if np.abs(f[j+1]-f[j]) &lt; 10**(-6): # check convergence
            print('Converged after {} iterations'.format(j+1))
            break
        if j == iterMax-1:
            print('Failed to converge after {} iterations'.format(j+1))
    x_out[:,jj] = x
    y_out[:,jj] = y
    f_out[:,jj] = f
    
    # If converged before iterMax, replace 0s with NaNs
    x_out[(j+2):,jj] = np.nan
    y_out[(j+2):,jj] = np.nan
    f_out[(j+2):,jj] = np.nan


</t>
<t tx="ekr.20241218004931.47">plt.figure()
plt.contour(X,Y,F,colors='k')
for jj in range(3):
    plt.plot(x_out[:,jj],y_out[:,jj],'o')
plt.show()

</t>
<t tx="ekr.20241218004931.48">fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})
ax.plot_surface(X, Y, F,linewidth=0,cmap='binary',alpha=0.3)
for jj in range(3):
    ax.scatter(x_out[:,jj],y_out[:,jj],f_out[:,jj]+0.1,'o',s=100)
ax.view_init(elev=40, azim=-100)
plt.show()

</t>
<t tx="ekr.20241218004931.49"></t>
<t tx="ekr.20241218004931.5">xtrain = np.concatenate((v[:60,np.array([1,3])],v[80:140,np.array([1,3])]))
label = np.repeat(np.array([1,-1]),60)
test = np.concatenate((v[60:80,np.array([1,3])],v[140:160,np.array([1,3])]))

lda = LinearDiscriminantAnalysis()
test_class = lda.fit(xtrain, label).predict(test)

truth = np.repeat(np.array([1,-1]),20)
E = 100*(1-np.sum(0.5*np.abs(test_class - truth))/40)

fig,axs = plt.subplots(2)
axs[0].bar(range(40),test_class)

axs[1].plot(v[:80,1],v[:80,3],'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
axs[1].plot(v[80:,1],v[80:,3],'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

plt.show()

</t>
<t tx="ekr.20241218004931.50"></t>
<t tx="ekr.20241218004931.51">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.53">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os
from keras.utils import to_categorical
from keras.models import Sequential
from keras.layers import Dense, Conv2D, Flatten, MaxPool2D
from keras import optimizers


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.54">letters_train_mat = io.loadmat(os.path.join('..','DATA','lettersTrainSet.mat'))
letters_test_mat = io.loadmat(os.path.join('..','DATA','lettersTestSet.mat'))
XTrain = letters_train_mat['XTrain']
TTrain = letters_train_mat['TTrain_cell']
XTest = letters_test_mat['XTest']
TTest = letters_test_mat['TTest_cell']

perm = np.random.permutation(1500)[:20]


# By default, Keras expects data in form (batch, height, width, channels) 
XTrain = np.transpose(XTrain,axes=[3,0,1,2])
XTest = np.transpose(XTest,axes=[3,0,1,2])



fig,axs = plt.subplots(4,5)
axs = axs.reshape(-1)

for j in range(len(axs)):
    axs[j].imshow(np.squeeze(XTrain[perm[j],:,:,:]),cmap='gray')
    axs[j].axis('off')

</t>
<t tx="ekr.20241218004931.55">classes = np.unique(TTrain)
y_train_label = np.zeros_like(TTrain)
y_test_label = np.zeros_like(TTest)
for nc in range(len(classes)):
    y_train_label[TTrain == classes[nc]] = nc
    y_test_label[TTest == classes[nc]] = nc

y_train_label = y_train_label.reshape(-1)
y_test_label = y_test_label.reshape(-1)
    
#one-hot encode categorical classes
y_train = to_categorical(y_train_label)
y_test = to_categorical(y_test_label)

</t>
<t tx="ekr.20241218004931.56">#create model
model = Sequential()

#add model layers
model.add(Conv2D(filters=16, kernel_size=5, activation='relu', input_shape=(28,28,1)))
model.add(MaxPool2D(pool_size=2, strides=2))
model.add(Flatten())
model.add(Dense(len(classes), activation='softmax'))

sgd_optimizer = optimizers.SGD(momentum=0.9)
model.compile(optimizer=sgd_optimizer, loss='categorical_crossentropy')
model.fit(XTrain, y_train, epochs=30)

</t>
<t tx="ekr.20241218004931.57">YPredict = np.argmax(model.predict(XTest),axis=1)
# argmax reverses the one-hot encoding scheme

accuracy = np.sum(YPredict == y_test_label)/len(y_test_label)
print('Accuracy = {}'.format(accuracy))

</t>
<t tx="ekr.20241218004931.58"></t>
<t tx="ekr.20241218004931.59"></t>
<t tx="ekr.20241218004931.6">plt.rcParams['figure.figsize'] = [8,4]
fig,axs = plt.subplots(1,2)
for j in range(2):
    U3 = np.flipud(np.reshape(u[:,2*j+1],(32,32)))
    axs[j].pcolor(np.rot90(U3),cmap='hot')
    axs[j].axis('off')

</t>
<t tx="ekr.20241218004931.60">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.62">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import integrate
from mpl_toolkits.mplot3d import Axes3D

from keras.models import Sequential
from keras.layers import Dense, Conv2D, Flatten, MaxPool2D
from keras import optimizers
from keras.layers import Activation
from keras.utils.generic_utils import get_custom_objects
from keras import backend as K


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.63">## Simulate the Lorenz System

dt = 0.01
T = 8
t = np.arange(0,T+dt,dt)
beta = 8/3
sigma = 10
rho = 28


nn_input = np.zeros((100*(len(t)-1),3))
nn_output = np.zeros_like(nn_input)

fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})


def lorenz_deriv(x_y_z, t0, sigma=sigma, beta=beta, rho=rho):
    x, y, z = x_y_z
    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]

np.random.seed(123)
x0 = -15 + 30 * np.random.random((100, 3))

x_t = np.asarray([integrate.odeint(lorenz_deriv, x0_j, t)
                  for x0_j in x0])

for j in range(100):
    nn_input[j*(len(t)-1):(j+1)*(len(t)-1),:] = x_t[j,:-1,:]
    nn_output[j*(len(t)-1):(j+1)*(len(t)-1),:] = x_t[j,1:,:]
    x, y, z = x_t[j,:,:].T
    ax.plot(x, y, z,linewidth=1)
    ax.scatter(x0[j,0],x0[j,1],x0[j,2],color='r')
             
ax.view_init(18, -113)
plt.show()


</t>
<t tx="ekr.20241218004931.64">## Neural Net

# Define activation functions
def logsig(x):
    return K.variable(np.divide(1,(1+np.exp(-K.eval(x)))))

def radbas(x):
    return K.variable(np.exp(-np.power(K.eval(x),2)))

def purelin(x):
    return x


#create model
model = Sequential()

#add model layers
model.add(Dense(10, activation=logsig))
model.add(Dense(10, activation=radbas))
model.add(Dense(10, activation=purelin))




sgd_optimizer = optimizers.SGD(momentum=0.9)
model.compile(optimizer=sgd_optimizer, loss='categorical_crossentropy')
model.fit(nn_input, nn_output, epochs=30)

</t>
<t tx="ekr.20241218004931.65">nn_input.shape

</t>
<t tx="ekr.20241218004931.66"></t>
<t tx="ekr.20241218004931.67"></t>
<t tx="ekr.20241218004931.68">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.7">dogdata_mat = io.loadmat(os.path.join('..','DATA','dogData.mat'))
catdata_mat = io.loadmat(os.path.join('..','DATA','catData.mat'))

dog = dogdata_mat['dog']
cat = catdata_mat['cat']

CD = np.concatenate((dog,cat),axis=1)

u,s,vT = np.linalg.svd(CD-np.mean(CD),full_matrices=0)
v = vT.T

</t>
<t tx="ekr.20241218004931.70">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.71">startval = 1
endval = 4
xvals = np.array([[],[]])
n_iter = 1000
n_plot = 100

def logistic(xk,r):
    return r*xk*(1-xk)

for r in np.arange(startval,endval,0.00025):
    x = 0.5
    for i in range(n_iter):
        x = logistic(x,r)
        if i == n_iter-n_plot:
            xss = x
        if i &gt; n_iter-n_plot:
            xvals = np.append(xvals,np.array([[r],[x]]),axis=1)
            if np.abs(x-xss) &lt; 0.001:
                break


</t>
<t tx="ekr.20241218004931.72">plt.plot(xvals[1,:],xvals[0,:],'.',ms=0.1,color='k')
plt.xlim(0,1)
plt.ylim(1,endval)
plt.gca().invert_yaxis()

</t>
<t tx="ekr.20241218004931.73">plt.plot(xvals[1,:],xvals[0,:],'.',ms=0.1,color='k')
plt.xlim(0,1)
plt.ylim(3.45,4)
plt.gca().invert_yaxis()

</t>
<t tx="ekr.20241218004931.74"></t>
<t tx="ekr.20241218004931.75">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.77">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D
from scipy import integrate


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.78">## Simulate the Lorenz System

dt = 0.001
T = 50
t = np.arange(0,T+dt,dt)
beta = 8/3
sigma = 10
rho = 28

fig,ax = plt.subplots(1,1,subplot_kw={'projection': '3d'})


def lorenz_deriv(x_y_z, t0, sigma=sigma, beta=beta, rho=rho):
    x, y, z = x_y_z
    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]

np.random.seed(123)
x0 = (0,1,20)

x_t = integrate.odeint(lorenz_deriv, x0, t,rtol=10**(-12),atol=10**(-12)*np.ones_like(x0))

x, y, z = x_t.T
plt.plot(x, y, z,linewidth=1)
plt.scatter(x0[0],x0[1],x0[2],color='r')
             
ax.view_init(18, -113)
plt.show()

</t>
<t tx="ekr.20241218004931.79"></t>
<t tx="ekr.20241218004931.8">plt.rcParams['figure.figsize'] = [12, 12]
xtrain = np.concatenate((v[:60,np.array([1,3])],v[80:140,np.array([1,3])]))
label = np.repeat(np.array([1,-1]),60)
test = np.concatenate((v[60:80,np.array([1,3])],v[140:160,np.array([1,3])]))

lda = LinearDiscriminantAnalysis()
test_class = lda.fit(xtrain, label).predict(test)

fig,axs = plt.subplots(2)
axs[0].bar(range(40),test_class)

axs[1].plot(v[:80,1],v[:80,3],'ro',MarkerFaceColor=(0,1,0.2),MarkerEdgeColor='k',ms=12)
axs[1].plot(v[80:,1],v[80:,3],'bo',MarkerFaceColor=(0.9,0,1),MarkerEdgeColor='k',ms=12)

plt.show()

</t>
<t tx="ekr.20241218004931.80"></t>
<t tx="ekr.20241218004931.81">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.83">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io
import os

rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [8, 16]

</t>
<t tx="ekr.20241218004931.84">vortall_mat = io.loadmat(os.path.join('..','DATA','VORTALL.mat'))
X = vortall_mat['VORTALL']
# VORTALL contains flow fields reshaped into column vectors

</t>
<t tx="ekr.20241218004931.85">def DMD(X,Xprime,r):
    U,Sigma,VT = np.linalg.svd(X,full_matrices=0) # Step 1
    Ur = U[:,:r]
    Sigmar = np.diag(Sigma[:r])
    VTr = VT[:r,:]
    Atilde = np.linalg.solve(Sigmar.T,(Ur.T @ Xprime @ VTr.T).T).T # Step 2
    Lambda, W = np.linalg.eig(Atilde) # Step 3
    Lambda = np.diag(Lambda)
    
    Phi = Xprime @ np.linalg.solve(Sigmar.T,VTr).T @ W # Step 4
    alpha1 = Sigmar @ VTr[:,0]
    b = np.linalg.solve(W @ Lambda,alpha1)
    return Phi, Lambda, b


</t>
<t tx="ekr.20241218004931.86">Phi, Lambda, b = DMD(X[:,:-1],X[:,1:],21)

</t>
<t tx="ekr.20241218004931.87">## Plot Mode 2
vortmin = -5
vortmax = 5
V2 = np.copy(np.real(np.reshape(Phi[:,1],(449,199))))
V2 = V2.T

# normalize values... not symmetric
minval = np.min(V2)
maxval = np.max(V2)

if np.abs(minval) &lt; 5 and np.abs(maxval) &lt; 5:
    if np.abs(minval) &gt; np.abs(maxval):
        vortmax = maxval
        vortmin = -maxval
    else:
        vortmin = minval
        vortmax = -minval

V2[V2 &gt; vortmax] = vortmax
V2[V2 &lt; vortmin] = vortmin

plt.imshow(V2,cmap='jet',vmin=vortmin,vmax=vortmax)

cvals = np.array([-4,-2,-1,-0.5,-0.25,-0.155])
plt.contour(V2,cvals*vortmax/5,colors='k',linestyles='dashed',linewidths=1)
plt.contour(V2,np.flip(-cvals)*vortmax/5,colors='k',linestyles='solid',linewidths=0.4)

plt.scatter(49,99,5000,color='k') # draw cylinder


plt.show()

</t>
<t tx="ekr.20241218004931.88">V2 = np.real(np.reshape(Phi[:,1],(199,449)))

# plt.hist(np.real(Phi).reshape(-1),128)
plt.hist(V2.reshape(-1),128)
plt.show()

</t>
<t tx="ekr.20241218004931.89"></t>
<t tx="ekr.20241218004931.9">## Cross-validate
E = np.zeros(100)

for jj in range(100):
    r1 = np.random.permutation(80)
    r2 = np.random.permutation(80)
    ind1 = r1[:60]
    ind2 = r2[:60]+60
    ind1t = r1[60:80]
    ind2t = r2[60:80]+60
    
    xtrain = np.concatenate((v[ind1[:, np.newaxis],np.array([1,3])], v[ind2[:, np.newaxis],np.array([1,3])]))
    test = np.concatenate((v[ind1t[:, np.newaxis],np.array([1,3])], v[ind2t[:, np.newaxis],np.array([1,3])]))
    
    label = np.repeat(np.array([1,-1]),60)

    lda = LinearDiscriminantAnalysis()
    test_class = lda.fit(xtrain, label).predict(test)

    truth = np.repeat(np.array([1,-1]),20)
    E[jj] = 100*np.sum(np.abs(test_class-truth))/40
    
plt.bar(range(100),E,color=(0.5,0.5,0.5))
plt.plot(range(100),np.mean(E)*np.ones(100),'r:',linewidth=3)
plt.show()

</t>
<t tx="ekr.20241218004931.90"></t>
<t tx="ekr.20241218004931.91">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004931.93">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D
from scipy import integrate


rcParams.update({'font.size': 18})
plt.rcParams['figure.figsize'] = [12, 12]

</t>
<t tx="ekr.20241218004931.94">## Simulate the Lorenz System

dt = 0.01
T = 50
t = np.arange(dt,T+dt,dt)
beta = 8/3
sigma = 10
rho = 28
n = 3

def lorenz_deriv(x_y_z, t0, sigma=sigma, beta=beta, rho=rho):
    x, y, z = x_y_z
    return [sigma * (y - x), x * (rho - z) - y, x * y - beta * z]

np.random.seed(123)
x0 = (-8,8,27)

x = integrate.odeint(lorenz_deriv, x0, t,rtol=10**(-12),atol=10**(-12)*np.ones_like(x0))


</t>
<t tx="ekr.20241218004931.95">## Compute Derivative
dx = np.zeros_like(x)
for j in range(len(t)):
    dx[j,:] = lorenz_deriv(x[j,:],0,sigma,beta,rho)


</t>
<t tx="ekr.20241218004931.96">## SINDy Function Definitions

def poolData(yin,nVars,polyorder):
    n = yin.shape[0]
    yout = np.zeros((n,1))
    
    # poly order 0
    yout[:,0] = np.ones(n)
    
    # poly order 1
    for i in range(nVars):
        yout = np.append(yout,yin[:,i].reshape((yin.shape[0],1)),axis=1)
    
    # poly order 2
    if polyorder &gt;= 2:
        for i in range(nVars):
            for j in range(i,nVars):
                yout = np.append(yout,(yin[:,i]*yin[:,j]).reshape((yin.shape[0],1)),axis=1)
                
    # poly order 3
    if polyorder &gt;= 3:
        for i in range(nVars):
            for j in range(i,nVars):
                for k in range(j,nVars):
                    yout = np.append(yout,(yin[:,i]*yin[:,j]*yin[:,k]).reshape((yin.shape[0],1)),axis=1)
    
    return yout

def sparsifyDynamics(Theta,dXdt,lamb,n):
    Xi = np.linalg.lstsq(Theta,dXdt,rcond=None)[0] # Initial guess: Least-squares
    
    for k in range(10):
        smallinds = np.abs(Xi) &lt; lamb # Find small coefficients
        Xi[smallinds] = 0                          # and threshold
        for ind in range(n):                       # n is state dimension
            biginds = smallinds[:,ind] == 0
            # Regress dynamics onto remaining terms to find sparse Xi
            Xi[biginds,ind] = np.linalg.lstsq(Theta[:,biginds],dXdt[:,ind],rcond=None)[0]
            
    return Xi


</t>
<t tx="ekr.20241218004931.97">Theta = poolData(x,n,3) # Up to third order polynomials
lamb = 0.025 # sparsification knob lambda
Xi = sparsifyDynamics(Theta,dx,lamb,n)

print(Xi)

</t>
<t tx="ekr.20241218004931.98"></t>
<t tx="ekr.20241218004931.99">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.10">## Plot input/output pair for OKID
fig,axs = plt.subplots(2)

axs[0].set_title('Inputs')
axs[0].step(range(uRandom.shape[1]),uRandom[0,:],label='u1')
axs[0].step(range(uRandom.shape[1]),uRandom[1,:],label='u2')
axs[0].set_xlabel('t')
axs[0].set_ylabel('u')

axs[1].set_title('Outputs')
axs[1].step(range(yRandom.shape[1]),uRandom[0,:],label='y1')
axs[1].step(range(yRandom.shape[1]),uRandom[1,:],label='y2')
axs[1].set_xlabel('t')
axs[1].set_ylabel('y')

for ax in axs:
    ax.legend(prop={'size': 12})


plt.show()

</t>
<t tx="ekr.20241218004932.101">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.102">L = 10 # define domain
x2 = np.arange(-L,L,0.1) 
n = len(x2)
k = n*(2*np.pi/(2*L))*np.fft.fftfreq(n) # k-vector
ye = np.exp(-np.power(x2,2))
ye2 = np.exp(np.power(x2,2)/2) # define Gaussians

y = np.zeros((n,10))

for jj in range(10): # loop through 10 modes
    # 2nd derivative
    yd = np.real(np.fft.ifft((np.power((1j)*k,jj))*np.fft.fft(ye)))
    
    mode = np.power(-1,jj) * \
        np.power((np.power(2,jj)*np.math.factorial(jj)*np.sqrt(np.pi)),-0.5) * \
        ye2 * yd
            
    y[:,jj] = mode # store modes as columns
            
x = x2[int(n/2)-40 : int(n/2)+41] # keep only -4&lt;x&lt;4
yharm = y[int(n/2)-40 : int(n/2)+41,:]

</t>
<t tx="ekr.20241218004932.103">n = len(x)
f = np.exp(-np.power(x-0.5,2)) + 3*np.exp(-2*np.power(x+1.5,2))

a = np.zeros(10)

for jj in range(10):
    a[jj] = np.trapz(f*yharm[:,jj],x)

f2 = yharm @ a
Efull = np.linalg.norm(f2-f) # recontruction error
    
M = np.zeros((10,10))

for jj in range(10): # matrix M reconstruction
    for kk in range(jj+1):
        Area = np.trapz(yharm[:,jj]*yharm[:,kk],x)
        M[jj,kk] = Area
        M[kk,jj] = Area

Cfull = np.linalg.cond(M) # get condition number

</t>
<t tx="ekr.20241218004932.104">## Test Random trials with P% of measurements

# matrices for mean and variance of error and conditioning numbers
E = np.zeros(5)
Ec = np.zeros(5)
V = np.zeros(5)
Vc = np.zeros(5)

for thresh in range(5):
    Err = np.zeros(1000)
    con = np.zeros(1000)
    for jloop in range(1000): # 1000 random trials
        n2 = np.random.choice(n,size=8*(thresh+1)) # random sampling
        P = np.zeros(n)
        P[n2] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
        
        ftild = np.zeros(10)
        for jj in range(10): # reconstruction using gappy
            ftild[jj] = np.trapz(P*f*yharm[:,jj],x)

        atild = np.linalg.solve(M2,ftild) # compute error
        f2 = yharm @ atild                # compute reconstruction
        Err[jloop] = np.linalg.norm(f2-f) # L2 error
        con[jloop] = np.linalg.cond(M2)   # condition number
        
    # mean and variance
    E[thresh] = np.mean(np.log(Err+1))
    V[thresh] = np.var(np.log(Err+1))
    Ec[thresh] = np.mean(np.log(con))
    Vc[thresh] = np.var(np.log(con))
    
E = np.concatenate((E,[Efull]))
V = np.concatenate((V,[0]))
Ec = np.concatenate((Ec,[Cfull]))
Vc = np.concatenate((Vc,[0]))

</t>
<t tx="ekr.20241218004932.105">fig,axs = plt.subplots(2,1)
axs[0].bar(range(len(E)),E,yerr=V,ecolor='r',capsize=5)
axs[1].bar(range(len(Ec)),Ec,yerr=Vc,ecolor='r',capsize=5)

plt.show()

</t>
<t tx="ekr.20241218004932.106">## For 20% measurements, sort great from bad
Pmaster = np.zeros((n,200))
Er = np.zeros(200)
co = np.zeros(200)
for jloop in range(200): # 200 random trials
    n2 = np.random.choice(n,20) # random sampling
    P = np.zeros(n)
    P[n2] = 1
    Pmaster[:,jloop] = P

    # compute M matrix
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area

    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*f*yharm[:,jj],x)

    atild = np.linalg.solve(M2,ftild) # compute error
    f2 = yharm @ atild                # compute reconstruction
    Er[jloop] = np.linalg.norm(f2-f) # L2 error
    co[jloop] = np.linalg.cond(M2)   # condition number

</t>
<t tx="ekr.20241218004932.107">fig,axs = plt.subplots(3,1)
axs[0].bar(range(len(co)),np.log(co))
axs[0].set_xlim(0,len(co))
axs[1].hist(np.log(Er+1),50)
axs[2].hist(np.log(co),50)

plt.show()

</t>
<t tx="ekr.20241218004932.108">fig, ax = plt.subplots(1,1)
ax.pcolor(-Pmaster,cmap='hot')
ax.set_aspect('equal', 'box')

</t>
<t tx="ekr.20241218004932.109">jloc = np.argsort(co)
Cloc = co[jloc]

jbest = jloc[:11]
jworst = jloc[-11:]
Sbest = Pmaster[:,jbest]
Sworst = Pmaster[:,jworst]
csor = np.concatenate((100*Cloc[:10],np.zeros(10),Cloc[-10:]))
# Note that the values for the 10 best are inflated 100-fold 
# for plotting visibility

fig,axs = plt.subplots(3,1)
axs[0].pcolor(-Sbest.T,cmap='hot')
axs[1].pcolor(-Sworst.T,cmap='hot')
axs[2].bar(range(len(csor)),csor)

for ax in axs[:-1]:
    ax.set_aspect('equal', 'box')
plt.show()

</t>
<t tx="ekr.20241218004932.11">uRandom.shape

</t>
<t tx="ekr.20241218004932.110">m = 30
q = np.random.rand(m,m)
q = q.reshape(-1)
n = m**2
p = np.random.choice(n,200)
q2 = np.zeros(n)
q2[p] = q[p]
p2 = np.random.choice(n,40)
q3 = np.zeros(n)
q3[p2] = q[p2]
q = q.reshape((m,m))
q2 = q2.reshape((m,m))
q3 = q3.reshape((m,m))

fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
axs[0].pcolormesh(-q,cmap='hot')
axs[1].pcolormesh(-q2,cmap='hot')
axs[2].pcolor(-q3,cmap='hot')

for ax in axs[:-1]:
    ax.set_aspect('equal', 'box')
    ax.minorticks_off()
    ax.grid(True, which='major', axis='both', linestyle='-', color='k')
    ax.set_xticks(range(m), minor=False)
    ax.set_yticks(range(m), minor=False)
    ax.tick_params(bottom=False,left=False)
    ax.set_xticklabels('')
    ax.set_yticklabels('')
    ax.set_xlim(0,m)
    ax.set_ylim(0,m)

axs[-1].axis(False)
plt.show()

</t>
<t tx="ekr.20241218004932.111"></t>
<t tx="ekr.20241218004932.112">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.114">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.115">L = 10 # define domain
x2 = np.arange(-L,L,0.1) 
n = len(x2)
k = n*(2*np.pi/(2*L))*np.fft.fftfreq(n) # k-vector
ye = np.exp(-np.power(x2,2))
ye2 = np.exp(np.power(x2,2)/2) # define Gaussians

y = np.zeros((n,10))

for jj in range(10): # loop through 10 modes
    # 2nd derivative
    yd = np.real(np.fft.ifft((np.power((1j)*k,jj))*np.fft.fft(ye)))
    
    mode = np.power(-1,jj) * \
        np.power((np.power(2,jj)*np.math.factorial(jj)*np.sqrt(np.pi)),-0.5) * \
        ye2 * yd
            
    y[:,jj] = mode # store modes as columns
            
x = x2[int(n/2)-40 : int(n/2)+41] # keep only -4&lt;x&lt;4
yharm = y[int(n/2)-40 : int(n/2)+41,:]
n = len(x)
f = np.exp(-np.power(x-0.5,2)) + 3*np.exp(-2*np.power(x+1.5,2))


</t>
<t tx="ekr.20241218004932.116">## Method 1 -- Condition Number
n2 = 20 # number of sensors
nall = np.arange(n)
ns = np.array([],dtype='int')
kond = np.zeros(n2)
Psum = np.zeros((n,n2))
f1 = np.zeros((n,n2))
E = np.zeros(n2)
for jsense in range(n2):
    con = np.zeros(n-jsense-1)
    for jloop in range(n-jsense-1):
        P = np.zeros(n)
        P[ns] = 1
        P[nall[jloop]] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
        
        con[jloop] = np.linalg.cond(M2) # compute condition number
    n1 = np.argmin(con) # location to minimize condition #
    s1 = con[n1]
    kond[jsense] = s1
    ns = np.append(ns,nall[n1]) # add sensor location
    nall = np.setdiff1d(nall,ns) # new sensor indices
    P = np.zeros(n)
    P[ns] = 1
    Psum[:,jsense] = P
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
            
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f1[:,jsense] = yharm @ atild        # iterative reconstruction
    E[jsense] = np.linalg.norm(f1[:,jsense]-f) # iterative error

</t>
<t tx="ekr.20241218004932.117">plt.rcParams['figure.figsize'] = [12,10]
fig, axs = plt.subplots(3,1)
axs[0].bar(range(n2),np.log(kond),facecolor=(0.7,0.7,0.7))
axs[1].bar(range(n2),np.log(E+1),facecolor=(0.7,0.7,0.7))
axs[2].pcolor(-Psum.T,cmap='hot')

plt.show()

</t>
<t tx="ekr.20241218004932.118">titer = np.arange(1,21)
titer = np.append(titer,25)
titer2 = np.arange(9,21)
titer2 = np.append(titer2,25)
f1 = np.concatenate((f1,f.reshape(n,1)),axis=1)
f2 = np.concatenate((f1[:,9:21],f.reshape(n,1)),axis=1)


</t>
<t tx="ekr.20241218004932.119">plt.rcParams['figure.figsize'] = [12,6]
fig, axs = plt.subplots(ncols=2, subplot_kw={'projection': '3d'})
for ti in range(len(titer)):
    axs[0].plot(x,titer[ti]*np.ones_like(x),f1[:,ti],color='k')
    
for ti in range(len(titer2)):
    axs[1].plot(x,titer2[ti]*np.ones_like(x),f2[:,ti],color='k')
    
for ax in axs:
    ax.view_init(azim=120,elev=30)
    ax.set_xlim(-4,4)
    ax.set_ylim(0,25)


</t>
<t tx="ekr.20241218004932.12"></t>
<t tx="ekr.20241218004932.120">## Method 2 -- Max Diagonal vs. Off-Diagonal
n2 = 60 # number of sensors
nall = np.arange(n)
ns = np.array([],dtype='int')
kond2 = np.zeros(n2)
Psum2 = np.zeros((n,n2))
f2 = np.zeros((n,n2))
E2 = np.zeros(n2)
for jsense in range(n2):
    con = np.zeros(n-jsense-1)
    for jloop in range(n-jsense-1):
        P = np.zeros(n)
        P[ns] = 1
        P[nall[jloop]] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
                
        # compute proxy measure
        con[jloop] = 2*np.sum(np.diag(M2))-np.sum(M2.reshape(-1))
    n1 = np.argmax(con) # location to maximize condition #
    s1 = con[n1]
    kond2[jsense] = s1
    ns = np.append(ns,nall[n1]) # add sensor location
    nall = np.setdiff1d(nall,ns) # new sensor indices
    P = np.zeros(n)
    P[ns] = 1
    Psum2[:,jsense] = P
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
            
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f2[:,jsense] = yharm @ atild        # iterative reconstruction
    E2[jsense] = np.linalg.norm(f2[:,jsense]-f) # iterative error

</t>
<t tx="ekr.20241218004932.121">plt.rcParams['figure.figsize'] = [12,10]
fig, axs = plt.subplots(3,1)
axs[0].bar(range(n2),kond2,facecolor=(0.7,0.7,0.7))
axs[0].set_xlim(0,61)
axs[0].set_ylim(0,15)
axs[1].bar(range(n2),np.log(E2+1),facecolor=(0.7,0.7,0.7))
axs[1].set_xlim(0,61)
axs[1].set_ylim(0,12)
axs[2].pcolor(-Psum2.T,cmap='hot')

plt.show()

</t>
<t tx="ekr.20241218004932.122">## Method 1 -- First 4 Condition Number
n2 = 4 # number of sensors
nall = np.arange(n)
ns = np.array([],dtype='int')
kond = np.zeros(n2)
Psum = np.zeros((n,n2))
f1 = np.zeros((n,n2))
E = np.zeros(n2)
fig,axs = plt.subplots(4,1)
for jsense in range(n2):
    con = np.zeros(n-jsense-1)
    for jloop in range(n-jsense-1):
        P = np.zeros(n)
        P[ns] = 1
        P[nall[jloop]] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
        
        con[jloop] = np.linalg.cond(M2) # compute condition number
    n1 = np.argmin(con) # location to minimize condition #
    s1 = con[n1]
    kond[jsense] = s1
    ns = np.append(ns,nall[n1]) # add sensor location
    nall = np.setdiff1d(nall,ns) # new sensor indices
    P = np.zeros(n)
    P[ns] = 1
    Psum[:,jsense] = P
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
            
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f1[:,jsense] = yharm @ atild        # iterative reconstruction
    E[jsense] = np.linalg.norm(f1[:,jsense]-f) # iterative error
    
    temp = np.zeros(n)
    if jsense == 0:
        contemp = con
        temp[n1] = s1
    elif jsense == 1:
        contemp = np.concatenate((con[:ns[0]],[0],con[ns[0]:]))
        con2 = contemp
        temp[n1+1] = s1
    elif jsense == 2:
        contemp = np.concatenate((con[:ns[0]],[0],con[ns[0]:ns[1]],[0],con[ns[1]:]))
        con3 = contemp
        temp[n1+1] = s1
    elif jsense == 3:
        contemp = np.concatenate((con[:ns[0]],[0],con[ns[0]:ns[1]],[0],con[ns[1]:ns[2]],[0],con[ns[2]:]))
        con4 = contemp
        temp[n1+1] = s1
        
    axs[jsense].bar(range(len(contemp)),np.log(contemp),facecolor=(0.7,0.7,0.7))
    axs[jsense].bar(range(len(temp)),np.log(temp),facecolor='r')
    axs[jsense].set_xlim(0,80)
    axs[jsense].set_ylim(0,100)

</t>
<t tx="ekr.20241218004932.123"></t>
<t tx="ekr.20241218004932.124">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.126">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.127">L = 10 # define domain
x2 = np.arange(-L,L,0.1) 
n = len(x2)
k = n*(2*np.pi/(2*L))*np.fft.fftfreq(n) # k-vector
ye = np.exp(-np.power(x2,2))
ye2 = np.exp(np.power(x2,2)/2) # define Gaussians

y = np.zeros((n,10))

for jj in range(10): # loop through 10 modes
    # 2nd derivative
    yd = np.real(np.fft.ifft((np.power((1j)*k,jj))*np.fft.fft(ye)))
    
    mode = np.power(-1,jj) * \
        np.power((np.power(2,jj)*np.math.factorial(jj)*np.sqrt(np.pi)),-0.5) * \
        ye2 * yd
            
    y[:,jj] = mode # store modes as columns
            
x = x2[int(n/2)-40 : int(n/2)+41] # keep only -4&lt;x&lt;4
yharm = y[int(n/2)-40 : int(n/2)+41,:]
n = len(x)
f = np.exp(-np.power(x-0.5,2)) + 3*np.exp(-2*np.power(x+1.5,2))

E = np.zeros(13)
con = np.zeros(13)

</t>
<t tx="ekr.20241218004932.128">## Method 1 -- Start with max of each mode
ns = np.array([],dtype='int')

for jj in range(10): # walk through the modes
    n1 = np.argmax(yharm[:,jj]) # pick max
    s1 = yharm[n1,jj]
    ns = np.append(ns,n1)

P = np.zeros(n)
P[ns] = 1

# compute M matrix
M2 = np.zeros((10,10))
for jj in range(10):
    for kk in range(jj+1):
        Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
        M2[jj,kk] = Area
        M2[kk,jj] = Area

ftild = np.zeros(10)
for jj in range(10): # reconstruction using gappy
    ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
atild = np.linalg.solve(M2,ftild) # compute error
f1 = yharm @ atild        # iterative reconstruction
E[0] = np.linalg.norm(f1-f) # iterative error
con[0] = np.linalg.cond(M2)

plt.plot(x,f,'r')
plt.plot(x,f1,'k')
plt.show()

</t>
<t tx="ekr.20241218004932.129">## Method 2 -- Start with max and mins of each mode
ns = np.array([],dtype='int')

for jj in range(10): # walk through the modes
    n1 = np.argmax(yharm[:,jj]) # pick max
    s1 = yharm[n1,jj]
    ns = np.append(ns,n1)

for jj in range(1,10): # no minimum on first mode
    n2 = np.argmin(yharm[:,jj]) # pick min
    s2 = yharm[n2,jj]
    ns = np.append(ns,n2)
    
    
P = np.zeros(n)
P[ns] = 1

# compute M matrix
M2 = np.zeros((10,10))
for jj in range(10):
    for kk in range(jj+1):
        Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
        M2[jj,kk] = Area
        M2[kk,jj] = Area

ftild = np.zeros(10)
for jj in range(10): # reconstruction using gappy
    ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
atild = np.linalg.solve(M2,ftild) # compute error
f1 = yharm @ atild        # iterative reconstruction
E[1] = np.linalg.norm(f1-f) # iterative error
con[1] = np.linalg.cond(M2)

plt.plot(x,f,'r')
plt.plot(x,f1,'k')
plt.show()

</t>
<t tx="ekr.20241218004932.13">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.130">## Method 3 -- Search for extrema, then select random N sensors
nmax = np.array([],dtype='int')
nmin = np.copy(nmax)
Psum = np.zeros((n,10))
for jj in range(10): # walk through the modes
    nmaxt = np.array([],dtype='int')
    nmint = np.copy(nmaxt)
    
    for kk in range(1,n-1):
        if yharm[kk,jj] &gt; yharm[kk-1,jj] and yharm[kk,jj] &gt; yharm[kk+1,jj]:
            nmax = np.append(nmax,kk)
            nmaxt = np.append(nmaxt,kk)
        if yharm[kk,jj] &lt; yharm[kk-1,jj] and yharm[kk,jj] &lt; yharm[kk+1,jj]:
            nmin = np.append(nmin,kk)
            nmint = np.append(nmint,kk)
    
    nst = np.concatenate((nmaxt, nmint))
    Psum[nst,jj] = 1

ns = np.concatenate((nmax,nmin))
ni = np.random.choice(len(ns),20)
nsr = ns[ni]
# P = np.zeros(n)
# P[nsr] = 1

fig,axs = plt.subplots(2,1)
axs[0].pcolor(yharm.T,cmap='hot')
axs[1].pcolor(-Psum.T,cmap='hot')
    
P = np.zeros(n)
P[ns] = 1

# compute M matrix
M2 = np.zeros((10,10))
for jj in range(10):
    for kk in range(jj+1):
        Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
        M2[jj,kk] = Area
        M2[kk,jj] = Area

ftild = np.zeros(10)
for jj in range(10): # reconstruction using gappy
    ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
atild = np.linalg.solve(M2,ftild) # compute error
f1 = yharm @ atild        # iterative reconstruction
E[2] = np.linalg.norm(f1-f) # iterative error
con[2] = np.linalg.cond(M2)

plt.figure()
plt.plot(x,f,'r')
plt.plot(x,f1,'k')
plt.show()

</t>
<t tx="ekr.20241218004932.131">## select random 20 - shuffle
ntot = len(ns)
E_tri = np.zeros(100)
con_tri = np.copy(E_tri)
for jtrials in range(100):
    ni = np.random.choice(ntot,20)
    nsr = ns[ni]
    P = np.zeros(n)
    P[nsr] = 1

    # compute M matrix
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area

    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f1 = yharm @ atild        # iterative reconstruction
    E_tri[jtrials] = np.linalg.norm(f1-f) # iterative error
    con_tri[jtrials] = np.linalg.cond(M2)

fig, axs = plt.subplots(2,1)
axs[0].bar(range(100),np.log(con_tri),facecolor=(0.7,0.7,0.7))
axs[1].bar(range(100),np.log(E_tri+1),facecolor=(0.7,0.7,0.7))

plt.show()

E[3:5] = 0
con[3:5] = 0
Estri = np.sort(E_tri)
contri = np.sort(con_tri)
E[5:10] = Estri[:5]
con[5:10] = contri[:5]
con[10:12] = 0
E[10:12] = 0

</t>
<t tx="ekr.20241218004932.132">## Method to compare -- Willcox condition number
n2 = 20 # number of sensors
nall = np.arange(n)
ns = np.array([],dtype='int')
kond = np.zeros(n2)
Psum = np.zeros((n,n2))
f1 = np.zeros((n,n2))
EW = np.zeros(n2)
for jsense in range(n2):
    con2 = np.zeros(n-jsense-1)
    for jloop in range(n-jsense-1):
        P = np.zeros(n)
        P[ns] = 1
        P[nall[jloop]] = 1
        
        # compute M matrix
        M2 = np.zeros((10,10))
        for jj in range(10):
            for kk in range(jj+1):
                Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
                M2[jj,kk] = Area
                M2[kk,jj] = Area
        
        con2[jloop] = np.linalg.cond(M2) # compute condition number
    n1 = np.argmin(con2) # location to minimize condition #
    s1 = con2[n1]
    kond[jsense] = s1
    ns = np.append(ns,nall[n1]) # add sensor location
    nall = np.setdiff1d(nall,ns) # new sensor indices
    P = np.zeros(n)
    P[ns] = 1
    Psum[:,jsense] = P
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(P*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
            
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(P*(f*yharm[:,jj]),x)
    atild = np.linalg.solve(M2,ftild) # compute error
    f1[:,jsense] = yharm @ atild        # iterative reconstruction
    EW[jsense] = np.linalg.norm(f1[:,jsense]-f) # iterative error
    
E[12] = EW[-1]
con[12] = kond[-1]

dum1 = np.zeros(13)
dum2 = np.zeros(13)
dum1[-1] = EW[-1]
dum2[-1] = kond[-1]

fig, axs = plt.subplots(2,1)
axs[0].bar(range(13),np.log(E+1),facecolor=(0.7,0.7,0.7))
axs[1].bar(range(13),np.log(con),facecolor=(0.7,0.7,0.7))
axs[0].bar(range(13),np.log(dum1+1),facecolor='r')
axs[1].bar(range(13),np.log(dum2),facecolor='r')


plt.show()

</t>
<t tx="ekr.20241218004932.133">fig,axs = plt.subplots(3,1)
axs[0].bar(range(len(kond)),np.log(kond),facecolor=(0.7,0.7,0.7))
axs[1].bar(range(len(EW)),np.log(EW+1),facecolor=(0.7,0.7,0.7))
axs[2].pcolor(-Psum.T,cmap='hot')
plt.show()

</t>
<t tx="ekr.20241218004932.134">titer = np.arange(1,21)
titer = np.append(titer,25)
titer2 = np.arange(9,21)
titer2 = np.append(titer2,25)
f1 = np.concatenate((f1,f.reshape(n,1)),axis=1)
f2 = np.concatenate((f1[:,9:21],f.reshape(n,1)),axis=1)

</t>
<t tx="ekr.20241218004932.135">plt.rcParams['figure.figsize'] = [12,6]
fig, axs = plt.subplots(ncols=2, subplot_kw={'projection': '3d'})
for ti in range(len(titer)):
    axs[0].plot(x,titer[ti]*np.ones_like(x),f1[:,ti],color='k')
    
for ti in range(len(titer2)):
    axs[1].plot(x,titer2[ti]*np.ones_like(x),f2[:,ti],color='k')
    
for ax in axs:
    ax.view_init(azim=120,elev=30)
    ax.set_xlim(-4,4)
    ax.set_ylim(0,25)


</t>
<t tx="ekr.20241218004932.136"></t>
<t tx="ekr.20241218004932.137">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.139">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import integrate
from scipy.linalg import qr
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.140"># spatial discretization
L = 40 
n = 256
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n]

# wavenumbers for FFT
k = n*(2*np.pi/L)*np.fft.fftfreq(n) # k-vector

# time domain collection points
t = np.linspace(0,2*np.pi,61)


</t>
<t tx="ekr.20241218004932.141">def ch_pod_sol_rhs(ut_split,t,k=k):
    ut = ut_split[:n] + (1j)*ut_split[n:]
    u = np.fft.ifft(ut)
    rhs = -0.5*(1j)*np.power(k,2)*ut + (1j)*np.fft.fft(np.power(np.abs(u),2)*u)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241218004932.142">N = 2
u0 = N/np.cosh(x)
ut = np.fft.fft(u0)

ut_split = np.concatenate((np.real(ut),np.imag(ut))) # Separate real/complex pieces

utsol_split = integrate.odeint(ch_pod_sol_rhs,ut_split,t,mxstep=10**6)
utsol = utsol_split[:,:n] + (1j)*utsol_split[:,n:]

usol = np.zeros_like(utsol)
for jj in range(len(t)):
    usol[jj,:] = np.fft.ifft(utsol[jj,:]) # transforming back


</t>
<t tx="ekr.20241218004932.143">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1, projection='3d')
ax.view_init(elev=25, azim=110)

for tt in range(len(t)):
    ax.plot(x,t[tt]*np.ones_like(x),np.abs(usol[tt,:]),color='k',linewidth=0.75)

ax.set_ylim(0,2*np.pi)
plt.show()

</t>
<t tx="ekr.20241218004932.144">X = usol.T # data matrix X
U,S,WT = np.linalg.svd(X,full_matrices=0) # SVD reduction

r = 3 # select rank truncation
Psi = U[:,:r] # select POD modes
a0 = Psi.T @ u0 # project initial conditions

</t>
<t tx="ekr.20241218004932.145">NL = (1j)*np.power(np.abs(X),2)*X
XI,S_NL,WT = np.linalg.svd(NL,full_matrices=0)

# First DEIM point
nmax = np.argmax(np.abs(XI[:,0]))
XI_m = XI[:,0].reshape(n,1)
z = np.zeros((n,1))
P = np.copy(z)
P[nmax] = 1

# DEIM points 2 to r
for jj in range(1,r):
    c = np.linalg.solve(P.T @ XI_m, P.T @ XI[:,jj].reshape(n,1))
    res = XI[:,jj].reshape(n,1) - XI_m @ c
    nmax = np.argmax(np.abs(res))
    XI_m = np.concatenate((XI_m,XI[:,jj].reshape(n,1)),axis=1)
    P = np.concatenate((P,z),axis=1)
    P[nmax,jj] = 1

</t>
<t tx="ekr.20241218004932.146">P_NL = Psi.T @ (XI_m @ np.linalg.inv(P.T @ XI_m)) # nonlinear projection
P_Psi = P.T @ Psi # interpolation of Psi

Lxx = np.zeros((n,r),dtype='complex_')
for jj in range(r):
    Lxx[:,jj] = np.fft.ifft(-np.power(k,2)*np.fft.fft(Psi[:,jj]))

L = 0.5 * (1j) * Psi.T @ Lxx # projected linear term


</t>
<t tx="ekr.20241218004932.147">def rom_deim_rhs(a_split,tspan,P_NL=P_NL,P_Psi=P_Psi,L=L):
    a = a_split[:r] + (1j)*a_split[r:]
    N = P_Psi @ a
    rhs = L @ a + (1j) * P_NL @ (np.power(np.abs(N),2)*N)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241218004932.148">a0_split = np.concatenate((np.real(a0),np.imag(a0))) # Separate real/complex pieces

a_split = integrate.odeint(rom_deim_rhs,a0_split,t,mxstep=10**6)
a = a_split[:,:r] + (1j)*a_split[:,r:]

Xtilde = Psi @ a.T # DEIM approximation

</t>
<t tx="ekr.20241218004932.149">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1, projection='3d')
ax.view_init(elev=25, azim=110)

for tt in range(len(t)):
    ax.plot(x,t[tt]*np.ones_like(x),np.abs(Xtilde[:,tt]),color='k',linewidth=0.75)

ax.set_ylim(0,2*np.pi)
plt.show()

</t>
<t tx="ekr.20241218004932.15">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal,io
import os
from scipy.linalg import fractional_matrix_power

# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241218004932.150">## QR DEIM
Q,R,pivot = qr(NL.T,pivoting=True)
P_qr = np.zeros_like(x)
P_qr[pivot[:3]] = 1

plt.rcParams['figure.figsize'] = [10,2]
plt.bar(x,P_qr,width=0.05)
plt.show()

</t>
<t tx="ekr.20241218004932.151"></t>
<t tx="ekr.20241218004932.152"></t>
<t tx="ekr.20241218004932.153">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.155">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import integrate
from scipy.linalg import qr
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [10,10]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.156"># spatial discretization
L = 40 
n = 256
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n]

# wavenumbers for FFT
k = n*(2*np.pi/L)*np.fft.fftfreq(n) # k-vector

# time domain collection points
t = np.linspace(0,2*np.pi,61)


</t>
<t tx="ekr.20241218004932.157">def ch_pod_sol_rhs(ut_split,t,k=k):
    ut = ut_split[:n] + (1j)*ut_split[n:]
    u = np.fft.ifft(ut)
    rhs = -0.5*(1j)*np.power(k,2)*ut + (1j)*np.fft.fft(np.power(np.abs(u),2)*u)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241218004932.158">N = 2
u0 = N/np.cosh(x)
ut = np.fft.fft(u0)

ut_split = np.concatenate((np.real(ut),np.imag(ut))) # Separate real/complex pieces

utsol_split = integrate.odeint(ch_pod_sol_rhs,ut_split,t,mxstep=10**6)
utsol = utsol_split[:,:n] + (1j)*utsol_split[:,n:]

usol = np.zeros_like(utsol)
for jj in range(len(t)):
    usol[jj,:] = np.fft.ifft(utsol[jj,:]) # transforming back


</t>
<t tx="ekr.20241218004932.159">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1, projection='3d')
ax.view_init(elev=25, azim=110)

for tt in range(len(t)):
    ax.plot(x,t[tt]*np.ones_like(x),np.abs(usol[tt,:]),color='k',linewidth=0.75)

ax.set_ylim(0,2*np.pi)
plt.show()

</t>
<t tx="ekr.20241218004932.16">q = 2   # Number of inputs
p = 2   # Number of outputs
n = 100 # State dimension
r = 10 # Reduced model order

testSys_mat = io.loadmat(os.path.join('..','DATA','testSys_Fig9p5_ABCD.mat'))
A = testSys_mat['A']
B = testSys_mat['B']
C = testSys_mat['C']
D = testSys_mat['D']

sys = ss(A,B,C,D,1)

</t>
<t tx="ekr.20241218004932.160">X = usol.T # data matrix X
U,S,WT = np.linalg.svd(X,full_matrices=0) # SVD reduction

r = 3 # select rank truncation
Psi = U[:,:r] # select POD modes
a0 = Psi.T @ u0 # project initial conditions

</t>
<t tx="ekr.20241218004932.161">NL = (1j)*np.power(np.abs(X),2)*X
XI,S_NL,WT = np.linalg.svd(NL,full_matrices=0)

# First DEIM point
nmax = np.argmax(np.abs(XI[:,0]))
XI_m = XI[:,0].reshape(n,1)
z = np.zeros((n,1))
P = np.copy(z)
P[nmax] = 1

# DEIM points 2 to r
for jj in range(1,r):
    c = np.linalg.solve(P.T @ XI_m, P.T @ XI[:,jj].reshape(n,1))
    res = XI[:,jj].reshape(n,1) - XI_m @ c
    nmax = np.argmax(np.abs(res))
    XI_m = np.concatenate((XI_m,XI[:,jj].reshape(n,1)),axis=1)
    P = np.concatenate((P,z),axis=1)
    P[nmax,jj] = 1

</t>
<t tx="ekr.20241218004932.162">P_NL = Psi.T @ (XI_m @ np.linalg.inv(P.T @ XI_m)) # nonlinear projection
P_Psi = P.T @ Psi # interpolation of Psi

Lxx = np.zeros((n,r),dtype='complex_')
for jj in range(r):
    Lxx[:,jj] = np.fft.ifft(-np.power(k,2)*np.fft.fft(Psi[:,jj]))

L = 0.5 * (1j) * Psi.T @ Lxx # projected linear term


</t>
<t tx="ekr.20241218004932.163">def rom_deim_rhs(a_split,tspan,P_NL=P_NL,P_Psi=P_Psi,L=L):
    a = a_split[:r] + (1j)*a_split[r:]
    N = P_Psi @ a
    rhs = L @ a + (1j) * P_NL @ (np.power(np.abs(N),2)*N)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241218004932.164">a0_split = np.concatenate((np.real(a0),np.imag(a0))) # Separate real/complex pieces

a_split = integrate.odeint(rom_deim_rhs,a0_split,t,mxstep=10**6)
a = a_split[:,:r] + (1j)*a_split[:,r:]

Xtilde = Psi @ a.T # DEIM approximation

</t>
<t tx="ekr.20241218004932.165">fig = plt.figure()
ax = fig.add_subplot(1, 1, 1, projection='3d')
ax.view_init(elev=25, azim=110)

for tt in range(len(t)):
    ax.plot(x,t[tt]*np.ones_like(x),np.abs(Xtilde[:,tt]),color='k',linewidth=0.75)

ax.set_ylim(0,2*np.pi)
plt.show()

</t>
<t tx="ekr.20241218004932.166">plt.plot(x,-np.real(Psi[:,:3]))
plt.xlim(-4,4)
plt.ylim(-1,1)
[plt.bar(x, P[:,jj],width=0.025,color='k') for jj in range(3)]
[plt.bar(x,-P[:,jj],width=0.025,color='k') for jj in range(3)]
plt.show()

</t>
<t tx="ekr.20241218004932.167">## QR compare
plt.rcParams['figure.figsize'] = [8,8]
fig,axs = plt.subplots(2,1)
axs[0].plot(x,-np.real(Psi[:,:3]))
[axs[0].bar(x, P[:,jj],width=0.025,color='k') for jj in range(3)]
[axs[0].bar(x,-P[:,jj],width=0.025,color='k') for jj in range(3)]

Q,R,pivot = qr(NL.T,pivoting=True)
P_qr = np.zeros_like(x)
P_qr[pivot[:3]] = 1

axs[1].plot(x,-np.real(Psi[:,:3]))
axs[1].bar(x, P_qr,width=0.025,color='k')
axs[1].bar(x,-P_qr,width=0.025,color='k')

for ax in axs:
    ax.set_xlim(-4,4)
    ax.set_ylim(-1,1)

plt.show()

</t>
<t tx="ekr.20241218004932.168"></t>
<t tx="ekr.20241218004932.17">## Figure 1 = simple impulse response

tspan = np.arange(100)
y,t = impulse(sys,T=tspan)
t = np.concatenate((np.arange(-10,0,1),t))
y = np.concatenate((np.zeros((10,1)),y))
u = np.zeros_like(y)
u[10] = 1

</t>
<t tx="ekr.20241218004932.18">plt.step(t,u,'k',linewidth=1.5)
plt.grid()
plt.title('u')
plt.show()

</t>
<t tx="ekr.20241218004932.19">plt.step(t,y,'k',linewidth=1.5)
plt.grid()
plt.title('y')
plt.show()

</t>
<t tx="ekr.20241218004932.2">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from control.matlab import *
import slycot
from scipy import signal,io
import os
from scipy.linalg import fractional_matrix_power

# Python control toolbox available at https://python-control.readthedocs.io/

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})


</t>
<t tx="ekr.20241218004932.20">## FIgure 2 - OKID response

t = np.arange(100)
u = np.zeros_like(t)
u[:50] = np.random.randn(50)
y,t,_ = lsim(sys,u,t)

t = np.concatenate((np.arange(-10,0,1),t))
y = np.concatenate((np.zeros((10,1)),y))
u = np.concatenate((np.zeros(10),u))

</t>
<t tx="ekr.20241218004932.21">plt.step(t,u,'k',linewidth=1.5)
plt.grid()
plt.title('u')
plt.show()

</t>
<t tx="ekr.20241218004932.22">plt.step(t,y,'k',linewidth=1.5)
plt.grid()
plt.title('y')
plt.show()
</t>
<t tx="ekr.20241218004932.23"></t>
<t tx="ekr.20241218004932.24">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.26">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io, signal
import os

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.27">J = lambda u,t: (25-np.power((5-u),2)) 
u = 0
y0 = J(u,0)

</t>
<t tx="ekr.20241218004932.28">## Extremum Seeking Control Parameters
freq = 10*2*np.pi # sample frequency
dt = 1/freq
T = 10 # total period of simulation (in seconds)
A = 0.2 # amplitude
omega = 10*2*np.pi # 10 Hz
phase = 0
K = 5 # Integration gain

</t>
<t tx="ekr.20241218004932.29">## High pass filter (Butterworth filter)
butterorder = 1
butterfreq = 2 # in Hz
butterfreq = butterfreq/(freq/2) # normalize to Nyquist frequency
b,a = signal.butter(butterorder,butterfreq,'highpass')
ys = np.zeros(butterorder+1)+y0
HPF = np.zeros(butterorder+1)

uhat = u
yvals = np.zeros(int(T/dt))
uhats = np.zeros_like(yvals)
uvals = np.zeros_like(yvals)
for ii in range(int(T/dt)):
    t = ii*dt
    yvals[ii] = J(u,t)
    for k in range(butterorder):
        ys[k] = ys[k+1]
        HPF[k] = HPF[k+1]
    ys[butterorder] = yvals[ii]
    HPFnew = 0
    for k in range(butterorder+1):
        HPFnew = HPFnew + b[k]*ys[butterorder-k]
    for k in range(1,butterorder+1):
        HPFnew = HPFnew - a[k]*HPF[butterorder-k]
    
    HPF[butterorder] = HPFnew
    
    xi = HPFnew*np.sin(omega*t + phase)
    uhat = uhat + xi*K*dt
    u = uhat + A*np.sin(omega*t + phase)
    uhats[ii] = uhat
    uvals[ii] = u

</t>
<t tx="ekr.20241218004932.3">q = 2   # Number of inputs
p = 2   # Number of outputs
n = 100 # State dimension
r = 10 # Reduced model order

testSys_mat = io.loadmat(os.path.join('..','DATA','testSys_ABCD.mat'))
A = testSys_mat['A']
B = testSys_mat['B']
C = testSys_mat['C']
D = testSys_mat['D']

sysFull = ss(A,B,C,D,1)

</t>
<t tx="ekr.20241218004932.30">## Figures
tspan = dt*np.arange(int(T/dt))
fig,axs = plt.subplots(2,1)
axs[0].plot(tspan,uvals,linewidth=1.2,label='u')
axs[0].plot(tspan,uhats,linewidth=1.2,label='uhat')
axs[0].legend()
axs[0].grid()

axs[1].plot(tspan,yvals,linewidth=1.2)
axs[1].grid()
axs[1].set_ylim(-1,26)

plt.show()

</t>
<t tx="ekr.20241218004932.31"></t>
<t tx="ekr.20241218004932.32"></t>
<t tx="ekr.20241218004932.33">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.35">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
from scipy import io, signal
import os

plt.rcParams['figure.figsize'] = [8, 8]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.36">J = lambda u,t: (25-np.power((5-u-np.sin(t)),2)) 
u = 0
y0 = J(u,0)

</t>
<t tx="ekr.20241218004932.37">## Extremum Seeking Control Parameters
freq = 100 # sample frequency
dt = 1/freq
T = 100 # total period of simulation (in seconds)
A = 0.2 # amplitude
omega = 10*2*np.pi # 10 Hz
phase = 0
K = 5 # Integration gain

</t>
<t tx="ekr.20241218004932.38">## High pass filter (Butterworth filter)
butterorder = 1
butterfreq = 2 # in Hz
butterfreq = butterfreq/(freq/2) # normalize to Nyquist frequency
b,a = signal.butter(butterorder,butterfreq,'highpass')
ys = np.zeros(butterorder+1)+y0
HPF = np.zeros(butterorder+1)

uhat = u
yvals = np.zeros(int(T/dt))
uhats = np.zeros_like(yvals)
uvals = np.zeros_like(yvals)
for ii in range(int(T/dt)):
    t = ii*dt
    yvals[ii] = J(u,t)
    for k in range(butterorder):
        ys[k] = ys[k+1]
        HPF[k] = HPF[k+1]
    ys[butterorder] = yvals[ii]
    HPFnew = 0
    for k in range(butterorder+1):
        HPFnew = HPFnew + b[k]*ys[butterorder-k]
    for k in range(1,butterorder+1):
        HPFnew = HPFnew - a[k]*HPF[butterorder-k]
    
    HPF[butterorder] = HPFnew
    
    xi = HPFnew*np.sin(omega*t + phase)
    uhat = uhat + xi*K*dt
    u = uhat + A*np.sin(omega*t + phase)
    uhats[ii] = uhat
    uvals[ii] = u

</t>
<t tx="ekr.20241218004932.39">## Figures
tspan = dt*np.arange(int(T/dt))
fig,axs = plt.subplots(2,1)
axs[0].plot(tspan,uvals,linewidth=1.2,label='u')
axs[0].plot(tspan,uhats,linewidth=1.2,label='uhat')
axs[0].legend()
axs[0].grid()

axs[1].plot(tspan,yvals,linewidth=1.2)
axs[1].grid()
axs[1].set_ylim(-1,26)

plt.show()

</t>
<t tx="ekr.20241218004932.4">yFull = np.zeros((r*5+2,p,q))
tspan = np.arange(0,(r*5+2),1)
m = len(tspan)

for qi in range(q):
    yFull[:,:,qi],t = impulse(sysFull,T=tspan,input=qi)


YY = np.transpose(yFull,axes=(1,2,0)) # reorder to size p x q x m


</t>
<t tx="ekr.20241218004932.40"></t>
<t tx="ekr.20241218004932.41"></t>
<t tx="ekr.20241218004932.42">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.44">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams
import os

plt.rcParams['figure.figsize'] = [12, 6]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.45">L = 20
n = 80
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n]
u = np.exp(-np.power(x,2))
u1 = np.exp(-0.1*np.power(x,2))
u2 = np.exp(-10*np.power(x,2))

ut = np.fft.fft(u)
ut1 = np.fft.fft(u1)
ut2 = np.fft.fft(u2)

uts = np.fft.fftshift(ut)
uts1 = np.fft.fftshift(ut1)
uts2 = np.fft.fftshift(ut2)

k = n*(2*np.pi/L)*np.fft.fftfreq(n)
km = n*np.fft.fftfreq(n)

</t>
<t tx="ekr.20241218004932.46">fig,axs = plt.subplots(1,2)
axs[0].plot(x,u2,'b-o')
axs[0].plot(x,u1,'r-o')
axs[0].plot(x,u,'k-o')
axs[0].set_title('u(x)')

axs[1].plot(km,np.abs(ut2)/np.max(np.abs(ut2)),'b-o')
axs[1].plot(km,np.abs(ut1)/np.max(np.abs(ut1)),'r-o')
axs[1].plot(km,np.abs(ut)/np.max(np.abs(ut)),'k-o')
axs[1].set_title('uhat(k)')

plt.show()

</t>
<t tx="ekr.20241218004932.47">ut21 = np.zeros(n,dtype='complex_')
ut22 = np.zeros_like(ut21)
ut23 = np.zeros_like(ut21)

erx = np.zeros(19)
er1 = np.zeros_like(erx)
er2 = np.zeros_like(erx)
er3 = np.zeros_like(erx)

for j in range(19):
    for jj in range(j):
        ut21[(int(n/2)-1-jj) : (int(n/2)+1+jj)] = uts[(int(n/2)-1-jj) : (int(n/2)+1+jj)]
        ut22[(int(n/2)-1-jj) : (int(n/2)+1+jj)] = uts1[(int(n/2)-1-jj) : (int(n/2)+1+jj)]
        ut23[(int(n/2)-1-jj) : (int(n/2)+1+jj)] = uts2[(int(n/2)-1-jj) : (int(n/2)+1+jj)]
    
    ut31 = np.fft.fftshift(ut21)
    ut32 = np.fft.fftshift(ut22)
    ut33 = np.fft.fftshift(ut23)
    
    u31 = np.fft.ifft(ut31)
    u32 = np.fft.ifft(ut32)
    u33 = np.fft.ifft(ut33)
    
    plt.plot(x,np.real(u31),'k')
    
    erx[j] = 2*(j+1)+1
    er1[j] = np.linalg.norm(u-u31)
    er2[j] = np.linalg.norm(u1-u32)
    er3[j] = np.linalg.norm(u2-u33)


</t>
<t tx="ekr.20241218004932.48">plt.semilogy(erx,er3,'b',linewidth=2)
plt.semilogy(erx,er2,'r',linewidth=2)
plt.semilogy(erx,er1,'k',linewidth=2)
plt.ylabel('Error')
plt.xlabel('# of modes')
plt.grid()

plt.show()

</t>
<t tx="ekr.20241218004932.49"></t>
<t tx="ekr.20241218004932.5">## ERA and OKID Function Definitions

def ERA(YY,m,n,nin,nout,r):
    Dr = np.zeros((nout,nin))
    Y = np.zeros((nout,nin,YY.shape[2]-1))
    for i in range(nout):
        for j in range(nin):
            Dr[i,j] = YY[i,j,0]
            Y[i,j,:] = YY[i,j,1:]
            
    assert len(Y[:,1,1]) == nout
    assert len(Y[1,:,1]) == nin
    assert len(Y[1,1,:]) &gt;= m+n
    
    H = np.zeros((nout*m,nin*n))
    H2 = np.zeros((nout*m,nin*n))
    
    for i in range(m):
        for j in range(n):
            for Q in range(nout):
                for P in range(nin):
                    H[nout*i+Q,nin*j+P] = Y[Q,P,i+j]
                    H2[nout*i+Q,nin*j+P] = Y[Q,P,i+j+1]
                    
    U,S,VT = np.linalg.svd(H,full_matrices=0)
    V = VT.T
    Sigma = np.diag(S[:r])
    Ur = U[:,:r]
    Vr = V[:,:r]
    Ar = fractional_matrix_power(Sigma,-0.5) @ Ur.T @ H2 @ Vr @ fractional_matrix_power(Sigma,-0.5)
    Br = fractional_matrix_power(Sigma,-0.5) @ Ur.T @ H[:,:nin]
    Cr = H[:nout,:] @ Vr @ fractional_matrix_power(Sigma,-0.5)
    HSVs = S
    
    return Ar,Br,Cr,Dr,HSVs

def OKID(y,u,r):
    # inputs:  y (sampled output), u (sampled input), r (effective system order)
    # outputs: H (Markov parameters), M (Observer gain)
    
    PP = y.shape[0] # number of outputs
    MM = y.shape[1] # number of output samples
    QQ = u.shape[0] # number of inputs
    lu = u.shape[1] # number of input samples
    
    assert MM == lu
    
    LL = r*5
    
    # Form data matrices y and V
    V = np.zeros((QQ+(QQ+PP)*LL,MM))
    for i in range(MM):
        V[:QQ,i] = u[:QQ,i]
        
    for i in range(1,LL+1):
        for j in range(MM-i):
            vtemp = np.concatenate((u[:,j],y[:,j]))
            V[QQ+(i-1)*(QQ+PP):QQ+i*(QQ+PP),i+j] = vtemp
    
    # Solve for observer Markov parameters Ybar
    Ybar = y @ np.linalg.pinv(V,rcond=10**(-3))
    
    # Isolate system Markov parameters H, and observer gain M
    D = Ybar[:,:QQ] # feed-through term (or D matrix) is the first term
    
    Y = np.zeros((PP,QQ,LL))
    Ybar1 = np.zeros((PP,QQ,LL))
    Ybar2 = np.zeros((PP,QQ,LL))
    
    for i in range(LL):
        Ybar1[:,:,i] = Ybar[:,QQ+(QQ+PP)*i : QQ+(QQ+PP)*i+QQ]
        Ybar2[:,:,i] = Ybar[:,QQ+(QQ+PP)*i+QQ : QQ+(QQ+PP)*(i+1)]
    
    Y[:,:,0] = Ybar1[:,:,0] + Ybar2[:,:,0] @ D
    for k in range(1,LL):
        Y[:,:,k] = Ybar1[:,:,k] + Ybar2[:,:,k] @ D
        for i in range(k-1):
            Y[:,:,k] += Ybar2[:,:,i] @ Y[:,:,k-i-1]
            
    H = np.zeros((D.shape[0],D.shape[1],LL+1))
    H[:,:,0] = D
    
    for k in range(1,LL+1):
        H[:,:,k] = Y[:,:,k-1]
        
    return H


</t>
<t tx="ekr.20241218004932.50">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.52">import numpy as np
import matplotlib.pyplot as plt
from matplotlib.colors import LightSource, Normalize
from matplotlib import rcParams, cm
from scipy import integrate
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [12, 6]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.53">L = 30
n = 512
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n] # Spatial discretization

k = n*(2*np.pi/L)*np.fft.fftfreq(n)
V = np.power(x,2) # potential
t = np.arange(0,20,.2) # time domain collection points


</t>
<t tx="ekr.20241218004932.54">def harm_rhs(ut_split,t,k=k,V=V,n=n):
    ut = ut_split[:n] + (1j)*ut_split[n:]
    u = np.fft.ifft(ut)
    rhs = -0.5*(1j)*np.power(k,2)*ut - 0.5*(1j)*np.fft.fft(V*u)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241218004932.55">u = np.exp(-0.2*np.power(x-1,2)) # initial conditions
ut = np.fft.fft(u) # FFT initial data
ut_split = np.concatenate((np.real(ut),np.imag(ut)))

utsol_split = integrate.odeint(harm_rhs,ut_split,t,mxstep=10**6)
utsol = utsol_split[:,:n] + (1j)*utsol_split[:,n:]

usol = np.zeros_like(utsol)
for jj in range(len(t)):
    usol[jj,:] = np.fft.ifft(utsol[jj,:])

</t>
<t tx="ekr.20241218004932.56">u2 = np.exp(-0.2*np.power(x-0,2)) # initial conditions
ut2 = np.fft.fft(u2) # FFT initial data
ut2_split = np.concatenate((np.real(ut2),np.imag(ut2)))

ut2sol_split = integrate.odeint(harm_rhs,ut2_split,t,mxstep=10**6)
ut2sol = ut2sol_split[:,:n] + (1j)*ut2sol_split[:,n:]

u2sol = np.zeros_like(ut2sol)
for jj in range(len(t)):
    u2sol[jj,:] = np.fft.ifft(ut2sol[jj,:])

</t>
<t tx="ekr.20241218004932.57">ax = Axes3D(plt.figure())
T,X = np.meshgrid(t,x)
light = LightSource(90, 45)
illuminated_surface = light.shade(np.abs(usol.T)+2, cmap=cm.Greys_r)
ax.plot_surface(X, T, np.abs(usol.T)+2, rstride=1, cstride=1,linewidth=0, antialiased=True, \
                facecolors=illuminated_surface,vmin=0)

cmap = plt.cm.Greys_r
norm = Normalize(vmin=np.abs(usol).min(), vmax=np.abs(usol).max())
colors = cmap(norm(np.abs(usol.T)))
ax.plot_surface(X, T, np.zeros_like(X), rstride=1, cstride=1,linewidth=0, antialiased=False, \
                facecolors=colors)

tv = np.zeros_like(x)+20
Vx = np.power(x,2)
ax.plot(x[11:-12],tv[11:-12],Vx[11:-12]/100+2,'k',linewidth=2)
ax.set_title('u (1-centered)')
plt.show()

</t>
<t tx="ekr.20241218004932.58">ax = Axes3D(plt.figure())
T,X = np.meshgrid(t,x)
light = LightSource(90, 45)
illuminated_surface = light.shade(np.abs(u2sol.T)+2, cmap=cm.Greys_r)
ax.plot_surface(X, T, np.abs(u2sol.T)+2, rstride=1, cstride=1,linewidth=0, antialiased=True, \
                facecolors=illuminated_surface,vmin=0)

cmap = plt.cm.Greys_r
norm = Normalize(vmin=np.abs(u2sol).min(), vmax=np.abs(u2sol).max())
colors = cmap(norm(np.abs(u2sol.T)))
ax.plot_surface(X, T, np.zeros_like(X), rstride=1, cstride=1,linewidth=0, antialiased=False, \
                facecolors=colors)

tv = np.zeros_like(x)+20
Vx = np.power(x,2)
ax.plot(x[11:-12],tv[11:-12],Vx[11:-12]/100+2,'k',linewidth=2)
ax.set_title('u2 (0-centered)')
plt.show()

</t>
<t tx="ekr.20241218004932.59">usol3 = np.zeros_like(usol)
for jj in range(len(t)):
    usol3[jj,:] = usol[jj,np.flip(np.arange(n))]
    
usym = np.concatenate((usol,usol3))

U,S,VT = np.linalg.svd(usol.T)
U2,S2,VT2 = np.linalg.svd(u2sol.T)
U3,S3,VT3 = np.linalg.svd(usym.T)

</t>
<t tx="ekr.20241218004932.6">## Compute ERA from impulse response
mco = int(np.floor((yFull.shape[0]-1)/2)) # m_c = m_o = (m-1)/2
Ar,Br,Cr,Dr,HSVs = ERA(YY,mco,mco,q,p,r)
sysERA = ss(Ar,Br,Cr,Dr,1)

</t>
<t tx="ekr.20241218004932.60">plt.plot(100*S/np.sum(S),'ko',linewidth=2)
plt.title('Singular values: u (1-centered)')
plt.show()

</t>
<t tx="ekr.20241218004932.61">plt.plot(100*S2/np.sum(S2),'ko',linewidth=2)
plt.title('Singular values: u2 (0-centered)')
plt.show()

</t>
<t tx="ekr.20241218004932.62">fig,axs = plt.subplots(3,1)
Up = np.zeros((n,5))
for jj in range(5):
    Up[:,jj] = np.real(U[:,jj]/np.linalg.norm(U[:,jj]))
    
[axs[2].plot(x,np.real(Up[:,k]),linewidth=2,label='mode {}'.format(k+1)) for k in range(5)]

Up2 = np.zeros((n,5))
for jj in range(5):
    Up2[:,jj] = np.real(U2[:,jj]/np.linalg.norm(U2[:,jj]))
    
[axs[1].plot(x,np.real(Up2[:,k]),linewidth=2) for k in range(5)]


h = np.array([np.ones_like(x),2*x,4*np.power(x,2),8*np.power(x,3)-12*x,\
             16*np.power(x,4)-48*np.power(x,2)+12])

phi = np.zeros((n,5))
phi2 = np.zeros((n,5))


for jj in range(5):
    phi[:,jj] = (1/(np.sqrt(np.math.factorial(jj)*(2**jj)*np.sqrt(np.pi))) * \
                np.exp(-np.power(x,2)/2)*h[jj,:])
    phi2[:,jj] = phi[:,jj]/np.linalg.norm(phi[:,jj])
    
[axs[0].plot(x,np.real(phi2[:,k]),linewidth=2) for k in range(5)]

for ax in axs:
    ax.set_xlim(-5,5)
    
axs[1].set_ylabel('u2')
axs[2].set_ylabel('u')
axs[2].legend(bbox_to_anchor=(1.03,1.55), loc="upper left")
plt.show()

</t>
<t tx="ekr.20241218004932.63"></t>
<t tx="ekr.20241218004932.64">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.66">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams, cm
from scipy import integrate
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.67">L = 40
n = 512
x2 = np.linspace(-L/2,L/2,n+1)
x = x2[:n] # Spatial discretization

k = n*(2*np.pi/L)*np.fft.fftfreq(n)
t = np.linspace(0,2*np.pi,21) 


</t>
<t tx="ekr.20241218004932.68">def nls_rhs(ut_split,t,k=k):
    ut = ut_split[:n] + (1j)*ut_split[n:]
    u = np.fft.ifft(ut)
    rhs = -0.5*(1j)*np.power(k,2)*ut + (1j)*np.fft.fft(np.power(np.abs(u),2)*u)
    rhs_split = np.concatenate((np.real(rhs),np.imag(rhs)))
    return rhs_split


</t>
<t tx="ekr.20241218004932.69">N = 1
u = N/np.cosh(x)   # initial conditions
ut = np.fft.fft(u) # FFT initial data
ut_split = np.concatenate((np.real(ut),np.imag(ut))) # Separate real/complex pieces

utsol_split = integrate.odeint(nls_rhs,ut_split,t,mxstep=10**6)
utsol = utsol_split[:,:n] + (1j)*utsol_split[:,n:]

usol = np.zeros_like(utsol)
for jj in range(len(t)):
    usol[jj,:] = np.fft.ifft(utsol[jj,:]) # transforming back


</t>
<t tx="ekr.20241218004932.7">## Compute random input simulation for OKID
uRandom = np.random.randn(q,200) # Random forcing input
yRandom = lsim(sysFull,uRandom,range(200))[0].T # Output

</t>
<t tx="ekr.20241218004932.70">N = 2
u2 = N/np.cosh(x)   # initial conditions
ut2 = np.fft.fft(u2) # FFT initial data
ut2_split = np.concatenate((np.real(ut2),np.imag(ut2))) # Separate real/complex pieces

ut2sol_split = integrate.odeint(nls_rhs,ut2_split,t,mxstep=10**6)
ut2sol = ut2sol_split[:,:n] + (1j)*ut2sol_split[:,n:]

u2sol = np.zeros_like(ut2sol)
for jj in range(len(t)):
    u2sol[jj,:] = np.fft.ifft(ut2sol[jj,:]) # transforming back


</t>
<t tx="ekr.20241218004932.71">fig = plt.figure()
axs = [fig.add_subplot(2, 2, k, projection='3d') for k in range(1,5)]

for ax in axs:
    ax.view_init(elev=25, azim=110)


for tt in range(len(t)):
    axs[0].plot(x,t[tt]*np.ones_like(x),np.abs(usol[tt,:]),color='k',linewidth=0.75)
    axs[2].plot(np.fft.fftshift(k),t[tt]*np.ones_like(x), \
                np.abs(np.fft.fftshift(utsol[tt,:])),color='k',linewidth=0.75)
    
    axs[1].plot(x,t[tt]*np.ones_like(x),np.abs(u2sol[tt,:]),color='k',linewidth=0.75)
    axs[3].plot(np.fft.fftshift(k),t[tt]*np.ones_like(x), \
                np.abs(np.fft.fftshift(ut2sol[tt,:])),color='k',linewidth=0.75)

plt.show()

</t>
<t tx="ekr.20241218004932.72">U,S,VT = np.linalg.svd(usol.T)
U2,S2,VT2 = np.linalg.svd(u2sol.T)

</t>
<t tx="ekr.20241218004932.73">plt.rcParams['figure.figsize'] = [12, 6]

fig,axs = plt.subplots(1,2)
axs[0].semilogy(100*S/np.sum(S),'ko',ms=10)
axs[0].semilogy(0,100*S[0]/np.sum(S),'bo',ms=10)
axs[0].semilogy(1,100*S[1]/np.sum(S),'go',ms=10)
axs[0].semilogy(2,100*S[2]/np.sum(S),'ro',ms=10)
axs[0].set_xlim(-1,21)

axs[1].semilogy(100*S2/np.sum(S2),'ko',ms=10)
axs[1].semilogy(0,100*S2[0]/np.sum(S2),'bo',ms=10)
axs[1].semilogy(1,100*S2[1]/np.sum(S2),'go',ms=10)
axs[1].semilogy(2,100*S2[2]/np.sum(S2),'ro',ms=10)
axs[1].set_xlim(-1,21)

plt.show()

</t>
<t tx="ekr.20241218004932.74">color_list = ['b','g','r']
for jj in range(3):
    plt.plot(x,np.real(U[:,jj]),color=color_list[jj],linewidth=2, \
             label='mode {}'.format(jj+1))
plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004932.75">for jj in range(3):
    plt.plot(x,np.real(U2[:,jj]),color=color_list[jj],linewidth=2, \
        label='mode {}'.format(jj+1))
plt.legend()
plt.show()

</t>
<t tx="ekr.20241218004932.76"></t>
<t tx="ekr.20241218004932.77">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.79">import numpy as np
import matplotlib.pyplot as plt
from matplotlib import rcParams, cm
from scipy import integrate
from mpl_toolkits.mplot3d import Axes3D 


plt.rcParams['figure.figsize'] = [12, 12]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.8">## Compute OKID and then ERA
H = OKID(yRandom,uRandom,r)
mco = int(np.floor((H.shape[2]-1)/2)) # m_c = m_o
Ar,Br,Cr,Dr,HSVs = ERA(H,mco,mco,q,p,r)
sysERAOKID = ss(Ar,Br,Cr,Dr,1)

</t>
<t tx="ekr.20241218004932.80">L = 20
n = 100
x = np.linspace(-L,L,n)
y = np.copy(x)

X,Y = np.meshgrid(x,y)

Xd = np.zeros((n**2,n))
for jj in range(n):
    u = np.tanh(np.sqrt(np.power(X,2)+np.power(Y,2))) * \
            np.cos(np.angle(X+(1j)*Y)- \
            np.sqrt(np.power(X,2)+np.power(Y,2)) + \
           (jj+1)/10)
    f = np.exp(-0.01*(np.power(X,2) + np.power(Y,2)))
    uf = u * f
    Xd[:,jj] = uf.reshape(-1)

plt.pcolor(x,y,uf,cmap='hot')
plt.show()

</t>
<t tx="ekr.20241218004932.81">U,S,VT = np.linalg.svd(Xd,full_matrices=0)
V = VT.T

plt.rcParams['figure.figsize'] = [12, 6]

[plt.plot(V[:,k],linewidth=2,label='mode {}'.format(k+1)) for k in range(4)]

plt.legend(loc='lower right')
plt.show()

</t>
<t tx="ekr.20241218004932.82">fig, axs = plt.subplots(2,1)
axs[0].plot(100*S/np.sum(S),'ko',ms=10)
axs[0].set_ylabel('Singular Values')
axs[1].semilogy(100*S/np.sum(S),'ko',ms=10)
axs[1].set_ylabel('Singular Values (log)')

for ax in axs:
    ax.set_xlim(-1,40)

plt.show()

</t>
<t tx="ekr.20241218004932.83">plt.rcParams['figure.figsize'] = [12, 12]
fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

for jj in range(4):
    mode = np.reshape(U[:,jj],(n,n))
    axs[jj].pcolor(X,Y,mode,cmap='gray')
    axs[jj].axis(False)


</t>
<t tx="ekr.20241218004932.84">u = np.tanh(np.sqrt(np.power(X,2)+np.power(Y,2))) * \
            np.cos(np.angle(X+(1j)*Y)- \
            np.sqrt(np.power(X,2)+np.power(Y,2)))
f = np.exp(-0.01*(np.power(X,2)+np.power(Y,2)))
uf = u*f

plt.rcParams['figure.figsize'] = [12,4]
fig,axs = plt.subplots(1,3)
axs[0].pcolor(x,y,uf,cmap='gray')
axs[1].pcolor(x,y,np.abs(uf),cmap='gray')
axs[2].pcolor(x,y,np.power(uf,5),cmap='gray')

for ax in axs:
    ax.axis(False)

</t>
<t tx="ekr.20241218004932.85">## Translation
n = 200
L = 20
x = np.linspace(-L,L,n) # space
y = np.copy(x)
m = 41
T = 10
t = np.linspace(0,T,m) # time
c = 3 # wave speed

X = np.zeros((n,m))
for jj in range(m):
    X[:,jj] = np.exp(-np.power(x+15-c*t[jj],2))
    
U,S,VT = np.linalg.svd(X)
V = VT.T

</t>
<t tx="ekr.20241218004932.86">plt.rcParams['figure.figsize'] = [12,12]
fig = plt.figure()
ax = fig.add_subplot(1,1,1,projection='3d')
ax.view_init(elev=70, azim=-70)

for jj in range(m):
    ax.plot(x,t[jj]*np.ones_like(x),X[:,jj],'k',linewidth=0.75)

</t>
<t tx="ekr.20241218004932.87">U2,S2,V2T = np.linalg.svd(X)
V2 = V2T.T

fig, axs = plt.subplots(2,1)
axs[0].plot(100*S2/np.sum(S2),'ko',ms=10)
axs[0].set_ylabel('Singular Values')
axs[1].semilogy(100*S2/np.sum(S2),'ko',ms=10)
axs[1].set_ylabel('Singular Values (log)')

for ax in axs:
    ax.set_xlim(-1,40)

plt.show()

</t>
<t tx="ekr.20241218004932.88"></t>
<t tx="ekr.20241218004932.89"></t>
<t tx="ekr.20241218004932.9">## Plot impulse responses for all methods

y1 = np.zeros((200,p,q))
y2 = np.zeros((100,p,q))
y3 = np.zeros((100,p,q))

for qi in range(q):
    y1[:,:,qi],t1 = impulse(sysFull,np.arange(200),input=qi)
    y2[:,:,qi],t2 = impulse(sysERA,np.arange(100),input=qi)
    y3[:,:,qi],t3 = impulse(sysERAOKID,np.arange(100),input=qi)

    


fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)

axs[0].step(t1,y1[:,0,0],linewidth=2)
axs[0].step(t2,y2[:,0,0],linewidth=1.2)
axs[0].step(t3,y3[:,0,0],linewidth=1)
axs[0].set_ylabel('y1')
axs[0].set_title('u1')

axs[1].step(t1,y1[:,0,1],linewidth=2)
axs[1].step(t2,y2[:,0,1],linewidth=1.2)
axs[1].step(t3,y3[:,0,1],linewidth=1)
axs[1].set_title('u2')

axs[2].step(t1,y1[:,1,0],linewidth=2)
axs[2].step(t2,y2[:,1,0],linewidth=1.2)
axs[2].step(t3,y3[:,1,0],linewidth=1)
axs[2].set_ylabel('y2')

axs[3].step(t1,y1[:,1,1],linewidth=2,label='Full model, n=100')
axs[3].step(t2,y2[:,1,1],linewidth=1.2,label='ERA, r={}'.format(r))
axs[3].step(t3,y3[:,1,1],linewidth=1,label='ERA/OKID, r={}'.format(r))
axs[3].legend(prop={'size': 12})

for ax in axs:
    ax.set_xlim(0,60)

plt.show()

</t>
<t tx="ekr.20241218004932.90">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218004932.92">import numpy as np
from scipy.sparse import linalg
import matplotlib.pyplot as plt
from matplotlib import rcParams


plt.rcParams['figure.figsize'] = [12,6]
plt.rcParams.update({'font.size': 18})

</t>
<t tx="ekr.20241218004932.93">L = 10 # define domain
x2 = np.arange(-L,L,0.1) 
n = len(x2)
k = n*(2*np.pi/(2*L))*np.fft.fftfreq(n) # k-vector
ye = np.exp(-np.power(x2,2))
ye2 = np.exp(np.power(x2,2)/2) # define Gaussians

y = np.zeros((n,10))

for jj in range(10): # loop through 10 modes
    # 2nd derivative
    yd = np.real(np.fft.ifft((np.power((1j)*k,jj))*np.fft.fft(ye)))
    
    mode = np.power(-1,jj) * \
        np.power((np.power(2,jj)*np.math.factorial(jj)*np.sqrt(np.pi)),-0.5) * \
        ye2 * yd
            
    y[:,jj] = mode # store modes as columns
            
x = x2[int(n/2)-40 : int(n/2)+41] # keep only -4&lt;x&lt;4
yharm = y[int(n/2)-40 : int(n/2)+41,:]

plt.pcolor(np.flipud(np.rot90(yharm)),cmap='hot')
plt.axis(False)
plt.show()

</t>
<t tx="ekr.20241218004932.94">plt.rcParams['figure.figsize'] = [12,12]
fig, axs = plt.subplots(3,1)

n = len(x)
f = np.exp(-np.power(x-0.5,2)) + 3*np.exp(-2*np.power(x+1.5,2))
axs[0].plot(x,f,'k')
Err = np.zeros(4)

a = np.zeros(10)

for jj in range(10):
    a[jj] = np.trapz(f*yharm[:,jj],x)

f2 = yharm @ a
axs[0].plot(x,f2,'r')
Err[0] = np.linalg.norm(f2-f) # recontruction error
    
M = np.zeros((10,10))

for jj in range(10): # matrix M reconstruction
    for kk in range(jj+1):
        Area = np.trapz(yharm[:,jj]*yharm[:,kk],x)
        M[jj,kk] = Area
        M[kk,jj] = Area
        
print('Conditioning number of M: {}'.format(np.linalg.cond(M)))

color_list = ['g','m','b']
MJ = np.zeros((10,10,3))
condJ = np.zeros(3)
sJ = np.zeros((3,n))
for jloop in range(3):
    s = (np.random.rand(n) &gt; 0.8) # grab 20% random measurements
    sJ[jloop,:] = s
    # construct M_j
    M2 = np.zeros((10,10))
    for jj in range(10):
        for kk in range(jj+1):
            Area = np.trapz(s*yharm[:,jj]*yharm[:,kk],x)
            M2[jj,kk] = Area
            M2[kk,jj] = Area
    MJ[:,:,jloop] = M2
    condJ[jloop] = np.linalg.cond(M2)
    print('Conditioning number of M{}: {}'.format((jloop+1),np.linalg.cond(M2)))

    
    ftild = np.zeros(10)
    for jj in range(10): # reconstruction using gappy
        ftild[jj] = np.trapz(s*f*yharm[:,jj],x)
    
    atild = np.linalg.solve(M2,ftild) # compute error
    f2 = yharm @ atild
    axs[0].plot(x,f2,color=color_list[jloop])
    Err[jloop+1] = np.linalg.norm(f2-f)
    
con2 = np.concatenate(([1],condJ))
axs[1].bar(range(len(con2)),np.log(con2)+1)
axs[2].bar(range(len(Err)),Err)

for ax in axs:
    ax.set_xticklabels([''])
    ax.set_yticklabels([''])

plt.show()

</t>
<t tx="ekr.20241218004932.95">plt.rcParams['figure.figsize'] = [12,12]
fig,axs = plt.subplots(4,1)
axs[0].pcolor(x,range(10),np.flipud(np.rot90(yharm)),cmap='hot')
for jloop in range(3):
    axs[jloop+1].bar(x,sJ[jloop,:],align='edge', width=0.05)
    axs[jloop+1].set_xlim(x[0],x[-1])
for ax in axs:
    ax.axis(False)
plt.show()

</t>
<t tx="ekr.20241218004932.96">fig,axs = plt.subplots(2,2)
axs = axs.reshape(-1)
axs[0].pcolor(np.arange(10,0,-1),np.arange(0,10),M.T,cmap='hot')

for jloop in range(3):
    axs[jloop+1].pcolor(np.arange(10,0,-1),np.arange(0,10),np.squeeze(MJ[:,:,jloop]).T,cmap='hot')
    
for ax in axs:
    ax.axis(False)

</t>
<t tx="ekr.20241218004932.97">plt.rcParams['figure.figsize'] = [12,6]
L = 4
x = np.arange(-L,L+0.1,0.1)
n = len(x)
dx = x[1]-x[0]
A = np.zeros((n-2,n-2))
for jj in range(n-2):
    A[jj,jj] = -2 -(dx**2)*x[jj+1]**2
    
for jj in range(n-3):
    A[jj+1,jj] = 1
    A[jj,jj+1] = 1
    
A[0,0] = A[0,0]+4/3
A[0,1] = A[0,1]-1/3
A[-1,-1] = A[-1,-1]+4/3
A[-1,-2] = A[-1,-2]-1/3

D, V3 = linalg.eigs(-A,10,which='SR') # 10 eigenvalues with the smallest real parts

V2 = np.row_stack(((4/3)*V3[0,:]-(1/3)*V3[1,:] , V3 , (4/3)*V3[-1,:]-(1/3)*V3[-2,:]))
V = np.zeros_like(V2)

for jj in range(10):
    V[:,jj] = V2[:,jj]/np.sqrt(np.trapz(np.power(V2[:,jj],2),x))
    
sort_ind = np.argsort(D/dx**2)
Esolb = D[sort_ind]/dx**2

ysolb = np.zeros_like(V)

for jj in range(10):
    ysolb[:,jj] = V[:,sort_ind[jj]]
    
plt.pcolor(-np.real(np.flipud(np.rot90(ysolb))),cmap='hot')
plt.axis(False)
plt.show()

</t>
<t tx="ekr.20241218004932.98"></t>
<t tx="ekr.20241218004932.99">@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20241218050405.2">class PlotWindow(QWidget):
    def __init__(self):
        super().__init__()
        self.canvas = FigureCanvas()
        self.toolbar = NavigationToolbar(self.canvas, self)

        self.button = QPushButton('Plot')
        self.button.clicked.connect(self.plotdemo)

        layout = QVBoxLayout(self)
        layout.addWidget(self.toolbar)
        layout.addWidget(self.canvas)
        layout.addWidget(self.button)
        self.setLayout(layout)
        self.setStyleSheet('* {background: lightgrey;}')

    def plotfig(self, fig):
        self.canvas.figure = fig
        self.canvas.draw()

    def plotdemo(self):
        """Generate and plot some data.
        
        Cycles through curve type and color
        randomly. Adapted from 
        https://plotnine.readthedocs.io/en/stable/tutorials/miscellaneous-a-pyqt5-application.html
        """
        n = 100
        x = np.linspace(0, 2 * np.pi, n)
        y1 = np.sin(x)
        y2 = np.random.rand(n)
        y3 = np.cos(x) * np.sin(x)

        # change the dependent variable and color each time this method is called
        y = random.choice([y1, y2, y3])
        color = random.choice(['blue', 'red', 'green', 'cyan'])

        plt.plot(x, y, color)
        fig = plt.gcf()
        self.plotfig(fig)
        fig.clear()
</t>
<t tx="ekr.20241218050405.3">"""Create, show, or hide Plot9 tab in Log pane."""

&lt;&lt; PlotWindow imports &gt;&gt;
@others  # Define PlotWindow class.

log = c.frame.log
TABNAME = 'Pyplot'
WIDGET_NAME = f'{TABNAME}-widget'
VISIBLE = f'{TABNAME}-visible'

if log.contentsDict.get(VISIBLE, False):
    log.deleteTab(TABNAME)
    log.contentsDict[VISIBLE] = False
    log.contentsDict[WIDGET_NAME] = None
else:
    # Create our widget and embed it in a tab
    w = PlotWindow()
    log.createTab(TABNAME, widget = w, createText = False)
    log.selectTab(TABNAME)
    log.contentsDict[VISIBLE] = True
    log.contentsDict[WIDGET_NAME] = w
</t>
<t tx="ekr.20241218050659.1">import random
import numpy as np

from matplotlib.backends.qt_compat import QtWidgets
from matplotlib.backends.backend_qtagg import (
    FigureCanvas, NavigationToolbar2QT as NavigationToolbar)
from matplotlib import pyplot as plt

QApplication = QtWidgets.QApplication
QPushButton = QtWidgets.QPushButton
QDialog = QtWidgets.QDialog
QVBoxLayout = QtWidgets.QVBoxLayout
QWidget = QtWidgets.QWidget
</t>
<t tx="ekr.20241223020730.10">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;style&gt;
ul.leo-tree-example  {
    background-color: #ffffec;
    zoom: 150%; # blurs icons a bit.
}
ul.leo-tree-example li {
    background-repeat: no-repeat;
    background-position: 0px 5px;
    padding-left: 27px;
}
li {
    background-image:
url('https://raw.github.com/vivainio/leo/master/leo/Icons/box00.GIF');
    background-repeat: no-repeat;
    background-position: 0px 5px;
    padding-left: 27px;
}
li.selected {
    background-color: lightgrey;
}
li.leaf {
    list-style-type: none;
}
li.plus {
  list-style-image: url('http://leoeditor.com/plusnode.gif')
}
li.minus {
  list-style-image: url('http://leoeditor.com/minusnode.gif')
}
li.leaf {
  background-image: url('http://leoeditor.com/box00.GIF')
}
li.body {
  background-image: url('http://leoeditor.com/box01.GIF')
}
li.mark {
  background-image: url('http://leoeditor.com/box02.GIF')
}
li.mark-body {
  background-image: url('http://leoeditor.com/box03.GIF')
}
li.clone {
  background-image: url('http://leoeditor.com/box04.GIF')
}
li.clone-body {
  background-image: url('http://leoeditor.com/box05.GIF')
}
li.clone-mark {
  background-image: url('http://leoeditor.com/box06.GIF')
}
li.clone-mark-body {
  background-image: url('http://leoeditor.com/box07.GIF')
}
li.dirty {
  background-image: url('http://leoeditor.com/box08.GIF')
}
li.dirty-body {
  background-image: url('http://leoeditor.com/box09.GIF')
}
li.dirty-mark {
  background-image: url('http://leoeditor.com/box10.GIF')
}
li.dirty-mark-body {
  background-image: url('http://leoeditor.com/box11.GIF')
}
li.dirty-clone {
  background-image: url('http://leoeditor.com/box12.GIF')
}
li.dirty-clone-body {
  background-image: url('http://leoeditor.com/box13.GIF')
}
li.dirty-clone-mark {
  background-image: url('http://leoeditor.com/box14.GIF')
}
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;ul class="leo-tree-example"&gt;
&lt;li class='plus clone-mark'&gt;
test
&lt;/li&gt;
&lt;ul&gt;
  &lt;li class='plus clone-body'&gt;
  child
  &lt;/li&gt;
  &lt;ul&gt;
    &lt;li class='leaf body'&gt;
    grandchild
    &lt;/li&gt;
  &lt;/ul&gt;
  &lt;li class='plus clone-body'&gt;
  child
  &lt;/li&gt;
  &lt;ul&gt;
    &lt;li class='leaf body'&gt;
    grandchild
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/ul&gt;
&lt;/ul&gt;
&lt;/body&gt;
&lt;/html&gt;</t>
<t tx="ekr.20241223020730.11">@language html

&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;
&lt;!--@+leo-ver=5-thin--&gt;
&lt;!--@+node:ekr.20100808060203.4273: * @thin html/front.html--&gt;
&lt;!--@@first--&gt;
&lt;!--@@first--&gt;

&lt;!--@@language html--&gt;
&lt;!--@@tabwidth -2--&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
&lt;head&gt;
    &lt;!--@+&lt;&lt; head &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4274: ** &lt;&lt; head &gt;&gt;--&gt;
    &lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8" /&gt;

    &lt;title&gt;Leo's Home Page&lt;/title&gt;
    &lt;link rel="stylesheet" href="_static/default.css" type="text/css" /&gt;
    &lt;link rel="stylesheet" href="_static/silver_city.css" type="text/css" /&gt;
    &lt;!--
    &lt;script type="text/javascript"&gt;
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '4.7-final',
        COLLAPSE_MODINDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    &lt;/script&gt;
    --&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/jquery.js"&gt;&lt;/script&gt;--&gt;
    &lt;!-- &lt;script type="text/javascript" src="_static/doctools.js"&gt;&lt;/script&gt;--&gt;
    &lt;link rel="top" title="Leo v4.7-final documentation" href="index.html" /&gt;
    &lt;link rel="Users Guide" title="Leo&amp;#8217;s Users Guide" href="leo_toc.html" /&gt;
    &lt;!-- &lt;link rel="prev" title="Chapter 5: Using Leos Commands" href="commands.html" /&gt;--&gt; 
    &lt;!--@-&lt;&lt; head &gt;&gt;--&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;!--@+&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4276: ** &lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             accesskey="I"&gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             accesskey="N"&gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             accesskey="P"&gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt;

      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div top nav &gt;&gt;--&gt;
    &lt;div class="document"&gt;
      &lt;div class="documentwrapper"&gt;
        &lt;div class="bodywrapper"&gt;
          &lt;div class="body"&gt;
            &lt;!--@+&lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;!--@+node:ekr.20100808060203.4286: ** &lt;&lt; div outer section &gt;&gt;--&gt;
            &lt;div class="section" id="Leo&amp;#8217;s Home page"&gt;

                &lt;h1&gt;Leo&amp;#8217;s Home Page&lt;/h1&gt;

                Leo is...

                &lt;!--@+&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!--@+node:ekr.20100808060203.4288: *3* &lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;li&gt;
                    An outline-oriented &lt;i&gt;browser&lt;/i&gt; and &lt;i&gt;project manager&lt;/i&gt; that organizes&lt;br&gt;
                    programs, web sites, URL's, pictures, movies or any other kind of data.&lt;br&gt;
                    You can organize your data in as many ways as you like within a &lt;i&gt;single&lt;/i&gt; outline.&lt;/li&gt;
                &lt;li&gt;
                    A &lt;i&gt;programmer's editor&lt;/i&gt; that fully integrates outline structure with programming.
                    &lt;!--
                    &lt;a HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/a&gt; and
                    &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt; markup.&lt;/li&gt;
                    --&gt;
                &lt;li&gt;
                    &lt;i&gt;Fully scriptable&lt;/i&gt; using &lt;a HREF="http://www.python.org/"&gt;Python&lt;/a&gt;.
                    Leo's core is 100% pure Python.&lt;/li&gt;
                &lt;li&gt;
                    &lt;i&gt;Portable&lt;/i&gt;. Leo runs on Windows, Linux and MacOS X.&lt;br&gt;
                    Leo requires either the
                    &lt;a HREF="http://docs.python.org/library/tkinter.html"&gt;Tkinter&lt;/a&gt; or
                    &lt;a HREF="http://www.riverbankcomputing.co.uk/software/pyqt/intro"&gt;PyQt&lt;/a&gt; widget set.&lt;br&gt;
                    Leo's outline files are &lt;a HREF="http://www.w3.org/XML/"&gt;XML&lt;/a&gt; format.&lt;/li&gt;
                &lt;li&gt;
                    &lt;a href="http://www.opensource.org/"&gt;&lt;i&gt;Open Software&lt;/i&gt;&lt;/a&gt;,
                    distributed under the
                    &lt;a href="http://www.opensource.org/licenses/mit-license.php/"&gt;MIT License&lt;/a&gt;.&lt;/li&gt;
                &lt;!--@-&lt;&lt; what is Leo list &gt;&gt;--&gt;
                &lt;!-- div body toc --&gt;
                &lt;!-- &lt; &lt; inner sections &gt; &gt; --&gt;

                &lt;p&gt;Leo has an active community of helpful users and developers.&lt;br&gt;
                Please use the &lt;a href="http://groups.google.com/group/leo-editor"&gt;leo-editor&lt;/a&gt;
                group to ask questions and make suggestions.&lt;/p&gt;

                &lt;p&gt;Leo's author is &lt;a HREF="ekr.html"&gt;Edward K. Ream&lt;/a&gt;&lt;/p&gt;

            &lt;/div&gt;
            &lt;!--@-&lt;&lt; div outer section &gt;&gt;--&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@+&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;!--@+node:ekr.20100808060203.4282: ** &lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="sphinxsidebar"&gt;
          &lt;div class="sphinxsidebarwrapper"&gt;
              &lt;!--@+&lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;!--@+node:ekr.20100808060203.4283: *3* &lt;&lt; sidebar contents &gt;&gt;--&gt;
              &lt;p class="logo"&gt;&lt;a href="leo_toc.html"&gt;
                &lt;img class="logo" src="_static/Leo4-80-border.jpg" alt="Logo"/&gt;&lt;/a&gt;&lt;/p&gt;

              &lt;a class="reference external" href="intro.html"&gt;
                Read this tutorial first&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;
                Another tutorial&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http:screen-shots.html"&gt;
                Screen shots of Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="testimonials.html"&gt;
                Quotes from Leo&amp;#8217;s Users&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external"
                href="http://sourceforge.net/project/showfiles.php?group_id=3458&amp;amp;package_id=29106"&gt;
                Download Leo&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://groups.google.com/group/leo-editor"&gt;
                leo-editor: Google Groups&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://launchpad.net/leo-editor"&gt;
                leo-editor: Launchpad&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://leo.zwiki.org"&gt;
                Leo&amp;#8217;s Wiki&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="http://www.mind-mapping.org/"&gt;
                Mind Mapping&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="leoLinks.html"&gt;
                More links...&lt;/a&gt;&lt;br&gt;

              &lt;!-- &lt;a class="reference external"  href="install.html"&gt;Installing Leo&lt;/a&gt;&lt;br&gt;--&gt; 
              &lt;!-- &lt;a class="reference external"  href="intro.html"&gt;Beginners Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="leo_toc.html"&gt;Users Guide&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- &lt;a class="reference external"  href="FAQ.html"&gt;FAQ&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!--Leo&amp;#8217;s &lt;a class="reference external" href="http://www.greygreen.org/leo/"&gt;Daily snapshots&lt;/a&gt;&lt;br&gt;--&gt;
              &lt;!-- 
              &lt;h5&gt;Edward K. Ream&lt;/h5&gt;
              &lt;a class="reference external" href="ekr.html"&gt;Home&lt;/a&gt;&lt;br&gt;
              &lt;a class="reference external" href="mailto:edreamleo@gmail.com"&gt;Contact&lt;/a&gt;&lt;br&gt;
              --&gt; 
              &lt;!--@-&lt;&lt; sidebar contents &gt;&gt;--&gt;
          &lt;!-- &lt; &lt; sidebar links &gt; &gt; --&gt;
          &lt;!-- &lt; &lt; searchbox &gt; &gt; --&gt;
          &lt;/div&gt;
      &lt;/div&gt;
      &lt;!--@-&lt;&lt; sidebar &gt;&gt;--&gt;
      &lt;div class="clearer"&gt;&lt;/div&gt;
    &lt;/div&gt;
    &lt;!--@+&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4277: ** &lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;div class="related"&gt;
      &lt;h3&gt;Navigation&lt;/h3&gt;
      &lt;ul&gt;
        &lt;li class="right" style="margin-right: 10px"&gt;
          &lt;a href="genindex.html" title="General Index"
             &gt;index&lt;/a&gt;&lt;/li&gt;
        &lt;li class="right" &gt;
          &lt;a href="leo_toc.html" title="Leo&amp;#8217;s Users Guide"
             &gt;contents&lt;/a&gt; |&lt;/li&gt;
        &lt;!--
        &lt;li class="right" &gt;
          &lt;a href="commands.html" title="Chapter 5: Using Leo&amp;#8217;s Commands"
             &gt;previous&lt;/a&gt; |&lt;/li&gt;
        --&gt;
        &lt;li&gt;&lt;a href="leo_toc.html"&gt;Leo v4.7-final documentation&lt;/a&gt; &amp;raquo;&lt;/li&gt; 
      &lt;/ul&gt;
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div bottom nav &gt;&gt;--&gt;
    &lt;!--@+&lt;&lt; div footer &gt;&gt;--&gt;
    &lt;!--@+node:ekr.20100808060203.4278: ** &lt;&lt; div footer &gt;&gt;--&gt;
    &lt;div class="footer"&gt;
      &amp;copy; Copyright 2010, Edward K. Ream.
      Last updated on Aug 08, 2010.
      Created using &lt;a href="http://sphinx.pocoo.org/"&gt;Sphinx&lt;/a&gt; 0.6.3.
    &lt;/div&gt;
    &lt;!--@-&lt;&lt; div footer &gt;&gt;--&gt;
  &lt;/body&gt;
&lt;/html&gt;
&lt;!--@-leo--&gt;
</t>
<t tx="ekr.20241223020730.12"></t>
<t tx="ekr.20241223020730.13">C:\Repos\leo-editor\leo\Icons\LeoLogo.svg

@language rest
@wrap
</t>
<t tx="ekr.20241223020730.14"></t>
<t tx="ekr.20241223020730.15">Leosplash.GIF
</t>
<t tx="ekr.20241223020730.16"></t>
<t tx="ekr.20241223020730.17">#
# a bar plot with errorbars
N = 5
menMeans = (20, 35, 30, 35, 27)
menStd = (2, 3, 4, 1, 2)
ind = np.arange(N)  # the x locations for the groups
width = 0.35       # the width of the bars
fig, ax = plt.subplots()
rects1 = ax.bar(ind, menMeans, width, color='r', yerr=menStd)
womenMeans = (25, 32, 34, 20, 25)
womenStd = (3, 5, 2, 3, 3)
rects2 = ax.bar(ind + width, womenMeans, width, color='y', yerr=womenStd)
# add some text for labels, title and axes ticks
ax.set_ylabel('Scores')
ax.set_title('Scores by group and gender')
ax.set_xticks(ind + width)
ax.set_xticklabels(('G1', 'G2', 'G3', 'G4', 'G5'))
ax.legend((rects1[0], rects2[0]), ('Men', 'Women'))

def autolabel(rects):
    # attach some text labels
    for rect in rects:
        height = rect.get_height()
        ax.text(rect.get_x() + rect.get_width()/2., 1.05*height,
                '%d' % int(height),
                ha='center', va='bottom')

autolabel(rects1)
autolabel(rects2)
</t>
<t tx="ekr.20241223020730.18"># http://matplotlib.org/1.5.1/examples/animation/basic_example.html

def update_line(num, data, line):
        line.set_data(data[..., :num])
        return line, # a tuple.

fig1 = plt.figure()
data = np.random.rand(2, 100) ### 2, 25)
# g.printObj(data)
l, = plt.plot([], [], 'r-')
plt.xlim(0, 1)
plt.ylim(0, 1)
plt.xlabel('x')
plt.title('test')
line_ani = animation.FuncAnimation(fig1, update_line, 25,
    fargs=(data, l), interval=50, blit=True)
# Retain a reference to animation.
g.app.permanentScriptDict['pyplot_animations'] = animation

</t>
<t tx="ekr.20241223020730.19"># http://matplotlib.org/1.5.1/examples/animation/basic_example.html

fig2 = plt.figure()
x = np.arange(-9, 10)
y = np.arange(-9, 10).reshape(-1, 1)
base = np.hypot(x, y)
images = []
for add in np.arange(15):
    images.append((plt.pcolor(x, y, base + add, norm=plt.Normalize(0, 30)),))
animation = animation.ArtistAnimation(fig2, images,
    interval=50,
    repeat_delay=30,
    blit=True)
# Retain a reference to animation.
g.app.permanentScriptDict['pyplot_animations'] = animation
</t>
<t tx="ekr.20241223020730.20"># http://matplotlib.org/1.5.1/examples/animation/animate_decay.html
# import numpy as np
# import matplotlib.pyplot as plt
# import matplotlib.animation as animation

@others

# global data.
fig, ax = plt.subplots()
line, = ax.plot([], [], lw=2)
ax.grid()
xdata, ydata = [], []
animation = animation.FuncAnimation(
    fig, run, data_gen, blit=False, interval=10,
    repeat=False, init_func=init,
    cache_frame_data=False,
)
# Retain a reference to animation.
g.app.permanentScriptDict['pyplot_animations'] = animation
</t>
<t tx="ekr.20241223020730.21">def data_gen(t=0):
    for n in range(500): # n not used.
        t += 0.1
        yield t, np.sin(2*np.pi*t) * np.exp(-t/10.0)
</t>
<t tx="ekr.20241223020730.22">def init():
    ax.set_ylim(-1.1, 1.1)
    ax.set_xlim(0, 10)
    del xdata[:]
    del ydata[:]
    line.set_data(xdata, ydata)
    return line,
</t>
<t tx="ekr.20241223020730.23">def run(data):
    # update the data
    t, y = data
    xdata.append(t)
    ydata.append(y)
    xmin, xmax = ax.get_xlim()
    if t &gt;= xmax:
        ax.set_xlim(xmin, 2*xmax)
        ax.figure.canvas.draw()
    line.set_data(xdata, ydata)
    return line,
</t>
<t tx="ekr.20241223020730.24">x1 = np.linspace(0.0, 5.0)
x2 = np.linspace(0.0, 2.0)
y1 = np.cos(2 * np.pi * x1) * np.exp(-x1)
y2 = np.cos(2 * np.pi * x2)
# Grpah 1.
plt.subplot(2, 1, 1)
plt.plot(x1, y1, 'ko-')
plt.title('A tale of 2 subplots')
plt.ylabel('Damped oscillation')
# Graph 2.
plt.subplot(2, 1, 2)
plt.plot(x2, y2, 'r.-')
plt.xlabel('time (s)')
plt.ylabel('Undamped')</t>
<t tx="ekr.20241223020730.25"></t>
<t tx="ekr.20241223020730.26">@nocolor-node
&lt;?xml version="1.0" standalone="no"?&gt;
&lt;!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.0//EN" "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd"&gt;
&lt;svg width="20cm" height="15cm" viewBox="0 0 800 600"
     xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlik/"
     baseProfile="tiny" version="1.2"&gt;
   &lt;title&gt;Spheres&lt;/title&gt;
   &lt;desc&gt;Semi-transparent bubbles on a colored background.&lt;/desc&gt;
     &lt;defs&gt;
       &lt;!-- Create radial gradients for each bubble. --&gt;
       &lt;radialGradient id="blueBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#cdcdff" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#cdaacd" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="redBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#ffcdcd" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#bbbb99" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="greenBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#cdffcd" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#99aaaa" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="yellowBubble" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" stop-opacity="1" /&gt;
         &lt;stop offset="25%" stop-color="#ffffcd" stop-opacity=".65" /&gt;
         &lt;stop offset="100%" stop-color="#bbbbaa" stop-opacity=".75" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="background" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="400" fx="250" fy="250"&gt;
         &lt;stop offset="0%" stop-color="#ffffee" /&gt;
         &lt;stop offset="100%" stop-color="#ccccaa" /&gt;
       &lt;/radialGradient&gt;
       &lt;linearGradient id="surface" gradientUnits="userSpaceOnUse"
                       x1="-100" y1="200" x2="400" y2="200"&gt;
         &lt;stop offset="0%" stop-color="#ffffcc" /&gt;
         &lt;stop offset="100%" stop-color="#bbbb88" /&gt;
       &lt;/linearGradient&gt;

       &lt;!-- Create radial gradients for each circle to make them look like
            spheres. --&gt;
       &lt;radialGradient id="blueSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="blue" /&gt;
         &lt;stop offset="100%" stop-color="#222244" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="redSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="red" /&gt;
         &lt;stop offset="100%" stop-color="#442222" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="greenSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="green" /&gt;
         &lt;stop offset="100%" stop-color="#113311" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="yellowSphere" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="-50"&gt;
         &lt;stop offset="0%" stop-color="white" /&gt;
         &lt;stop offset="75%" stop-color="yellow" /&gt;
         &lt;stop offset="100%" stop-color="#444422" /&gt;
       &lt;/radialGradient&gt;
       &lt;radialGradient id="shadowGrad" gradientUnits="userSpaceOnUse"
                       cx="0" cy="0" r="100" fx="-50" fy="50"&gt;
         &lt;stop offset="0%" stop-color="black" stop-opacity="1.0" /&gt;
         &lt;stop offset="100%" stop-color="black" stop-opacity="0.0" /&gt;
       &lt;/radialGradient&gt;

       &lt;!-- Define a shadow for each sphere. --&gt;
       &lt;circle id="shadow" fill="url(#shadowGrad)" cx="0" cy="0" r="100" /&gt;
       &lt;g id="bubble"&gt;
         &lt;circle fill="black" cx="0" cy="0" r="50" /&gt;
         &lt;circle fill="#a6ce39" cx="0" cy="0" r="33" /&gt;
         &lt;path fill="black" d="M 37,50 L 50,37 L 12,-1 L 22,-11 L 10,-24 L -24,10
                               L -11,22 L -1,12 Z" /&gt;
         &lt;circle cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/defs&gt;
   &lt;g&gt;
     &lt;rect fill="url(#background)" x="0" y="0" width="800" height="600" /&gt;
   &lt;/g&gt;

   &lt;g transform="translate(200,700)"&gt;
     &lt;use xlink:href="#bubble" fill="url(#blueBubble)" /&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="1s" dur="10s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(315,700)"&gt;
     &lt;g transform="scale(0.5,0.5)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#redBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="3s" dur="7s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(80,700)"&gt;
     &lt;g transform="scale(0.65,0.65)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#greenBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="5s" dur="9s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(255,700)"&gt;
     &lt;g transform="scale(0.3,0.3)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#yellowBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="2s" dur="6s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(565,700)"&gt;
     &lt;g transform="scale(0.4,0.4)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#blueBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="4s" dur="8s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(715,700)"&gt;
     &lt;g transform="scale(0.6,0.6)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#redBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="1s" dur="4s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(645,700)"&gt;
     &lt;g transform="scale(0.375,0.375)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#greenBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="0s" dur="11s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(555,700)"&gt;
     &lt;g transform="scale(0.9,0.9)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#yellowBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="3s" dur="7.5s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;

   &lt;g transform="translate(360,700)"&gt;
     &lt;g transform="scale(0.5,0.5)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#blueBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="3s" dur="6s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(215,700)"&gt;
     &lt;g transform="scale(0.45,0.45)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#redBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="5.5s" dur="7s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(420,700)"&gt;
     &lt;g transform="scale(0.75,0.75)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#greenBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="1s" dur="9s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;
   &lt;g transform="translate(815,700)"&gt;
     &lt;g transform="scale(0.6,0.6)"&gt;
       &lt;use xlink:href="#bubble" fill="url(#yellowBubble)" /&gt;
     &lt;/g&gt;
     &lt;animateTransform attributeName="transform" type="translate" additive="sum"
         values="0,0; 0,-800" begin="2s" dur="9.5s" fill="freeze" repeatCount="indefinite" /&gt;
   &lt;/g&gt;

   &lt;g transform="translate(225,375)" &gt;
     &lt;g transform="scale(1.0,0.5)" &gt;
       &lt;path d="M 0 0 L 350 0 L 450 450 L -100 450 z"
             fill="url(#surface)" stroke="none" /&gt;
     &lt;/g&gt;
   &lt;/g&gt;
     &lt;g transform="translate(200,0)" &gt;
     &lt;g transform="translate(200,490) scale(2.0,1.0) rotate(45)" &gt;
       &lt;rect fill="#a6ce39" x="-69" y="-69" width="138" height="138" /&gt;
       &lt;circle fill="black" cx="0" cy="0" r="50" /&gt;
       &lt;circle fill="#a6ce39" cx="0" cy="0" r="33" /&gt;
       &lt;path fill="black" d="M 37,50 L 50,37 L 12,-1 L 22,-11 L 10,-24 L -24,10
                             L -11,22 L -1,12 Z" /&gt;
       &lt;animateTransform attributeName="transform"  type="rotate" additive="sum" values="0; 360"
                  begin="0s" dur="10s" fill="freeze" repeatCount="indefinite" /&gt;
     &lt;/g&gt;
     &lt;g transform="translate(200,375)"&gt;
       &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
       &lt;circle fill="url(#blueSphere)" cx="0" cy="0" r="100" /&gt;
     &lt;/g&gt;
     &lt;g transform="translate(315,440)"&gt;
       &lt;g transform="scale(0.5,0.5)"&gt;
         &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
         &lt;circle fill="url(#redSphere)" cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/g&gt;
     &lt;g transform="translate(80,475)"&gt;
       &lt;g transform="scale(0.65,0.65)"&gt;
         &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
         &lt;circle fill="url(#greenSphere)" cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/g&gt;
     &lt;g transform="translate(255,525)"&gt;
       &lt;g transform="scale(0.3,0.3)"&gt;
         &lt;use xlink:href="#shadow" transform="translate(25,55) scale(1.0,0.5)" /&gt;
         &lt;circle fill="url(#yellowSphere)" cx="0" cy="0" r="100" /&gt;
       &lt;/g&gt;
     &lt;/g&gt;
   &lt;/g&gt;
&lt;/svg&gt;</t>
<t tx="ekr.20241223020730.27">C:\Repos\leo-editor\leo\Icons\bubbles.svg
</t>
<t tx="ekr.20241223020730.28">@language rest
@wrap

''' Creates a window for *live* rendering of rst, html, etc.  (Qt only).

Commands
========

viewrendered.py creates the following (``Alt-X``) commands:

``viewrendered``
    opens a new window where the current body text is rendered as HTML
    (if it starts with '&lt;'), or otherwise reStructuredText.
``viewrendered-big``
    as above, but zoomed in, useful for presentations
``viewrendered-html``
    displays the html source generated from reStructuredText, useful for
    debugging

``viewrendered`` sets the process current directory (os.chdir()) to the path
to the node being rendered, to allow relative paths to work in
``.. image::`` directives.

reStructuredText errors and warnings may be shown.  For example, both::

    Heading
    -------

    `This` is **really** a line of text.

and::

    &lt;h1&gt;Heading&lt;h1&gt;

    &lt;tt&gt;This&lt;/tt&gt; is &lt;b&gt;really&lt;/b&gt; a line of text.

will look something like:

**Heading**

`This` is **really** a line of text.

Settings
========

@string view-rendered-default-kind = rst
----------------------------------------

The default kind of rendering.  One of (big,rst,html)
    
@bool view-rendered-auto-create = False
---------------------------------------

When True, the plugin will create a rendering pane automatically.

'''
</t>
<t tx="ekr.20241223020730.29"></t>
<t tx="ekr.20241223020730.30">@language md

# Title

This is **bold** and *italics*.

More info at [Leo's home page](&lt;http://leoeditor.com/).

### Section

- Bullet list
- Another item
- Third item.
</t>
<t tx="ekr.20241223020730.32">@language md

- Item

[link](xxx)</t>
<t tx="ekr.20241223020730.33"></t>
<t tx="ekr.20241223020730.34">@language rest

#####
Title
#####

This is **bold** and *italics*.

More info at `Leo's home page &lt;http://leoeditor.com/&gt;`_.

Section
=======

- Bullet list
- Another item
- Third item.</t>
<t tx="ekr.20241223020730.37">@language rest
@wrap
code::

    print('Hello world')
    for i in 0,1:
        print(i)
    
</t>
<t tx="ekr.20241223020730.38"></t>
<t tx="ekr.20241223020730.39">@language md
@wrap

[Leo's home page](https://leo-editor.github.io/leo-editor/)
</t>
<t tx="ekr.20241223020730.40">@language rest
@wrap

`Leo's home page &lt;https://leo-editor.github.io/leo-editor/&gt;`_

</t>
<t tx="ekr.20241223020730.41">@language rest
@wrap

`EKR mail &lt;http://mail.google.com/mail/#inbox&gt;`_</t>
<t tx="ekr.20241223020730.42">@language md
@wrap

[weather.com](http://www.weather.com/weather/today/Madison+WI+53705?from=hp_promolocator&amp;lswe=53705&amp;lwsa=Weather36HourHealthCommand)
</t>
<t tx="ekr.20241223020730.7" __bookmarks="7d7100580700000069735f6475706571014930300a732e">@language python
@nosearch
# changed
</t>
<t tx="ekr.20241223020730.8"></t>
<t tx="ekr.20241223020730.9" __bookmarks="7d7100580700000069735f6475706571014930300a732e">@language html
&lt;a href="http://127.0.0.1:8000/leo_toc.html"&gt;Link&lt;/a&gt;</t>
<t tx="ekr.20241223024937.1"></t>
<t tx="ekr.20241224065831.1">@language mathjax

Define the &lt;b&gt;unit activation&lt;/b&gt;, $a_m$,
&lt;p&gt;
$a_m = \sum_{i=0}^D w_{ji}^{(1)}x_i$
&lt;p&gt;
for $m=1\ldots M$
</t>
<t tx="ekr.20241224161542.1">.. This only affects size of controls!</t>
<t tx="ekr.20241224172245.1"></t>
<t tx="ekr.20241224173005.1">@language mathjax

% https://www.khanacademy.org/math/algebra/x2f8bb11595b61c86 

The line passing through $(x1, y1)$ is
&lt;br&gt;
$y-y1= m(x-x1)$

&lt;p&gt;

Setting $y=0$ and solving for $x$,
the $x$ intercept is
&lt;br&gt;
$x = x1 -y1 / m$
</t>
<t tx="ekr.20241224173158.1">@language mathjax

\begin{align}
  e &amp; = \lim\limits_{n\to\infty}(1 + \dfrac{1}{n})^n \hspace{100cm} \\
    &amp; = \sum\limits_{n = 0}^{\infty} \dfrac{1}{n!}
\end{align}

&lt;p&gt;
The solution to the equation $\dot{x} = rx$ is
&lt;br&gt;
$x(t) = e^{rt} \cdot x(0)$
</t>
<t tx="ekr.20241224174349.1">@language mathjax

% Note \hspace{100cm}

\begin{align} 
    \backslash circ     &amp; \quad \circ \hspace{100cm} \\ 
    \backslash cdot     &amp; \quad \cdot \\ 
    \backslash dot\{x\} &amp; \quad \dot{x}
\end{align}

&lt;h3&gt;Horizontal spacing&lt;/h3&gt;

\begin{align} 
    \backslash , &amp; \quad small \hspace{100cm} \\
    \backslash ; &amp; \quad medium \\
    \backslash quad &amp; \quad large \\
\end{align} 
</t>
<t tx="ekr.20241225032316.1"></t>
<t tx="ekr.20241225033647.1">@language mathjax

&lt;tt&gt;\lim\limits_{n\to\infty}&lt;/tt&gt;:
$\quad\quad\quad \lim\limits_{n\to\infty}$

&lt;p&gt;

&lt;tt&gt;\sum\limits_{n = 0}^{\infty}&lt;/tt&gt;:
$\quad \sum\limits_{n = 0}^{\infty}$</t>
<t tx="ekr.20241225053337.1">@language html
@tabwidth -2

&lt;!-- Mathjax 3 is less good. --&gt;
&lt;!-- src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"&gt; --&gt;
&lt;!-- src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"&gt; --&gt;

&lt;head&gt;
  &lt;script type="text/x-mathjax-config"&gt;
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
    });
  &lt;/script&gt;
  &lt;script type="text/javascript" async
    src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_CHTML"&gt;
  &lt;/script&gt;
&lt;/head&gt;

&lt;!-- Comment --&gt;

$px^2 + qx + r = 0$
&lt;p&gt;
Roots of quadratic equation:
&lt;p&gt;
$x = {-q \pm \sqrt{q^2-4pr} \over 2p}$

&lt;p&gt;
&lt;!-- works ouside math mode, but only for 2.x --&gt;
\begin{equation}
  \int_0^\infty \frac{x^3}{e^x-1}\,dx = \frac{\pi^4}{15}
  \label{eq:sample}
\end{equation}

&lt;p&gt;
&lt;!-- works ouside math mode --&gt;
&lt;!-- Notice the \hspace{100cm} at the end of the first aligned line. --&gt;

\begin{align*} 
    \backslash circ     &amp; \quad \circ \hspace{100cm} \\ 
    \backslash cdot     &amp; \quad \cdot \\ 
    \backslash dot\{x\} &amp; \quad \dot{x}
\end{align*}
</t>
<t tx="ekr.20241225091600.1">@language mathjax
@tabwidth -2

% comment.

$px^2 + qx + r = 0$
&lt;p&gt;
Roots of quadratic equation:
&lt;p&gt;
$x = {-q \pm \sqrt{q^2-4pr} \over 2p}$
&lt;p&gt;
% Works ouside math mode.
\begin{equation}
  \int_0^\infty \frac{x^3}{e^x-1}\,dx = \frac{\pi^4}{15}
  \label{eq:sample}
\end{equation}

&lt;p&gt;
% Works ouside math mode.
% Notice \hspace{100cm}
\begin{align*} 
    \backslash circ     &amp; \quad \circ \hspace{100cm} \\ 
    \backslash cdot     &amp; \quad \cdot \\ 
    \backslash dot\{x\} &amp; \quad \dot{x}
\end{align*}
</t>
<t tx="ekr.20241226013008.1">C:\Repos\EKR-Math\temp.pdf
</t>
<t tx="ekr.20241226055452.1">@language mathjax

quadratic equation: 
$px^2 + qx + r = 0$

&lt;p&gt;

roots of quadratic equation:
$x = {-q \pm \sqrt{q^2-4pr} \over 2p}$
</t>
<t tx="ekr.20241226180843.1"></t>
<t tx="ekr.20241227063213.1"></t>
<t tx="ekr.20241231172240.1">@language typst

#set par(justify: true)
= Background

The equation $Q = rho A v + C$
defines the glacial flow rate.</t>
<t tx="ekr.20241231191937.1">@language katex

% Comment

\begin{align} 
    \backslash circ     &amp; \quad \circ \hspace{10cm} \nonumber  \\ 
    \backslash cdot     &amp; \quad \cdot               \nonumber \\ 
    \backslash dot\{x\} &amp; \quad \dot{x}             \nonumber \\
\end{align}

&lt;h3&gt;Horizontal spacing&lt;/h3&gt;

\begin{align} 
    \backslash ,    &amp; \quad small \hspace{10cm} \nonumber \\
    \backslash ;    &amp; \quad medium              \nonumber \\
    \backslash quad &amp; \quad large               \nonumber \\
\end{align}

&lt;h3&gt;Centered equations&lt;/h3&gt;

\begin{align}
    \lim\limits_{n\to\infty}    &amp; \nonumber \\
    \sum\limits_{n=0}^{\infty}  &amp; \nonumber \\
\end{align}

&lt;h3&gt;Left aligned equations&lt;/h3&gt;

\begin{align}
    \lim\limits_{n\to\infty}    &amp; \hspace{10cm} \nonumber \\
    \sum\limits_{n=0}^{\infty}  &amp; \nonumber \\
\end{align}

&lt;h3&gt;Another way&lt;/h3&gt;

\(
    \lim\limits_{n\to\infty} = \sum\limits_{n=0}^{\infty}
\)

</t>
<t tx="ekr.20250102052459.1">temp.pdf</t>
</tnodes>
</leo_file>
