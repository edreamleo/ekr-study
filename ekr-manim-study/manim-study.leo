<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20250121054642.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735805000000302e302e3371067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c75735803000000302e31710d7d710e580b0000005f5f626f6f6b6d61726b73710f7d7110580700000069735f6475706571114930300a7373752e"><vh>Startup &amp; readme</vh>
<v t="ekr.20250121055447.2" descendentVnodeUnknownAttributes="7d71002858010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735803000000302e3371067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c7573752e"><vh>@settings</vh>
<v t="ekr.20250121055447.4"><vh>@bool check-python-code-on-write = True</vh></v>
<v t="ekr.20250121055447.163"><vh>@data history-list</vh></v>
<v t="ekr.20250121055447.153"><vh>Buttons &amp; commands</vh>
<v t="ekr.20250121055447.154"><vh>@button backup</vh></v>
<v t="ekr.20250121054646.1"><vh>@button manim</vh></v>
</v>
<v t="ekr.20250121055447.164" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032312d30332d333071077573732e"><vh>@enabled-plugins</vh></v>
</v>
<v t="ekr.20250121055447.161" descendentVnodeUnknownAttributes="7d710058010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a7373732e"><vh>Scripts</vh>
<v t="ekr.20250121054955.1"><vh> Recursive import script</vh></v>
</v>
</v>
<v t="ekr.20250121055447.163"></v>
<v t="ekr.20250121055147.1"><vh>--- outside sources</vh>
<v t="ekr.20250121055138.1"><vh>micrograd</vh>
<v t="ekr.20250121055138.2"><vh>Python3.12..micrograd/engine.py</vh>
<v t="ekr.20250121055138.3"><vh>Value.__init__ &amp; __repr__</vh></v>
<v t="ekr.20250121055138.4"><vh>Value.backward</vh></v>
<v t="ekr.20250121055138.5"><vh>Value.relu</vh></v>
<v t="ekr.20250121055138.6"><vh>Value: fundamental ops</vh>
<v t="ekr.20250121055138.7"><vh>Value.__add__</vh></v>
<v t="ekr.20250121055138.8"><vh>Value.__mul__</vh></v>
<v t="ekr.20250121055138.9"><vh>Value.__pow__</vh></v>
</v>
<v t="ekr.20250121055138.10"><vh>Value: derived ops (wrong op?)</vh>
<v t="ekr.20250121055138.11"><vh>Value.__neg__</vh></v>
<v t="ekr.20250121055138.12"><vh>Value.__radd__</vh></v>
<v t="ekr.20250121055138.13"><vh>Value.__sub__</vh></v>
<v t="ekr.20250121055138.14"><vh>Value.__rsub__</vh></v>
<v t="ekr.20250121055138.15"><vh>Value.__rmul__</vh></v>
<v t="ekr.20250121055138.16"><vh>Value.__truediv__</vh></v>
<v t="ekr.20250121055138.17"><vh>Value.__rtruediv__</vh></v>
<v t="ekr.20250121055138.18"><vh>Value.__repr__</vh></v>
</v>
</v>
<v t="ekr.20250121055138.19"><vh>Python3.12..micrograd/nn.py</vh>
<v t="ekr.20250121055138.20"><vh>class Module</vh>
<v t="ekr.20250121055138.21"><vh>Module.zero_grad</vh></v>
<v t="ekr.20250121055138.22"><vh>Module.parameters</vh></v>
</v>
<v t="ekr.20250121055138.23"><vh>class Neuron</vh>
<v t="ekr.20250121055138.24"><vh>Neuron.__init__ &amp; __repr__</vh></v>
<v t="ekr.20250121055138.25"><vh>Neuron.__call__</vh></v>
<v t="ekr.20250121055138.26"><vh>Neuron.parameters</vh></v>
</v>
<v t="ekr.20250121055138.27"><vh>class Layer</vh>
<v t="ekr.20250121055138.28"><vh>Layer.__init__ &amp; __repr__</vh></v>
<v t="ekr.20250121055138.29"><vh>Layer.__call__</vh></v>
<v t="ekr.20250121055138.30"><vh>Layer.parameters</vh></v>
</v>
<v t="ekr.20250121055138.31"><vh>class MLP</vh>
<v t="ekr.20250121055138.32"><vh>MLP.__init__ &amp; __repr__</vh></v>
<v t="ekr.20250121055138.33"><vh>MLP.__call__</vh></v>
<v t="ekr.20250121055138.34"><vh>MLP.parameters</vh></v>
</v>
</v>
</v>
<v t="ekr.20250121054835.1"><vh>manim (3blue-1brown)</vh>
<v t="ekr.20250121054835.2"><vh>example_scenes.py</vh>
<v t="ekr.20250121054835.3"><vh>class OpeningManimExample</vh>
<v t="ekr.20250121054835.4"><vh>OpeningManimExample.construct</vh></v>
</v>
<v t="ekr.20250121054835.5"><vh>class AnimatingMethods</vh>
<v t="ekr.20250121054835.6"><vh>AnimatingMethods.construct</vh></v>
</v>
<v t="ekr.20250121054835.7"><vh>class TextExample</vh>
<v t="ekr.20250121054835.8"><vh>TextExample.construct</vh></v>
</v>
<v t="ekr.20250121054835.9"><vh>class TexTransformExample</vh>
<v t="ekr.20250121054835.10"><vh>TexTransformExample.construct</vh></v>
</v>
<v t="ekr.20250121054835.11"><vh>class TexIndexing</vh>
<v t="ekr.20250121054835.12"><vh>TexIndexing.construct</vh></v>
</v>
<v t="ekr.20250121054835.13"><vh>class UpdatersExample</vh>
<v t="ekr.20250121054835.14"><vh>UpdatersExample.construct</vh></v>
</v>
<v t="ekr.20250121054835.15"><vh>class CoordinateSystemExample</vh>
<v t="ekr.20250121054835.16"><vh>CoordinateSystemExample.construct</vh></v>
</v>
<v t="ekr.20250121054835.17"><vh>class GraphExample</vh>
<v t="ekr.20250121054835.18"><vh>GraphExample.construct</vh></v>
</v>
<v t="ekr.20250121054835.19"><vh>class TexAndNumbersExample</vh>
<v t="ekr.20250121054835.20"><vh>TexAndNumbersExample.construct</vh></v>
</v>
<v t="ekr.20250121054835.21"><vh>class SurfaceExample</vh>
<v t="ekr.20250121054835.22"><vh>SurfaceExample.construct</vh></v>
</v>
<v t="ekr.20250121054835.23"><vh>class InteractiveDevelopment</vh>
<v t="ekr.20250121054835.24"><vh>InteractiveDevelopment.construct</vh></v>
</v>
<v t="ekr.20250121054835.25"><vh>class ControlsExample</vh>
<v t="ekr.20250121054835.26"><vh>ControlsExample.setup</vh></v>
<v t="ekr.20250121054835.27"><vh>ControlsExample.construct</vh></v>
</v>
</v>
<v t="ekr.20250121054835.28"><vh>setup.py</vh></v>
<v t="ekr.20250121054835.29"><vh>C:/Repos/manim/docs</vh>
<v t="ekr.20250121054835.30"><vh>docs/example.py</vh>
<v t="ekr.20250121054835.31"><vh>class SquareToCircle</vh>
<v t="ekr.20250121054835.32"><vh>SquareToCircle.construct</vh></v>
</v>
<v t="ekr.20250121054835.33"><vh>class SquareToCircleEmbed</vh>
<v t="ekr.20250121054835.34"><vh>SquareToCircleEmbed.construct</vh></v>
</v>
</v>
<v t="ekr.20250121054835.35"><vh>C:/Repos/manim/docs/source</vh>
<v t="ekr.20250121054835.36"><vh>docs/source/conf.py</vh></v>
<v t="ekr.20250121054835.37"><vh>docs/source/manim_example_ext.py</vh>
<v t="ekr.20250121054835.38"><vh>class skip_manim_node</vh></v>
<v t="ekr.20250121054835.39"><vh>function: visit</vh></v>
<v t="ekr.20250121054835.40"><vh>function: depart</vh></v>
<v t="ekr.20250121054835.41"><vh>class ManimExampleDirective</vh>
<v t="ekr.20250121054835.42"><vh>ManimExampleDirective.run</vh></v>
</v>
<v t="ekr.20250121054835.43"><vh>function: setup</vh></v>
</v>
</v>
</v>
<v t="ekr.20250121054835.44"><vh>C:/Repos/manim/logo</vh>
<v t="ekr.20250121054835.45"><vh>logo/logo.py</vh>
<v t="ekr.20250121054835.46"><vh>class Thumbnail</vh>
<v t="ekr.20250121054835.47"><vh>Thumbnail.construct</vh></v>
<v t="ekr.20250121054835.48"><vh>Thumbnail.show_function_graph</vh></v>
</v>
</v>
</v>
<v t="ekr.20250121054835.49"><vh>C:/Repos/manim/manimlib</vh>
<v t="ekr.20250121054835.50"><vh>manimlib/__init__.py</vh></v>
<v t="ekr.20250121054835.51"><vh>manimlib/__main__.py</vh>
<v t="ekr.20250121054835.52"><vh>function: run_scenes</vh></v>
<v t="ekr.20250121054835.53"><vh>function: main</vh></v>
</v>
<v t="ekr.20250121054835.54"><vh>manimlib/config.py</vh>
<v t="ekr.20250121054835.55"><vh>function: initialize_manim_config</vh></v>
<v t="ekr.20250121054835.56"><vh>function: parse_cli</vh></v>
<v t="ekr.20250121054835.57"><vh>function: update_directory_config</vh></v>
<v t="ekr.20250121054835.58"><vh>function: update_window_config</vh></v>
<v t="ekr.20250121054835.59"><vh>function: update_camera_config</vh></v>
<v t="ekr.20250121054835.60"><vh>function: update_file_writer_config</vh></v>
<v t="ekr.20250121054835.61"><vh>function: update_scene_config</vh></v>
<v t="ekr.20250121054835.62"><vh>function: update_run_config</vh></v>
<v t="ekr.20250121054835.63"><vh>function: update_embed_config</vh></v>
<v t="ekr.20250121054835.64"><vh>function: load_yaml</vh></v>
<v t="ekr.20250121054835.65"><vh>function: get_manim_dir</vh></v>
<v t="ekr.20250121054835.66"><vh>function: get_resolution_from_args</vh></v>
<v t="ekr.20250121054835.67"><vh>function: get_file_ext</vh></v>
<v t="ekr.20250121054835.68"><vh>function: get_animations_numbers</vh></v>
<v t="ekr.20250121054835.69"><vh>function: get_output_directory</vh></v>
</v>
<v t="ekr.20250121054835.70"><vh>manimlib/constants.py</vh></v>
<v t="ekr.20250121054835.71"><vh>manimlib/extract_scene.py</vh>
<v t="ekr.20250121054835.72"><vh>class BlankScene</vh>
<v t="ekr.20250121054835.73"><vh>BlankScene.construct</vh></v>
</v>
<v t="ekr.20250121054835.74"><vh>function: is_child_scene</vh></v>
<v t="ekr.20250121054835.75"><vh>function: prompt_user_for_choice</vh></v>
<v t="ekr.20250121054835.76"><vh>function: compute_total_frames</vh></v>
<v t="ekr.20250121054835.77"><vh>function: scene_from_class</vh></v>
<v t="ekr.20250121054835.78"><vh>function: note_missing_scenes</vh></v>
<v t="ekr.20250121054835.79"><vh>function: get_scenes_to_render</vh></v>
<v t="ekr.20250121054835.80"><vh>function: get_scene_classes</vh></v>
<v t="ekr.20250121054835.81"><vh>function: get_indent</vh></v>
<v t="ekr.20250121054835.82"><vh>function: insert_embed_line_to_module</vh></v>
<v t="ekr.20250121054835.83"><vh>function: get_module</vh></v>
<v t="ekr.20250121054835.84"><vh>function: main</vh></v>
</v>
<v t="ekr.20250121054835.85"><vh>manimlib/logger.py</vh></v>
<v t="ekr.20250121054835.86"><vh>manimlib/module_loader.py</vh>
<v t="ekr.20250121054835.87"><vh>class ModuleLoader</vh>
<v t="ekr.20250121054835.88"><vh>ModuleLoader.get_module</vh></v>
<v t="ekr.20250121054835.89"><vh>ModuleLoader._exec_module_and_track_imports</vh></v>
<v t="ekr.20250121054835.90"><vh>ModuleLoader._reload_modules</vh></v>
<v t="ekr.20250121054835.91"><vh>ModuleLoader._is_user_defined_module</vh></v>
<v t="ekr.20250121054835.92"><vh>ModuleLoader._deep_reload</vh></v>
</v>
</v>
<v t="ekr.20250121054835.93"><vh>manimlib/shader_wrapper.py</vh>
<v t="ekr.20250121054835.94"><vh>class ShaderWrapper</vh>
<v t="ekr.20250121054835.95"><vh>ShaderWrapper.__init__</vh></v>
<v t="ekr.20250121054835.96"><vh>ShaderWrapper.__deepcopy__</vh></v>
<v t="ekr.20250121054835.97"><vh>ShaderWrapper.init_program_code</vh></v>
<v t="ekr.20250121054835.98"><vh>ShaderWrapper.init_program</vh></v>
<v t="ekr.20250121054835.99"><vh>ShaderWrapper.init_textures</vh></v>
<v t="ekr.20250121054835.100"><vh>ShaderWrapper.init_vertex_objects</vh></v>
<v t="ekr.20250121054835.101"><vh>ShaderWrapper.add_texture</vh></v>
<v t="ekr.20250121054835.102"><vh>ShaderWrapper.bind_to_mobject_uniforms</vh></v>
<v t="ekr.20250121054835.103"><vh>ShaderWrapper.get_id</vh></v>
<v t="ekr.20250121054835.104"><vh>ShaderWrapper.refresh_id</vh></v>
<v t="ekr.20250121054835.105"><vh>ShaderWrapper.replace_code</vh></v>
<v t="ekr.20250121054835.106"><vh>ShaderWrapper.use_clip_plane</vh></v>
<v t="ekr.20250121054835.107"><vh>ShaderWrapper.set_ctx_depth_test</vh></v>
<v t="ekr.20250121054835.108"><vh>ShaderWrapper.set_ctx_clip_plane</vh></v>
<v t="ekr.20250121054835.109"><vh>ShaderWrapper.read_in</vh></v>
<v t="ekr.20250121054835.110"><vh>ShaderWrapper.generate_vaos</vh></v>
<v t="ekr.20250121054835.111"><vh>ShaderWrapper.pre_render</vh></v>
<v t="ekr.20250121054835.112"><vh>ShaderWrapper.render</vh></v>
<v t="ekr.20250121054835.113"><vh>ShaderWrapper.update_program_uniforms</vh></v>
<v t="ekr.20250121054835.114"><vh>ShaderWrapper.release</vh></v>
<v t="ekr.20250121054835.115"><vh>ShaderWrapper.release_textures</vh></v>
</v>
<v t="ekr.20250121054835.116"><vh>class VShaderWrapper</vh>
<v t="ekr.20250121054835.117"><vh>VShaderWrapper.__init__</vh></v>
<v t="ekr.20250121054835.118"><vh>VShaderWrapper.init_program_code</vh></v>
<v t="ekr.20250121054835.119"><vh>VShaderWrapper.init_program</vh></v>
<v t="ekr.20250121054835.120"><vh>VShaderWrapper.init_vertex_objects</vh></v>
<v t="ekr.20250121054835.121"><vh>VShaderWrapper.generate_vaos</vh></v>
<v t="ekr.20250121054835.122"><vh>VShaderWrapper.set_backstroke</vh></v>
<v t="ekr.20250121054835.123"><vh>VShaderWrapper.refresh_id</vh></v>
<v t="ekr.20250121054835.124"><vh>VShaderWrapper.render_stroke</vh></v>
<v t="ekr.20250121054835.125"><vh>VShaderWrapper.render_fill</vh></v>
<v t="ekr.20250121054835.126"><vh>VShaderWrapper.get_fill_canvas</vh></v>
<v t="ekr.20250121054835.127"><vh>VShaderWrapper.render</vh></v>
</v>
</v>
<v t="ekr.20250121054835.128"><vh>manimlib/typing.py</vh></v>
<v t="ekr.20250121054835.129"><vh>manimlib/window.py</vh>
<v t="ekr.20250121054835.130"><vh>class Window</vh>
<v t="ekr.20250121054835.131"><vh>Window.__init__</vh></v>
<v t="ekr.20250121054835.132"><vh>Window.init_for_scene</vh></v>
<v t="ekr.20250121054835.133"><vh>Window.get_monitor</vh></v>
<v t="ekr.20250121054835.134"><vh>Window.get_default_size</vh></v>
<v t="ekr.20250121054835.135"><vh>Window.position_from_string</vh></v>
<v t="ekr.20250121054835.136"><vh>Window.focus</vh></v>
<v t="ekr.20250121054835.137"><vh>Window.to_default_position</vh></v>
<v t="ekr.20250121054835.138"><vh>Window.pixel_coords_to_space_coords</vh></v>
<v t="ekr.20250121054835.139"><vh>Window.has_undrawn_event</vh></v>
<v t="ekr.20250121054835.140"><vh>Window.swap_buffers</vh></v>
<v t="ekr.20250121054835.141"><vh>Window.note_undrawn_event</vh></v>
<v t="ekr.20250121054835.142"><vh>Window.on_mouse_motion</vh></v>
<v t="ekr.20250121054835.143"><vh>Window.on_mouse_drag</vh></v>
<v t="ekr.20250121054835.144"><vh>Window.on_mouse_press</vh></v>
<v t="ekr.20250121054835.145"><vh>Window.on_mouse_release</vh></v>
<v t="ekr.20250121054835.146"><vh>Window.on_mouse_scroll</vh></v>
<v t="ekr.20250121054835.147"><vh>Window.on_key_press</vh></v>
<v t="ekr.20250121054835.148"><vh>Window.on_key_release</vh></v>
<v t="ekr.20250121054835.149"><vh>Window.on_resize</vh></v>
<v t="ekr.20250121054835.150"><vh>Window.on_show</vh></v>
<v t="ekr.20250121054835.151"><vh>Window.on_hide</vh></v>
<v t="ekr.20250121054835.152"><vh>Window.on_close</vh></v>
<v t="ekr.20250121054835.153"><vh>Window.is_key_pressed</vh></v>
</v>
</v>
<v t="ekr.20250121054835.154"><vh>C:/Repos/manim/manimlib/animation</vh>
<v t="ekr.20250121054835.155"><vh>manimlib/animation/__init__.py</vh></v>
<v t="ekr.20250121054835.156"><vh>manimlib/animation/animation.py</vh>
<v t="ekr.20250121054835.157"><vh>class Animation</vh>
<v t="ekr.20250121054835.158"><vh>Animation.__init__</vh></v>
<v t="ekr.20250121054835.159"><vh>Animation.__str__</vh></v>
<v t="ekr.20250121054835.160"><vh>Animation.begin</vh></v>
<v t="ekr.20250121054835.161"><vh>Animation.finish</vh></v>
<v t="ekr.20250121054835.162"><vh>Animation.clean_up_from_scene</vh></v>
<v t="ekr.20250121054835.163"><vh>Animation.create_starting_mobject</vh></v>
<v t="ekr.20250121054835.164"><vh>Animation.get_all_mobjects</vh></v>
<v t="ekr.20250121054835.165"><vh>Animation.get_all_families_zipped</vh></v>
<v t="ekr.20250121054835.166"><vh>Animation.update_mobjects</vh></v>
<v t="ekr.20250121054835.167"><vh>Animation.get_all_mobjects_to_update</vh></v>
<v t="ekr.20250121054835.168"><vh>Animation.copy</vh></v>
<v t="ekr.20250121054835.169"><vh>Animation.update_rate_info</vh></v>
<v t="ekr.20250121054835.170"><vh>Animation.interpolate</vh></v>
<v t="ekr.20250121054835.171"><vh>Animation.update</vh></v>
<v t="ekr.20250121054835.172"><vh>Animation.time_spanned_alpha</vh></v>
<v t="ekr.20250121054835.173"><vh>Animation.interpolate_mobject</vh></v>
<v t="ekr.20250121054835.174"><vh>Animation.interpolate_submobject</vh></v>
<v t="ekr.20250121054835.175"><vh>Animation.get_sub_alpha</vh></v>
<v t="ekr.20250121054835.176"><vh>Animation.set_run_time</vh></v>
<v t="ekr.20250121054835.177"><vh>Animation.get_run_time</vh></v>
<v t="ekr.20250121054835.178"><vh>Animation.set_rate_func</vh></v>
<v t="ekr.20250121054835.179"><vh>Animation.get_rate_func</vh></v>
<v t="ekr.20250121054835.180"><vh>Animation.set_name</vh></v>
<v t="ekr.20250121054835.181"><vh>Animation.is_remover</vh></v>
</v>
<v t="ekr.20250121054835.182"><vh>function: prepare_animation</vh></v>
</v>
<v t="ekr.20250121054835.183"><vh>manimlib/animation/composition.py</vh>
<v t="ekr.20250121054835.184"><vh>class AnimationGroup</vh>
<v t="ekr.20250121054835.185"><vh>AnimationGroup.__init__</vh></v>
<v t="ekr.20250121054835.186"><vh>AnimationGroup.get_all_mobjects</vh></v>
<v t="ekr.20250121054835.187"><vh>AnimationGroup.begin</vh></v>
<v t="ekr.20250121054835.188"><vh>AnimationGroup.finish</vh></v>
<v t="ekr.20250121054835.189"><vh>AnimationGroup.clean_up_from_scene</vh></v>
<v t="ekr.20250121054835.190"><vh>AnimationGroup.update_mobjects</vh></v>
<v t="ekr.20250121054835.191"><vh>AnimationGroup.calculate_max_end_time</vh></v>
<v t="ekr.20250121054835.192"><vh>AnimationGroup.build_animations_with_timings</vh></v>
<v t="ekr.20250121054835.193"><vh>AnimationGroup.interpolate</vh></v>
</v>
<v t="ekr.20250121054835.194"><vh>class Succession</vh>
<v t="ekr.20250121054835.195"><vh>Succession.__init__</vh></v>
<v t="ekr.20250121054835.196"><vh>Succession.begin</vh></v>
<v t="ekr.20250121054835.197"><vh>Succession.finish</vh></v>
<v t="ekr.20250121054835.198"><vh>Succession.update_mobjects</vh></v>
<v t="ekr.20250121054835.199"><vh>Succession.interpolate</vh></v>
</v>
<v t="ekr.20250121054835.200"><vh>class LaggedStart</vh>
<v t="ekr.20250121054835.201"><vh>LaggedStart.__init__</vh></v>
</v>
<v t="ekr.20250121054835.202"><vh>class LaggedStartMap</vh>
<v t="ekr.20250121054835.203"><vh>LaggedStartMap.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.204"><vh>manimlib/animation/creation.py</vh>
<v t="ekr.20250121054835.205"><vh>class ShowPartial</vh>
<v t="ekr.20250121054835.206"><vh>ShowPartial.__init__</vh></v>
<v t="ekr.20250121054835.207"><vh>ShowPartial.interpolate_submobject</vh></v>
<v t="ekr.20250121054835.208"><vh>ShowPartial.get_bounds</vh></v>
</v>
<v t="ekr.20250121054835.209"><vh>class ShowCreation</vh>
<v t="ekr.20250121054835.210"><vh>ShowCreation.__init__</vh></v>
<v t="ekr.20250121054835.211"><vh>ShowCreation.get_bounds</vh></v>
</v>
<v t="ekr.20250121054835.212"><vh>class Uncreate</vh>
<v t="ekr.20250121054835.213"><vh>Uncreate.__init__</vh></v>
</v>
<v t="ekr.20250121054835.214"><vh>class DrawBorderThenFill</vh>
<v t="ekr.20250121054835.215"><vh>DrawBorderThenFill.__init__</vh></v>
<v t="ekr.20250121054835.216"><vh>DrawBorderThenFill.begin</vh></v>
<v t="ekr.20250121054835.217"><vh>DrawBorderThenFill.finish</vh></v>
<v t="ekr.20250121054835.218"><vh>DrawBorderThenFill.get_outline</vh></v>
<v t="ekr.20250121054835.219"><vh>DrawBorderThenFill.get_all_mobjects</vh></v>
<v t="ekr.20250121054835.220"><vh>DrawBorderThenFill.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250121054835.221"><vh>class Write</vh>
<v t="ekr.20250121054835.222"><vh>Write.__init__</vh></v>
<v t="ekr.20250121054835.223"><vh>Write.compute_run_time</vh></v>
<v t="ekr.20250121054835.224"><vh>Write.compute_lag_ratio</vh></v>
</v>
<v t="ekr.20250121054835.225"><vh>class ShowIncreasingSubsets</vh>
<v t="ekr.20250121054835.226"><vh>ShowIncreasingSubsets.__init__</vh></v>
<v t="ekr.20250121054835.227"><vh>ShowIncreasingSubsets.interpolate_mobject</vh></v>
<v t="ekr.20250121054835.228"><vh>ShowIncreasingSubsets.update_submobject_list</vh></v>
</v>
<v t="ekr.20250121054835.229"><vh>class ShowSubmobjectsOneByOne</vh>
<v t="ekr.20250121054835.230"><vh>ShowSubmobjectsOneByOne.__init__</vh></v>
<v t="ekr.20250121054835.231"><vh>ShowSubmobjectsOneByOne.update_submobject_list</vh></v>
</v>
<v t="ekr.20250121054835.232"><vh>class AddTextWordByWord</vh>
<v t="ekr.20250121054835.233"><vh>AddTextWordByWord.__init__</vh></v>
<v t="ekr.20250121054835.234"><vh>AddTextWordByWord.clean_up_from_scene</vh></v>
</v>
</v>
<v t="ekr.20250121054835.235"><vh>manimlib/animation/fading.py</vh>
<v t="ekr.20250121054835.236"><vh>class Fade</vh>
<v t="ekr.20250121054835.237"><vh>Fade.__init__</vh></v>
</v>
<v t="ekr.20250121054835.238"><vh>class FadeIn</vh>
<v t="ekr.20250121054835.239"><vh>FadeIn.create_target</vh></v>
<v t="ekr.20250121054835.240"><vh>FadeIn.create_starting_mobject</vh></v>
</v>
<v t="ekr.20250121054835.241"><vh>class FadeOut</vh>
<v t="ekr.20250121054835.242"><vh>FadeOut.__init__</vh></v>
<v t="ekr.20250121054835.243"><vh>FadeOut.create_target</vh></v>
</v>
<v t="ekr.20250121054835.244"><vh>class FadeInFromPoint</vh>
<v t="ekr.20250121054835.245"><vh>FadeInFromPoint.__init__</vh></v>
</v>
<v t="ekr.20250121054835.246"><vh>class FadeOutToPoint</vh>
<v t="ekr.20250121054835.247"><vh>FadeOutToPoint.__init__</vh></v>
</v>
<v t="ekr.20250121054835.248"><vh>class FadeTransform</vh>
<v t="ekr.20250121054835.249"><vh>FadeTransform.__init__</vh></v>
<v t="ekr.20250121054835.250"><vh>FadeTransform.begin</vh></v>
<v t="ekr.20250121054835.251"><vh>FadeTransform.ghost_to</vh></v>
<v t="ekr.20250121054835.252"><vh>FadeTransform.get_all_mobjects</vh></v>
<v t="ekr.20250121054835.253"><vh>FadeTransform.get_all_families_zipped</vh></v>
<v t="ekr.20250121054835.254"><vh>FadeTransform.clean_up_from_scene</vh></v>
</v>
<v t="ekr.20250121054835.255"><vh>class FadeTransformPieces</vh>
<v t="ekr.20250121054835.256"><vh>FadeTransformPieces.begin</vh></v>
<v t="ekr.20250121054835.257"><vh>FadeTransformPieces.ghost_to</vh></v>
</v>
<v t="ekr.20250121054835.258"><vh>class VFadeIn</vh>
<v t="ekr.20250121054835.259"><vh>VFadeIn.__init__</vh></v>
<v t="ekr.20250121054835.260"><vh>VFadeIn.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250121054835.261"><vh>class VFadeOut</vh>
<v t="ekr.20250121054835.262"><vh>VFadeOut.__init__</vh></v>
<v t="ekr.20250121054835.263"><vh>VFadeOut.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250121054835.264"><vh>class VFadeInThenOut</vh>
<v t="ekr.20250121054835.265"><vh>VFadeInThenOut.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.266"><vh>manimlib/animation/growing.py</vh>
<v t="ekr.20250121054835.267"><vh>class GrowFromPoint</vh>
<v t="ekr.20250121054835.268"><vh>GrowFromPoint.__init__</vh></v>
<v t="ekr.20250121054835.269"><vh>GrowFromPoint.create_target</vh></v>
<v t="ekr.20250121054835.270"><vh>GrowFromPoint.create_starting_mobject</vh></v>
</v>
<v t="ekr.20250121054835.271"><vh>class GrowFromCenter</vh>
<v t="ekr.20250121054835.272"><vh>GrowFromCenter.__init__</vh></v>
</v>
<v t="ekr.20250121054835.273"><vh>class GrowFromEdge</vh>
<v t="ekr.20250121054835.274"><vh>GrowFromEdge.__init__</vh></v>
</v>
<v t="ekr.20250121054835.275"><vh>class GrowArrow</vh>
<v t="ekr.20250121054835.276"><vh>GrowArrow.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.277"><vh>manimlib/animation/indication.py</vh>
<v t="ekr.20250121054835.278"><vh>class FocusOn</vh>
<v t="ekr.20250121054835.279"><vh>FocusOn.__init__</vh></v>
<v t="ekr.20250121054835.280"><vh>FocusOn.create_target</vh></v>
<v t="ekr.20250121054835.281"><vh>FocusOn.create_starting_mobject</vh></v>
</v>
<v t="ekr.20250121054835.282"><vh>class Indicate</vh>
<v t="ekr.20250121054835.283"><vh>Indicate.__init__</vh></v>
<v t="ekr.20250121054835.284"><vh>Indicate.create_target</vh></v>
</v>
<v t="ekr.20250121054835.285"><vh>class Flash</vh>
<v t="ekr.20250121054835.286"><vh>Flash.__init__</vh></v>
<v t="ekr.20250121054835.287"><vh>Flash.create_lines</vh></v>
<v t="ekr.20250121054835.288"><vh>Flash.create_line_anims</vh></v>
</v>
<v t="ekr.20250121054835.289"><vh>class CircleIndicate</vh>
<v t="ekr.20250121054835.290"><vh>CircleIndicate.__init__</vh></v>
</v>
<v t="ekr.20250121054835.291"><vh>class ShowPassingFlash</vh>
<v t="ekr.20250121054835.292"><vh>ShowPassingFlash.__init__</vh></v>
<v t="ekr.20250121054835.293"><vh>ShowPassingFlash.get_bounds</vh></v>
<v t="ekr.20250121054835.294"><vh>ShowPassingFlash.finish</vh></v>
</v>
<v t="ekr.20250121054835.295"><vh>class VShowPassingFlash</vh>
<v t="ekr.20250121054835.296"><vh>VShowPassingFlash.__init__</vh></v>
<v t="ekr.20250121054835.297"><vh>VShowPassingFlash.taper_kernel</vh></v>
<v t="ekr.20250121054835.298"><vh>VShowPassingFlash.begin</vh></v>
<v t="ekr.20250121054835.299"><vh>VShowPassingFlash.interpolate_submobject</vh></v>
<v t="ekr.20250121054835.300"><vh>VShowPassingFlash.finish</vh></v>
</v>
<v t="ekr.20250121054835.301"><vh>class FlashAround</vh>
<v t="ekr.20250121054835.302"><vh>FlashAround.__init__</vh></v>
<v t="ekr.20250121054835.303"><vh>FlashAround.get_path</vh></v>
</v>
<v t="ekr.20250121054835.304"><vh>class FlashUnder</vh>
<v t="ekr.20250121054835.305"><vh>FlashUnder.get_path</vh></v>
</v>
<v t="ekr.20250121054835.306"><vh>class ShowCreationThenDestruction</vh>
<v t="ekr.20250121054835.307"><vh>ShowCreationThenDestruction.__init__</vh></v>
</v>
<v t="ekr.20250121054835.308"><vh>class ShowCreationThenFadeOut</vh>
<v t="ekr.20250121054835.309"><vh>ShowCreationThenFadeOut.__init__</vh></v>
</v>
<v t="ekr.20250121054835.310"><vh>class AnimationOnSurroundingRectangle</vh>
<v t="ekr.20250121054835.311"><vh>AnimationOnSurroundingRectangle.__init__</vh></v>
</v>
<v t="ekr.20250121054835.312"><vh>class ShowPassingFlashAround</vh></v>
<v t="ekr.20250121054835.313"><vh>class ShowCreationThenDestructionAround</vh></v>
<v t="ekr.20250121054835.314"><vh>class ShowCreationThenFadeAround</vh></v>
<v t="ekr.20250121054835.315"><vh>class ApplyWave</vh>
<v t="ekr.20250121054835.316"><vh>ApplyWave.__init__</vh></v>
</v>
<v t="ekr.20250121054835.317"><vh>class WiggleOutThenIn</vh>
<v t="ekr.20250121054835.318"><vh>WiggleOutThenIn.__init__</vh></v>
<v t="ekr.20250121054835.319"><vh>WiggleOutThenIn.get_scale_about_point</vh></v>
<v t="ekr.20250121054835.320"><vh>WiggleOutThenIn.get_rotate_about_point</vh></v>
<v t="ekr.20250121054835.321"><vh>WiggleOutThenIn.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250121054835.322"><vh>class TurnInsideOut</vh>
<v t="ekr.20250121054835.323"><vh>TurnInsideOut.__init__</vh></v>
<v t="ekr.20250121054835.324"><vh>TurnInsideOut.create_target</vh></v>
</v>
<v t="ekr.20250121054835.325"><vh>class FlashyFadeIn</vh>
<v t="ekr.20250121054835.326"><vh>FlashyFadeIn.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.327"><vh>manimlib/animation/movement.py</vh>
<v t="ekr.20250121054835.328"><vh>class Homotopy</vh>
<v t="ekr.20250121054835.329"><vh>Homotopy.__init__</vh></v>
<v t="ekr.20250121054835.330"><vh>Homotopy.function_at_time_t</vh></v>
<v t="ekr.20250121054835.331"><vh>Homotopy.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250121054835.332"><vh>class SmoothedVectorizedHomotopy</vh></v>
<v t="ekr.20250121054835.333"><vh>class ComplexHomotopy</vh>
<v t="ekr.20250121054835.334"><vh>ComplexHomotopy.__init__</vh></v>
</v>
<v t="ekr.20250121054835.335"><vh>class PhaseFlow</vh>
<v t="ekr.20250121054835.336"><vh>PhaseFlow.__init__</vh></v>
<v t="ekr.20250121054835.337"><vh>PhaseFlow.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250121054835.338"><vh>class MoveAlongPath</vh>
<v t="ekr.20250121054835.339"><vh>MoveAlongPath.__init__</vh></v>
<v t="ekr.20250121054835.340"><vh>MoveAlongPath.interpolate_mobject</vh></v>
</v>
</v>
<v t="ekr.20250121054835.341"><vh>manimlib/animation/numbers.py</vh>
<v t="ekr.20250121054835.342"><vh>class ChangingDecimal</vh>
<v t="ekr.20250121054835.343"><vh>ChangingDecimal.__init__</vh></v>
<v t="ekr.20250121054835.344"><vh>ChangingDecimal.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250121054835.345"><vh>class ChangeDecimalToValue</vh>
<v t="ekr.20250121054835.346"><vh>ChangeDecimalToValue.__init__</vh></v>
</v>
<v t="ekr.20250121054835.347"><vh>class CountInFrom</vh>
<v t="ekr.20250121054835.348"><vh>CountInFrom.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.349"><vh>manimlib/animation/rotation.py</vh>
<v t="ekr.20250121054835.350"><vh>class Rotating</vh>
<v t="ekr.20250121054835.351"><vh>Rotating.__init__</vh></v>
<v t="ekr.20250121054835.352"><vh>Rotating.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250121054835.353"><vh>class Rotate</vh>
<v t="ekr.20250121054835.354"><vh>Rotate.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.355"><vh>manimlib/animation/specialized.py</vh>
<v t="ekr.20250121054835.356"><vh>class Broadcast</vh>
<v t="ekr.20250121054835.357"><vh>Broadcast.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.358"><vh>manimlib/animation/transform.py</vh>
<v t="ekr.20250121054835.359"><vh>class Transform</vh>
<v t="ekr.20250121054835.360"><vh>Transform.__init__</vh></v>
<v t="ekr.20250121054835.361"><vh>Transform.init_path_func</vh></v>
<v t="ekr.20250121054835.362"><vh>Transform.begin</vh></v>
<v t="ekr.20250121054835.363"><vh>Transform.finish</vh></v>
<v t="ekr.20250121054835.364"><vh>Transform.create_target</vh></v>
<v t="ekr.20250121054835.365"><vh>Transform.check_target_mobject_validity</vh></v>
<v t="ekr.20250121054835.366"><vh>Transform.clean_up_from_scene</vh></v>
<v t="ekr.20250121054835.367"><vh>Transform.update_config</vh></v>
<v t="ekr.20250121054835.368"><vh>Transform.get_all_mobjects</vh></v>
<v t="ekr.20250121054835.369"><vh>Transform.get_all_families_zipped</vh></v>
<v t="ekr.20250121054835.370"><vh>Transform.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250121054835.371"><vh>class ReplacementTransform</vh></v>
<v t="ekr.20250121054835.372"><vh>class TransformFromCopy</vh>
<v t="ekr.20250121054835.373"><vh>TransformFromCopy.__init__</vh></v>
</v>
<v t="ekr.20250121054835.374"><vh>class MoveToTarget</vh>
<v t="ekr.20250121054835.375"><vh>MoveToTarget.__init__</vh></v>
<v t="ekr.20250121054835.376"><vh>MoveToTarget.check_validity_of_input</vh></v>
</v>
<v t="ekr.20250121054835.377"><vh>class _MethodAnimation</vh>
<v t="ekr.20250121054835.378"><vh>_MethodAnimation.__init__</vh></v>
</v>
<v t="ekr.20250121054835.379"><vh>class ApplyMethod</vh>
<v t="ekr.20250121054835.380"><vh>ApplyMethod.__init__</vh></v>
<v t="ekr.20250121054835.381"><vh>ApplyMethod.check_validity_of_input</vh></v>
<v t="ekr.20250121054835.382"><vh>ApplyMethod.create_target</vh></v>
</v>
<v t="ekr.20250121054835.383"><vh>class ApplyPointwiseFunction</vh>
<v t="ekr.20250121054835.384"><vh>ApplyPointwiseFunction.__init__</vh></v>
</v>
<v t="ekr.20250121054835.385"><vh>class ApplyPointwiseFunctionToCenter</vh>
<v t="ekr.20250121054835.386"><vh>ApplyPointwiseFunctionToCenter.__init__</vh></v>
<v t="ekr.20250121054835.387"><vh>ApplyPointwiseFunctionToCenter.create_target</vh></v>
</v>
<v t="ekr.20250121054835.388"><vh>class FadeToColor</vh>
<v t="ekr.20250121054835.389"><vh>FadeToColor.__init__</vh></v>
</v>
<v t="ekr.20250121054835.390"><vh>class ScaleInPlace</vh>
<v t="ekr.20250121054835.391"><vh>ScaleInPlace.__init__</vh></v>
</v>
<v t="ekr.20250121054835.392"><vh>class ShrinkToCenter</vh>
<v t="ekr.20250121054835.393"><vh>ShrinkToCenter.__init__</vh></v>
</v>
<v t="ekr.20250121054835.394"><vh>class Restore</vh>
<v t="ekr.20250121054835.395"><vh>Restore.__init__</vh></v>
</v>
<v t="ekr.20250121054835.396"><vh>class ApplyFunction</vh>
<v t="ekr.20250121054835.397"><vh>ApplyFunction.__init__</vh></v>
<v t="ekr.20250121054835.398"><vh>ApplyFunction.create_target</vh></v>
</v>
<v t="ekr.20250121054835.399"><vh>class ApplyMatrix</vh>
<v t="ekr.20250121054835.400"><vh>ApplyMatrix.__init__</vh></v>
<v t="ekr.20250121054835.401"><vh>ApplyMatrix.initialize_matrix</vh></v>
</v>
<v t="ekr.20250121054835.402"><vh>class ApplyComplexFunction</vh>
<v t="ekr.20250121054835.403"><vh>ApplyComplexFunction.__init__</vh></v>
<v t="ekr.20250121054835.404"><vh>ApplyComplexFunction.init_path_func</vh></v>
</v>
<v t="ekr.20250121054835.405"><vh>class CyclicReplace</vh>
<v t="ekr.20250121054835.406"><vh>CyclicReplace.__init__</vh></v>
<v t="ekr.20250121054835.407"><vh>CyclicReplace.create_target</vh></v>
</v>
<v t="ekr.20250121054835.408"><vh>class Swap</vh></v>
</v>
<v t="ekr.20250121054835.409"><vh>manimlib/animation/transform_matching_parts.py</vh>
<v t="ekr.20250121054835.410"><vh>class TransformMatchingParts</vh>
<v t="ekr.20250121054835.411"><vh>TransformMatchingParts.__init__</vh></v>
<v t="ekr.20250121054835.412"><vh>TransformMatchingParts.add_transform</vh></v>
<v t="ekr.20250121054835.413"><vh>TransformMatchingParts.find_pairs_with_matching_shapes</vh></v>
<v t="ekr.20250121054835.414"><vh>TransformMatchingParts.clean_up_from_scene</vh></v>
</v>
<v t="ekr.20250121054835.415"><vh>class TransformMatchingShapes</vh></v>
<v t="ekr.20250121054835.416"><vh>class TransformMatchingStrings</vh>
<v t="ekr.20250121054835.417"><vh>TransformMatchingStrings.__init__</vh></v>
<v t="ekr.20250121054835.418"><vh>TransformMatchingStrings.matching_blocks</vh></v>
</v>
<v t="ekr.20250121054835.419"><vh>class TransformMatchingTex</vh></v>
</v>
<v t="ekr.20250121054835.420"><vh>manimlib/animation/update.py</vh>
<v t="ekr.20250121054835.421"><vh>class UpdateFromFunc</vh>
<v t="ekr.20250121054835.422"><vh>UpdateFromFunc.__init__</vh></v>
<v t="ekr.20250121054835.423"><vh>UpdateFromFunc.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250121054835.424"><vh>class UpdateFromAlphaFunc</vh>
<v t="ekr.20250121054835.425"><vh>UpdateFromAlphaFunc.__init__</vh></v>
<v t="ekr.20250121054835.426"><vh>UpdateFromAlphaFunc.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250121054835.427"><vh>class MaintainPositionRelativeTo</vh>
<v t="ekr.20250121054835.428"><vh>MaintainPositionRelativeTo.__init__</vh></v>
<v t="ekr.20250121054835.429"><vh>MaintainPositionRelativeTo.interpolate_mobject</vh></v>
</v>
</v>
</v>
<v t="ekr.20250121054835.430"><vh>C:/Repos/manim/manimlib/camera</vh>
<v t="ekr.20250121054835.431"><vh>manimlib/camera/__init__.py</vh></v>
<v t="ekr.20250121054835.432"><vh>manimlib/camera/camera.py</vh>
<v t="ekr.20250121054835.433"><vh>class Camera</vh>
<v t="ekr.20250121054835.434"><vh>Camera.__init__</vh></v>
<v t="ekr.20250121054835.435"><vh>Camera.init_frame</vh></v>
<v t="ekr.20250121054835.436"><vh>Camera.init_context</vh></v>
<v t="ekr.20250121054835.437"><vh>Camera.init_fbo</vh></v>
<v t="ekr.20250121054835.438"><vh>Camera.init_light_source</vh></v>
<v t="ekr.20250121054835.439"><vh>Camera.use_window_fbo</vh></v>
<v t="ekr.20250121054835.440"><vh>Camera.get_fbo</vh></v>
<v t="ekr.20250121054835.441"><vh>Camera.clear</vh></v>
<v t="ekr.20250121054835.442"><vh>Camera.blit</vh></v>
<v t="ekr.20250121054835.443"><vh>Camera.get_raw_fbo_data</vh></v>
<v t="ekr.20250121054835.444"><vh>Camera.get_image</vh></v>
<v t="ekr.20250121054835.445"><vh>Camera.get_pixel_array</vh></v>
<v t="ekr.20250121054835.446"><vh>Camera.get_texture</vh></v>
<v t="ekr.20250121054835.447"><vh>Camera.get_pixel_size</vh></v>
<v t="ekr.20250121054835.448"><vh>Camera.get_pixel_shape</vh></v>
<v t="ekr.20250121054835.449"><vh>Camera.get_pixel_width</vh></v>
<v t="ekr.20250121054835.450"><vh>Camera.get_pixel_height</vh></v>
<v t="ekr.20250121054835.451"><vh>Camera.get_aspect_ratio</vh></v>
<v t="ekr.20250121054835.452"><vh>Camera.get_frame_height</vh></v>
<v t="ekr.20250121054835.453"><vh>Camera.get_frame_width</vh></v>
<v t="ekr.20250121054835.454"><vh>Camera.get_frame_shape</vh></v>
<v t="ekr.20250121054835.455"><vh>Camera.get_frame_center</vh></v>
<v t="ekr.20250121054835.456"><vh>Camera.get_location</vh></v>
<v t="ekr.20250121054835.457"><vh>Camera.resize_frame_shape</vh></v>
<v t="ekr.20250121054835.458"><vh>Camera.capture</vh></v>
<v t="ekr.20250121054835.459"><vh>Camera.refresh_uniforms</vh></v>
</v>
<v t="ekr.20250121054835.460"><vh>class ThreeDCamera</vh>
<v t="ekr.20250121054835.461"><vh>ThreeDCamera.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.462"><vh>manimlib/camera/camera_frame.py</vh>
<v t="ekr.20250121054835.463"><vh>class CameraFrame</vh>
<v t="ekr.20250121054835.464"><vh>CameraFrame.__init__</vh></v>
<v t="ekr.20250121054835.465"><vh>CameraFrame.set_orientation</vh></v>
<v t="ekr.20250121054835.466"><vh>CameraFrame.get_orientation</vh></v>
<v t="ekr.20250121054835.467"><vh>CameraFrame.make_orientation_default</vh></v>
<v t="ekr.20250121054835.468"><vh>CameraFrame.to_default_state</vh></v>
<v t="ekr.20250121054835.469"><vh>CameraFrame.get_euler_angles</vh></v>
<v t="ekr.20250121054835.470"><vh>CameraFrame.get_theta</vh></v>
<v t="ekr.20250121054835.471"><vh>CameraFrame.get_phi</vh></v>
<v t="ekr.20250121054835.472"><vh>CameraFrame.get_gamma</vh></v>
<v t="ekr.20250121054835.473"><vh>CameraFrame.get_scale</vh></v>
<v t="ekr.20250121054835.474"><vh>CameraFrame.get_inverse_camera_rotation_matrix</vh></v>
<v t="ekr.20250121054835.475"><vh>CameraFrame.get_view_matrix</vh></v>
<v t="ekr.20250121054835.476"><vh>CameraFrame.get_inv_view_matrix</vh></v>
<v t="ekr.20250121054835.477"><vh>CameraFrame.interpolate</vh></v>
<v t="ekr.20250121054835.478"><vh>CameraFrame.rotate</vh></v>
<v t="ekr.20250121054835.479"><vh>CameraFrame.set_euler_angles</vh></v>
<v t="ekr.20250121054835.480"><vh>CameraFrame.increment_euler_angles</vh></v>
<v t="ekr.20250121054835.481"><vh>CameraFrame.set_euler_axes</vh></v>
<v t="ekr.20250121054835.482"><vh>CameraFrame.reorient</vh></v>
<v t="ekr.20250121054835.483"><vh>CameraFrame.set_theta</vh></v>
<v t="ekr.20250121054835.484"><vh>CameraFrame.set_phi</vh></v>
<v t="ekr.20250121054835.485"><vh>CameraFrame.set_gamma</vh></v>
<v t="ekr.20250121054835.486"><vh>CameraFrame.increment_theta</vh></v>
<v t="ekr.20250121054835.487"><vh>CameraFrame.increment_phi</vh></v>
<v t="ekr.20250121054835.488"><vh>CameraFrame.increment_gamma</vh></v>
<v t="ekr.20250121054835.489"><vh>CameraFrame.add_ambient_rotation</vh></v>
<v t="ekr.20250121054835.490"><vh>CameraFrame.set_focal_distance</vh></v>
<v t="ekr.20250121054835.491"><vh>CameraFrame.set_field_of_view</vh></v>
<v t="ekr.20250121054835.492"><vh>CameraFrame.get_shape</vh></v>
<v t="ekr.20250121054835.493"><vh>CameraFrame.get_aspect_ratio</vh></v>
<v t="ekr.20250121054835.494"><vh>CameraFrame.get_center</vh></v>
<v t="ekr.20250121054835.495"><vh>CameraFrame.get_width</vh></v>
<v t="ekr.20250121054835.496"><vh>CameraFrame.get_height</vh></v>
<v t="ekr.20250121054835.497"><vh>CameraFrame.get_focal_distance</vh></v>
<v t="ekr.20250121054835.498"><vh>CameraFrame.get_field_of_view</vh></v>
<v t="ekr.20250121054835.499"><vh>CameraFrame.get_implied_camera_location</vh></v>
<v t="ekr.20250121054835.500"><vh>CameraFrame.to_fixed_frame_point</vh></v>
<v t="ekr.20250121054835.501"><vh>CameraFrame.from_fixed_frame_point</vh></v>
</v>
</v>
</v>
<v t="ekr.20250121054835.502"><vh>C:/Repos/manim/manimlib/event_handler</vh>
<v t="ekr.20250121054835.503"><vh>manimlib/event_handler/__init__.py</vh></v>
<v t="ekr.20250121054835.504"><vh>manimlib/event_handler/event_dispatcher.py</vh>
<v t="ekr.20250121054835.505"><vh>class EventDispatcher</vh>
<v t="ekr.20250121054835.506"><vh>EventDispatcher.__init__</vh></v>
<v t="ekr.20250121054835.507"><vh>EventDispatcher.add_listner</vh></v>
<v t="ekr.20250121054835.508"><vh>EventDispatcher.remove_listner</vh></v>
<v t="ekr.20250121054835.509"><vh>EventDispatcher.dispatch</vh></v>
<v t="ekr.20250121054835.510"><vh>EventDispatcher.get_listners_count</vh></v>
<v t="ekr.20250121054835.511"><vh>EventDispatcher.get_mouse_point</vh></v>
<v t="ekr.20250121054835.512"><vh>EventDispatcher.get_mouse_drag_point</vh></v>
<v t="ekr.20250121054835.513"><vh>EventDispatcher.is_key_pressed</vh></v>
</v>
</v>
<v t="ekr.20250121054835.514"><vh>manimlib/event_handler/event_listner.py</vh>
<v t="ekr.20250121054835.515"><vh>class EventListener</vh>
<v t="ekr.20250121054835.516"><vh>EventListener.__init__</vh></v>
<v t="ekr.20250121054835.517"><vh>EventListener.__eq__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.518"><vh>manimlib/event_handler/event_type.py</vh>
<v t="ekr.20250121054835.519"><vh>class EventType</vh></v>
</v>
</v>
<v t="ekr.20250121054835.520"><vh>C:/Repos/manim/manimlib/mobject</vh>
<v t="ekr.20250121054835.521"><vh>manimlib/mobject/__init__.py</vh></v>
<v t="ekr.20250121054835.522"><vh>manimlib/mobject/boolean_ops.py</vh>
<v t="ekr.20250121054835.523"><vh>function: _convert_vmobject_to_skia_path</vh></v>
<v t="ekr.20250121054835.524"><vh>function: _convert_skia_path_to_vmobject</vh></v>
<v t="ekr.20250121054835.525"><vh>class Union</vh>
<v t="ekr.20250121054835.526"><vh>Union.__init__</vh></v>
</v>
<v t="ekr.20250121054835.527"><vh>class Difference</vh>
<v t="ekr.20250121054835.528"><vh>Difference.__init__</vh></v>
</v>
<v t="ekr.20250121054835.529"><vh>class Intersection</vh>
<v t="ekr.20250121054835.530"><vh>Intersection.__init__</vh></v>
</v>
<v t="ekr.20250121054835.531"><vh>class Exclusion</vh>
<v t="ekr.20250121054835.532"><vh>Exclusion.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.533"><vh>manimlib/mobject/changing.py</vh>
<v t="ekr.20250121054835.534"><vh>class AnimatedBoundary</vh>
<v t="ekr.20250121054835.535"><vh>AnimatedBoundary.__init__</vh></v>
<v t="ekr.20250121054835.536"><vh>AnimatedBoundary.update_boundary_copies</vh></v>
<v t="ekr.20250121054835.537"><vh>AnimatedBoundary.full_family_become_partial</vh></v>
</v>
<v t="ekr.20250121054835.538"><vh>class TracedPath</vh>
<v t="ekr.20250121054835.539"><vh>TracedPath.__init__</vh></v>
<v t="ekr.20250121054835.540"><vh>TracedPath.update_path</vh></v>
</v>
<v t="ekr.20250121054835.541"><vh>class TracingTail</vh>
<v t="ekr.20250121054835.542"><vh>TracingTail.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.543"><vh>manimlib/mobject/coordinate_systems.py</vh>
<v t="ekr.20250121054835.544"><vh>function: full_range_specifier</vh></v>
<v t="ekr.20250121054835.545"><vh>class CoordinateSystem</vh>
<v t="ekr.20250121054835.546"><vh>CoordinateSystem.__init__</vh></v>
<v t="ekr.20250121054835.547"><vh>CoordinateSystem.coords_to_point</vh></v>
<v t="ekr.20250121054835.548"><vh>CoordinateSystem.point_to_coords</vh></v>
<v t="ekr.20250121054835.549"><vh>CoordinateSystem.c2p</vh></v>
<v t="ekr.20250121054835.550"><vh>CoordinateSystem.p2c</vh></v>
<v t="ekr.20250121054835.551"><vh>CoordinateSystem.get_origin</vh></v>
<v t="ekr.20250121054835.552"><vh>CoordinateSystem.get_axes</vh></v>
<v t="ekr.20250121054835.553"><vh>CoordinateSystem.get_all_ranges</vh></v>
<v t="ekr.20250121054835.554"><vh>CoordinateSystem.get_axis</vh></v>
<v t="ekr.20250121054835.555"><vh>CoordinateSystem.get_x_axis</vh></v>
<v t="ekr.20250121054835.556"><vh>CoordinateSystem.get_y_axis</vh></v>
<v t="ekr.20250121054835.557"><vh>CoordinateSystem.get_z_axis</vh></v>
<v t="ekr.20250121054835.558"><vh>CoordinateSystem.get_x_axis_label</vh></v>
<v t="ekr.20250121054835.559"><vh>CoordinateSystem.get_y_axis_label</vh></v>
<v t="ekr.20250121054835.560"><vh>CoordinateSystem.get_axis_label</vh></v>
<v t="ekr.20250121054835.561"><vh>CoordinateSystem.get_axis_labels</vh></v>
<v t="ekr.20250121054835.562"><vh>CoordinateSystem.get_line_from_axis_to_point</vh></v>
<v t="ekr.20250121054835.563"><vh>CoordinateSystem.get_v_line</vh></v>
<v t="ekr.20250121054835.564"><vh>CoordinateSystem.get_h_line</vh></v>
<v t="ekr.20250121054835.565"><vh>CoordinateSystem.get_graph</vh></v>
<v t="ekr.20250121054835.566"><vh>CoordinateSystem.get_parametric_curve</vh></v>
<v t="ekr.20250121054835.567"><vh>CoordinateSystem.input_to_graph_point</vh></v>
<v t="ekr.20250121054835.568"><vh>CoordinateSystem.i2gp</vh></v>
<v t="ekr.20250121054835.569"><vh>CoordinateSystem.bind_graph_to_func</vh></v>
<v t="ekr.20250121054835.570"><vh>CoordinateSystem.get_graph_label</vh></v>
<v t="ekr.20250121054835.571"><vh>CoordinateSystem.get_v_line_to_graph</vh></v>
<v t="ekr.20250121054835.572"><vh>CoordinateSystem.get_h_line_to_graph</vh></v>
<v t="ekr.20250121054835.573"><vh>CoordinateSystem.get_scatterplot</vh></v>
<v t="ekr.20250121054835.574"><vh>CoordinateSystem.angle_of_tangent</vh></v>
<v t="ekr.20250121054835.575"><vh>CoordinateSystem.slope_of_tangent</vh></v>
<v t="ekr.20250121054835.576"><vh>CoordinateSystem.get_tangent_line</vh></v>
<v t="ekr.20250121054835.577"><vh>CoordinateSystem.get_riemann_rectangles</vh></v>
<v t="ekr.20250121054835.578"><vh>CoordinateSystem.get_area_under_graph</vh></v>
</v>
<v t="ekr.20250121054835.579"><vh>class Axes</vh>
<v t="ekr.20250121054835.580"><vh>Axes.__init__</vh></v>
<v t="ekr.20250121054835.581"><vh>Axes.create_axis</vh></v>
<v t="ekr.20250121054835.582"><vh>Axes.coords_to_point</vh></v>
<v t="ekr.20250121054835.583"><vh>Axes.point_to_coords</vh></v>
<v t="ekr.20250121054835.584"><vh>Axes.get_axes</vh></v>
<v t="ekr.20250121054835.585"><vh>Axes.get_all_ranges</vh></v>
<v t="ekr.20250121054835.586"><vh>Axes.add_coordinate_labels</vh></v>
</v>
<v t="ekr.20250121054835.587"><vh>class ThreeDAxes</vh>
<v t="ekr.20250121054835.588"><vh>ThreeDAxes.__init__</vh></v>
<v t="ekr.20250121054835.589"><vh>ThreeDAxes.get_all_ranges</vh></v>
<v t="ekr.20250121054835.590"><vh>ThreeDAxes.add_axis_labels</vh></v>
<v t="ekr.20250121054835.591"><vh>ThreeDAxes.get_graph</vh></v>
<v t="ekr.20250121054835.592"><vh>ThreeDAxes.get_parametric_surface</vh></v>
</v>
<v t="ekr.20250121054835.593"><vh>class NumberPlane</vh>
<v t="ekr.20250121054835.594"><vh>NumberPlane.__init__</vh></v>
<v t="ekr.20250121054835.595"><vh>NumberPlane.init_background_lines</vh></v>
<v t="ekr.20250121054835.596"><vh>NumberPlane.get_lines</vh></v>
<v t="ekr.20250121054835.597"><vh>NumberPlane.get_lines_parallel_to_axis</vh></v>
<v t="ekr.20250121054835.598"><vh>NumberPlane.get_x_unit_size</vh></v>
<v t="ekr.20250121054835.599"><vh>NumberPlane.get_y_unit_size</vh></v>
<v t="ekr.20250121054835.600"><vh>NumberPlane.get_axes</vh></v>
<v t="ekr.20250121054835.601"><vh>NumberPlane.get_vector</vh></v>
<v t="ekr.20250121054835.602"><vh>NumberPlane.prepare_for_nonlinear_transform</vh></v>
</v>
<v t="ekr.20250121054835.603"><vh>class ComplexPlane</vh>
<v t="ekr.20250121054835.604"><vh>ComplexPlane.number_to_point</vh></v>
<v t="ekr.20250121054835.605"><vh>ComplexPlane.n2p</vh></v>
<v t="ekr.20250121054835.606"><vh>ComplexPlane.point_to_number</vh></v>
<v t="ekr.20250121054835.607"><vh>ComplexPlane.p2n</vh></v>
<v t="ekr.20250121054835.608"><vh>ComplexPlane.get_default_coordinate_values</vh></v>
<v t="ekr.20250121054835.609"><vh>ComplexPlane.add_coordinate_labels</vh></v>
</v>
</v>
<v t="ekr.20250121054835.610"><vh>manimlib/mobject/frame.py</vh>
<v t="ekr.20250121054835.611"><vh>class ScreenRectangle</vh>
<v t="ekr.20250121054835.612"><vh>ScreenRectangle.__init__</vh></v>
</v>
<v t="ekr.20250121054835.613"><vh>class FullScreenRectangle</vh>
<v t="ekr.20250121054835.614"><vh>FullScreenRectangle.__init__</vh></v>
</v>
<v t="ekr.20250121054835.615"><vh>class FullScreenFadeRectangle</vh>
<v t="ekr.20250121054835.616"><vh>FullScreenFadeRectangle.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.617"><vh>manimlib/mobject/functions.py</vh>
<v t="ekr.20250121054835.618"><vh>class ParametricCurve</vh>
<v t="ekr.20250121054835.619"><vh>ParametricCurve.__init__</vh></v>
<v t="ekr.20250121054835.620"><vh>ParametricCurve.get_point_from_function</vh></v>
<v t="ekr.20250121054835.621"><vh>ParametricCurve.init_points</vh></v>
<v t="ekr.20250121054835.622"><vh>ParametricCurve.get_t_func</vh></v>
<v t="ekr.20250121054835.623"><vh>ParametricCurve.get_function</vh></v>
<v t="ekr.20250121054835.624"><vh>ParametricCurve.get_x_range</vh></v>
</v>
<v t="ekr.20250121054835.625"><vh>class FunctionGraph</vh>
<v t="ekr.20250121054835.626"><vh>FunctionGraph.__init__</vh></v>
<v t="ekr.20250121054835.627"><vh>FunctionGraph.parametric_function</vh></v>
</v>
<v t="ekr.20250121054835.628"><vh>class ImplicitFunction</vh>
<v t="ekr.20250121054835.629"><vh>ImplicitFunction.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.630"><vh>manimlib/mobject/geometry.py</vh>
<v t="ekr.20250121054835.631"><vh>class TipableVMobject</vh>
<v t="ekr.20250121054835.632"><vh>TipableVMobject.add_tip</vh></v>
<v t="ekr.20250121054835.633"><vh>TipableVMobject.create_tip</vh></v>
<v t="ekr.20250121054835.634"><vh>TipableVMobject.get_unpositioned_tip</vh></v>
<v t="ekr.20250121054835.635"><vh>TipableVMobject.position_tip</vh></v>
<v t="ekr.20250121054835.636"><vh>TipableVMobject.reset_endpoints_based_on_tip</vh></v>
<v t="ekr.20250121054835.637"><vh>TipableVMobject.asign_tip_attr</vh></v>
<v t="ekr.20250121054835.638"><vh>TipableVMobject.has_tip</vh></v>
<v t="ekr.20250121054835.639"><vh>TipableVMobject.has_start_tip</vh></v>
<v t="ekr.20250121054835.640"><vh>TipableVMobject.pop_tips</vh></v>
<v t="ekr.20250121054835.641"><vh>TipableVMobject.get_tips</vh></v>
<v t="ekr.20250121054835.642"><vh>TipableVMobject.get_tip</vh></v>
<v t="ekr.20250121054835.643"><vh>TipableVMobject.get_default_tip_length</vh></v>
<v t="ekr.20250121054835.644"><vh>TipableVMobject.get_first_handle</vh></v>
<v t="ekr.20250121054835.645"><vh>TipableVMobject.get_last_handle</vh></v>
<v t="ekr.20250121054835.646"><vh>TipableVMobject.get_end</vh></v>
<v t="ekr.20250121054835.647"><vh>TipableVMobject.get_start</vh></v>
<v t="ekr.20250121054835.648"><vh>TipableVMobject.get_length</vh></v>
</v>
<v t="ekr.20250121054835.649"><vh>class Arc</vh>
<v t="ekr.20250121054835.650"><vh>Arc.__init__</vh></v>
<v t="ekr.20250121054835.651"><vh>Arc.get_arc_center</vh></v>
<v t="ekr.20250121054835.652"><vh>Arc.get_start_angle</vh></v>
<v t="ekr.20250121054835.653"><vh>Arc.get_stop_angle</vh></v>
<v t="ekr.20250121054835.654"><vh>Arc.move_arc_center_to</vh></v>
</v>
<v t="ekr.20250121054835.655"><vh>class ArcBetweenPoints</vh>
<v t="ekr.20250121054835.656"><vh>ArcBetweenPoints.__init__</vh></v>
</v>
<v t="ekr.20250121054835.657"><vh>class CurvedArrow</vh>
<v t="ekr.20250121054835.658"><vh>CurvedArrow.__init__</vh></v>
</v>
<v t="ekr.20250121054835.659"><vh>class CurvedDoubleArrow</vh>
<v t="ekr.20250121054835.660"><vh>CurvedDoubleArrow.__init__</vh></v>
</v>
<v t="ekr.20250121054835.661"><vh>class Circle</vh>
<v t="ekr.20250121054835.662"><vh>Circle.__init__</vh></v>
<v t="ekr.20250121054835.663"><vh>Circle.surround</vh></v>
<v t="ekr.20250121054835.664"><vh>Circle.point_at_angle</vh></v>
<v t="ekr.20250121054835.665"><vh>Circle.get_radius</vh></v>
</v>
<v t="ekr.20250121054835.666"><vh>class Dot</vh>
<v t="ekr.20250121054835.667"><vh>Dot.__init__</vh></v>
</v>
<v t="ekr.20250121054835.668"><vh>class SmallDot</vh>
<v t="ekr.20250121054835.669"><vh>SmallDot.__init__</vh></v>
</v>
<v t="ekr.20250121054835.670"><vh>class Ellipse</vh>
<v t="ekr.20250121054835.671"><vh>Ellipse.__init__</vh></v>
</v>
<v t="ekr.20250121054835.672"><vh>class AnnularSector</vh>
<v t="ekr.20250121054835.673"><vh>AnnularSector.__init__</vh></v>
</v>
<v t="ekr.20250121054835.674"><vh>class Sector</vh>
<v t="ekr.20250121054835.675"><vh>Sector.__init__</vh></v>
</v>
<v t="ekr.20250121054835.676"><vh>class Annulus</vh>
<v t="ekr.20250121054835.677"><vh>Annulus.__init__</vh></v>
</v>
<v t="ekr.20250121054835.678"><vh>class Line</vh>
<v t="ekr.20250121054835.679"><vh>Line.__init__</vh></v>
<v t="ekr.20250121054835.680"><vh>Line.set_points_by_ends</vh></v>
<v t="ekr.20250121054835.681"><vh>Line.set_path_arc</vh></v>
<v t="ekr.20250121054835.682"><vh>Line.set_start_and_end_attrs</vh></v>
<v t="ekr.20250121054835.683"><vh>Line.pointify</vh></v>
<v t="ekr.20250121054835.684"><vh>Line.put_start_and_end_on</vh></v>
<v t="ekr.20250121054835.685"><vh>Line.get_vector</vh></v>
<v t="ekr.20250121054835.686"><vh>Line.get_unit_vector</vh></v>
<v t="ekr.20250121054835.687"><vh>Line.get_angle</vh></v>
<v t="ekr.20250121054835.688"><vh>Line.get_projection</vh></v>
<v t="ekr.20250121054835.689"><vh>Line.get_slope</vh></v>
<v t="ekr.20250121054835.690"><vh>Line.set_angle</vh></v>
<v t="ekr.20250121054835.691"><vh>Line.set_length</vh></v>
<v t="ekr.20250121054835.692"><vh>Line.get_arc_length</vh></v>
</v>
<v t="ekr.20250121054835.693"><vh>class DashedLine</vh>
<v t="ekr.20250121054835.694"><vh>DashedLine.__init__</vh></v>
<v t="ekr.20250121054835.695"><vh>DashedLine.calculate_num_dashes</vh></v>
<v t="ekr.20250121054835.696"><vh>DashedLine.get_start</vh></v>
<v t="ekr.20250121054835.697"><vh>DashedLine.get_end</vh></v>
<v t="ekr.20250121054835.698"><vh>DashedLine.get_first_handle</vh></v>
<v t="ekr.20250121054835.699"><vh>DashedLine.get_last_handle</vh></v>
</v>
<v t="ekr.20250121054835.700"><vh>class TangentLine</vh>
<v t="ekr.20250121054835.701"><vh>TangentLine.__init__</vh></v>
</v>
<v t="ekr.20250121054835.702"><vh>class Elbow</vh>
<v t="ekr.20250121054835.703"><vh>Elbow.__init__</vh></v>
</v>
<v t="ekr.20250121054835.704"><vh>class StrokeArrow</vh>
<v t="ekr.20250121054835.705"><vh>StrokeArrow.__init__</vh></v>
<v t="ekr.20250121054835.706"><vh>StrokeArrow.set_points_by_ends</vh></v>
<v t="ekr.20250121054835.707"><vh>StrokeArrow.insert_tip_anchor</vh></v>
<v t="ekr.20250121054835.708"><vh>StrokeArrow.create_tip_with_stroke_width</vh></v>
<v t="ekr.20250121054835.709"><vh>StrokeArrow.reset_tip</vh></v>
<v t="ekr.20250121054835.710"><vh>StrokeArrow.set_stroke</vh></v>
<v t="ekr.20250121054835.711"><vh>StrokeArrow._handle_scale_side_effects</vh></v>
</v>
<v t="ekr.20250121054835.712"><vh>class Arrow</vh>
<v t="ekr.20250121054835.713"><vh>Arrow.__init__</vh></v>
<v t="ekr.20250121054835.714"><vh>Arrow.get_key_dimensions</vh></v>
<v t="ekr.20250121054835.715"><vh>Arrow.set_points_by_ends</vh></v>
<v t="ekr.20250121054835.716"><vh>Arrow.reset_points_around_ends</vh></v>
<v t="ekr.20250121054835.717"><vh>Arrow.get_start</vh></v>
<v t="ekr.20250121054835.718"><vh>Arrow.get_end</vh></v>
<v t="ekr.20250121054835.719"><vh>Arrow.get_start_and_end</vh></v>
<v t="ekr.20250121054835.720"><vh>Arrow.put_start_and_end_on</vh></v>
<v t="ekr.20250121054835.721"><vh>Arrow.scale</vh></v>
<v t="ekr.20250121054835.722"><vh>Arrow.set_thickness</vh></v>
<v t="ekr.20250121054835.723"><vh>Arrow.set_path_arc</vh></v>
<v t="ekr.20250121054835.724"><vh>Arrow.set_perpendicular_to_camera</vh></v>
</v>
<v t="ekr.20250121054835.725"><vh>class Vector</vh>
<v t="ekr.20250121054835.726"><vh>Vector.__init__</vh></v>
</v>
<v t="ekr.20250121054835.727"><vh>class CubicBezier</vh>
<v t="ekr.20250121054835.728"><vh>CubicBezier.__init__</vh></v>
</v>
<v t="ekr.20250121054835.729"><vh>class Polygon</vh>
<v t="ekr.20250121054835.730"><vh>Polygon.__init__</vh></v>
<v t="ekr.20250121054835.731"><vh>Polygon.get_vertices</vh></v>
<v t="ekr.20250121054835.732"><vh>Polygon.round_corners</vh></v>
</v>
<v t="ekr.20250121054835.733"><vh>class Polyline</vh>
<v t="ekr.20250121054835.734"><vh>Polyline.__init__</vh></v>
</v>
<v t="ekr.20250121054835.735"><vh>class RegularPolygon</vh>
<v t="ekr.20250121054835.736"><vh>RegularPolygon.__init__</vh></v>
</v>
<v t="ekr.20250121054835.737"><vh>class Triangle</vh>
<v t="ekr.20250121054835.738"><vh>Triangle.__init__</vh></v>
</v>
<v t="ekr.20250121054835.739"><vh>class ArrowTip</vh>
<v t="ekr.20250121054835.740"><vh>ArrowTip.__init__</vh></v>
<v t="ekr.20250121054835.741"><vh>ArrowTip.get_base</vh></v>
<v t="ekr.20250121054835.742"><vh>ArrowTip.get_tip_point</vh></v>
<v t="ekr.20250121054835.743"><vh>ArrowTip.get_vector</vh></v>
<v t="ekr.20250121054835.744"><vh>ArrowTip.get_angle</vh></v>
<v t="ekr.20250121054835.745"><vh>ArrowTip.get_length</vh></v>
</v>
<v t="ekr.20250121054835.746"><vh>class Rectangle</vh>
<v t="ekr.20250121054835.747"><vh>Rectangle.__init__</vh></v>
<v t="ekr.20250121054835.748"><vh>Rectangle.surround</vh></v>
</v>
<v t="ekr.20250121054835.749"><vh>class Square</vh>
<v t="ekr.20250121054835.750"><vh>Square.__init__</vh></v>
</v>
<v t="ekr.20250121054835.751"><vh>class RoundedRectangle</vh>
<v t="ekr.20250121054835.752"><vh>RoundedRectangle.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.753"><vh>manimlib/mobject/interactive.py</vh>
<v t="ekr.20250121054835.754"><vh>class MotionMobject</vh>
<v t="ekr.20250121054835.755"><vh>MotionMobject.__init__</vh></v>
<v t="ekr.20250121054835.756"><vh>MotionMobject.mob_on_mouse_drag</vh></v>
</v>
<v t="ekr.20250121054835.757"><vh>class Button</vh>
<v t="ekr.20250121054835.758"><vh>Button.__init__</vh></v>
<v t="ekr.20250121054835.759"><vh>Button.mob_on_mouse_press</vh></v>
</v>
<v t="ekr.20250121054835.760"><vh>class ControlMobject</vh>
<v t="ekr.20250121054835.761"><vh>ControlMobject.__init__</vh></v>
<v t="ekr.20250121054835.762"><vh>ControlMobject.set_value</vh></v>
<v t="ekr.20250121054835.763"><vh>ControlMobject.assert_value</vh></v>
<v t="ekr.20250121054835.764"><vh>ControlMobject.set_value_anim</vh></v>
</v>
<v t="ekr.20250121054835.765"><vh>class EnableDisableButton</vh>
<v t="ekr.20250121054835.766"><vh>EnableDisableButton.__init__</vh></v>
<v t="ekr.20250121054835.767"><vh>EnableDisableButton.assert_value</vh></v>
<v t="ekr.20250121054835.768"><vh>EnableDisableButton.set_value_anim</vh></v>
<v t="ekr.20250121054835.769"><vh>EnableDisableButton.toggle_value</vh></v>
<v t="ekr.20250121054835.770"><vh>EnableDisableButton.on_mouse_press</vh></v>
</v>
<v t="ekr.20250121054835.771"><vh>class Checkbox</vh>
<v t="ekr.20250121054835.772"><vh>Checkbox.__init__</vh></v>
<v t="ekr.20250121054835.773"><vh>Checkbox.assert_value</vh></v>
<v t="ekr.20250121054835.774"><vh>Checkbox.toggle_value</vh></v>
<v t="ekr.20250121054835.775"><vh>Checkbox.set_value_anim</vh></v>
<v t="ekr.20250121054835.776"><vh>Checkbox.on_mouse_press</vh></v>
<v t="ekr.20250121054835.777"><vh>Checkbox.get_checkmark</vh></v>
<v t="ekr.20250121054835.778"><vh>Checkbox.get_cross</vh></v>
</v>
<v t="ekr.20250121054835.779"><vh>class LinearNumberSlider</vh>
<v t="ekr.20250121054835.780"><vh>LinearNumberSlider.__init__</vh></v>
<v t="ekr.20250121054835.781"><vh>LinearNumberSlider.assert_value</vh></v>
<v t="ekr.20250121054835.782"><vh>LinearNumberSlider.set_value_anim</vh></v>
<v t="ekr.20250121054835.783"><vh>LinearNumberSlider.slider_on_mouse_drag</vh></v>
<v t="ekr.20250121054835.784"><vh>LinearNumberSlider.get_value_from_point</vh></v>
</v>
<v t="ekr.20250121054835.785"><vh>class ColorSliders</vh>
<v t="ekr.20250121054835.786"><vh>ColorSliders.__init__</vh></v>
<v t="ekr.20250121054835.787"><vh>ColorSliders.get_background</vh></v>
<v t="ekr.20250121054835.788"><vh>ColorSliders.set_value</vh></v>
<v t="ekr.20250121054835.789"><vh>ColorSliders.get_value</vh></v>
<v t="ekr.20250121054835.790"><vh>ColorSliders.get_picked_color</vh></v>
<v t="ekr.20250121054835.791"><vh>ColorSliders.get_picked_opacity</vh></v>
</v>
<v t="ekr.20250121054835.792"><vh>class Textbox</vh>
<v t="ekr.20250121054835.793"><vh>Textbox.__init__</vh></v>
<v t="ekr.20250121054835.794"><vh>Textbox.set_value_anim</vh></v>
<v t="ekr.20250121054835.795"><vh>Textbox.update_text</vh></v>
<v t="ekr.20250121054835.796"><vh>Textbox.active_anim</vh></v>
<v t="ekr.20250121054835.797"><vh>Textbox.box_on_mouse_press</vh></v>
<v t="ekr.20250121054835.798"><vh>Textbox.on_key_press</vh></v>
</v>
<v t="ekr.20250121054835.799"><vh>class ControlPanel</vh>
<v t="ekr.20250121054835.800"><vh>ControlPanel.__init__</vh></v>
<v t="ekr.20250121054835.801"><vh>ControlPanel.move_panel_and_controls_to_panel_opener</vh></v>
<v t="ekr.20250121054835.802"><vh>ControlPanel.add_controls</vh></v>
<v t="ekr.20250121054835.803"><vh>ControlPanel.remove_controls</vh></v>
<v t="ekr.20250121054835.804"><vh>ControlPanel.open_panel</vh></v>
<v t="ekr.20250121054835.805"><vh>ControlPanel.close_panel</vh></v>
<v t="ekr.20250121054835.806"><vh>ControlPanel.panel_opener_on_mouse_drag</vh></v>
<v t="ekr.20250121054835.807"><vh>ControlPanel.panel_on_mouse_scroll</vh></v>
</v>
</v>
<v t="ekr.20250121054835.808"><vh>manimlib/mobject/matrix.py</vh>
<v t="ekr.20250121054835.809"><vh>class Matrix</vh>
<v t="ekr.20250121054835.810"><vh>Matrix.__init__</vh></v>
<v t="ekr.20250121054835.811"><vh>Matrix.copy</vh></v>
<v t="ekr.20250121054835.812"><vh>Matrix.create_mobject_matrix</vh></v>
<v t="ekr.20250121054835.813"><vh>Matrix.element_to_mobject</vh></v>
<v t="ekr.20250121054835.814"><vh>Matrix.create_brackets</vh></v>
<v t="ekr.20250121054835.815"><vh>Matrix.get_column</vh></v>
<v t="ekr.20250121054835.816"><vh>Matrix.get_row</vh></v>
<v t="ekr.20250121054835.817"><vh>Matrix.get_columns</vh></v>
<v t="ekr.20250121054835.818"><vh>Matrix.get_rows</vh></v>
<v t="ekr.20250121054835.819"><vh>Matrix.set_column_colors</vh></v>
<v t="ekr.20250121054835.820"><vh>Matrix.add_background_to_entries</vh></v>
<v t="ekr.20250121054835.821"><vh>Matrix.swap_entry_for_dots</vh></v>
<v t="ekr.20250121054835.822"><vh>Matrix.swap_entries_for_ellipses</vh></v>
<v t="ekr.20250121054835.823"><vh>Matrix.get_mob_matrix</vh></v>
<v t="ekr.20250121054835.824"><vh>Matrix.get_entries</vh></v>
<v t="ekr.20250121054835.825"><vh>Matrix.get_brackets</vh></v>
<v t="ekr.20250121054835.826"><vh>Matrix.get_ellipses</vh></v>
</v>
<v t="ekr.20250121054835.827"><vh>class DecimalMatrix</vh>
<v t="ekr.20250121054835.828"><vh>DecimalMatrix.__init__</vh></v>
<v t="ekr.20250121054835.829"><vh>DecimalMatrix.element_to_mobject</vh></v>
</v>
<v t="ekr.20250121054835.830"><vh>class IntegerMatrix</vh>
<v t="ekr.20250121054835.831"><vh>IntegerMatrix.__init__</vh></v>
</v>
<v t="ekr.20250121054835.832"><vh>class TexMatrix</vh>
<v t="ekr.20250121054835.833"><vh>TexMatrix.__init__</vh></v>
</v>
<v t="ekr.20250121054835.834"><vh>class MobjectMatrix</vh>
<v t="ekr.20250121054835.835"><vh>MobjectMatrix.__init__</vh></v>
<v t="ekr.20250121054835.836"><vh>MobjectMatrix.element_to_mobject</vh></v>
</v>
</v>
<v t="ekr.20250121054835.837"><vh>manimlib/mobject/mobject.py</vh>
<v t="ekr.20250121054835.838"><vh>class Mobject</vh>
<v t="ekr.20250121054835.839"><vh>Mobject.__init__</vh></v>
<v t="ekr.20250121054835.840"><vh>Mobject.__str__</vh></v>
<v t="ekr.20250121054835.841"><vh>Mobject.__add__</vh></v>
<v t="ekr.20250121054835.842"><vh>Mobject.__mul__</vh></v>
<v t="ekr.20250121054835.843"><vh>Mobject.init_data</vh></v>
<v t="ekr.20250121054835.844"><vh>Mobject.init_uniforms</vh></v>
<v t="ekr.20250121054835.845"><vh>Mobject.init_colors</vh></v>
<v t="ekr.20250121054835.846"><vh>Mobject.init_points</vh></v>
<v t="ekr.20250121054835.847"><vh>Mobject.set_uniforms</vh></v>
<v t="ekr.20250121054835.848"><vh>Mobject.animate</vh></v>
<v t="ekr.20250121054835.849"><vh>Mobject.always</vh></v>
<v t="ekr.20250121054835.850"><vh>Mobject.f_always</vh></v>
<v t="ekr.20250121054835.851"><vh>Mobject.note_changed_data</vh></v>
<v t="ekr.20250121054835.852"><vh>Mobject.affects_data</vh></v>
<v t="ekr.20250121054835.853"><vh>Mobject.affects_family_data</vh></v>
<v t="ekr.20250121054835.854"><vh>Mobject.set_data</vh></v>
<v t="ekr.20250121054835.855"><vh>Mobject.resize_points</vh></v>
<v t="ekr.20250121054835.856"><vh>Mobject.set_points</vh></v>
<v t="ekr.20250121054835.857"><vh>Mobject.append_points</vh></v>
<v t="ekr.20250121054835.858"><vh>Mobject.reverse_points</vh></v>
<v t="ekr.20250121054835.859"><vh>Mobject.apply_points_function</vh></v>
<v t="ekr.20250121054835.860"><vh>Mobject.match_points</vh></v>
<v t="ekr.20250121054835.861"><vh>Mobject.get_points</vh></v>
<v t="ekr.20250121054835.862"><vh>Mobject.clear_points</vh></v>
<v t="ekr.20250121054835.863"><vh>Mobject.get_num_points</vh></v>
<v t="ekr.20250121054835.864"><vh>Mobject.get_all_points</vh></v>
<v t="ekr.20250121054835.865"><vh>Mobject.has_points</vh></v>
<v t="ekr.20250121054835.866"><vh>Mobject.get_bounding_box</vh></v>
<v t="ekr.20250121054835.867"><vh>Mobject.compute_bounding_box</vh></v>
<v t="ekr.20250121054835.868"><vh>Mobject.refresh_bounding_box</vh></v>
<v t="ekr.20250121054835.869"><vh>Mobject.are_points_touching</vh></v>
<v t="ekr.20250121054835.870"><vh>Mobject.is_point_touching</vh></v>
<v t="ekr.20250121054835.871"><vh>Mobject.is_touching</vh></v>
<v t="ekr.20250121054835.872"><vh>Mobject.__getitem__</vh></v>
<v t="ekr.20250121054835.873"><vh>Mobject.__iter__</vh></v>
<v t="ekr.20250121054835.874"><vh>Mobject.__len__</vh></v>
<v t="ekr.20250121054835.875"><vh>Mobject.split</vh></v>
<v t="ekr.20250121054835.876"><vh>Mobject.note_changed_family</vh></v>
<v t="ekr.20250121054835.877"><vh>Mobject.get_family</vh></v>
<v t="ekr.20250121054835.878"><vh>Mobject.family_members_with_points</vh></v>
<v t="ekr.20250121054835.879"><vh>Mobject.get_ancestors</vh></v>
<v t="ekr.20250121054835.880"><vh>Mobject.add</vh></v>
<v t="ekr.20250121054835.881"><vh>Mobject.remove</vh></v>
<v t="ekr.20250121054835.882"><vh>Mobject.clear</vh></v>
<v t="ekr.20250121054835.883"><vh>Mobject.add_to_back</vh></v>
<v t="ekr.20250121054835.884"><vh>Mobject.replace_submobject</vh></v>
<v t="ekr.20250121054835.885"><vh>Mobject.insert_submobject</vh></v>
<v t="ekr.20250121054835.886"><vh>Mobject.set_submobjects</vh></v>
<v t="ekr.20250121054835.887"><vh>Mobject.digest_mobject_attrs</vh></v>
<v t="ekr.20250121054835.888"><vh>Mobject.arrange</vh></v>
<v t="ekr.20250121054835.889"><vh>Mobject.arrange_in_grid</vh></v>
<v t="ekr.20250121054835.890"><vh>Mobject.arrange_to_fit_dim</vh></v>
<v t="ekr.20250121054835.891"><vh>Mobject.arrange_to_fit_width</vh></v>
<v t="ekr.20250121054835.892"><vh>Mobject.arrange_to_fit_height</vh></v>
<v t="ekr.20250121054835.893"><vh>Mobject.arrange_to_fit_depth</vh></v>
<v t="ekr.20250121054835.894"><vh>Mobject.sort</vh></v>
<v t="ekr.20250121054835.895"><vh>Mobject.shuffle</vh></v>
<v t="ekr.20250121054835.896"><vh>Mobject.reverse_submobjects</vh></v>
<v t="ekr.20250121054835.897"><vh>Mobject.stash_mobject_pointers</vh></v>
<v t="ekr.20250121054835.898"><vh>Mobject.serialize</vh></v>
<v t="ekr.20250121054835.899"><vh>Mobject.deserialize</vh></v>
<v t="ekr.20250121054835.900"><vh>Mobject.deepcopy</vh></v>
<v t="ekr.20250121054835.901"><vh>Mobject.copy</vh></v>
<v t="ekr.20250121054835.902"><vh>Mobject.generate_target</vh></v>
<v t="ekr.20250121054835.903"><vh>Mobject.save_state</vh></v>
<v t="ekr.20250121054835.904"><vh>Mobject.restore</vh></v>
<v t="ekr.20250121054835.905"><vh>Mobject.become</vh></v>
<v t="ekr.20250121054835.906"><vh>Mobject.looks_identical</vh></v>
<v t="ekr.20250121054835.907"><vh>Mobject.has_same_shape_as</vh></v>
<v t="ekr.20250121054835.908"><vh>Mobject.replicate</vh></v>
<v t="ekr.20250121054835.909"><vh>Mobject.get_grid</vh></v>
<v t="ekr.20250121054835.910"><vh>Mobject.init_updaters</vh></v>
<v t="ekr.20250121054835.911"><vh>Mobject.update</vh></v>
<v t="ekr.20250121054835.912"><vh>Mobject.get_updaters</vh></v>
<v t="ekr.20250121054835.913"><vh>Mobject.add_updater</vh></v>
<v t="ekr.20250121054835.914"><vh>Mobject.insert_updater</vh></v>
<v t="ekr.20250121054835.915"><vh>Mobject.remove_updater</vh></v>
<v t="ekr.20250121054835.916"><vh>Mobject.clear_updaters</vh></v>
<v t="ekr.20250121054835.917"><vh>Mobject.match_updaters</vh></v>
<v t="ekr.20250121054835.918"><vh>Mobject.suspend_updating</vh></v>
<v t="ekr.20250121054835.919"><vh>Mobject.resume_updating</vh></v>
<v t="ekr.20250121054835.920"><vh>Mobject.has_updaters</vh></v>
<v t="ekr.20250121054835.921"><vh>Mobject.refresh_has_updater_status</vh></v>
<v t="ekr.20250121054835.922"><vh>Mobject.is_changing</vh></v>
<v t="ekr.20250121054835.923"><vh>Mobject.set_animating_status</vh></v>
<v t="ekr.20250121054835.924"><vh>Mobject.shift</vh></v>
<v t="ekr.20250121054835.925"><vh>Mobject.scale</vh></v>
<v t="ekr.20250121054835.926"><vh>Mobject._handle_scale_side_effects</vh></v>
<v t="ekr.20250121054835.927"><vh>Mobject.stretch</vh></v>
<v t="ekr.20250121054835.928"><vh>Mobject.rotate_about_origin</vh></v>
<v t="ekr.20250121054835.929"><vh>Mobject.rotate</vh></v>
<v t="ekr.20250121054835.930"><vh>Mobject.flip</vh></v>
<v t="ekr.20250121054835.931"><vh>Mobject.apply_function</vh></v>
<v t="ekr.20250121054835.932"><vh>Mobject.apply_function_to_position</vh></v>
<v t="ekr.20250121054835.933"><vh>Mobject.apply_function_to_submobject_positions</vh></v>
<v t="ekr.20250121054835.934"><vh>Mobject.apply_matrix</vh></v>
<v t="ekr.20250121054835.935"><vh>Mobject.apply_complex_function</vh></v>
<v t="ekr.20250121054835.936"><vh>Mobject.wag</vh></v>
<v t="ekr.20250121054835.937"><vh>Mobject.center</vh></v>
<v t="ekr.20250121054835.938"><vh>Mobject.align_on_border</vh></v>
<v t="ekr.20250121054835.939"><vh>Mobject.to_corner</vh></v>
<v t="ekr.20250121054835.940"><vh>Mobject.to_edge</vh></v>
<v t="ekr.20250121054835.941"><vh>Mobject.next_to</vh></v>
<v t="ekr.20250121054835.942"><vh>Mobject.shift_onto_screen</vh></v>
<v t="ekr.20250121054835.943"><vh>Mobject.is_off_screen</vh></v>
<v t="ekr.20250121054835.944"><vh>Mobject.stretch_about_point</vh></v>
<v t="ekr.20250121054835.945"><vh>Mobject.stretch_in_place</vh></v>
<v t="ekr.20250121054835.946"><vh>Mobject.rescale_to_fit</vh></v>
<v t="ekr.20250121054835.947"><vh>Mobject.stretch_to_fit_width</vh></v>
<v t="ekr.20250121054835.948"><vh>Mobject.stretch_to_fit_height</vh></v>
<v t="ekr.20250121054835.949"><vh>Mobject.stretch_to_fit_depth</vh></v>
<v t="ekr.20250121054835.950"><vh>Mobject.set_width</vh></v>
<v t="ekr.20250121054835.951"><vh>Mobject.set_height</vh></v>
<v t="ekr.20250121054835.952"><vh>Mobject.set_depth</vh></v>
<v t="ekr.20250121054835.953"><vh>Mobject.set_max_width</vh></v>
<v t="ekr.20250121054835.954"><vh>Mobject.set_max_height</vh></v>
<v t="ekr.20250121054835.955"><vh>Mobject.set_max_depth</vh></v>
<v t="ekr.20250121054835.956"><vh>Mobject.set_min_width</vh></v>
<v t="ekr.20250121054835.957"><vh>Mobject.set_min_height</vh></v>
<v t="ekr.20250121054835.958"><vh>Mobject.set_min_depth</vh></v>
<v t="ekr.20250121054835.959"><vh>Mobject.set_shape</vh></v>
<v t="ekr.20250121054835.960"><vh>Mobject.set_coord</vh></v>
<v t="ekr.20250121054835.961"><vh>Mobject.set_x</vh></v>
<v t="ekr.20250121054835.962"><vh>Mobject.set_y</vh></v>
<v t="ekr.20250121054835.963"><vh>Mobject.set_z</vh></v>
<v t="ekr.20250121054835.964"><vh>Mobject.set_z_index</vh></v>
<v t="ekr.20250121054835.965"><vh>Mobject.space_out_submobjects</vh></v>
<v t="ekr.20250121054835.966"><vh>Mobject.move_to</vh></v>
<v t="ekr.20250121054835.967"><vh>Mobject.replace</vh></v>
<v t="ekr.20250121054835.968"><vh>Mobject.surround</vh></v>
<v t="ekr.20250121054835.969"><vh>Mobject.put_start_and_end_on</vh></v>
<v t="ekr.20250121054835.970"><vh>Mobject.set_rgba_array</vh></v>
<v t="ekr.20250121054835.971"><vh>Mobject.set_color_by_rgba_func</vh></v>
<v t="ekr.20250121054835.972"><vh>Mobject.set_color_by_rgb_func</vh></v>
<v t="ekr.20250121054835.973"><vh>Mobject.set_rgba_array_by_color</vh></v>
<v t="ekr.20250121054835.974"><vh>Mobject.set_color</vh></v>
<v t="ekr.20250121054835.975"><vh>Mobject.set_opacity</vh></v>
<v t="ekr.20250121054835.976"><vh>Mobject.get_color</vh></v>
<v t="ekr.20250121054835.977"><vh>Mobject.get_opacity</vh></v>
<v t="ekr.20250121054835.978"><vh>Mobject.get_opacities</vh></v>
<v t="ekr.20250121054835.979"><vh>Mobject.set_color_by_gradient</vh></v>
<v t="ekr.20250121054835.980"><vh>Mobject.set_submobject_colors_by_gradient</vh></v>
<v t="ekr.20250121054835.981"><vh>Mobject.fade</vh></v>
<v t="ekr.20250121054835.982"><vh>Mobject.get_shading</vh></v>
<v t="ekr.20250121054835.983"><vh>Mobject.set_shading</vh></v>
<v t="ekr.20250121054835.984"><vh>Mobject.get_reflectiveness</vh></v>
<v t="ekr.20250121054835.985"><vh>Mobject.get_gloss</vh></v>
<v t="ekr.20250121054835.986"><vh>Mobject.get_shadow</vh></v>
<v t="ekr.20250121054835.987"><vh>Mobject.set_reflectiveness</vh></v>
<v t="ekr.20250121054835.988"><vh>Mobject.set_gloss</vh></v>
<v t="ekr.20250121054835.989"><vh>Mobject.set_shadow</vh></v>
<v t="ekr.20250121054835.990"><vh>Mobject.add_background_rectangle</vh></v>
<v t="ekr.20250121054835.991"><vh>Mobject.add_background_rectangle_to_submobjects</vh></v>
<v t="ekr.20250121054835.992"><vh>Mobject.add_background_rectangle_to_family_members_with_points</vh></v>
<v t="ekr.20250121054835.993"><vh>Mobject.get_bounding_box_point</vh></v>
<v t="ekr.20250121054835.994"><vh>Mobject.get_edge_center</vh></v>
<v t="ekr.20250121054835.995"><vh>Mobject.get_corner</vh></v>
<v t="ekr.20250121054835.996"><vh>Mobject.get_all_corners</vh></v>
<v t="ekr.20250121054835.997"><vh>Mobject.get_center</vh></v>
<v t="ekr.20250121054835.998"><vh>Mobject.get_center_of_mass</vh></v>
<v t="ekr.20250121054835.999"><vh>Mobject.get_boundary_point</vh></v>
<v t="ekr.20250121054835.1000"><vh>Mobject.get_continuous_bounding_box_point</vh></v>
<v t="ekr.20250121054835.1001"><vh>Mobject.get_top</vh></v>
<v t="ekr.20250121054835.1002"><vh>Mobject.get_bottom</vh></v>
<v t="ekr.20250121054835.1003"><vh>Mobject.get_right</vh></v>
<v t="ekr.20250121054835.1004"><vh>Mobject.get_left</vh></v>
<v t="ekr.20250121054835.1005"><vh>Mobject.get_zenith</vh></v>
<v t="ekr.20250121054835.1006"><vh>Mobject.get_nadir</vh></v>
<v t="ekr.20250121054835.1007"><vh>Mobject.length_over_dim</vh></v>
<v t="ekr.20250121054835.1008"><vh>Mobject.get_width</vh></v>
<v t="ekr.20250121054835.1009"><vh>Mobject.get_height</vh></v>
<v t="ekr.20250121054835.1010"><vh>Mobject.get_depth</vh></v>
<v t="ekr.20250121054835.1011"><vh>Mobject.get_shape</vh></v>
<v t="ekr.20250121054835.1012"><vh>Mobject.get_coord</vh></v>
<v t="ekr.20250121054835.1013"><vh>Mobject.get_x</vh></v>
<v t="ekr.20250121054835.1014"><vh>Mobject.get_y</vh></v>
<v t="ekr.20250121054835.1015"><vh>Mobject.get_z</vh></v>
<v t="ekr.20250121054835.1016"><vh>Mobject.get_start</vh></v>
<v t="ekr.20250121054835.1017"><vh>Mobject.get_end</vh></v>
<v t="ekr.20250121054835.1018"><vh>Mobject.get_start_and_end</vh></v>
<v t="ekr.20250121054835.1019"><vh>Mobject.point_from_proportion</vh></v>
<v t="ekr.20250121054835.1020"><vh>Mobject.pfp</vh></v>
<v t="ekr.20250121054835.1021"><vh>Mobject.get_pieces</vh></v>
<v t="ekr.20250121054835.1022"><vh>Mobject.get_z_index_reference_point</vh></v>
<v t="ekr.20250121054835.1023"><vh>Mobject.match_color</vh></v>
<v t="ekr.20250121054835.1024"><vh>Mobject.match_style</vh></v>
<v t="ekr.20250121054835.1025"><vh>Mobject.match_dim_size</vh></v>
<v t="ekr.20250121054835.1026"><vh>Mobject.match_width</vh></v>
<v t="ekr.20250121054835.1027"><vh>Mobject.match_height</vh></v>
<v t="ekr.20250121054835.1028"><vh>Mobject.match_depth</vh></v>
<v t="ekr.20250121054835.1029"><vh>Mobject.match_coord</vh></v>
<v t="ekr.20250121054835.1030"><vh>Mobject.match_x</vh></v>
<v t="ekr.20250121054835.1031"><vh>Mobject.match_y</vh></v>
<v t="ekr.20250121054835.1032"><vh>Mobject.match_z</vh></v>
<v t="ekr.20250121054835.1033"><vh>Mobject.align_to</vh></v>
<v t="ekr.20250121054835.1034"><vh>Mobject.get_group_class</vh></v>
<v t="ekr.20250121054835.1035"><vh>Mobject.is_aligned_with</vh></v>
<v t="ekr.20250121054835.1036"><vh>Mobject.align_data_and_family</vh></v>
<v t="ekr.20250121054835.1037"><vh>Mobject.align_data</vh></v>
<v t="ekr.20250121054835.1038"><vh>Mobject.align_points</vh></v>
<v t="ekr.20250121054835.1039"><vh>Mobject.align_family</vh></v>
<v t="ekr.20250121054835.1040"><vh>Mobject.push_self_into_submobjects</vh></v>
<v t="ekr.20250121054835.1041"><vh>Mobject.add_n_more_submobjects</vh></v>
<v t="ekr.20250121054835.1042"><vh>Mobject.invisible_copy</vh></v>
<v t="ekr.20250121054835.1043"><vh>Mobject.interpolate</vh></v>
<v t="ekr.20250121054835.1044"><vh>Mobject.pointwise_become_partial</vh></v>
<v t="ekr.20250121054835.1045"><vh>Mobject.lock_data</vh></v>
<v t="ekr.20250121054835.1046"><vh>Mobject.lock_uniforms</vh></v>
<v t="ekr.20250121054835.1047"><vh>Mobject.lock_matching_data</vh></v>
<v t="ekr.20250121054835.1048"><vh>Mobject.unlock_data</vh></v>
<v t="ekr.20250121054835.1049"><vh>Mobject.affects_shader_info_id</vh></v>
<v t="ekr.20250121054835.1050"><vh>Mobject.set_uniform</vh></v>
<v t="ekr.20250121054835.1051"><vh>Mobject.fix_in_frame</vh></v>
<v t="ekr.20250121054835.1052"><vh>Mobject.unfix_from_frame</vh></v>
<v t="ekr.20250121054835.1053"><vh>Mobject.is_fixed_in_frame</vh></v>
<v t="ekr.20250121054835.1054"><vh>Mobject.apply_depth_test</vh></v>
<v t="ekr.20250121054835.1055"><vh>Mobject.deactivate_depth_test</vh></v>
<v t="ekr.20250121054835.1056"><vh>Mobject.set_clip_plane</vh></v>
<v t="ekr.20250121054835.1057"><vh>Mobject.deactivate_clip_plane</vh></v>
<v t="ekr.20250121054835.1058"><vh>Mobject.replace_shader_code</vh></v>
<v t="ekr.20250121054835.1059"><vh>Mobject.set_color_by_code</vh></v>
<v t="ekr.20250121054835.1060"><vh>Mobject.set_color_by_xyz_func</vh></v>
<v t="ekr.20250121054835.1061"><vh>Mobject.init_shader_wrapper</vh></v>
<v t="ekr.20250121054835.1062"><vh>Mobject.refresh_shader_wrapper_id</vh></v>
<v t="ekr.20250121054835.1063"><vh>Mobject.get_shader_wrapper</vh></v>
<v t="ekr.20250121054835.1064"><vh>Mobject.get_shader_wrapper_list</vh></v>
<v t="ekr.20250121054835.1065"><vh>Mobject.get_shader_data</vh></v>
<v t="ekr.20250121054835.1066"><vh>Mobject.get_uniforms</vh></v>
<v t="ekr.20250121054835.1067"><vh>Mobject.get_shader_vert_indices</vh></v>
<v t="ekr.20250121054835.1068"><vh>Mobject.render</vh></v>
<v t="ekr.20250121054835.1069"><vh>Mobject.init_event_listners</vh></v>
<v t="ekr.20250121054835.1070"><vh>Mobject.add_event_listner</vh></v>
<v t="ekr.20250121054835.1071"><vh>Mobject.remove_event_listner</vh></v>
<v t="ekr.20250121054835.1072"><vh>Mobject.clear_event_listners</vh></v>
<v t="ekr.20250121054835.1073"><vh>Mobject.get_event_listners</vh></v>
<v t="ekr.20250121054835.1074"><vh>Mobject.get_family_event_listners</vh></v>
<v t="ekr.20250121054835.1075"><vh>Mobject.get_has_event_listner</vh></v>
<v t="ekr.20250121054835.1076"><vh>Mobject.add_mouse_motion_listner</vh></v>
<v t="ekr.20250121054835.1077"><vh>Mobject.remove_mouse_motion_listner</vh></v>
<v t="ekr.20250121054835.1078"><vh>Mobject.add_mouse_press_listner</vh></v>
<v t="ekr.20250121054835.1079"><vh>Mobject.remove_mouse_press_listner</vh></v>
<v t="ekr.20250121054835.1080"><vh>Mobject.add_mouse_release_listner</vh></v>
<v t="ekr.20250121054835.1081"><vh>Mobject.remove_mouse_release_listner</vh></v>
<v t="ekr.20250121054835.1082"><vh>Mobject.add_mouse_drag_listner</vh></v>
<v t="ekr.20250121054835.1083"><vh>Mobject.remove_mouse_drag_listner</vh></v>
<v t="ekr.20250121054835.1084"><vh>Mobject.add_mouse_scroll_listner</vh></v>
<v t="ekr.20250121054835.1085"><vh>Mobject.remove_mouse_scroll_listner</vh></v>
<v t="ekr.20250121054835.1086"><vh>Mobject.add_key_press_listner</vh></v>
<v t="ekr.20250121054835.1087"><vh>Mobject.remove_key_press_listner</vh></v>
<v t="ekr.20250121054835.1088"><vh>Mobject.add_key_release_listner</vh></v>
<v t="ekr.20250121054835.1089"><vh>Mobject.remove_key_release_listner</vh></v>
<v t="ekr.20250121054835.1090"><vh>Mobject.throw_error_if_no_points</vh></v>
</v>
<v t="ekr.20250121054835.1091"><vh>class Group</vh>
<v t="ekr.20250121054835.1092"><vh>Group.__init__</vh></v>
<v t="ekr.20250121054835.1093"><vh>Group._ingest_args</vh></v>
<v t="ekr.20250121054835.1094"><vh>Group.__add__</vh></v>
<v t="ekr.20250121054835.1095"><vh>Group.__getitem__</vh></v>
</v>
<v t="ekr.20250121054835.1096"><vh>class Point</vh>
<v t="ekr.20250121054835.1097"><vh>Point.__init__</vh></v>
<v t="ekr.20250121054835.1098"><vh>Point.get_width</vh></v>
<v t="ekr.20250121054835.1099"><vh>Point.get_height</vh></v>
<v t="ekr.20250121054835.1100"><vh>Point.get_location</vh></v>
<v t="ekr.20250121054835.1101"><vh>Point.get_bounding_box_point</vh></v>
<v t="ekr.20250121054835.1102"><vh>Point.set_location</vh></v>
</v>
<v t="ekr.20250121054835.1103"><vh>class _AnimationBuilder</vh>
<v t="ekr.20250121054835.1104"><vh>_AnimationBuilder.__init__</vh></v>
<v t="ekr.20250121054835.1105"><vh>_AnimationBuilder.__getattr__</vh></v>
<v t="ekr.20250121054835.1106"><vh>_AnimationBuilder.__call__</vh></v>
<v t="ekr.20250121054835.1107"><vh>_AnimationBuilder.set_anim_args</vh></v>
<v t="ekr.20250121054835.1108"><vh>_AnimationBuilder.build</vh></v>
</v>
<v t="ekr.20250121054835.1109"><vh>function: override_animate</vh></v>
<v t="ekr.20250121054835.1110"><vh>class _UpdaterBuilder</vh>
<v t="ekr.20250121054835.1111"><vh>_UpdaterBuilder.__init__</vh></v>
<v t="ekr.20250121054835.1112"><vh>_UpdaterBuilder.__getattr__</vh></v>
</v>
<v t="ekr.20250121054835.1113"><vh>class _FunctionalUpdaterBuilder</vh>
<v t="ekr.20250121054835.1114"><vh>_FunctionalUpdaterBuilder.__init__</vh></v>
<v t="ekr.20250121054835.1115"><vh>_FunctionalUpdaterBuilder.__getattr__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1116"><vh>manimlib/mobject/mobject_update_utils.py</vh>
<v t="ekr.20250121054835.1117"><vh>function: assert_is_mobject_method</vh></v>
<v t="ekr.20250121054835.1118"><vh>function: always</vh></v>
<v t="ekr.20250121054835.1119"><vh>function: f_always</vh></v>
<v t="ekr.20250121054835.1120"><vh>function: always_redraw</vh></v>
<v t="ekr.20250121054835.1121"><vh>function: always_shift</vh></v>
<v t="ekr.20250121054835.1122"><vh>function: always_rotate</vh></v>
<v t="ekr.20250121054835.1123"><vh>function: turn_animation_into_updater</vh></v>
<v t="ekr.20250121054835.1124"><vh>function: cycle_animation</vh></v>
</v>
<v t="ekr.20250121054835.1125"><vh>manimlib/mobject/number_line.py</vh>
<v t="ekr.20250121054835.1126"><vh>class NumberLine</vh>
<v t="ekr.20250121054835.1127"><vh>NumberLine.__init__</vh></v>
<v t="ekr.20250121054835.1128"><vh>NumberLine.get_tick_range</vh></v>
<v t="ekr.20250121054835.1129"><vh>NumberLine.add_ticks</vh></v>
<v t="ekr.20250121054835.1130"><vh>NumberLine.get_tick</vh></v>
<v t="ekr.20250121054835.1131"><vh>NumberLine.get_tick_marks</vh></v>
<v t="ekr.20250121054835.1132"><vh>NumberLine.number_to_point</vh></v>
<v t="ekr.20250121054835.1133"><vh>NumberLine.point_to_number</vh></v>
<v t="ekr.20250121054835.1134"><vh>NumberLine.n2p</vh></v>
<v t="ekr.20250121054835.1135"><vh>NumberLine.p2n</vh></v>
<v t="ekr.20250121054835.1136"><vh>NumberLine.get_unit_size</vh></v>
<v t="ekr.20250121054835.1137"><vh>NumberLine.get_number_mobject</vh></v>
<v t="ekr.20250121054835.1138"><vh>NumberLine.add_numbers</vh></v>
</v>
<v t="ekr.20250121054835.1139"><vh>class UnitInterval</vh>
<v t="ekr.20250121054835.1140"><vh>UnitInterval.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1141"><vh>manimlib/mobject/numbers.py</vh>
<v t="ekr.20250121054835.1142"><vh>function: char_to_cahced_mob</vh></v>
<v t="ekr.20250121054835.1143"><vh>class DecimalNumber</vh>
<v t="ekr.20250121054835.1144"><vh>DecimalNumber.__init__</vh></v>
<v t="ekr.20250121054835.1145"><vh>DecimalNumber.set_submobjects_from_number</vh></v>
<v t="ekr.20250121054835.1146"><vh>DecimalNumber.get_num_string</vh></v>
<v t="ekr.20250121054835.1147"><vh>DecimalNumber.char_to_mob</vh></v>
<v t="ekr.20250121054835.1148"><vh>DecimalNumber.interpolate</vh></v>
<v t="ekr.20250121054835.1149"><vh>DecimalNumber.get_font_size</vh></v>
<v t="ekr.20250121054835.1150"><vh>DecimalNumber.get_formatter</vh></v>
<v t="ekr.20250121054835.1151"><vh>DecimalNumber.get_complex_formatter</vh></v>
<v t="ekr.20250121054835.1152"><vh>DecimalNumber.get_tex</vh></v>
<v t="ekr.20250121054835.1153"><vh>DecimalNumber.set_value</vh></v>
<v t="ekr.20250121054835.1154"><vh>DecimalNumber._handle_scale_side_effects</vh></v>
<v t="ekr.20250121054835.1155"><vh>DecimalNumber.get_value</vh></v>
<v t="ekr.20250121054835.1156"><vh>DecimalNumber.increment_value</vh></v>
</v>
<v t="ekr.20250121054835.1157"><vh>class Integer</vh>
<v t="ekr.20250121054835.1158"><vh>Integer.__init__</vh></v>
<v t="ekr.20250121054835.1159"><vh>Integer.get_value</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1160"><vh>manimlib/mobject/probability.py</vh>
<v t="ekr.20250121054835.1161"><vh>class SampleSpace</vh>
<v t="ekr.20250121054835.1162"><vh>SampleSpace.__init__</vh></v>
<v t="ekr.20250121054835.1163"><vh>SampleSpace.add_title</vh></v>
<v t="ekr.20250121054835.1164"><vh>SampleSpace.add_label</vh></v>
<v t="ekr.20250121054835.1165"><vh>SampleSpace.complete_p_list</vh></v>
<v t="ekr.20250121054835.1166"><vh>SampleSpace.get_division_along_dimension</vh></v>
<v t="ekr.20250121054835.1167"><vh>SampleSpace.get_horizontal_division</vh></v>
<v t="ekr.20250121054835.1168"><vh>SampleSpace.get_vertical_division</vh></v>
<v t="ekr.20250121054835.1169"><vh>SampleSpace.divide_horizontally</vh></v>
<v t="ekr.20250121054835.1170"><vh>SampleSpace.divide_vertically</vh></v>
<v t="ekr.20250121054835.1171"><vh>SampleSpace.get_subdivision_braces_and_labels</vh></v>
<v t="ekr.20250121054835.1172"><vh>SampleSpace.get_side_braces_and_labels</vh></v>
<v t="ekr.20250121054835.1173"><vh>SampleSpace.get_top_braces_and_labels</vh></v>
<v t="ekr.20250121054835.1174"><vh>SampleSpace.get_bottom_braces_and_labels</vh></v>
<v t="ekr.20250121054835.1175"><vh>SampleSpace.add_braces_and_labels</vh></v>
<v t="ekr.20250121054835.1176"><vh>SampleSpace.__getitem__</vh></v>
</v>
<v t="ekr.20250121054835.1177"><vh>class BarChart</vh>
<v t="ekr.20250121054835.1178"><vh>BarChart.__init__</vh></v>
<v t="ekr.20250121054835.1179"><vh>BarChart.add_axes</vh></v>
<v t="ekr.20250121054835.1180"><vh>BarChart.add_bars</vh></v>
<v t="ekr.20250121054835.1181"><vh>BarChart.change_bar_values</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1182"><vh>manimlib/mobject/shape_matchers.py</vh>
<v t="ekr.20250121054835.1183"><vh>class SurroundingRectangle</vh>
<v t="ekr.20250121054835.1184"><vh>SurroundingRectangle.__init__</vh></v>
<v t="ekr.20250121054835.1185"><vh>SurroundingRectangle.surround</vh></v>
<v t="ekr.20250121054835.1186"><vh>SurroundingRectangle.set_buff</vh></v>
</v>
<v t="ekr.20250121054835.1187"><vh>class BackgroundRectangle</vh>
<v t="ekr.20250121054835.1188"><vh>BackgroundRectangle.__init__</vh></v>
<v t="ekr.20250121054835.1189"><vh>BackgroundRectangle.pointwise_become_partial</vh></v>
<v t="ekr.20250121054835.1190"><vh>BackgroundRectangle.set_style</vh></v>
<v t="ekr.20250121054835.1191"><vh>BackgroundRectangle.get_fill_color</vh></v>
</v>
<v t="ekr.20250121054835.1192"><vh>class Cross</vh>
<v t="ekr.20250121054835.1193"><vh>Cross.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1194"><vh>class Underline</vh>
<v t="ekr.20250121054835.1195"><vh>Underline.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1196"><vh>manimlib/mobject/three_dimensions.py</vh>
<v t="ekr.20250121054835.1197"><vh>class SurfaceMesh</vh>
<v t="ekr.20250121054835.1198"><vh>SurfaceMesh.__init__</vh></v>
<v t="ekr.20250121054835.1199"><vh>SurfaceMesh.init_points</vh></v>
</v>
<v t="ekr.20250121054835.1200"><vh>class Sphere</vh>
<v t="ekr.20250121054835.1201"><vh>Sphere.__init__</vh></v>
<v t="ekr.20250121054835.1202"><vh>Sphere.uv_func</vh></v>
</v>
<v t="ekr.20250121054835.1203"><vh>class Torus</vh>
<v t="ekr.20250121054835.1204"><vh>Torus.__init__</vh></v>
<v t="ekr.20250121054835.1205"><vh>Torus.uv_func</vh></v>
</v>
<v t="ekr.20250121054835.1206"><vh>class Cylinder</vh>
<v t="ekr.20250121054835.1207"><vh>Cylinder.__init__</vh></v>
<v t="ekr.20250121054835.1208"><vh>Cylinder.init_points</vh></v>
<v t="ekr.20250121054835.1209"><vh>Cylinder.uv_func</vh></v>
</v>
<v t="ekr.20250121054835.1210"><vh>class Cone</vh>
<v t="ekr.20250121054835.1211"><vh>Cone.__init__</vh></v>
<v t="ekr.20250121054835.1212"><vh>Cone.uv_func</vh></v>
</v>
<v t="ekr.20250121054835.1213"><vh>class Line3D</vh>
<v t="ekr.20250121054835.1214"><vh>Line3D.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1215"><vh>class Disk3D</vh>
<v t="ekr.20250121054835.1216"><vh>Disk3D.__init__</vh></v>
<v t="ekr.20250121054835.1217"><vh>Disk3D.uv_func</vh></v>
</v>
<v t="ekr.20250121054835.1218"><vh>class Square3D</vh>
<v t="ekr.20250121054835.1219"><vh>Square3D.__init__</vh></v>
<v t="ekr.20250121054835.1220"><vh>Square3D.uv_func</vh></v>
</v>
<v t="ekr.20250121054835.1221"><vh>function: square_to_cube_faces</vh></v>
<v t="ekr.20250121054835.1222"><vh>class Cube</vh>
<v t="ekr.20250121054835.1223"><vh>Cube.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1224"><vh>class Prism</vh>
<v t="ekr.20250121054835.1225"><vh>Prism.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1226"><vh>class VGroup3D</vh>
<v t="ekr.20250121054835.1227"><vh>VGroup3D.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1228"><vh>class VCube</vh>
<v t="ekr.20250121054835.1229"><vh>VCube.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1230"><vh>class VPrism</vh>
<v t="ekr.20250121054835.1231"><vh>VPrism.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1232"><vh>class Dodecahedron</vh>
<v t="ekr.20250121054835.1233"><vh>Dodecahedron.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1234"><vh>class Prismify</vh>
<v t="ekr.20250121054835.1235"><vh>Prismify.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1236"><vh>manimlib/mobject/value_tracker.py</vh>
<v t="ekr.20250121054835.1237"><vh>class ValueTracker</vh>
<v t="ekr.20250121054835.1238"><vh>ValueTracker.__init__</vh></v>
<v t="ekr.20250121054835.1239"><vh>ValueTracker.init_uniforms</vh></v>
<v t="ekr.20250121054835.1240"><vh>ValueTracker.get_value</vh></v>
<v t="ekr.20250121054835.1241"><vh>ValueTracker.set_value</vh></v>
<v t="ekr.20250121054835.1242"><vh>ValueTracker.increment_value</vh></v>
</v>
<v t="ekr.20250121054835.1243"><vh>class ExponentialValueTracker</vh>
<v t="ekr.20250121054835.1244"><vh>ExponentialValueTracker.get_value</vh></v>
<v t="ekr.20250121054835.1245"><vh>ExponentialValueTracker.set_value</vh></v>
</v>
<v t="ekr.20250121054835.1246"><vh>class ComplexValueTracker</vh></v>
</v>
<v t="ekr.20250121054835.1247"><vh>manimlib/mobject/vector_field.py</vh>
<v t="ekr.20250121054835.1248"><vh>function: get_vectorized_rgb_gradient_function</vh></v>
<v t="ekr.20250121054835.1249"><vh>function: get_rgb_gradient_function</vh></v>
<v t="ekr.20250121054835.1250"><vh>function: ode_solution_points</vh></v>
<v t="ekr.20250121054835.1251"><vh>function: move_along_vector_field</vh></v>
<v t="ekr.20250121054835.1252"><vh>function: move_submobjects_along_vector_field</vh></v>
<v t="ekr.20250121054835.1253"><vh>function: move_points_along_vector_field</vh></v>
<v t="ekr.20250121054835.1254"><vh>function: get_sample_coords</vh></v>
<v t="ekr.20250121054835.1255"><vh>function: vectorize</vh></v>
<v t="ekr.20250121054835.1256"><vh>class VectorField</vh>
<v t="ekr.20250121054835.1257"><vh>VectorField.__init__</vh></v>
<v t="ekr.20250121054835.1258"><vh>VectorField.init_points</vh></v>
<v t="ekr.20250121054835.1259"><vh>VectorField.get_sample_points</vh></v>
<v t="ekr.20250121054835.1260"><vh>VectorField.init_base_stroke_width_array</vh></v>
<v t="ekr.20250121054835.1261"><vh>VectorField.set_sample_coords</vh></v>
<v t="ekr.20250121054835.1262"><vh>VectorField.set_stroke</vh></v>
<v t="ekr.20250121054835.1263"><vh>VectorField.set_stroke_width</vh></v>
<v t="ekr.20250121054835.1264"><vh>VectorField.update_sample_points</vh></v>
<v t="ekr.20250121054835.1265"><vh>VectorField.update_vectors</vh></v>
</v>
<v t="ekr.20250121054835.1266"><vh>class TimeVaryingVectorField</vh>
<v t="ekr.20250121054835.1267"><vh>TimeVaryingVectorField.__init__</vh></v>
<v t="ekr.20250121054835.1268"><vh>TimeVaryingVectorField.increment_time</vh></v>
</v>
<v t="ekr.20250121054835.1269"><vh>class StreamLines</vh>
<v t="ekr.20250121054835.1270"><vh>StreamLines.__init__</vh></v>
<v t="ekr.20250121054835.1271"><vh>StreamLines.point_func</vh></v>
<v t="ekr.20250121054835.1272"><vh>StreamLines.draw_lines</vh></v>
<v t="ekr.20250121054835.1273"><vh>StreamLines.get_sample_coords</vh></v>
<v t="ekr.20250121054835.1274"><vh>StreamLines.init_style</vh></v>
</v>
<v t="ekr.20250121054835.1275"><vh>class AnimatedStreamLines</vh>
<v t="ekr.20250121054835.1276"><vh>AnimatedStreamLines.__init__</vh></v>
<v t="ekr.20250121054835.1277"><vh>AnimatedStreamLines.update</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1278"><vh>C:/Repos/manim/manimlib/mobject/svg</vh>
<v t="ekr.20250121054835.1279"><vh>manimlib/mobject/svg/__init__.py</vh></v>
<v t="ekr.20250121054835.1280"><vh>manimlib/mobject/svg/brace.py</vh>
<v t="ekr.20250121054835.1281"><vh>class Brace</vh>
<v t="ekr.20250121054835.1282"><vh>Brace.__init__</vh></v>
<v t="ekr.20250121054835.1283"><vh>Brace.set_initial_width</vh></v>
<v t="ekr.20250121054835.1284"><vh>Brace.put_at_tip</vh></v>
<v t="ekr.20250121054835.1285"><vh>Brace.get_text</vh></v>
<v t="ekr.20250121054835.1286"><vh>Brace.get_tex</vh></v>
<v t="ekr.20250121054835.1287"><vh>Brace.get_tip</vh></v>
<v t="ekr.20250121054835.1288"><vh>Brace.get_direction</vh></v>
</v>
<v t="ekr.20250121054835.1289"><vh>class BraceLabel</vh>
<v t="ekr.20250121054835.1290"><vh>BraceLabel.__init__</vh></v>
<v t="ekr.20250121054835.1291"><vh>BraceLabel.creation_anim</vh></v>
<v t="ekr.20250121054835.1292"><vh>BraceLabel.shift_brace</vh></v>
<v t="ekr.20250121054835.1293"><vh>BraceLabel.change_label</vh></v>
<v t="ekr.20250121054835.1294"><vh>BraceLabel.change_brace_label</vh></v>
<v t="ekr.20250121054835.1295"><vh>BraceLabel.copy</vh></v>
</v>
<v t="ekr.20250121054835.1296"><vh>class BraceText</vh></v>
</v>
<v t="ekr.20250121054835.1297"><vh>manimlib/mobject/svg/drawings.py</vh>
<v t="ekr.20250121054835.1298"><vh>class Checkmark</vh></v>
<v t="ekr.20250121054835.1299"><vh>class Exmark</vh></v>
<v t="ekr.20250121054835.1300"><vh>class Lightbulb</vh>
<v t="ekr.20250121054835.1301"><vh>Lightbulb.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1302"><vh>class Speedometer</vh>
<v t="ekr.20250121054835.1303"><vh>Speedometer.__init__</vh></v>
<v t="ekr.20250121054835.1304"><vh>Speedometer.get_center</vh></v>
<v t="ekr.20250121054835.1305"><vh>Speedometer.get_needle_tip</vh></v>
<v t="ekr.20250121054835.1306"><vh>Speedometer.get_needle_angle</vh></v>
<v t="ekr.20250121054835.1307"><vh>Speedometer.rotate_needle</vh></v>
<v t="ekr.20250121054835.1308"><vh>Speedometer.move_needle_to_velocity</vh></v>
</v>
<v t="ekr.20250121054835.1309"><vh>class Laptop</vh>
<v t="ekr.20250121054835.1310"><vh>Laptop.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1311"><vh>class VideoIcon</vh>
<v t="ekr.20250121054835.1312"><vh>VideoIcon.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1313"><vh>class VideoSeries</vh>
<v t="ekr.20250121054835.1314"><vh>VideoSeries.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1315"><vh>class Clock</vh>
<v t="ekr.20250121054835.1316"><vh>Clock.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1317"><vh>class ClockPassesTime</vh>
<v t="ekr.20250121054835.1318"><vh>ClockPassesTime.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1319"><vh>class Bubble</vh>
<v t="ekr.20250121054835.1320"><vh>Bubble.__init__</vh></v>
<v t="ekr.20250121054835.1321"><vh>Bubble.get_body</vh></v>
<v t="ekr.20250121054835.1322"><vh>Bubble.get_tip</vh></v>
<v t="ekr.20250121054835.1323"><vh>Bubble.get_bubble_center</vh></v>
<v t="ekr.20250121054835.1324"><vh>Bubble.move_tip_to</vh></v>
<v t="ekr.20250121054835.1325"><vh>Bubble.flip</vh></v>
<v t="ekr.20250121054835.1326"><vh>Bubble.pin_to</vh></v>
<v t="ekr.20250121054835.1327"><vh>Bubble.position_mobject_inside</vh></v>
<v t="ekr.20250121054835.1328"><vh>Bubble.add_content</vh></v>
<v t="ekr.20250121054835.1329"><vh>Bubble.write</vh></v>
<v t="ekr.20250121054835.1330"><vh>Bubble.resize_to_content</vh></v>
<v t="ekr.20250121054835.1331"><vh>Bubble.clear</vh></v>
</v>
<v t="ekr.20250121054835.1332"><vh>class SpeechBubble</vh>
<v t="ekr.20250121054835.1333"><vh>SpeechBubble.__init__</vh></v>
<v t="ekr.20250121054835.1334"><vh>SpeechBubble.get_body</vh></v>
</v>
<v t="ekr.20250121054835.1335"><vh>class ThoughtBubble</vh>
<v t="ekr.20250121054835.1336"><vh>ThoughtBubble.__init__</vh></v>
<v t="ekr.20250121054835.1337"><vh>ThoughtBubble.get_body</vh></v>
</v>
<v t="ekr.20250121054835.1338"><vh>class OldSpeechBubble</vh></v>
<v t="ekr.20250121054835.1339"><vh>class DoubleSpeechBubble</vh></v>
<v t="ekr.20250121054835.1340"><vh>class OldThoughtBubble</vh>
<v t="ekr.20250121054835.1341"><vh>OldThoughtBubble.get_body</vh></v>
<v t="ekr.20250121054835.1342"><vh>OldThoughtBubble.make_green_screen</vh></v>
</v>
<v t="ekr.20250121054835.1343"><vh>class VectorizedEarth</vh>
<v t="ekr.20250121054835.1344"><vh>VectorizedEarth.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1345"><vh>class Piano</vh>
<v t="ekr.20250121054835.1346"><vh>Piano.__init__</vh></v>
<v t="ekr.20250121054835.1347"><vh>Piano.add_white_keys</vh></v>
<v t="ekr.20250121054835.1348"><vh>Piano.add_black_keys</vh></v>
<v t="ekr.20250121054835.1349"><vh>Piano.sort_keys</vh></v>
</v>
<v t="ekr.20250121054835.1350"><vh>class Piano3D</vh>
<v t="ekr.20250121054835.1351"><vh>Piano3D.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1352"><vh>class DieFace</vh>
<v t="ekr.20250121054835.1353"><vh>DieFace.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1354"><vh>class Dartboard</vh>
<v t="ekr.20250121054835.1355"><vh>Dartboard.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1356"><vh>manimlib/mobject/svg/old_tex_mobject.py</vh>
<v t="ekr.20250121054835.1357"><vh>class SingleStringTex</vh>
<v t="ekr.20250121054835.1358"><vh>SingleStringTex.__init__</vh></v>
<v t="ekr.20250121054835.1359"><vh>SingleStringTex.hash_seed</vh></v>
<v t="ekr.20250121054835.1360"><vh>SingleStringTex.get_svg_string_by_content</vh></v>
<v t="ekr.20250121054835.1361"><vh>SingleStringTex.get_tex_file_body</vh></v>
<v t="ekr.20250121054835.1362"><vh>SingleStringTex.get_modified_expression</vh></v>
<v t="ekr.20250121054835.1363"><vh>SingleStringTex.modify_special_strings</vh></v>
<v t="ekr.20250121054835.1364"><vh>SingleStringTex.balance_braces</vh></v>
<v t="ekr.20250121054835.1365"><vh>SingleStringTex.get_tex</vh></v>
<v t="ekr.20250121054835.1366"><vh>SingleStringTex.organize_submobjects_left_to_right</vh></v>
</v>
<v t="ekr.20250121054835.1367"><vh>class OldTex</vh>
<v t="ekr.20250121054835.1368"><vh>OldTex.__init__</vh></v>
<v t="ekr.20250121054835.1369"><vh>OldTex.break_up_tex_strings</vh></v>
<v t="ekr.20250121054835.1370"><vh>OldTex.break_up_by_substrings</vh></v>
<v t="ekr.20250121054835.1371"><vh>OldTex.get_parts_by_tex</vh></v>
<v t="ekr.20250121054835.1372"><vh>OldTex.get_part_by_tex</vh></v>
<v t="ekr.20250121054835.1373"><vh>OldTex.set_color_by_tex</vh></v>
<v t="ekr.20250121054835.1374"><vh>OldTex.set_color_by_tex_to_color_map</vh></v>
<v t="ekr.20250121054835.1375"><vh>OldTex.index_of_part</vh></v>
<v t="ekr.20250121054835.1376"><vh>OldTex.index_of_part_by_tex</vh></v>
<v t="ekr.20250121054835.1377"><vh>OldTex.slice_by_tex</vh></v>
<v t="ekr.20250121054835.1378"><vh>OldTex.sort_alphabetically</vh></v>
<v t="ekr.20250121054835.1379"><vh>OldTex.set_bstroke</vh></v>
</v>
<v t="ekr.20250121054835.1380"><vh>class OldTexText</vh>
<v t="ekr.20250121054835.1381"><vh>OldTexText.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1382"><vh>manimlib/mobject/svg/special_tex.py</vh>
<v t="ekr.20250121054835.1383"><vh>class BulletedList</vh>
<v t="ekr.20250121054835.1384"><vh>BulletedList.__init__</vh></v>
<v t="ekr.20250121054835.1385"><vh>BulletedList.fade_all_but</vh></v>
</v>
<v t="ekr.20250121054835.1386"><vh>class TexTextFromPresetString</vh>
<v t="ekr.20250121054835.1387"><vh>TexTextFromPresetString.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1388"><vh>class Title</vh>
<v t="ekr.20250121054835.1389"><vh>Title.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1390"><vh>manimlib/mobject/svg/string_mobject.py</vh>
<v t="ekr.20250121054835.1391"><vh>class StringMobject</vh>
<v t="ekr.20250121054835.1392"><vh>StringMobject.__init__</vh></v>
<v t="ekr.20250121054835.1393"><vh>StringMobject.get_svg_string</vh></v>
<v t="ekr.20250121054835.1394"><vh>StringMobject.get_svg_string_by_content</vh></v>
<v t="ekr.20250121054835.1395"><vh>StringMobject.assign_labels_by_color</vh></v>
<v t="ekr.20250121054835.1396"><vh>StringMobject.mobjects_from_svg_string</vh></v>
<v t="ekr.20250121054835.1397"><vh>StringMobject.rearrange_submobjects_by_positions</vh></v>
<v t="ekr.20250121054835.1398"><vh>StringMobject.find_spans_by_selector</vh></v>
<v t="ekr.20250121054835.1399"><vh>StringMobject.span_contains</vh></v>
<v t="ekr.20250121054835.1400"><vh>StringMobject.parse</vh></v>
<v t="ekr.20250121054835.1401"><vh>StringMobject.get_content</vh></v>
<v t="ekr.20250121054835.1402"><vh>StringMobject.get_command_matches</vh></v>
<v t="ekr.20250121054835.1403"><vh>StringMobject.get_command_flag</vh></v>
<v t="ekr.20250121054835.1404"><vh>StringMobject.replace_for_content</vh></v>
<v t="ekr.20250121054835.1405"><vh>StringMobject.replace_for_matching</vh></v>
<v t="ekr.20250121054835.1406"><vh>StringMobject.get_attr_dict_from_command_pair</vh></v>
<v t="ekr.20250121054835.1407"><vh>StringMobject.get_configured_items</vh></v>
<v t="ekr.20250121054835.1408"><vh>StringMobject.get_command_string</vh></v>
<v t="ekr.20250121054835.1409"><vh>StringMobject.get_content_prefix_and_suffix</vh></v>
<v t="ekr.20250121054835.1410"><vh>StringMobject.get_submob_indices_list_by_span</vh></v>
<v t="ekr.20250121054835.1411"><vh>StringMobject.get_specified_part_items</vh></v>
<v t="ekr.20250121054835.1412"><vh>StringMobject.get_specified_substrings</vh></v>
<v t="ekr.20250121054835.1413"><vh>StringMobject.get_group_part_items</vh></v>
<v t="ekr.20250121054835.1414"><vh>StringMobject.get_submob_indices_lists_by_selector</vh></v>
<v t="ekr.20250121054835.1415"><vh>StringMobject.build_parts_from_indices_lists</vh></v>
<v t="ekr.20250121054835.1416"><vh>StringMobject.build_groups</vh></v>
<v t="ekr.20250121054835.1417"><vh>StringMobject.select_parts</vh></v>
<v t="ekr.20250121054835.1418"><vh>StringMobject.__getitem__</vh></v>
<v t="ekr.20250121054835.1419"><vh>StringMobject.select_part</vh></v>
<v t="ekr.20250121054835.1420"><vh>StringMobject.substr_to_path_count</vh></v>
<v t="ekr.20250121054835.1421"><vh>StringMobject.get_symbol_substrings</vh></v>
<v t="ekr.20250121054835.1422"><vh>StringMobject.select_unisolated_substring</vh></v>
<v t="ekr.20250121054835.1423"><vh>StringMobject.set_parts_color</vh></v>
<v t="ekr.20250121054835.1424"><vh>StringMobject.set_parts_color_by_dict</vh></v>
<v t="ekr.20250121054835.1425"><vh>StringMobject.get_string</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1426"><vh>manimlib/mobject/svg/svg_mobject.py</vh>
<v t="ekr.20250121054835.1427"><vh>function: _convert_point_to_3d</vh></v>
<v t="ekr.20250121054835.1428"><vh>class SVGMobject</vh>
<v t="ekr.20250121054835.1429"><vh>SVGMobject.__init__</vh></v>
<v t="ekr.20250121054835.1430"><vh>SVGMobject.init_svg_mobject</vh></v>
<v t="ekr.20250121054835.1431"><vh>SVGMobject.hash_seed</vh></v>
<v t="ekr.20250121054835.1432"><vh>SVGMobject.mobjects_from_svg_string</vh></v>
<v t="ekr.20250121054835.1433"><vh>SVGMobject.file_name_to_svg_string</vh></v>
<v t="ekr.20250121054835.1434"><vh>SVGMobject.modify_xml_tree</vh></v>
<v t="ekr.20250121054835.1435"><vh>SVGMobject.generate_config_style_dict</vh></v>
<v t="ekr.20250121054835.1436"><vh>SVGMobject.mobjects_from_svg</vh></v>
<v t="ekr.20250121054835.1437"><vh>SVGMobject.handle_transform</vh></v>
<v t="ekr.20250121054835.1438"><vh>SVGMobject.apply_style_to_mobject</vh></v>
<v t="ekr.20250121054835.1439"><vh>SVGMobject.path_to_mobject</vh></v>
<v t="ekr.20250121054835.1440"><vh>SVGMobject.line_to_mobject</vh></v>
<v t="ekr.20250121054835.1441"><vh>SVGMobject.rect_to_mobject</vh></v>
<v t="ekr.20250121054835.1442"><vh>SVGMobject.ellipse_to_mobject</vh></v>
<v t="ekr.20250121054835.1443"><vh>SVGMobject.polygon_to_mobject</vh></v>
<v t="ekr.20250121054835.1444"><vh>SVGMobject.polyline_to_mobject</vh></v>
<v t="ekr.20250121054835.1445"><vh>SVGMobject.text_to_mobject</vh></v>
</v>
<v t="ekr.20250121054835.1446"><vh>class VMobjectFromSVGPath</vh>
<v t="ekr.20250121054835.1447"><vh>VMobjectFromSVGPath.__init__</vh></v>
<v t="ekr.20250121054835.1448"><vh>VMobjectFromSVGPath.init_points</vh></v>
<v t="ekr.20250121054835.1449"><vh>VMobjectFromSVGPath.handle_commands</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1450"><vh>manimlib/mobject/svg/tex_mobject.py</vh>
<v t="ekr.20250121054835.1451"><vh>class Tex</vh>
<v t="ekr.20250121054835.1452"><vh>Tex.__init__</vh></v>
<v t="ekr.20250121054835.1453"><vh>Tex.get_svg_string_by_content</vh></v>
<v t="ekr.20250121054835.1454"><vh>Tex._handle_scale_side_effects</vh></v>
<v t="ekr.20250121054835.1455"><vh>Tex.get_command_matches</vh></v>
<v t="ekr.20250121054835.1456"><vh>Tex.get_command_flag</vh></v>
<v t="ekr.20250121054835.1457"><vh>Tex.replace_for_content</vh></v>
<v t="ekr.20250121054835.1458"><vh>Tex.replace_for_matching</vh></v>
<v t="ekr.20250121054835.1459"><vh>Tex.get_attr_dict_from_command_pair</vh></v>
<v t="ekr.20250121054835.1460"><vh>Tex.get_configured_items</vh></v>
<v t="ekr.20250121054835.1461"><vh>Tex.get_color_command</vh></v>
<v t="ekr.20250121054835.1462"><vh>Tex.get_command_string</vh></v>
<v t="ekr.20250121054835.1463"><vh>Tex.get_content_prefix_and_suffix</vh></v>
<v t="ekr.20250121054835.1464"><vh>Tex.get_parts_by_tex</vh></v>
<v t="ekr.20250121054835.1465"><vh>Tex.get_part_by_tex</vh></v>
<v t="ekr.20250121054835.1466"><vh>Tex.set_color_by_tex</vh></v>
<v t="ekr.20250121054835.1467"><vh>Tex.set_color_by_tex_to_color_map</vh></v>
<v t="ekr.20250121054835.1468"><vh>Tex.get_tex</vh></v>
<v t="ekr.20250121054835.1469"><vh>Tex.substr_to_path_count</vh></v>
<v t="ekr.20250121054835.1470"><vh>Tex.get_symbol_substrings</vh></v>
<v t="ekr.20250121054835.1471"><vh>Tex.make_number_changeable</vh></v>
</v>
<v t="ekr.20250121054835.1472"><vh>class TexText</vh></v>
</v>
<v t="ekr.20250121054835.1473"><vh>manimlib/mobject/svg/text_mobject.py</vh>
<v t="ekr.20250121054835.1474"><vh>class _Alignment</vh>
<v t="ekr.20250121054835.1475"><vh>_Alignment.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1476"><vh>function: markup_to_svg</vh></v>
<v t="ekr.20250121054835.1477"><vh>class MarkupText</vh>
<v t="ekr.20250121054835.1478"><vh>MarkupText.__init__</vh></v>
<v t="ekr.20250121054835.1479"><vh>MarkupText.get_svg_string_by_content</vh></v>
<v t="ekr.20250121054835.1480"><vh>MarkupText.escape_markup_char</vh></v>
<v t="ekr.20250121054835.1481"><vh>MarkupText.unescape_markup_char</vh></v>
<v t="ekr.20250121054835.1482"><vh>MarkupText.get_command_matches</vh></v>
<v t="ekr.20250121054835.1483"><vh>MarkupText.get_command_flag</vh></v>
<v t="ekr.20250121054835.1484"><vh>MarkupText.replace_for_content</vh></v>
<v t="ekr.20250121054835.1485"><vh>MarkupText.replace_for_matching</vh></v>
<v t="ekr.20250121054835.1486"><vh>MarkupText.get_attr_dict_from_command_pair</vh></v>
<v t="ekr.20250121054835.1487"><vh>MarkupText.get_configured_items</vh></v>
<v t="ekr.20250121054835.1488"><vh>MarkupText.get_command_string</vh></v>
<v t="ekr.20250121054835.1489"><vh>MarkupText.get_content_prefix_and_suffix</vh></v>
<v t="ekr.20250121054835.1490"><vh>MarkupText.get_parts_by_text</vh></v>
<v t="ekr.20250121054835.1491"><vh>MarkupText.get_part_by_text</vh></v>
<v t="ekr.20250121054835.1492"><vh>MarkupText.set_color_by_text</vh></v>
<v t="ekr.20250121054835.1493"><vh>MarkupText.set_color_by_text_to_color_map</vh></v>
<v t="ekr.20250121054835.1494"><vh>MarkupText.get_text</vh></v>
</v>
<v t="ekr.20250121054835.1495"><vh>class Text</vh>
<v t="ekr.20250121054835.1496"><vh>Text.__init__</vh></v>
<v t="ekr.20250121054835.1497"><vh>Text.get_command_matches</vh></v>
<v t="ekr.20250121054835.1498"><vh>Text.get_command_flag</vh></v>
<v t="ekr.20250121054835.1499"><vh>Text.replace_for_content</vh></v>
<v t="ekr.20250121054835.1500"><vh>Text.replace_for_matching</vh></v>
</v>
<v t="ekr.20250121054835.1501"><vh>class Code</vh>
<v t="ekr.20250121054835.1502"><vh>Code.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1503"><vh>function: register_font</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1504"><vh>C:/Repos/manim/manimlib/mobject/types</vh>
<v t="ekr.20250121054835.1505"><vh>manimlib/mobject/types/__init__.py</vh></v>
<v t="ekr.20250121054835.1506"><vh>manimlib/mobject/types/dot_cloud.py</vh>
<v t="ekr.20250121054835.1507"><vh>class DotCloud</vh>
<v t="ekr.20250121054835.1508"><vh>DotCloud.__init__</vh></v>
<v t="ekr.20250121054835.1509"><vh>DotCloud.init_uniforms</vh></v>
<v t="ekr.20250121054835.1510"><vh>DotCloud.to_grid</vh></v>
<v t="ekr.20250121054835.1511"><vh>DotCloud.set_radii</vh></v>
<v t="ekr.20250121054835.1512"><vh>DotCloud.get_radii</vh></v>
<v t="ekr.20250121054835.1513"><vh>DotCloud.set_radius</vh></v>
<v t="ekr.20250121054835.1514"><vh>DotCloud.get_radius</vh></v>
<v t="ekr.20250121054835.1515"><vh>DotCloud.scale_radii</vh></v>
<v t="ekr.20250121054835.1516"><vh>DotCloud.set_glow_factor</vh></v>
<v t="ekr.20250121054835.1517"><vh>DotCloud.get_glow_factor</vh></v>
<v t="ekr.20250121054835.1518"><vh>DotCloud.compute_bounding_box</vh></v>
<v t="ekr.20250121054835.1519"><vh>DotCloud.scale</vh></v>
<v t="ekr.20250121054835.1520"><vh>DotCloud.make_3d</vh></v>
</v>
<v t="ekr.20250121054835.1521"><vh>class TrueDot</vh>
<v t="ekr.20250121054835.1522"><vh>TrueDot.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1523"><vh>class GlowDots</vh>
<v t="ekr.20250121054835.1524"><vh>GlowDots.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1525"><vh>class GlowDot</vh>
<v t="ekr.20250121054835.1526"><vh>GlowDot.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1527"><vh>manimlib/mobject/types/image_mobject.py</vh>
<v t="ekr.20250121054835.1528"><vh>class ImageMobject</vh>
<v t="ekr.20250121054835.1529"><vh>ImageMobject.__init__</vh></v>
<v t="ekr.20250121054835.1530"><vh>ImageMobject.init_data</vh></v>
<v t="ekr.20250121054835.1531"><vh>ImageMobject.init_points</vh></v>
<v t="ekr.20250121054835.1532"><vh>ImageMobject.set_opacity</vh></v>
<v t="ekr.20250121054835.1533"><vh>ImageMobject.set_color</vh></v>
<v t="ekr.20250121054835.1534"><vh>ImageMobject.point_to_rgb</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1535"><vh>manimlib/mobject/types/point_cloud_mobject.py</vh>
<v t="ekr.20250121054835.1536"><vh>class PMobject</vh>
<v t="ekr.20250121054835.1537"><vh>PMobject.set_points</vh></v>
<v t="ekr.20250121054835.1538"><vh>PMobject.add_points</vh></v>
<v t="ekr.20250121054835.1539"><vh>PMobject.add_point</vh></v>
<v t="ekr.20250121054835.1540"><vh>PMobject.set_color_by_gradient</vh></v>
<v t="ekr.20250121054835.1541"><vh>PMobject.match_colors</vh></v>
<v t="ekr.20250121054835.1542"><vh>PMobject.filter_out</vh></v>
<v t="ekr.20250121054835.1543"><vh>PMobject.sort_points</vh></v>
<v t="ekr.20250121054835.1544"><vh>PMobject.ingest_submobjects</vh></v>
<v t="ekr.20250121054835.1545"><vh>PMobject.point_from_proportion</vh></v>
<v t="ekr.20250121054835.1546"><vh>PMobject.pointwise_become_partial</vh></v>
</v>
<v t="ekr.20250121054835.1547"><vh>class PGroup</vh>
<v t="ekr.20250121054835.1548"><vh>PGroup.__init__</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1549"><vh>manimlib/mobject/types/surface.py</vh>
<v t="ekr.20250121054835.1550"><vh>class Surface</vh>
<v t="ekr.20250121054835.1551"><vh>Surface.__init__</vh></v>
<v t="ekr.20250121054835.1552"><vh>Surface.uv_func</vh></v>
<v t="ekr.20250121054835.1553"><vh>Surface.init_points</vh></v>
<v t="ekr.20250121054835.1554"><vh>Surface.uv_to_point</vh></v>
<v t="ekr.20250121054835.1555"><vh>Surface.apply_points_function</vh></v>
<v t="ekr.20250121054835.1556"><vh>Surface.compute_triangle_indices</vh></v>
<v t="ekr.20250121054835.1557"><vh>Surface.get_triangle_indices</vh></v>
<v t="ekr.20250121054835.1558"><vh>Surface.get_unit_normals</vh></v>
<v t="ekr.20250121054835.1559"><vh>Surface.pointwise_become_partial</vh></v>
<v t="ekr.20250121054835.1560"><vh>Surface.get_partial_points_array</vh></v>
<v t="ekr.20250121054835.1561"><vh>Surface.sort_faces_back_to_front</vh></v>
<v t="ekr.20250121054835.1562"><vh>Surface.always_sort_to_camera</vh></v>
<v t="ekr.20250121054835.1563"><vh>Surface.get_shader_vert_indices</vh></v>
</v>
<v t="ekr.20250121054835.1564"><vh>class ParametricSurface</vh>
<v t="ekr.20250121054835.1565"><vh>ParametricSurface.__init__</vh></v>
<v t="ekr.20250121054835.1566"><vh>ParametricSurface.uv_func</vh></v>
</v>
<v t="ekr.20250121054835.1567"><vh>class SGroup</vh>
<v t="ekr.20250121054835.1568"><vh>SGroup.__init__</vh></v>
<v t="ekr.20250121054835.1569"><vh>SGroup.init_points</vh></v>
</v>
<v t="ekr.20250121054835.1570"><vh>class TexturedSurface</vh>
<v t="ekr.20250121054835.1571"><vh>TexturedSurface.__init__</vh></v>
<v t="ekr.20250121054835.1572"><vh>TexturedSurface.init_points</vh></v>
<v t="ekr.20250121054835.1573"><vh>TexturedSurface.init_uniforms</vh></v>
<v t="ekr.20250121054835.1574"><vh>TexturedSurface.set_opacity</vh></v>
<v t="ekr.20250121054835.1575"><vh>TexturedSurface.set_color</vh></v>
<v t="ekr.20250121054835.1576"><vh>TexturedSurface.pointwise_become_partial</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1577"><vh>manimlib/mobject/types/vectorized_mobject.py</vh>
<v t="ekr.20250121054835.1578"><vh>class VMobject</vh>
<v t="ekr.20250121054835.1579"><vh>VMobject.__init__</vh></v>
<v t="ekr.20250121054835.1580"><vh>VMobject.get_group_class</vh></v>
<v t="ekr.20250121054835.1581"><vh>VMobject.init_uniforms</vh></v>
<v t="ekr.20250121054835.1582"><vh>VMobject.add</vh></v>
<v t="ekr.20250121054835.1583"><vh>VMobject.init_colors</vh></v>
<v t="ekr.20250121054835.1584"><vh>VMobject.set_fill</vh></v>
<v t="ekr.20250121054835.1585"><vh>VMobject.set_stroke</vh></v>
<v t="ekr.20250121054835.1586"><vh>VMobject.set_backstroke</vh></v>
<v t="ekr.20250121054835.1587"><vh>VMobject.set_style</vh></v>
<v t="ekr.20250121054835.1588"><vh>VMobject.get_style</vh></v>
<v t="ekr.20250121054835.1589"><vh>VMobject.match_style</vh></v>
<v t="ekr.20250121054835.1590"><vh>VMobject.set_color</vh></v>
<v t="ekr.20250121054835.1591"><vh>VMobject.set_opacity</vh></v>
<v t="ekr.20250121054835.1592"><vh>VMobject.set_anti_alias_width</vh></v>
<v t="ekr.20250121054835.1593"><vh>VMobject.fade</vh></v>
<v t="ekr.20250121054835.1594"><vh>VMobject.get_fill_colors</vh></v>
<v t="ekr.20250121054835.1595"><vh>VMobject.get_fill_opacities</vh></v>
<v t="ekr.20250121054835.1596"><vh>VMobject.get_stroke_colors</vh></v>
<v t="ekr.20250121054835.1597"><vh>VMobject.get_stroke_opacities</vh></v>
<v t="ekr.20250121054835.1598"><vh>VMobject.get_stroke_widths</vh></v>
<v t="ekr.20250121054835.1599"><vh>VMobject.get_fill_color</vh></v>
<v t="ekr.20250121054835.1600"><vh>VMobject.get_fill_opacity</vh></v>
<v t="ekr.20250121054835.1601"><vh>VMobject.get_stroke_color</vh></v>
<v t="ekr.20250121054835.1602"><vh>VMobject.get_stroke_width</vh></v>
<v t="ekr.20250121054835.1603"><vh>VMobject.get_stroke_opacity</vh></v>
<v t="ekr.20250121054835.1604"><vh>VMobject.get_color</vh></v>
<v t="ekr.20250121054835.1605"><vh>VMobject.get_anti_alias_width</vh></v>
<v t="ekr.20250121054835.1606"><vh>VMobject.has_stroke</vh></v>
<v t="ekr.20250121054835.1607"><vh>VMobject.has_fill</vh></v>
<v t="ekr.20250121054835.1608"><vh>VMobject.get_opacity</vh></v>
<v t="ekr.20250121054835.1609"><vh>VMobject.set_flat_stroke</vh></v>
<v t="ekr.20250121054835.1610"><vh>VMobject.get_flat_stroke</vh></v>
<v t="ekr.20250121054835.1611"><vh>VMobject.set_scale_stroke_with_zoom</vh></v>
<v t="ekr.20250121054835.1612"><vh>VMobject.get_scale_stroke_with_zoom</vh></v>
<v t="ekr.20250121054835.1613"><vh>VMobject.set_joint_type</vh></v>
<v t="ekr.20250121054835.1614"><vh>VMobject.get_joint_type</vh></v>
<v t="ekr.20250121054835.1615"><vh>VMobject.apply_depth_test</vh></v>
<v t="ekr.20250121054835.1616"><vh>VMobject.deactivate_depth_test</vh></v>
<v t="ekr.20250121054835.1617"><vh>VMobject.use_winding_fill</vh></v>
<v t="ekr.20250121054835.1618"><vh>VMobject.set_anchors_and_handles</vh></v>
<v t="ekr.20250121054835.1619"><vh>VMobject.start_new_path</vh></v>
<v t="ekr.20250121054835.1620"><vh>VMobject.add_cubic_bezier_curve</vh></v>
<v t="ekr.20250121054835.1621"><vh>VMobject.add_cubic_bezier_curve_to</vh></v>
<v t="ekr.20250121054835.1622"><vh>VMobject.add_quadratic_bezier_curve_to</vh></v>
<v t="ekr.20250121054835.1623"><vh>VMobject.add_line_to</vh></v>
<v t="ekr.20250121054835.1624"><vh>VMobject.add_smooth_curve_to</vh></v>
<v t="ekr.20250121054835.1625"><vh>VMobject.add_smooth_cubic_curve_to</vh></v>
<v t="ekr.20250121054835.1626"><vh>VMobject.add_arc_to</vh></v>
<v t="ekr.20250121054835.1627"><vh>VMobject.has_new_path_started</vh></v>
<v t="ekr.20250121054835.1628"><vh>VMobject.get_last_point</vh></v>
<v t="ekr.20250121054835.1629"><vh>VMobject.get_reflection_of_last_handle</vh></v>
<v t="ekr.20250121054835.1630"><vh>VMobject.close_path</vh></v>
<v t="ekr.20250121054835.1631"><vh>VMobject.is_closed</vh></v>
<v t="ekr.20250121054835.1632"><vh>VMobject.subdivide_curves_by_condition</vh></v>
<v t="ekr.20250121054835.1633"><vh>VMobject.subdivide_sharp_curves</vh></v>
<v t="ekr.20250121054835.1634"><vh>VMobject.subdivide_intersections</vh></v>
<v t="ekr.20250121054835.1635"><vh>VMobject.add_points_as_corners</vh></v>
<v t="ekr.20250121054835.1636"><vh>VMobject.set_points_as_corners</vh></v>
<v t="ekr.20250121054835.1637"><vh>VMobject.set_points_smoothly</vh></v>
<v t="ekr.20250121054835.1638"><vh>VMobject.is_smooth</vh></v>
<v t="ekr.20250121054835.1639"><vh>VMobject.change_anchor_mode</vh></v>
<v t="ekr.20250121054835.1640"><vh>VMobject.make_smooth</vh></v>
<v t="ekr.20250121054835.1641"><vh>VMobject.make_approximately_smooth</vh></v>
<v t="ekr.20250121054835.1642"><vh>VMobject.make_jagged</vh></v>
<v t="ekr.20250121054835.1643"><vh>VMobject.add_subpath</vh></v>
<v t="ekr.20250121054835.1644"><vh>VMobject.append_vectorized_mobject</vh></v>
<v t="ekr.20250121054835.1645"><vh>VMobject.consider_points_equal</vh></v>
<v t="ekr.20250121054835.1646"><vh>VMobject.get_bezier_tuples_from_points</vh></v>
<v t="ekr.20250121054835.1647"><vh>VMobject.get_bezier_tuples</vh></v>
<v t="ekr.20250121054835.1648"><vh>VMobject.get_subpath_end_indices_from_points</vh></v>
<v t="ekr.20250121054835.1649"><vh>VMobject.get_subpath_end_indices</vh></v>
<v t="ekr.20250121054835.1650"><vh>VMobject.get_subpaths_from_points</vh></v>
<v t="ekr.20250121054835.1651"><vh>VMobject.get_subpaths</vh></v>
<v t="ekr.20250121054835.1652"><vh>VMobject.get_nth_curve_points</vh></v>
<v t="ekr.20250121054835.1653"><vh>VMobject.get_nth_curve_function</vh></v>
<v t="ekr.20250121054835.1654"><vh>VMobject.get_num_curves</vh></v>
<v t="ekr.20250121054835.1655"><vh>VMobject.quick_point_from_proportion</vh></v>
<v t="ekr.20250121054835.1656"><vh>VMobject.curve_and_prop_of_partial_point</vh></v>
<v t="ekr.20250121054835.1657"><vh>VMobject.point_from_proportion</vh></v>
<v t="ekr.20250121054835.1658"><vh>VMobject.get_anchors_and_handles</vh></v>
<v t="ekr.20250121054835.1659"><vh>VMobject.get_start_anchors</vh></v>
<v t="ekr.20250121054835.1660"><vh>VMobject.get_end_anchors</vh></v>
<v t="ekr.20250121054835.1661"><vh>VMobject.get_anchors</vh></v>
<v t="ekr.20250121054835.1662"><vh>VMobject.get_points_without_null_curves</vh></v>
<v t="ekr.20250121054835.1663"><vh>VMobject.get_arc_length</vh></v>
<v t="ekr.20250121054835.1664"><vh>VMobject.get_area_vector</vh></v>
<v t="ekr.20250121054835.1665"><vh>VMobject.get_unit_normal</vh></v>
<v t="ekr.20250121054835.1666"><vh>VMobject.refresh_unit_normal</vh></v>
<v t="ekr.20250121054835.1667"><vh>VMobject.rotate</vh></v>
<v t="ekr.20250121054835.1668"><vh>VMobject.ensure_positive_orientation</vh></v>
<v t="ekr.20250121054835.1669"><vh>VMobject.align_points</vh></v>
<v t="ekr.20250121054835.1670"><vh>VMobject.insert_n_curves</vh></v>
<v t="ekr.20250121054835.1671"><vh>VMobject.insert_n_curves_to_point_list</vh></v>
<v t="ekr.20250121054835.1672"><vh>VMobject.pointwise_become_partial</vh></v>
<v t="ekr.20250121054835.1673"><vh>VMobject.get_subcurve</vh></v>
<v t="ekr.20250121054835.1674"><vh>VMobject.get_outer_vert_indices</vh></v>
<v t="ekr.20250121054835.1675"><vh>VMobject.get_triangulation</vh></v>
<v t="ekr.20250121054835.1676"><vh>VMobject.refresh_joint_angles</vh></v>
<v t="ekr.20250121054835.1677"><vh>VMobject.get_joint_angles</vh></v>
<v t="ekr.20250121054835.1678"><vh>VMobject.lock_matching_data</vh></v>
<v t="ekr.20250121054835.1679"><vh>VMobject.triggers_refresh</vh></v>
<v t="ekr.20250121054835.1680"><vh>VMobject.set_points</vh></v>
<v t="ekr.20250121054835.1681"><vh>VMobject.append_points</vh></v>
<v t="ekr.20250121054835.1682"><vh>VMobject.reverse_points</vh></v>
<v t="ekr.20250121054835.1683"><vh>VMobject.set_data</vh></v>
<v t="ekr.20250121054835.1684"><vh>VMobject.apply_function</vh></v>
<v t="ekr.20250121054835.1685"><vh>VMobject.stretch</vh></v>
<v t="ekr.20250121054835.1686"><vh>VMobject.apply_matrix</vh></v>
<v t="ekr.20250121054835.1687"><vh>VMobject.rotate</vh></v>
<v t="ekr.20250121054835.1688"><vh>VMobject.set_animating_status</vh></v>
<v t="ekr.20250121054835.1689"><vh>VMobject.init_shader_wrapper</vh></v>
<v t="ekr.20250121054835.1690"><vh>VMobject.refresh_shader_wrapper_id</vh></v>
<v t="ekr.20250121054835.1691"><vh>VMobject.get_shader_data</vh></v>
<v t="ekr.20250121054835.1692"><vh>VMobject.get_shader_vert_indices</vh></v>
</v>
<v t="ekr.20250121054835.1693"><vh>class VGroup</vh>
<v t="ekr.20250121054835.1694"><vh>VGroup.__init__</vh></v>
<v t="ekr.20250121054835.1695"><vh>VGroup.__add__</vh></v>
<v t="ekr.20250121054835.1696"><vh>VGroup.__getitem__</vh></v>
</v>
<v t="ekr.20250121054835.1697"><vh>class VectorizedPoint</vh>
<v t="ekr.20250121054835.1698"><vh>VectorizedPoint.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1699"><vh>class CurvesAsSubmobjects</vh>
<v t="ekr.20250121054835.1700"><vh>CurvesAsSubmobjects.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1701"><vh>class DashedVMobject</vh>
<v t="ekr.20250121054835.1702"><vh>DashedVMobject.__init__</vh></v>
</v>
<v t="ekr.20250121054835.1703"><vh>class VHighlight</vh>
<v t="ekr.20250121054835.1704"><vh>VHighlight.__init__</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20250121054835.1705"><vh>C:/Repos/manim/manimlib/scene</vh>
<v t="ekr.20250121054835.1706"><vh>manimlib/scene/__init__.py</vh></v>
<v t="ekr.20250121054835.1707"><vh>manimlib/scene/interactive_scene.py</vh>
<v t="ekr.20250121054835.1708"><vh>class InteractiveScene</vh>
<v t="ekr.20250121054835.1709"><vh>InteractiveScene.setup</vh></v>
<v t="ekr.20250121054835.1710"><vh>InteractiveScene.get_selection_rectangle</vh></v>
<v t="ekr.20250121054835.1711"><vh>InteractiveScene.update_selection_rectangle</vh></v>
<v t="ekr.20250121054835.1712"><vh>InteractiveScene.get_selection_highlight</vh></v>
<v t="ekr.20250121054835.1713"><vh>InteractiveScene.update_selection_highlight</vh></v>
<v t="ekr.20250121054835.1714"><vh>InteractiveScene.get_crosshair</vh></v>
<v t="ekr.20250121054835.1715"><vh>InteractiveScene.get_color_palette</vh></v>
<v t="ekr.20250121054835.1716"><vh>InteractiveScene.get_information_label</vh></v>
<v t="ekr.20250121054835.1717"><vh>InteractiveScene.get_state</vh></v>
<v t="ekr.20250121054835.1718"><vh>InteractiveScene.restore_state</vh></v>
<v t="ekr.20250121054835.1719"><vh>InteractiveScene.add</vh></v>
<v t="ekr.20250121054835.1720"><vh>InteractiveScene.remove</vh></v>
<v t="ekr.20250121054835.1721"><vh>InteractiveScene.toggle_selection_mode</vh></v>
<v t="ekr.20250121054835.1722"><vh>InteractiveScene.get_selection_search_set</vh></v>
<v t="ekr.20250121054835.1723"><vh>InteractiveScene.regenerate_selection_search_set</vh></v>
<v t="ekr.20250121054835.1724"><vh>InteractiveScene.refresh_selection_scope</vh></v>
<v t="ekr.20250121054835.1725"><vh>InteractiveScene.get_corner_dots</vh></v>
<v t="ekr.20250121054835.1726"><vh>InteractiveScene.get_highlight</vh></v>
<v t="ekr.20250121054835.1727"><vh>InteractiveScene.add_to_selection</vh></v>
<v t="ekr.20250121054835.1728"><vh>InteractiveScene.toggle_from_selection</vh></v>
<v t="ekr.20250121054835.1729"><vh>InteractiveScene.clear_selection</vh></v>
<v t="ekr.20250121054835.1730"><vh>InteractiveScene.disable_interaction</vh></v>
<v t="ekr.20250121054835.1731"><vh>InteractiveScene.enable_interaction</vh></v>
<v t="ekr.20250121054835.1732"><vh>InteractiveScene.copy_selection</vh></v>
<v t="ekr.20250121054835.1733"><vh>InteractiveScene.paste_selection</vh></v>
<v t="ekr.20250121054835.1734"><vh>InteractiveScene.delete_selection</vh></v>
<v t="ekr.20250121054835.1735"><vh>InteractiveScene.enable_selection</vh></v>
<v t="ekr.20250121054835.1736"><vh>InteractiveScene.gather_new_selection</vh></v>
<v t="ekr.20250121054835.1737"><vh>InteractiveScene.prepare_grab</vh></v>
<v t="ekr.20250121054835.1738"><vh>InteractiveScene.prepare_resizing</vh></v>
<v t="ekr.20250121054835.1739"><vh>InteractiveScene.toggle_color_palette</vh></v>
<v t="ekr.20250121054835.1740"><vh>InteractiveScene.display_information</vh></v>
<v t="ekr.20250121054835.1741"><vh>InteractiveScene.group_selection</vh></v>
<v t="ekr.20250121054835.1742"><vh>InteractiveScene.ungroup_selection</vh></v>
<v t="ekr.20250121054835.1743"><vh>InteractiveScene.nudge_selection</vh></v>
<v t="ekr.20250121054835.1744"><vh>InteractiveScene.on_key_press</vh></v>
<v t="ekr.20250121054835.1745"><vh>InteractiveScene.on_key_release</vh></v>
<v t="ekr.20250121054835.1746"><vh>InteractiveScene.handle_grabbing</vh></v>
<v t="ekr.20250121054835.1747"><vh>InteractiveScene.handle_resizing</vh></v>
<v t="ekr.20250121054835.1748"><vh>InteractiveScene.handle_sweeping_selection</vh></v>
<v t="ekr.20250121054835.1749"><vh>InteractiveScene.choose_color</vh></v>
<v t="ekr.20250121054835.1750"><vh>InteractiveScene.on_mouse_motion</vh></v>
<v t="ekr.20250121054835.1751"><vh>InteractiveScene.on_mouse_drag</vh></v>
<v t="ekr.20250121054835.1752"><vh>InteractiveScene.on_mouse_release</vh></v>
<v t="ekr.20250121054835.1753"><vh>InteractiveScene.copy_frame_positioning</vh></v>
<v t="ekr.20250121054835.1754"><vh>InteractiveScene.copy_cursor_position</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1755"><vh>manimlib/scene/scene.py</vh>
<v t="ekr.20250121054835.1756"><vh>class Scene</vh>
<v t="ekr.20250121054835.1757"><vh>Scene.__init__</vh></v>
<v t="ekr.20250121054835.1758"><vh>Scene.__str__</vh></v>
<v t="ekr.20250121054835.1759"><vh>Scene.get_window</vh></v>
<v t="ekr.20250121054835.1760"><vh>Scene.run</vh></v>
<v t="ekr.20250121054835.1761"><vh>Scene.setup</vh></v>
<v t="ekr.20250121054835.1762"><vh>Scene.construct</vh></v>
<v t="ekr.20250121054835.1763"><vh>Scene.tear_down</vh></v>
<v t="ekr.20250121054835.1764"><vh>Scene.interact</vh></v>
<v t="ekr.20250121054835.1765"><vh>Scene.embed</vh></v>
<v t="ekr.20250121054835.1766"><vh>Scene.get_image</vh></v>
<v t="ekr.20250121054835.1767"><vh>Scene.show</vh></v>
<v t="ekr.20250121054835.1768"><vh>Scene.update_frame</vh></v>
<v t="ekr.20250121054835.1769"><vh>Scene.emit_frame</vh></v>
<v t="ekr.20250121054835.1770"><vh>Scene.update_mobjects</vh></v>
<v t="ekr.20250121054835.1771"><vh>Scene.should_update_mobjects</vh></v>
<v t="ekr.20250121054835.1772"><vh>Scene.get_time</vh></v>
<v t="ekr.20250121054835.1773"><vh>Scene.increment_time</vh></v>
<v t="ekr.20250121054835.1774"><vh>Scene.get_top_level_mobjects</vh></v>
<v t="ekr.20250121054835.1775"><vh>Scene.get_mobject_family_members</vh></v>
<v t="ekr.20250121054835.1776"><vh>Scene.assemble_render_groups</vh></v>
<v t="ekr.20250121054835.1777"><vh>Scene.affects_mobject_list</vh></v>
<v t="ekr.20250121054835.1778"><vh>Scene.add</vh></v>
<v t="ekr.20250121054835.1779"><vh>Scene.add_mobjects_among</vh></v>
<v t="ekr.20250121054835.1780"><vh>Scene.replace</vh></v>
<v t="ekr.20250121054835.1781"><vh>Scene.remove</vh></v>
<v t="ekr.20250121054835.1782"><vh>Scene.bring_to_front</vh></v>
<v t="ekr.20250121054835.1783"><vh>Scene.bring_to_back</vh></v>
<v t="ekr.20250121054835.1784"><vh>Scene.clear</vh></v>
<v t="ekr.20250121054835.1785"><vh>Scene.get_mobjects</vh></v>
<v t="ekr.20250121054835.1786"><vh>Scene.get_mobject_copies</vh></v>
<v t="ekr.20250121054835.1787"><vh>Scene.point_to_mobject</vh></v>
<v t="ekr.20250121054835.1788"><vh>Scene.get_group</vh></v>
<v t="ekr.20250121054835.1789"><vh>Scene.id_to_mobject</vh></v>
<v t="ekr.20250121054835.1790"><vh>Scene.ids_to_group</vh></v>
<v t="ekr.20250121054835.1791"><vh>Scene.i2g</vh></v>
<v t="ekr.20250121054835.1792"><vh>Scene.i2m</vh></v>
<v t="ekr.20250121054835.1793"><vh>Scene.update_skipping_status</vh></v>
<v t="ekr.20250121054835.1794"><vh>Scene.stop_skipping</vh></v>
<v t="ekr.20250121054835.1795"><vh>Scene.get_time_progression</vh></v>
<v t="ekr.20250121054835.1796"><vh>Scene.get_run_time</vh></v>
<v t="ekr.20250121054835.1797"><vh>Scene.get_animation_time_progression</vh></v>
<v t="ekr.20250121054835.1798"><vh>Scene.get_wait_time_progression</vh></v>
<v t="ekr.20250121054835.1799"><vh>Scene.pre_play</vh></v>
<v t="ekr.20250121054835.1800"><vh>Scene.post_play</vh></v>
<v t="ekr.20250121054835.1801"><vh>Scene.begin_animations</vh></v>
<v t="ekr.20250121054835.1802"><vh>Scene.progress_through_animations</vh></v>
<v t="ekr.20250121054835.1803"><vh>Scene.finish_animations</vh></v>
<v t="ekr.20250121054835.1804"><vh>Scene.play</vh></v>
<v t="ekr.20250121054835.1805"><vh>Scene.wait</vh></v>
<v t="ekr.20250121054835.1806"><vh>Scene.hold_loop</vh></v>
<v t="ekr.20250121054835.1807"><vh>Scene.wait_until</vh></v>
<v t="ekr.20250121054835.1808"><vh>Scene.force_skipping</vh></v>
<v t="ekr.20250121054835.1809"><vh>Scene.revert_to_original_skipping_status</vh></v>
<v t="ekr.20250121054835.1810"><vh>Scene.add_sound</vh></v>
<v t="ekr.20250121054835.1811"><vh>Scene.get_state</vh></v>
<v t="ekr.20250121054835.1812"><vh>Scene.restore_state</vh></v>
<v t="ekr.20250121054835.1813"><vh>Scene.save_state</vh></v>
<v t="ekr.20250121054835.1814"><vh>Scene.undo</vh></v>
<v t="ekr.20250121054835.1815"><vh>Scene.redo</vh></v>
<v t="ekr.20250121054835.1816"><vh>Scene.temp_skip</vh></v>
<v t="ekr.20250121054835.1817"><vh>Scene.temp_progress_bar</vh></v>
<v t="ekr.20250121054835.1818"><vh>Scene.temp_record</vh></v>
<v t="ekr.20250121054835.1819"><vh>Scene.temp_config_change</vh></v>
<v t="ekr.20250121054835.1820"><vh>Scene.is_window_closing</vh></v>
<v t="ekr.20250121054835.1821"><vh>Scene.set_floor_plane</vh></v>
<v t="ekr.20250121054835.1822"><vh>Scene.on_mouse_motion</vh></v>
<v t="ekr.20250121054835.1823"><vh>Scene.on_mouse_drag</vh></v>
<v t="ekr.20250121054835.1824"><vh>Scene.on_mouse_press</vh></v>
<v t="ekr.20250121054835.1825"><vh>Scene.on_mouse_release</vh></v>
<v t="ekr.20250121054835.1826"><vh>Scene.on_mouse_scroll</vh></v>
<v t="ekr.20250121054835.1827"><vh>Scene.on_key_release</vh></v>
<v t="ekr.20250121054835.1828"><vh>Scene.on_key_press</vh></v>
<v t="ekr.20250121054835.1829"><vh>Scene.on_resize</vh></v>
<v t="ekr.20250121054835.1830"><vh>Scene.on_show</vh></v>
<v t="ekr.20250121054835.1831"><vh>Scene.on_hide</vh></v>
<v t="ekr.20250121054835.1832"><vh>Scene.on_close</vh></v>
<v t="ekr.20250121054835.1833"><vh>Scene.focus</vh></v>
</v>
<v t="ekr.20250121054835.1834"><vh>class SceneState</vh>
<v t="ekr.20250121054835.1835"><vh>SceneState.__init__</vh></v>
<v t="ekr.20250121054835.1836"><vh>SceneState.__eq__</vh></v>
<v t="ekr.20250121054835.1837"><vh>SceneState.mobjects_match</vh></v>
<v t="ekr.20250121054835.1838"><vh>SceneState.n_changes</vh></v>
<v t="ekr.20250121054835.1839"><vh>SceneState.restore_scene</vh></v>
</v>
<v t="ekr.20250121054835.1840"><vh>class EndScene</vh></v>
<v t="ekr.20250121054835.1841"><vh>class ThreeDScene</vh>
<v t="ekr.20250121054835.1842"><vh>ThreeDScene.add</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1843"><vh>manimlib/scene/scene_embed.py</vh>
<v t="ekr.20250121054835.1844"><vh>class InteractiveSceneEmbed</vh>
<v t="ekr.20250121054835.1845"><vh>InteractiveSceneEmbed.__init__</vh></v>
<v t="ekr.20250121054835.1846"><vh>InteractiveSceneEmbed.launch</vh></v>
<v t="ekr.20250121054835.1847"><vh>InteractiveSceneEmbed.get_ipython_shell_for_embedded_scene</vh></v>
<v t="ekr.20250121054835.1848"><vh>InteractiveSceneEmbed.get_shortcuts</vh></v>
<v t="ekr.20250121054835.1849"><vh>InteractiveSceneEmbed.enable_gui</vh></v>
<v t="ekr.20250121054835.1850"><vh>InteractiveSceneEmbed.ensure_frame_update_post_cell</vh></v>
<v t="ekr.20250121054835.1851"><vh>InteractiveSceneEmbed.ensure_flash_on_error</vh></v>
<v t="ekr.20250121054835.1852"><vh>InteractiveSceneEmbed.reload_scene</vh></v>
<v t="ekr.20250121054835.1853"><vh>InteractiveSceneEmbed.auto_reload</vh></v>
<v t="ekr.20250121054835.1854"><vh>InteractiveSceneEmbed.checkpoint_paste</vh></v>
</v>
<v t="ekr.20250121054835.1855"><vh>class CheckpointManager</vh>
<v t="ekr.20250121054835.1856"><vh>CheckpointManager.__init__</vh></v>
<v t="ekr.20250121054835.1857"><vh>CheckpointManager.checkpoint_paste</vh></v>
<v t="ekr.20250121054835.1858"><vh>CheckpointManager.get_leading_comment</vh></v>
<v t="ekr.20250121054835.1859"><vh>CheckpointManager.handle_checkpoint_key</vh></v>
<v t="ekr.20250121054835.1860"><vh>CheckpointManager.clear_checkpoints</vh></v>
</v>
</v>
<v t="ekr.20250121054835.1861"><vh>manimlib/scene/scene_file_writer.py</vh>
<v t="ekr.20250121054835.1862"><vh>class SceneFileWriter</vh>
<v t="ekr.20250121054835.1863"><vh>SceneFileWriter.__init__</vh></v>
<v t="ekr.20250121054835.1864"><vh>SceneFileWriter.init_output_directories</vh></v>
<v t="ekr.20250121054835.1865"><vh>SceneFileWriter.init_image_file_path</vh></v>
<v t="ekr.20250121054835.1866"><vh>SceneFileWriter.init_movie_file_path</vh></v>
<v t="ekr.20250121054835.1867"><vh>SceneFileWriter.init_partial_movie_directory</vh></v>
<v t="ekr.20250121054835.1868"><vh>SceneFileWriter.get_output_file_rootname</vh></v>
<v t="ekr.20250121054835.1869"><vh>SceneFileWriter.get_output_file_name</vh></v>
<v t="ekr.20250121054835.1870"><vh>SceneFileWriter.get_image_file_path</vh></v>
<v t="ekr.20250121054835.1871"><vh>SceneFileWriter.get_next_partial_movie_path</vh></v>
<v t="ekr.20250121054835.1872"><vh>SceneFileWriter.get_movie_file_path</vh></v>
<v t="ekr.20250121054835.1873"><vh>SceneFileWriter.init_audio</vh></v>
<v t="ekr.20250121054835.1874"><vh>SceneFileWriter.create_audio_segment</vh></v>
<v t="ekr.20250121054835.1875"><vh>SceneFileWriter.add_audio_segment</vh></v>
<v t="ekr.20250121054835.1876"><vh>SceneFileWriter.add_sound</vh></v>
<v t="ekr.20250121054835.1877"><vh>SceneFileWriter.begin</vh></v>
<v t="ekr.20250121054835.1878"><vh>SceneFileWriter.begin_animation</vh></v>
<v t="ekr.20250121054835.1879"><vh>SceneFileWriter.end_animation</vh></v>
<v t="ekr.20250121054835.1880"><vh>SceneFileWriter.finish</vh></v>
<v t="ekr.20250121054835.1881"><vh>SceneFileWriter.open_movie_pipe</vh></v>
<v t="ekr.20250121054835.1882"><vh>SceneFileWriter.use_fast_encoding</vh></v>
<v t="ekr.20250121054835.1883"><vh>SceneFileWriter.get_insert_file_path</vh></v>
<v t="ekr.20250121054835.1884"><vh>SceneFileWriter.begin_insert</vh></v>
<v t="ekr.20250121054835.1885"><vh>SceneFileWriter.end_insert</vh></v>
<v t="ekr.20250121054835.1886"><vh>SceneFileWriter.has_progress_display</vh></v>
<v t="ekr.20250121054835.1887"><vh>SceneFileWriter.set_progress_display_description</vh></v>
<v t="ekr.20250121054835.1888"><vh>SceneFileWriter.write_frame</vh></v>
<v t="ekr.20250121054835.1889"><vh>SceneFileWriter.close_movie_pipe</vh></v>
<v t="ekr.20250121054835.1890"><vh>SceneFileWriter.add_sound_to_video</vh></v>
<v t="ekr.20250121054835.1891"><vh>SceneFileWriter.save_final_image</vh></v>
<v t="ekr.20250121054835.1892"><vh>SceneFileWriter.print_file_ready_message</vh></v>
<v t="ekr.20250121054835.1893"><vh>SceneFileWriter.should_open_file</vh></v>
<v t="ekr.20250121054835.1894"><vh>SceneFileWriter.open_file</vh></v>
</v>
</v>
</v>
<v t="ekr.20250121054835.1895"><vh>C:/Repos/manim/manimlib/shaders</vh></v>
<v t="ekr.20250121054835.1896"><vh>C:/Repos/manim/manimlib/utils</vh>
<v t="ekr.20250121054835.1897"><vh>manimlib/utils/__init__.py</vh></v>
<v t="ekr.20250121054835.1898"><vh>manimlib/utils/bezier.py</vh>
<v t="ekr.20250121054835.1899"><vh>function: bezier</vh></v>
<v t="ekr.20250121054835.1900"><vh>function: partial_bezier_points</vh></v>
<v t="ekr.20250121054835.1901"><vh>function: partial_quadratic_bezier_points</vh></v>
<v t="ekr.20250121054835.1902"><vh>function: interpolate</vh></v>
<v t="ekr.20250121054835.1903"><vh>function: outer_interpolate</vh></v>
<v t="ekr.20250121054835.1904"><vh>function: set_array_by_interpolation</vh></v>
<v t="ekr.20250121054835.1905"><vh>function: integer_interpolate</vh></v>
<v t="ekr.20250121054835.1906"><vh>function: mid</vh></v>
<v t="ekr.20250121054835.1907"><vh>function: inverse_interpolate</vh></v>
<v t="ekr.20250121054835.1908"><vh>function: match_interpolate</vh></v>
<v t="ekr.20250121054835.1909"><vh>function: quadratic_bezier_points_for_arc</vh></v>
<v t="ekr.20250121054835.1910"><vh>function: approx_smooth_quadratic_bezier_handles</vh></v>
<v t="ekr.20250121054835.1911"><vh>function: smooth_quadratic_path</vh></v>
<v t="ekr.20250121054835.1912"><vh>function: get_smooth_cubic_bezier_handle_points</vh></v>
<v t="ekr.20250121054835.1913"><vh>function: diag_to_matrix</vh></v>
<v t="ekr.20250121054835.1914"><vh>function: is_closed</vh></v>
<v t="ekr.20250121054835.1915"><vh>function: get_quadratic_approximation_of_cubic</vh></v>
<v t="ekr.20250121054835.1916"><vh>function: get_smooth_quadratic_bezier_path_through</vh></v>
</v>
<v t="ekr.20250121054835.1917"><vh>manimlib/utils/cache.py</vh>
<v t="ekr.20250121054835.1918"><vh>function: cache_on_disk</vh></v>
<v t="ekr.20250121054835.1919"><vh>function: clear_cache</vh></v>
</v>
<v t="ekr.20250121054835.1920"><vh>manimlib/utils/color.py</vh>
<v t="ekr.20250121054835.1921"><vh>function: color_to_rgb</vh></v>
<v t="ekr.20250121054835.1922"><vh>function: color_to_rgba</vh></v>
<v t="ekr.20250121054835.1923"><vh>function: rgb_to_color</vh></v>
<v t="ekr.20250121054835.1924"><vh>function: rgba_to_color</vh></v>
<v t="ekr.20250121054835.1925"><vh>function: rgb_to_hex</vh></v>
<v t="ekr.20250121054835.1926"><vh>function: hex_to_rgb</vh></v>
<v t="ekr.20250121054835.1927"><vh>function: invert_color</vh></v>
<v t="ekr.20250121054835.1928"><vh>function: color_to_int_rgb</vh></v>
<v t="ekr.20250121054835.1929"><vh>function: color_to_int_rgba</vh></v>
<v t="ekr.20250121054835.1930"><vh>function: color_to_hex</vh></v>
<v t="ekr.20250121054835.1931"><vh>function: hex_to_int</vh></v>
<v t="ekr.20250121054835.1932"><vh>function: int_to_hex</vh></v>
<v t="ekr.20250121054835.1933"><vh>function: color_gradient</vh></v>
<v t="ekr.20250121054835.1934"><vh>function: interpolate_color</vh></v>
<v t="ekr.20250121054835.1935"><vh>function: interpolate_color_by_hsl</vh></v>
<v t="ekr.20250121054835.1936"><vh>function: average_color</vh></v>
<v t="ekr.20250121054835.1937"><vh>function: random_color</vh></v>
<v t="ekr.20250121054835.1938"><vh>function: random_bright_color</vh></v>
<v t="ekr.20250121054835.1939"><vh>function: get_colormap_from_colors</vh></v>
<v t="ekr.20250121054835.1940"><vh>function: get_color_map</vh></v>
<v t="ekr.20250121054835.1941"><vh>function: get_colormap_list</vh></v>
</v>
<v t="ekr.20250121054835.1942"><vh>manimlib/utils/debug.py</vh>
<v t="ekr.20250121054835.1943"><vh>function: print_family</vh></v>
<v t="ekr.20250121054835.1944"><vh>function: index_labels</vh></v>
</v>
<v t="ekr.20250121054835.1945"><vh>manimlib/utils/dict_ops.py</vh>
<v t="ekr.20250121054835.1946"><vh>function: merge_dicts_recursively</vh></v>
</v>
<v t="ekr.20250121054835.1947"><vh>manimlib/utils/directories.py</vh>
<v t="ekr.20250121054835.1948"><vh>function: get_directories</vh></v>
<v t="ekr.20250121054835.1949"><vh>function: get_cache_dir</vh></v>
<v t="ekr.20250121054835.1950"><vh>function: get_temp_dir</vh></v>
<v t="ekr.20250121054835.1951"><vh>function: get_downloads_dir</vh></v>
<v t="ekr.20250121054835.1952"><vh>function: get_output_dir</vh></v>
<v t="ekr.20250121054835.1953"><vh>function: get_raster_image_dir</vh></v>
<v t="ekr.20250121054835.1954"><vh>function: get_vector_image_dir</vh></v>
<v t="ekr.20250121054835.1955"><vh>function: get_sound_dir</vh></v>
<v t="ekr.20250121054835.1956"><vh>function: get_shader_dir</vh></v>
</v>
<v t="ekr.20250121054835.1957"><vh>manimlib/utils/family_ops.py</vh>
<v t="ekr.20250121054835.1958"><vh>function: extract_mobject_family_members</vh></v>
<v t="ekr.20250121054835.1959"><vh>function: recursive_mobject_remove</vh></v>
</v>
<v t="ekr.20250121054835.1960"><vh>manimlib/utils/file_ops.py</vh>
<v t="ekr.20250121054835.1961"><vh>function: guarantee_existence</vh></v>
<v t="ekr.20250121054835.1962"><vh>function: find_file</vh></v>
</v>
<v t="ekr.20250121054835.1963"><vh>manimlib/utils/images.py</vh>
<v t="ekr.20250121054835.1964"><vh>function: get_full_raster_image_path</vh></v>
<v t="ekr.20250121054835.1965"><vh>function: get_full_vector_image_path</vh></v>
<v t="ekr.20250121054835.1966"><vh>function: invert_image</vh></v>
</v>
<v t="ekr.20250121054835.1967"><vh>manimlib/utils/iterables.py</vh>
<v t="ekr.20250121054835.1968"><vh>function: remove_list_redundancies</vh></v>
<v t="ekr.20250121054835.1969"><vh>function: list_update</vh></v>
<v t="ekr.20250121054835.1970"><vh>function: list_difference_update</vh></v>
<v t="ekr.20250121054835.1971"><vh>function: adjacent_n_tuples</vh></v>
<v t="ekr.20250121054835.1972"><vh>function: adjacent_pairs</vh></v>
<v t="ekr.20250121054835.1973"><vh>function: batch_by_property</vh></v>
<v t="ekr.20250121054835.1974"><vh>function: listify</vh></v>
<v t="ekr.20250121054835.1975"><vh>function: shuffled</vh></v>
<v t="ekr.20250121054835.1976"><vh>function: resize_array</vh></v>
<v t="ekr.20250121054835.1977"><vh>function: resize_preserving_order</vh></v>
<v t="ekr.20250121054835.1978"><vh>function: resize_with_interpolation</vh></v>
<v t="ekr.20250121054835.1979"><vh>function: make_even</vh></v>
<v t="ekr.20250121054835.1980"><vh>function: arrays_match</vh></v>
<v t="ekr.20250121054835.1981"><vh>function: array_is_constant</vh></v>
<v t="ekr.20250121054835.1982"><vh>function: cartesian_product</vh></v>
<v t="ekr.20250121054835.1983"><vh>function: hash_obj</vh></v>
</v>
<v t="ekr.20250121054835.1984"><vh>manimlib/utils/paths.py</vh>
<v t="ekr.20250121054835.1985"><vh>function: straight_path</vh></v>
<v t="ekr.20250121054835.1986"><vh>function: path_along_arc</vh></v>
<v t="ekr.20250121054835.1987"><vh>function: clockwise_path</vh></v>
<v t="ekr.20250121054835.1988"><vh>function: counterclockwise_path</vh></v>
</v>
<v t="ekr.20250121054835.1989"><vh>manimlib/utils/rate_functions.py</vh>
<v t="ekr.20250121054835.1990"><vh>function: linear</vh></v>
<v t="ekr.20250121054835.1991"><vh>function: smooth</vh></v>
<v t="ekr.20250121054835.1992"><vh>function: rush_into</vh></v>
<v t="ekr.20250121054835.1993"><vh>function: rush_from</vh></v>
<v t="ekr.20250121054835.1994"><vh>function: slow_into</vh></v>
<v t="ekr.20250121054835.1995"><vh>function: double_smooth</vh></v>
<v t="ekr.20250121054835.1996"><vh>function: there_and_back</vh></v>
<v t="ekr.20250121054835.1997"><vh>function: there_and_back_with_pause</vh></v>
<v t="ekr.20250121054835.1998"><vh>function: running_start</vh></v>
<v t="ekr.20250121054835.1999"><vh>function: overshoot</vh></v>
<v t="ekr.20250121054835.2000"><vh>function: not_quite_there</vh></v>
<v t="ekr.20250121054835.2001"><vh>function: wiggle</vh></v>
<v t="ekr.20250121054835.2002"><vh>function: squish_rate_func</vh></v>
<v t="ekr.20250121054835.2003"><vh>function: lingering</vh></v>
<v t="ekr.20250121054835.2004"><vh>function: exponential_decay</vh></v>
</v>
<v t="ekr.20250121054835.2005"><vh>manimlib/utils/shaders.py</vh>
<v t="ekr.20250121054835.2006"><vh>function: image_path_to_texture</vh></v>
<v t="ekr.20250121054835.2007"><vh>function: get_shader_program</vh></v>
<v t="ekr.20250121054835.2008"><vh>function: set_program_uniform</vh></v>
<v t="ekr.20250121054835.2009"><vh>function: get_shader_code_from_file</vh></v>
<v t="ekr.20250121054835.2010"><vh>function: get_colormap_code</vh></v>
</v>
<v t="ekr.20250121054835.2011"><vh>manimlib/utils/simple_functions.py</vh>
<v t="ekr.20250121054835.2012"><vh>function: sigmoid</vh></v>
<v t="ekr.20250121054835.2013"><vh>function: choose</vh></v>
<v t="ekr.20250121054835.2014"><vh>function: gen_choose</vh></v>
<v t="ekr.20250121054835.2015"><vh>function: get_num_args</vh></v>
<v t="ekr.20250121054835.2016"><vh>function: get_parameters</vh></v>
<v t="ekr.20250121054835.2017"><vh>function: clip</vh></v>
<v t="ekr.20250121054835.2018"><vh>function: arr_clip</vh></v>
<v t="ekr.20250121054835.2019"><vh>function: fdiv</vh></v>
<v t="ekr.20250121054835.2020"><vh>function: binary_search</vh></v>
<v t="ekr.20250121054835.2021"><vh>function: hash_string</vh></v>
</v>
<v t="ekr.20250121054835.2022"><vh>manimlib/utils/sounds.py</vh>
<v t="ekr.20250121054835.2023"><vh>function: get_full_sound_file_path</vh></v>
</v>
<v t="ekr.20250121054835.2024"><vh>manimlib/utils/space_ops.py</vh>
<v t="ekr.20250121054835.2025"><vh>function: cross</vh></v>
<v t="ekr.20250121054835.2026"><vh>function: get_norm</vh></v>
<v t="ekr.20250121054835.2027"><vh>function: get_dist</vh></v>
<v t="ekr.20250121054835.2028"><vh>function: normalize</vh></v>
<v t="ekr.20250121054835.2029"><vh>function: poly_line_length</vh></v>
<v t="ekr.20250121054835.2030"><vh>function: quaternion_mult</vh></v>
<v t="ekr.20250121054835.2031"><vh>function: quaternion_from_angle_axis</vh></v>
<v t="ekr.20250121054835.2032"><vh>function: angle_axis_from_quaternion</vh></v>
<v t="ekr.20250121054835.2033"><vh>function: quaternion_conjugate</vh></v>
<v t="ekr.20250121054835.2034"><vh>function: rotate_vector</vh></v>
<v t="ekr.20250121054835.2035"><vh>function: rotate_vector_2d</vh></v>
<v t="ekr.20250121054835.2036"><vh>function: rotation_matrix_transpose_from_quaternion</vh></v>
<v t="ekr.20250121054835.2037"><vh>function: rotation_matrix_from_quaternion</vh></v>
<v t="ekr.20250121054835.2038"><vh>function: rotation_matrix</vh></v>
<v t="ekr.20250121054835.2039"><vh>function: rotation_matrix_transpose</vh></v>
<v t="ekr.20250121054835.2040"><vh>function: rotation_about_z</vh></v>
<v t="ekr.20250121054835.2041"><vh>function: rotation_between_vectors</vh></v>
<v t="ekr.20250121054835.2042"><vh>function: z_to_vector</vh></v>
<v t="ekr.20250121054835.2043"><vh>function: angle_of_vector</vh></v>
<v t="ekr.20250121054835.2044"><vh>function: angle_between_vectors</vh></v>
<v t="ekr.20250121054835.2045"><vh>function: project_along_vector</vh></v>
<v t="ekr.20250121054835.2046"><vh>function: normalize_along_axis</vh></v>
<v t="ekr.20250121054835.2047"><vh>function: get_unit_normal</vh></v>
<v t="ekr.20250121054835.2048"><vh>function: thick_diagonal</vh></v>
<v t="ekr.20250121054835.2049"><vh>function: compass_directions</vh></v>
<v t="ekr.20250121054835.2050"><vh>function: complex_to_R3</vh></v>
<v t="ekr.20250121054835.2051"><vh>function: R3_to_complex</vh></v>
<v t="ekr.20250121054835.2052"><vh>function: complex_func_to_R3_func</vh></v>
<v t="ekr.20250121054835.2053"><vh>function: center_of_mass</vh></v>
<v t="ekr.20250121054835.2054"><vh>function: midpoint</vh></v>
<v t="ekr.20250121054835.2055"><vh>function: line_intersection</vh></v>
<v t="ekr.20250121054835.2056"><vh>function: find_intersection</vh></v>
<v t="ekr.20250121054835.2057"><vh>function: line_intersects_path</vh></v>
<v t="ekr.20250121054835.2058"><vh>function: get_closest_point_on_line</vh></v>
<v t="ekr.20250121054835.2059"><vh>function: get_winding_number</vh></v>
<v t="ekr.20250121054835.2060"><vh>function: cross2d</vh></v>
<v t="ekr.20250121054835.2061"><vh>function: tri_area</vh></v>
<v t="ekr.20250121054835.2062"><vh>function: is_inside_triangle</vh></v>
<v t="ekr.20250121054835.2063"><vh>function: norm_squared</vh></v>
<v t="ekr.20250121054835.2064"><vh>function: earclip_triangulation</vh></v>
</v>
<v t="ekr.20250121054835.2065"><vh>manimlib/utils/tex.py</vh>
<v t="ekr.20250121054835.2066"><vh>function: num_tex_symbols</vh></v>
<v t="ekr.20250121054835.2067"><vh>function: remove_tex_environments</vh></v>
</v>
<v t="ekr.20250121054835.2068"><vh>manimlib/utils/tex_file_writing.py</vh>
<v t="ekr.20250121054835.2069"><vh>function: get_tex_template_config</vh></v>
<v t="ekr.20250121054835.2070"><vh>function: get_tex_config</vh></v>
<v t="ekr.20250121054835.2071"><vh>function: get_full_tex</vh></v>
<v t="ekr.20250121054835.2072"><vh>function: latex_to_svg</vh></v>
<v t="ekr.20250121054835.2073"><vh>function: full_tex_to_svg</vh></v>
<v t="ekr.20250121054835.2074"><vh>class LatexError</vh></v>
</v>
<v t="ekr.20250121054835.2075"><vh>manimlib/utils/tex_to_symbol_count.py</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20250121054839.1"><vh>--- local files</vh>
<v t="ekr.20250121052813.1"><vh>@file main.py </vh></v>
<v t="ekr.20250121053749.1"><vh>@edit manim.cfg</vh></v>
</v>
<v t="ekr.20250121052813.1"></v>
</vnodes>
<tnodes>
<t tx="ekr.20250121054642.1">@language rest

ekr-study/ekr-manim-study/manim.leo A study outline for:

- manim community edition
  https://github.com/ManimCommunity/manim
- micrograd: 
  https://github.com/karpathy/micrograd

@language python
</t>
<t tx="ekr.20250121054646.1">g.execute_shell_commands(f"manim -p -ql main.py SquareToCircle")
</t>
<t tx="ekr.20250121054835.1"></t>
<t tx="ekr.20250121054835.10">def construct(self):
    # Tex to color map
    t2c = {
        "A": BLUE,
        "B": TEAL,
        "C": GREEN,
    }
    # Configuration to pass along to each Tex mobject
    kw = dict(font_size=72, t2c=t2c)
    lines = VGroup(
        Tex("A^2 + B^2 = C^2", **kw),
        Tex("A^2 = C^2 - B^2", **kw),
        Tex("A^2 = (C + B)(C - B)", **kw),
        Tex(R"A = \sqrt{(C + B)(C - B)}", **kw),
    )
    lines.arrange(DOWN, buff=LARGE_BUFF)

    self.add(lines[0])
    # The animation TransformMatchingStrings will line up parts
    # of the source and target which have matching substring strings.
    # Here, giving it a little path_arc makes each part rotate into
    # their final positions, which feels appropriate for the idea of
    # rearranging an equation
    self.play(
        TransformMatchingStrings(
            lines[0].copy(), lines[1],
            # matched_keys specifies which substring should
            # line up. If it's not specified, the animation
            # will align the longest matching substrings.
            # In this case, the substring "^2 = C^2" would
            # trip it up
            matched_keys=["A^2", "B^2", "C^2"],
            # When you want a substring from the source
            # to go to a non-equal substring from the target,
            # use the key map.
            key_map={"+": "-"},
            path_arc=90 * DEG,
        ),
    )
    self.wait()
    self.play(TransformMatchingStrings(
        lines[1].copy(), lines[2],
        matched_keys=["A^2"]
    ))
    self.wait()
    self.play(
        TransformMatchingStrings(
            lines[2].copy(), lines[3],
            key_map={"2": R"\sqrt"},
            path_arc=-30 * DEG,
        ),
    )
    self.wait(2)
    self.play(LaggedStartMap(FadeOut, lines, shift=2 * RIGHT))

    # TransformMatchingShapes will try to line up all pieces of a
    # source mobject with those of a target, regardless of the
    # what Mobject type they are.
    source = Text("the morse code", height=1)
    target = Text("here come dots", height=1)
    saved_source = source.copy()

    self.play(Write(source))
    self.wait()
    kw = dict(run_time=3, path_arc=PI / 2)
    self.play(TransformMatchingShapes(source, target, **kw))
    self.wait()
    self.play(TransformMatchingShapes(target, saved_source, **kw))
    self.wait()
</t>
<t tx="ekr.20250121054835.100">def init_vertex_objects(self):
    self.vbo = None
    self.vaos = []
</t>
<t tx="ekr.20250121054835.1000">def get_continuous_bounding_box_point(self, direction: Vect3) -&gt; Vect3:
    dl, center, ur = self.get_bounding_box()
    corner_vect = (ur - center)
    return center + direction / np.max(np.abs(np.true_divide(
        direction, corner_vect,
        out=np.zeros(len(direction)),
        where=((corner_vect) != 0)
    )))
</t>
<t tx="ekr.20250121054835.1001">def get_top(self) -&gt; Vect3:
    return self.get_edge_center(UP)
</t>
<t tx="ekr.20250121054835.1002">def get_bottom(self) -&gt; Vect3:
    return self.get_edge_center(DOWN)
</t>
<t tx="ekr.20250121054835.1003">def get_right(self) -&gt; Vect3:
    return self.get_edge_center(RIGHT)
</t>
<t tx="ekr.20250121054835.1004">def get_left(self) -&gt; Vect3:
    return self.get_edge_center(LEFT)
</t>
<t tx="ekr.20250121054835.1005">def get_zenith(self) -&gt; Vect3:
    return self.get_edge_center(OUT)
</t>
<t tx="ekr.20250121054835.1006">def get_nadir(self) -&gt; Vect3:
    return self.get_edge_center(IN)
</t>
<t tx="ekr.20250121054835.1007">def length_over_dim(self, dim: int) -&gt; float:
    bb = self.get_bounding_box()
    return abs((bb[2] - bb[0])[dim])
</t>
<t tx="ekr.20250121054835.1008">def get_width(self) -&gt; float:
    return self.length_over_dim(0)
</t>
<t tx="ekr.20250121054835.1009">def get_height(self) -&gt; float:
    return self.length_over_dim(1)
</t>
<t tx="ekr.20250121054835.101">def add_texture(self, name: str, texture: moderngl.Texture):
    max_units = self.ctx.info['GL_MAX_TEXTURE_IMAGE_UNITS']
    if len(self.textures) &gt;= max_units:
        raise ValueError(f"Unable to use more than {max_units} textures for a program")
    # The position in the list determines its id
    self.texture_names_to_ids[name] = len(self.textures)
    self.textures.append(texture)
</t>
<t tx="ekr.20250121054835.1010">def get_depth(self) -&gt; float:
    return self.length_over_dim(2)
</t>
<t tx="ekr.20250121054835.1011">def get_shape(self) -&gt; Tuple[float]:
    return tuple(self.length_over_dim(dim) for dim in range(3))
</t>
<t tx="ekr.20250121054835.1012">def get_coord(self, dim: int, direction: Vect3 = ORIGIN) -&gt; float:
    """
    Meant to generalize get_x, get_y, get_z
    """
    return self.get_bounding_box_point(direction)[dim]
</t>
<t tx="ekr.20250121054835.1013">def get_x(self, direction=ORIGIN) -&gt; float:
    return self.get_coord(0, direction)
</t>
<t tx="ekr.20250121054835.1014">def get_y(self, direction=ORIGIN) -&gt; float:
    return self.get_coord(1, direction)
</t>
<t tx="ekr.20250121054835.1015">def get_z(self, direction=ORIGIN) -&gt; float:
    return self.get_coord(2, direction)
</t>
<t tx="ekr.20250121054835.1016">def get_start(self) -&gt; Vect3:
    self.throw_error_if_no_points()
    return self.get_points()[0].copy()
</t>
<t tx="ekr.20250121054835.1017">def get_end(self) -&gt; Vect3:
    self.throw_error_if_no_points()
    return self.get_points()[-1].copy()
</t>
<t tx="ekr.20250121054835.1018">def get_start_and_end(self) -&gt; tuple[Vect3, Vect3]:
    self.throw_error_if_no_points()
    points = self.get_points()
    return (points[0].copy(), points[-1].copy())
</t>
<t tx="ekr.20250121054835.1019">def point_from_proportion(self, alpha: float) -&gt; Vect3:
    points = self.get_points()
    i, subalpha = integer_interpolate(0, len(points) - 1, alpha)
    return interpolate(points[i], points[i + 1], subalpha)
</t>
<t tx="ekr.20250121054835.102">def bind_to_mobject_uniforms(self, mobject_uniforms: UniformDict):
    self.mobject_uniforms = mobject_uniforms
</t>
<t tx="ekr.20250121054835.1020">def pfp(self, alpha):
    """Abbreviation for point_from_proportion"""
    return self.point_from_proportion(alpha)
</t>
<t tx="ekr.20250121054835.1021">def get_pieces(self, n_pieces: int) -&gt; Group:
    template = self.copy()
    template.set_submobjects([])
    alphas = np.linspace(0, 1, n_pieces + 1)
    return Group(*[
        template.copy().pointwise_become_partial(
            self, a1, a2
        )
        for a1, a2 in zip(alphas[:-1], alphas[1:])
    ])
</t>
<t tx="ekr.20250121054835.1022">def get_z_index_reference_point(self) -&gt; Vect3:
    # TODO, better place to define default z_index_group?
    z_index_group = getattr(self, "z_index_group", self)
    return z_index_group.get_center()
</t>
<t tx="ekr.20250121054835.1023"># Match other mobject properties

def match_color(self, mobject: Mobject) -&gt; Self:
    return self.set_color(mobject.get_color())
</t>
<t tx="ekr.20250121054835.1024">def match_style(self, mobject: Mobject) -&gt; Self:
    self.set_color(mobject.get_color())
    self.set_opacity(mobject.get_opacity())
    self.set_shading(*mobject.get_shading())
    return self
</t>
<t tx="ekr.20250121054835.1025">def match_dim_size(self, mobject: Mobject, dim: int, **kwargs) -&gt; Self:
    return self.rescale_to_fit(
        mobject.length_over_dim(dim), dim,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.1026">def match_width(self, mobject: Mobject, **kwargs) -&gt; Self:
    return self.match_dim_size(mobject, 0, **kwargs)
</t>
<t tx="ekr.20250121054835.1027">def match_height(self, mobject: Mobject, **kwargs) -&gt; Self:
    return self.match_dim_size(mobject, 1, **kwargs)
</t>
<t tx="ekr.20250121054835.1028">def match_depth(self, mobject: Mobject, **kwargs) -&gt; Self:
    return self.match_dim_size(mobject, 2, **kwargs)
</t>
<t tx="ekr.20250121054835.1029">def match_coord(
    self,
    mobject_or_point: Mobject | Vect3,
    dim: int,
    direction: Vect3 = ORIGIN
) -&gt; Self:
    if isinstance(mobject_or_point, Mobject):
        coord = mobject_or_point.get_coord(dim, direction)
    else:
        coord = mobject_or_point[dim]
    return self.set_coord(coord, dim=dim, direction=direction)
</t>
<t tx="ekr.20250121054835.103">def get_id(self) -&gt; int:
    return self.id
</t>
<t tx="ekr.20250121054835.1030">def match_x(
    self,
    mobject_or_point: Mobject | Vect3,
    direction: Vect3 = ORIGIN
) -&gt; Self:
    return self.match_coord(mobject_or_point, 0, direction)
</t>
<t tx="ekr.20250121054835.1031">def match_y(
    self,
    mobject_or_point: Mobject | Vect3,
    direction: Vect3 = ORIGIN
) -&gt; Self:
    return self.match_coord(mobject_or_point, 1, direction)
</t>
<t tx="ekr.20250121054835.1032">def match_z(
    self,
    mobject_or_point: Mobject | Vect3,
    direction: Vect3 = ORIGIN
) -&gt; Self:
    return self.match_coord(mobject_or_point, 2, direction)
</t>
<t tx="ekr.20250121054835.1033">def align_to(
    self,
    mobject_or_point: Mobject | Vect3,
    direction: Vect3 = ORIGIN
) -&gt; Self:
    """
    Examples:
    mob1.align_to(mob2, UP) moves mob1 vertically so that its
    top edge lines ups with mob2's top edge.

    mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1
    horizontally so that it's center is directly above/below
    the center of mob2
    """
    if isinstance(mobject_or_point, Mobject):
        point = mobject_or_point.get_bounding_box_point(direction)
    else:
        point = mobject_or_point

    for dim in range(self.dim):
        if direction[dim] != 0:
            self.set_coord(point[dim], dim, direction)
    return self
</t>
<t tx="ekr.20250121054835.1034">def get_group_class(self):
    return Group
</t>
<t tx="ekr.20250121054835.1035"># Alignment

def is_aligned_with(self, mobject: Mobject) -&gt; bool:
    if len(self.data) != len(mobject.data):
        return False
    if len(self.submobjects) != len(mobject.submobjects):
        return False
    return all(
        sm1.is_aligned_with(sm2)
        for sm1, sm2 in zip(self.submobjects, mobject.submobjects)
    )
</t>
<t tx="ekr.20250121054835.1036">def align_data_and_family(self, mobject: Mobject) -&gt; Self:
    self.align_family(mobject)
    self.align_data(mobject)
    return self
</t>
<t tx="ekr.20250121054835.1037">def align_data(self, mobject: Mobject) -&gt; Self:
    for mob1, mob2 in zip(self.get_family(), mobject.get_family()):
        mob1.align_points(mob2)
    return self
</t>
<t tx="ekr.20250121054835.1038">def align_points(self, mobject: Mobject) -&gt; Self:
    max_len = max(self.get_num_points(), mobject.get_num_points())
    for mob in (self, mobject):
        mob.resize_points(max_len, resize_func=resize_preserving_order)
    return self
</t>
<t tx="ekr.20250121054835.1039">def align_family(self, mobject: Mobject) -&gt; Self:
    mob1 = self
    mob2 = mobject
    n1 = len(mob1)
    n2 = len(mob2)
    if n1 != n2:
        mob1.add_n_more_submobjects(max(0, n2 - n1))
        mob2.add_n_more_submobjects(max(0, n1 - n2))
    # Recurse
    for sm1, sm2 in zip(mob1.submobjects, mob2.submobjects):
        sm1.align_family(sm2)
    return self
</t>
<t tx="ekr.20250121054835.104">def refresh_id(self) -&gt; None:
    self.id = hash("".join(map(str, [
        "".join(map(str, self.program_code.values())),
        self.mobject_uniforms,
        self.depth_test,
        self.render_primitive,
        self.texture_paths,
    ])))
</t>
<t tx="ekr.20250121054835.1040">def push_self_into_submobjects(self) -&gt; Self:
    copy = self.copy()
    copy.set_submobjects([])
    self.resize_points(0)
    self.add(copy)
    return self
</t>
<t tx="ekr.20250121054835.1041">def add_n_more_submobjects(self, n: int) -&gt; Self:
    if n == 0:
        return self

    curr = len(self.submobjects)
    if curr == 0:
        # If empty, simply add n point mobjects
        null_mob = self.copy()
        null_mob.set_points([self.get_center()])
        self.set_submobjects([
            null_mob.copy()
            for k in range(n)
        ])
        return self
    target = curr + n
    repeat_indices = (np.arange(target) * curr) // target
    split_factors = [
        (repeat_indices == i).sum()
        for i in range(curr)
    ]
    new_submobs = []
    for submob, sf in zip(self.submobjects, split_factors):
        new_submobs.append(submob)
        for k in range(1, sf):
            new_submobs.append(submob.invisible_copy())
    self.set_submobjects(new_submobs)
    return self
</t>
<t tx="ekr.20250121054835.1042">def invisible_copy(self) -&gt; Self:
    return self.copy().set_opacity(0)
</t>
<t tx="ekr.20250121054835.1043"># Interpolate

def interpolate(
    self,
    mobject1: Mobject,
    mobject2: Mobject,
    alpha: float,
    path_func: Callable[[np.ndarray, np.ndarray, float], np.ndarray] = straight_path
) -&gt; Self:
    keys = [k for k in self.data.dtype.names if k not in self.locked_data_keys]
    if keys:
        self.note_changed_data()
    for key in keys:
        md1 = mobject1.data[key]
        md2 = mobject2.data[key]
        if key in self.const_data_keys:
            md1 = md1[0]
            md2 = md2[0]
        if key in self.pointlike_data_keys:
            self.data[key] = path_func(md1, md2, alpha)
        else:
            self.data[key] = (1 - alpha) * md1 + alpha * md2

    for key in self.uniforms:
        if key in self.locked_uniform_keys:
            continue
        if key not in mobject1.uniforms or key not in mobject2.uniforms:
            continue
        self.uniforms[key] = (1 - alpha) * mobject1.uniforms[key] + alpha * mobject2.uniforms[key]
    self.bounding_box[:] = path_func(mobject1.bounding_box, mobject2.bounding_box, alpha)
    return self
</t>
<t tx="ekr.20250121054835.1044">def pointwise_become_partial(self, mobject, a, b) -&gt; Self:
    """
    Set points in such a way as to become only
    part of mobject.
    Inputs 0 &lt;= a &lt; b &lt;= 1 determine what portion
    of mobject to become.
    """
    # To be implemented in subclass
    return self
</t>
<t tx="ekr.20250121054835.1045"># Locking data

def lock_data(self, keys: Iterable[str]) -&gt; Self:
    """
    To speed up some animations, particularly transformations,
    it can be handy to acknowledge which pieces of data
    won't change during the animation so that calls to
    interpolate can skip this, and so that it's not
    read into the shader_wrapper objects needlessly
    """
    if self.has_updaters():
        return self
    self.locked_data_keys = set(keys)
    return self
</t>
<t tx="ekr.20250121054835.1046">def lock_uniforms(self, keys: Iterable[str]) -&gt; Self:
    if self.has_updaters():
        return self
    self.locked_uniform_keys = set(keys)
    return self
</t>
<t tx="ekr.20250121054835.1047">def lock_matching_data(self, mobject1: Mobject, mobject2: Mobject) -&gt; Self:
    tuples = zip(
        self.get_family(),
        mobject1.get_family(),
        mobject2.get_family(),
    )
    for sm, sm1, sm2 in tuples:
        if not sm.data.dtype == sm1.data.dtype == sm2.data.dtype:
            continue
        sm.lock_data(
            key for key in sm.data.dtype.names
            if arrays_match(sm1.data[key], sm2.data[key])
        )
        sm.lock_uniforms(
            key for key in self.uniforms
            if all(listify(mobject1.uniforms.get(key, 0) == mobject2.uniforms.get(key, 0)))
        )
        sm.const_data_keys = set(
            key for key in sm.data.dtype.names
            if key not in sm.locked_data_keys
            if all(
                array_is_constant(mob.data[key])
                for mob in (sm, sm1, sm2)
            )
        )

    return self
</t>
<t tx="ekr.20250121054835.1048">def unlock_data(self) -&gt; Self:
    for mob in self.get_family():
        mob.locked_data_keys = set()
        mob.const_data_keys = set()
        mob.locked_uniform_keys = set()
    return self
</t>
<t tx="ekr.20250121054835.1049"># Operations touching shader uniforms

@staticmethod
def affects_shader_info_id(func: Callable[..., T]) -&gt; Callable[..., T]:
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        result = func(self, *args, **kwargs)
        self.refresh_shader_wrapper_id()
        return result
    return wrapper
</t>
<t tx="ekr.20250121054835.105">def replace_code(self, old: str, new: str) -&gt; None:
    code_map = self.program_code
    for name in code_map:
        if code_map[name] is None:
            continue
        code_map[name] = re.sub(old, new, code_map[name])
    self.init_program()
    self.refresh_id()
</t>
<t tx="ekr.20250121054835.1050">@affects_shader_info_id
def set_uniform(self, recurse: bool = True, **new_uniforms) -&gt; Self:
    for mob in self.get_family(recurse):
        mob.uniforms.update(new_uniforms)
    return self
</t>
<t tx="ekr.20250121054835.1051">@affects_shader_info_id
def fix_in_frame(self, recurse: bool = True) -&gt; Self:
    self.set_uniform(recurse, is_fixed_in_frame=1.0)
    return self
</t>
<t tx="ekr.20250121054835.1052">@affects_shader_info_id
def unfix_from_frame(self, recurse: bool = True) -&gt; Self:
    self.set_uniform(recurse, is_fixed_in_frame=0.0)
    return self
</t>
<t tx="ekr.20250121054835.1053">def is_fixed_in_frame(self) -&gt; bool:
    return bool(self.uniforms["is_fixed_in_frame"])
</t>
<t tx="ekr.20250121054835.1054">@affects_shader_info_id
def apply_depth_test(self, recurse: bool = True) -&gt; Self:
    for mob in self.get_family(recurse):
        mob.depth_test = True
    return self
</t>
<t tx="ekr.20250121054835.1055">@affects_shader_info_id
def deactivate_depth_test(self, recurse: bool = True) -&gt; Self:
    for mob in self.get_family(recurse):
        mob.depth_test = False
    return self
</t>
<t tx="ekr.20250121054835.1056">def set_clip_plane(
    self,
    vect: Vect3 | None = None,
    threshold: float | None = None,
    recurse=True
) -&gt; Self:
    for submob in self.get_family(recurse):
        if vect is not None:
            submob.uniforms["clip_plane"][:3] = vect
        if threshold is not None:
            submob.uniforms["clip_plane"][3] = threshold
    return self
</t>
<t tx="ekr.20250121054835.1057">def deactivate_clip_plane(self) -&gt; Self:
    self.uniforms["clip_plane"][:] = 0
    return self
</t>
<t tx="ekr.20250121054835.1058"># Shader code manipulation

@affects_data
def replace_shader_code(self, old: str, new: str) -&gt; Self:
    for mob in self.get_family():
        mob.shader_code_replacements[old] = new
        mob.shader_wrapper = None
    return self
</t>
<t tx="ekr.20250121054835.1059">def set_color_by_code(self, glsl_code: str) -&gt; Self:
    """
    Takes a snippet of code and inserts it into a
    context which has the following variables:
    vec4 color, vec3 point, vec3 unit_normal.
    The code should change the color variable
    """
    self.replace_shader_code(
        "///// INSERT COLOR FUNCTION HERE /////",
        glsl_code
    )
    return self
</t>
<t tx="ekr.20250121054835.106"># Changing context
def use_clip_plane(self):
    if "clip_plane" not in self.mobject_uniforms:
        return False
    return any(self.mobject_uniforms["clip_plane"])
</t>
<t tx="ekr.20250121054835.1060">def set_color_by_xyz_func(
    self,
    glsl_snippet: str,
    min_value: float = -5.0,
    max_value: float = 5.0,
    colormap: str = "viridis"
) -&gt; Self:
    """
    Pass in a glsl expression in terms of x, y and z which returns
    a float.
    """
    # TODO, add a version of this which changes the point data instead
    # of the shader code
    for char in "xyz":
        glsl_snippet = glsl_snippet.replace(char, "point." + char)
    rgb_list = get_colormap_list(colormap)
    self.set_color_by_code(
        "color.rgb = float_to_color({}, {}, {}, {});".format(
            glsl_snippet,
            float(min_value),
            float(max_value),
            get_colormap_code(rgb_list)
        )
    )
    return self
</t>
<t tx="ekr.20250121054835.1061"># For shader data

def init_shader_wrapper(self, ctx: Context):
    self.shader_wrapper = ShaderWrapper(
        ctx=ctx,
        vert_data=self.data,
        shader_folder=self.shader_folder,
        mobject_uniforms=self.uniforms,
        texture_paths=self.texture_paths,
        depth_test=self.depth_test,
        render_primitive=self.render_primitive,
        code_replacements=self.shader_code_replacements,
    )
</t>
<t tx="ekr.20250121054835.1062">def refresh_shader_wrapper_id(self):
    for submob in self.get_family():
        if submob.shader_wrapper is not None:
            submob.shader_wrapper.depth_test = submob.depth_test
            submob.shader_wrapper.refresh_id()
    for mob in (self, *self.get_ancestors()):
        mob._data_has_changed = True
    return self
</t>
<t tx="ekr.20250121054835.1063">def get_shader_wrapper(self, ctx: Context) -&gt; ShaderWrapper:
    if self.shader_wrapper is None:
        self.init_shader_wrapper(ctx)
    return self.shader_wrapper
</t>
<t tx="ekr.20250121054835.1064">def get_shader_wrapper_list(self, ctx: Context) -&gt; list[ShaderWrapper]:
    family = self.family_members_with_points()
    batches = batch_by_property(family, lambda sm: sm.get_shader_wrapper(ctx).get_id())

    result = []
    for submobs, sid in batches:
        shader_wrapper = submobs[0].shader_wrapper
        data_list = [sm.get_shader_data() for sm in submobs]
        shader_wrapper.read_in(data_list)
        result.append(shader_wrapper)
    return result
</t>
<t tx="ekr.20250121054835.1065">def get_shader_data(self) -&gt; np.ndarray:
    indices = self.get_shader_vert_indices()
    if indices is not None:
        return self.data[indices]
    else:
        return self.data
</t>
<t tx="ekr.20250121054835.1066">def get_uniforms(self):
    return self.uniforms
</t>
<t tx="ekr.20250121054835.1067">def get_shader_vert_indices(self) -&gt; Optional[np.ndarray]:
    return None
</t>
<t tx="ekr.20250121054835.1068">def render(self, ctx: Context, camera_uniforms: dict):
    if self._data_has_changed:
        self.shader_wrappers = self.get_shader_wrapper_list(ctx)
        self._data_has_changed = False
    for shader_wrapper in self.shader_wrappers:
        shader_wrapper.update_program_uniforms(camera_uniforms)
        shader_wrapper.pre_render()
        shader_wrapper.render()

# Event Handlers
"""
    Event handling follows the Event Bubbling model of DOM in javascript.
    Return false to stop the event bubbling.
    To learn more visit https://www.quirksmode.org/js/events_order.html

    Event Callback Argument is a callable function taking two arguments:
        1. Mobject
        2. EventData
"""
</t>
<t tx="ekr.20250121054835.1069">def init_event_listners(self):
    self.event_listners: list[EventListener] = []
</t>
<t tx="ekr.20250121054835.107">def set_ctx_depth_test(self, enable: bool = True) -&gt; None:
    if enable:
        self.ctx.enable(moderngl.DEPTH_TEST)
    else:
        self.ctx.disable(moderngl.DEPTH_TEST)
</t>
<t tx="ekr.20250121054835.1070">def add_event_listner(
    self,
    event_type: EventType,
    event_callback: Callable[[Mobject, dict[str]]]
):
    event_listner = EventListener(self, event_type, event_callback)
    self.event_listners.append(event_listner)
    EVENT_DISPATCHER.add_listner(event_listner)
    return self
</t>
<t tx="ekr.20250121054835.1071">def remove_event_listner(
    self,
    event_type: EventType,
    event_callback: Callable[[Mobject, dict[str]]]
):
    event_listner = EventListener(self, event_type, event_callback)
    while event_listner in self.event_listners:
        self.event_listners.remove(event_listner)
    EVENT_DISPATCHER.remove_listner(event_listner)
    return self
</t>
<t tx="ekr.20250121054835.1072">def clear_event_listners(self, recurse: bool = True):
    self.event_listners = []
    if recurse:
        for submob in self.submobjects:
            submob.clear_event_listners(recurse=recurse)
    return self
</t>
<t tx="ekr.20250121054835.1073">def get_event_listners(self):
    return self.event_listners
</t>
<t tx="ekr.20250121054835.1074">def get_family_event_listners(self):
    return list(it.chain(*[sm.get_event_listners() for sm in self.get_family()]))
</t>
<t tx="ekr.20250121054835.1075">def get_has_event_listner(self):
    return any(
        mob.get_event_listners()
        for mob in self.get_family()
    )
</t>
<t tx="ekr.20250121054835.1076">def add_mouse_motion_listner(self, callback):
    self.add_event_listner(EventType.MouseMotionEvent, callback)
</t>
<t tx="ekr.20250121054835.1077">def remove_mouse_motion_listner(self, callback):
    self.remove_event_listner(EventType.MouseMotionEvent, callback)
</t>
<t tx="ekr.20250121054835.1078">def add_mouse_press_listner(self, callback):
    self.add_event_listner(EventType.MousePressEvent, callback)
</t>
<t tx="ekr.20250121054835.1079">def remove_mouse_press_listner(self, callback):
    self.remove_event_listner(EventType.MousePressEvent, callback)
</t>
<t tx="ekr.20250121054835.108">def set_ctx_clip_plane(self, enable: bool = True) -&gt; None:
    if enable:
        gl.glEnable(gl.GL_CLIP_DISTANCE0)
</t>
<t tx="ekr.20250121054835.1080">def add_mouse_release_listner(self, callback):
    self.add_event_listner(EventType.MouseReleaseEvent, callback)
</t>
<t tx="ekr.20250121054835.1081">def remove_mouse_release_listner(self, callback):
    self.remove_event_listner(EventType.MouseReleaseEvent, callback)
</t>
<t tx="ekr.20250121054835.1082">def add_mouse_drag_listner(self, callback):
    self.add_event_listner(EventType.MouseDragEvent, callback)
</t>
<t tx="ekr.20250121054835.1083">def remove_mouse_drag_listner(self, callback):
    self.remove_event_listner(EventType.MouseDragEvent, callback)
</t>
<t tx="ekr.20250121054835.1084">def add_mouse_scroll_listner(self, callback):
    self.add_event_listner(EventType.MouseScrollEvent, callback)
</t>
<t tx="ekr.20250121054835.1085">def remove_mouse_scroll_listner(self, callback):
    self.remove_event_listner(EventType.MouseScrollEvent, callback)
</t>
<t tx="ekr.20250121054835.1086">def add_key_press_listner(self, callback):
    self.add_event_listner(EventType.KeyPressEvent, callback)
</t>
<t tx="ekr.20250121054835.1087">def remove_key_press_listner(self, callback):
    self.remove_event_listner(EventType.KeyPressEvent, callback)
</t>
<t tx="ekr.20250121054835.1088">def add_key_release_listner(self, callback):
    self.add_event_listner(EventType.KeyReleaseEvent, callback)
</t>
<t tx="ekr.20250121054835.1089">def remove_key_release_listner(self, callback):
    self.remove_event_listner(EventType.KeyReleaseEvent, callback)
</t>
<t tx="ekr.20250121054835.109"># Adding data

def read_in(self, data_list: Iterable[np.ndarray]):
    total_len = sum(map(len, data_list))
    if total_len == 0:
        if self.vbo is not None:
            self.vbo.clear()
        return

    # If possible, read concatenated data into existing list
    if len(self.vert_data) != total_len:
        self.vert_data = np.concatenate(data_list)
    else:
        np.concatenate(data_list, out=self.vert_data)

    # Either create new vbo, or read data into it
    total_size = self.vert_data.itemsize * total_len
    if self.vbo is not None and self.vbo.size != total_size:
        self.release()  # This sets vbo to be None
    if self.vbo is None:
        self.vbo = self.ctx.buffer(self.vert_data)
        self.generate_vaos()
    else:
        self.vbo.write(self.vert_data)
</t>
<t tx="ekr.20250121054835.1090"># Errors

def throw_error_if_no_points(self):
    if not self.has_points():
        message = "Cannot call Mobject.{} " +\
                  "for a Mobject with no points"
        caller_name = sys._getframe(1).f_code.co_name
        raise Exception(message.format(caller_name))
</t>
<t tx="ekr.20250121054835.1091">class Group(Mobject, Generic[SubmobjectType]):
    @others
</t>
<t tx="ekr.20250121054835.1092">def __init__(self, *mobjects: SubmobjectType | Iterable[SubmobjectType], **kwargs):
    super().__init__(**kwargs)
    self._ingest_args(*mobjects)
</t>
<t tx="ekr.20250121054835.1093">def _ingest_args(self, *args: Mobject | Iterable[Mobject]):
    if len(args) == 0:
        return
    if all(isinstance(mob, Mobject) for mob in args):
        self.add(*args)
    elif isinstance(args[0], Iterable):
        self.add(*args[0])
    else:
        raise Exception(f"Invalid argument to Group of type {type(args[0])}")
</t>
<t tx="ekr.20250121054835.1094">def __add__(self, other: Mobject | Group) -&gt; Self:
    assert isinstance(other, Mobject)
    return self.add(other)
</t>
<t tx="ekr.20250121054835.1095"># This is just here to make linters happy with references to things like Group(...)[0]
def __getitem__(self, index) -&gt; SubmobjectType:
    return super().__getitem__(index)
</t>
<t tx="ekr.20250121054835.1096">class Point(Mobject):
    @others
</t>
<t tx="ekr.20250121054835.1097">def __init__(
    self,
    location: Vect3 = ORIGIN,
    artificial_width: float = 1e-6,
    artificial_height: float = 1e-6,
    **kwargs
):
    self.artificial_width = artificial_width
    self.artificial_height = artificial_height
    super().__init__(**kwargs)
    self.set_location(location)
</t>
<t tx="ekr.20250121054835.1098">def get_width(self) -&gt; float:
    return self.artificial_width
</t>
<t tx="ekr.20250121054835.1099">def get_height(self) -&gt; float:
    return self.artificial_height
</t>
<t tx="ekr.20250121054835.11">class TexIndexing(Scene):
    @others
</t>
<t tx="ekr.20250121054835.110">def generate_vaos(self):
    # Vertex array object
    self.vaos = [
        self.ctx.vertex_array(
            program=program,
            content=[(self.vbo, self.vert_format, *self.vert_attributes)],
            mode=self.render_primitive,
        )
        for program in self.programs
    ]
</t>
<t tx="ekr.20250121054835.1100">def get_location(self) -&gt; Vect3:
    return self.get_points()[0].copy()
</t>
<t tx="ekr.20250121054835.1101">def get_bounding_box_point(self, *args, **kwargs) -&gt; Vect3:
    return self.get_location()
</t>
<t tx="ekr.20250121054835.1102">def set_location(self, new_loc: npt.ArrayLike) -&gt; Self:
    self.set_points(np.array(new_loc, ndmin=2, dtype=float))
    return self
</t>
<t tx="ekr.20250121054835.1103">class _AnimationBuilder:
    @others
</t>
<t tx="ekr.20250121054835.1104">def __init__(self, mobject: Mobject):
    self.mobject = mobject
    self.overridden_animation = None
    self.mobject.generate_target()
    self.is_chaining = False
    self.methods: list[Callable] = []
    self.anim_args = {}
    self.can_pass_args = True
</t>
<t tx="ekr.20250121054835.1105">def __getattr__(self, method_name: str):
    method = getattr(self.mobject.target, method_name)
    self.methods.append(method)
    has_overridden_animation = hasattr(method, "_override_animate")

    if (self.is_chaining and has_overridden_animation) or self.overridden_animation:
        raise NotImplementedError(
            "Method chaining is currently not supported for " + \
            "overridden animations"
        )

    def update_target(*method_args, **method_kwargs):
        if has_overridden_animation:
            self.overridden_animation = method._override_animate(
                self.mobject, *method_args, **method_kwargs
            )
        else:
            method(*method_args, **method_kwargs)
        return self

    self.is_chaining = True
    return update_target
</t>
<t tx="ekr.20250121054835.1106">def __call__(self, **kwargs):
    return self.set_anim_args(**kwargs)
</t>
<t tx="ekr.20250121054835.1107">def set_anim_args(self, **kwargs):
    '''
    You can change the args of :class:`~manimlib.animation.transform.Transform`, such as

    - ``run_time``
    - ``time_span``
    - ``rate_func``
    - ``lag_ratio``
    - ``path_arc``
    - ``path_func``

    and so on.
    '''

    if not self.can_pass_args:
        raise ValueError(
            "Animation arguments can only be passed by calling ``animate`` " + \
            "or ``set_anim_args`` and can only be passed once",
        )

    self.anim_args = kwargs
    self.can_pass_args = False
    return self
</t>
<t tx="ekr.20250121054835.1108">def build(self):
    from manimlib.animation.transform import _MethodAnimation

    if self.overridden_animation:
        return self.overridden_animation

    return _MethodAnimation(self.mobject, self.methods, **self.anim_args)
</t>
<t tx="ekr.20250121054835.1109">def override_animate(method):
    def decorator(animation_method):
        method._override_animate = animation_method
        return animation_method

    return decorator
</t>
<t tx="ekr.20250121054835.111"># Related to data and rendering
def pre_render(self):
    self.set_ctx_depth_test(self.depth_test)
    self.set_ctx_clip_plane(self.use_clip_plane())
    for tid, texture in enumerate(self.textures):
        texture.use(tid)
</t>
<t tx="ekr.20250121054835.1110">class _UpdaterBuilder:
    @others
</t>
<t tx="ekr.20250121054835.1111">def __init__(self, mobject: Mobject):
    self.mobject = mobject
</t>
<t tx="ekr.20250121054835.1112">def __getattr__(self, method_name: str):
    def add_updater(*method_args, **method_kwargs):
        self.mobject.add_updater(
            lambda m: getattr(m, method_name)(*method_args, **method_kwargs)
        )
        return self
    return add_updater
</t>
<t tx="ekr.20250121054835.1113">class _FunctionalUpdaterBuilder:
    @others
</t>
<t tx="ekr.20250121054835.1114">def __init__(self, mobject: Mobject):
    self.mobject = mobject
</t>
<t tx="ekr.20250121054835.1115">def __getattr__(self, method_name: str):
    def add_updater(*method_args, **method_kwargs):
        self.mobject.add_updater(
            lambda m: getattr(m, method_name)(
                *(arg() for arg in method_args),
                **{
                    key: value()
                    for key, value in method_kwargs.items()
                }
            )
        )
        return self
    return add_updater
</t>
<t tx="ekr.20250121054835.1116">from __future__ import annotations

import inspect

from manimlib.constants import DEG
from manimlib.constants import RIGHT
from manimlib.mobject.mobject import Mobject
from manimlib.utils.simple_functions import clip

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable

    import numpy as np

    from manimlib.animation.animation import Animation


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1117">def assert_is_mobject_method(method):
    assert inspect.ismethod(method)
    mobject = method.__self__
    assert isinstance(mobject, Mobject)
</t>
<t tx="ekr.20250121054835.1118">def always(method, *args, **kwargs):
    assert_is_mobject_method(method)
    mobject = method.__self__
    func = method.__func__
    mobject.add_updater(lambda m: func(m, *args, **kwargs))
    return mobject
</t>
<t tx="ekr.20250121054835.1119">def f_always(method, *arg_generators, **kwargs):
    """
    More functional version of always, where instead
    of taking in args, it takes in functions which output
    the relevant arguments.
    """
    assert_is_mobject_method(method)
    mobject = method.__self__
    func = method.__func__

    def updater(mob):
        args = [
            arg_generator()
            for arg_generator in arg_generators
        ]
        func(mob, *args, **kwargs)

    mobject.add_updater(updater)
    return mobject
</t>
<t tx="ekr.20250121054835.112">def render(self):
    for vao in self.vaos:
        vao.render()
</t>
<t tx="ekr.20250121054835.1120">def always_redraw(func: Callable[..., Mobject], *args, **kwargs) -&gt; Mobject:
    mob = func(*args, **kwargs)
    mob.add_updater(lambda m: mob.become(func(*args, **kwargs)))
    return mob
</t>
<t tx="ekr.20250121054835.1121">def always_shift(
    mobject: Mobject,
    direction: np.ndarray = RIGHT,
    rate: float = 0.1
) -&gt; Mobject:
    mobject.add_updater(
        lambda m, dt: m.shift(dt * rate * direction)
    )
    return mobject
</t>
<t tx="ekr.20250121054835.1122">def always_rotate(
    mobject: Mobject,
    rate: float = 20 * DEG,
    **kwargs
) -&gt; Mobject:
    mobject.add_updater(
        lambda m, dt: m.rotate(dt * rate, **kwargs)
    )
    return mobject
</t>
<t tx="ekr.20250121054835.1123">def turn_animation_into_updater(
    animation: Animation,
    cycle: bool = False,
    **kwargs
) -&gt; Mobject:
    """
    Add an updater to the animation's mobject which applies
    the interpolation and update functions of the animation

    If cycle is True, this repeats over and over.  Otherwise,
    the updater will be popped uplon completion
    """
    mobject = animation.mobject
    animation.update_rate_info(**kwargs)
    animation.suspend_mobject_updating = False
    animation.begin()
    animation.total_time = 0

    def update(m, dt):
        run_time = animation.get_run_time()
        time_ratio = animation.total_time / run_time
        if cycle:
            alpha = time_ratio % 1
        else:
            alpha = clip(time_ratio, 0, 1)
            if alpha &gt;= 1:
                animation.finish()
                m.remove_updater(update)
                return
        animation.interpolate(alpha)
        animation.update_mobjects(dt)
        animation.total_time += dt

    mobject.add_updater(update)
    return mobject
</t>
<t tx="ekr.20250121054835.1124">def cycle_animation(animation: Animation, **kwargs) -&gt; Mobject:
    return turn_animation_into_updater(
        animation, cycle=True, **kwargs
    )
</t>
<t tx="ekr.20250121054835.1125">from __future__ import annotations

import numpy as np

from manimlib.constants import DOWN, LEFT, RIGHT, UP
from manimlib.constants import GREY_B
from manimlib.constants import MED_SMALL_BUFF
from manimlib.mobject.geometry import Line
from manimlib.mobject.numbers import DecimalNumber
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.utils.bezier import interpolate
from manimlib.utils.bezier import outer_interpolate
from manimlib.utils.dict_ops import merge_dicts_recursively
from manimlib.utils.simple_functions import fdiv

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable, Optional
    from manimlib.typing import ManimColor, Vect3, Vect3Array, VectN, RangeSpecifier


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1126">class NumberLine(Line):
    @others
</t>
<t tx="ekr.20250121054835.1127">def __init__(
    self,
    x_range: RangeSpecifier = (-8, 8, 1),
    color: ManimColor = GREY_B,
    stroke_width: float = 2.0,
    # How big is one one unit of this number line in terms of absolute spacial distance
    unit_size: float = 1.0,
    width: Optional[float] = None,
    include_ticks: bool = True,
    tick_size: float = 0.1,
    longer_tick_multiple: float = 1.5,
    tick_offset: float = 0.0,
    # Change name
    big_tick_spacing: Optional[float] = None,
    big_tick_numbers: list[float] = [],
    include_numbers: bool = False,
    line_to_number_direction: Vect3 = DOWN,
    line_to_number_buff: float = MED_SMALL_BUFF,
    include_tip: bool = False,
    tip_config: dict = dict(
        width=0.25,
        length=0.25,
    ),
    decimal_number_config: dict = dict(
        num_decimal_places=0,
        font_size=36,
    ),
    numbers_to_exclude: list | None = None,
    **kwargs,
</t>
<t tx="ekr.20250121054835.1128">):
    self.x_range = x_range
    self.tick_size = tick_size
    self.longer_tick_multiple = longer_tick_multiple
    self.tick_offset = tick_offset
    if big_tick_spacing is not None:
        self.big_tick_numbers = np.arange(
            x_range[0],
            x_range[1] + big_tick_spacing,
            big_tick_spacing,
        )
    else:
        self.big_tick_numbers = list(big_tick_numbers)
    self.line_to_number_direction = line_to_number_direction
    self.line_to_number_buff = line_to_number_buff
    self.include_tip = include_tip
    self.tip_config = dict(tip_config)
    self.decimal_number_config = dict(decimal_number_config)
    self.numbers_to_exclude = numbers_to_exclude

    self.x_min, self.x_max = x_range[:2]
    self.x_step = 1 if len(x_range) == 2 else x_range[2]

    super().__init__(
        self.x_min * RIGHT, self.x_max * RIGHT,
        color=color,
        stroke_width=stroke_width,
        **kwargs
    )

    if width:
        self.set_width(width)
    else:
        self.scale(unit_size)
    self.center()

    if include_tip:
        self.add_tip()
        self.tip.set_stroke(
            self.stroke_color,
            self.stroke_width,
        )
    if include_ticks:
        self.add_ticks()
    if include_numbers:
        self.add_numbers(excluding=self.numbers_to_exclude)

def get_tick_range(self) -&gt; np.ndarray:
    if self.include_tip:
        x_max = self.x_max
    else:
        x_max = self.x_max + self.x_step
    result = np.arange(self.x_min, x_max, self.x_step)
    return result[result &lt;= self.x_max]
</t>
<t tx="ekr.20250121054835.1129">def add_ticks(self) -&gt; None:
    ticks = VGroup()
    for x in self.get_tick_range():
        size = self.tick_size
        if np.isclose(self.big_tick_numbers, x).any():
            size *= self.longer_tick_multiple
        ticks.add(self.get_tick(x, size))
    self.add(ticks)
    self.ticks = ticks
</t>
<t tx="ekr.20250121054835.113">def update_program_uniforms(self, camera_uniforms: UniformDict):
    for program in self.programs:
        if program is None:
            continue
        for uniforms in [self.mobject_uniforms, camera_uniforms, self.texture_names_to_ids]:
            for name, value in uniforms.items():
                set_program_uniform(program, name, value)
</t>
<t tx="ekr.20250121054835.1130">def get_tick(self, x: float, size: float | None = None) -&gt; Line:
    if size is None:
        size = self.tick_size
    result = Line(size * DOWN, size * UP)
    result.rotate(self.get_angle())
    result.move_to(self.number_to_point(x))
    result.match_style(self)
    return result
</t>
<t tx="ekr.20250121054835.1131">def get_tick_marks(self) -&gt; VGroup:
    return self.ticks
</t>
<t tx="ekr.20250121054835.1132">def number_to_point(self, number: float | VectN) -&gt; Vect3 | Vect3Array:
    start = self.get_points()[0]
    end = self.get_points()[-1]
    alpha = (number - self.x_min) / (self.x_max - self.x_min)
    return outer_interpolate(start, end, alpha)
</t>
<t tx="ekr.20250121054835.1133">def point_to_number(self, point: Vect3 | Vect3Array) -&gt; float | VectN:
    start = self.get_points()[0]
    end = self.get_points()[-1]
    vect = end - start
    proportion = fdiv(
        np.dot(point - start, vect),
        np.dot(end - start, vect),
    )
    return interpolate(self.x_min, self.x_max, proportion)
</t>
<t tx="ekr.20250121054835.1134">def n2p(self, number: float | VectN) -&gt; Vect3 | Vect3Array:
    """Abbreviation for number_to_point"""
    return self.number_to_point(number)
</t>
<t tx="ekr.20250121054835.1135">def p2n(self, point: Vect3 | Vect3Array) -&gt; float | VectN:
    """Abbreviation for point_to_number"""
    return self.point_to_number(point)
</t>
<t tx="ekr.20250121054835.1136">def get_unit_size(self) -&gt; float:
    return self.get_length() / (self.x_max - self.x_min)
</t>
<t tx="ekr.20250121054835.1137">def get_number_mobject(
    self,
    x: float,
    direction: Vect3 | None = None,
    buff: float | None = None,
    unit: float = 1.0,
    unit_tex: str = "",
    **number_config
) -&gt; DecimalNumber:
    number_config = merge_dicts_recursively(
        self.decimal_number_config, number_config,
    )
    if direction is None:
        direction = self.line_to_number_direction
    if buff is None:
        buff = self.line_to_number_buff
    if unit_tex:
        number_config["unit"] = unit_tex

    num_mob = DecimalNumber(x / unit, **number_config)
    num_mob.next_to(
        self.number_to_point(x),
        direction=direction,
        buff=buff
    )
    if x &lt; 0 and direction[0] == 0:
        # Align without the minus sign
        num_mob.shift(num_mob[0].get_width() * LEFT / 2)
    if x == unit and unit_tex:
        center = num_mob.get_center()
        num_mob.remove(num_mob[0])
        num_mob.move_to(center)
    return num_mob
</t>
<t tx="ekr.20250121054835.1138">def add_numbers(
    self,
    x_values: Iterable[float] | None = None,
    excluding: Iterable[float] | None = None,
    font_size: int = 24,
    **kwargs
) -&gt; VGroup:
    if x_values is None:
        x_values = self.get_tick_range()

    kwargs["font_size"] = font_size

    if excluding is None:
        excluding = self.numbers_to_exclude

    numbers = VGroup()
    for x in x_values:
        if excluding is not None and x in excluding:
            continue
        numbers.add(self.get_number_mobject(x, **kwargs))
    self.add(numbers)
    self.numbers = numbers
    return numbers
</t>
<t tx="ekr.20250121054835.1139">class UnitInterval(NumberLine):
    @others
    ):
        super().__init__(
            x_range=x_range,
            unit_size=unit_size,
            big_tick_numbers=big_tick_numbers,
            decimal_number_config=decimal_number_config,
            **kwargs
        )
</t>
<t tx="ekr.20250121054835.114">def release(self):
    for obj in (self.vbo, *self.vaos):
        if obj is not None:
            obj.release()
    self.init_vertex_objects()
</t>
<t tx="ekr.20250121054835.1140">def __init__(
    self,
    x_range: RangeSpecifier = (0, 1, 0.1),
    unit_size: float = 10,
    big_tick_numbers: list[float] = [0, 1],
    decimal_number_config: dict = dict(
        num_decimal_places=1,
    ),
    **kwargs
</t>
<t tx="ekr.20250121054835.1141">from __future__ import annotations
from functools import lru_cache

import numpy as np

from manimlib.constants import DOWN, LEFT, RIGHT, UP
from manimlib.constants import WHITE
from manimlib.mobject.svg.tex_mobject import Tex
from manimlib.mobject.svg.text_mobject import Text
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.paths import straight_path
from manimlib.utils.bezier import interpolate

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import TypeVar, Callable
    from manimlib.mobject.mobject import Mobject
    from manimlib.typing import ManimColor, Vect3, Self

    T = TypeVar("T", bound=VMobject)


@lru_cache()
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1142">def char_to_cahced_mob(char: str, **text_config):
    if "\\" in char:
        # This is for when the "character" is a LaTeX command
        # like ^\circ or \dots
        return Tex(char, **text_config)
    else:
        return Text(char, **text_config)
</t>
<t tx="ekr.20250121054835.1143">class DecimalNumber(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.1144">def __init__(
    self,
    number: float | complex = 0,
    color: ManimColor = WHITE,
    stroke_width: float = 0,
    fill_opacity: float = 1.0,
    fill_border_width: float = 0.5,
    num_decimal_places: int = 2,
    include_sign: bool = False,
    group_with_commas: bool = True,
    digit_buff_per_font_unit: float = 0.001,
    show_ellipsis: bool = False,
    unit: str | None = None,  # Aligned to bottom unless it starts with "^"
    include_background_rectangle: bool = False,
    edge_to_fix: Vect3 = LEFT,
    font_size: float = 48,
    text_config: dict = dict(),  # Do not pass in font_size here
    **kwargs
</t>
<t tx="ekr.20250121054835.1145">):
    self.num_decimal_places = num_decimal_places
    self.include_sign = include_sign
    self.group_with_commas = group_with_commas
    self.digit_buff_per_font_unit = digit_buff_per_font_unit
    self.show_ellipsis = show_ellipsis
    self.unit = unit
    self.include_background_rectangle = include_background_rectangle
    self.edge_to_fix = edge_to_fix
    self.font_size = font_size
    self.text_config = dict(text_config)

    super().__init__(
        color=color,
        stroke_width=stroke_width,
        fill_opacity=fill_opacity,
        fill_border_width=fill_border_width,
        **kwargs
    )

    self.set_submobjects_from_number(number)
    self.init_colors()

def set_submobjects_from_number(self, number: float | complex) -&gt; None:
    # Create the submobject list
    self.number = number
    self.num_string = self.get_num_string(number)

    # Submob_templates will be a list of cached Tex and Text mobjects,
    # with the intent of calling .copy or .become on them
    submob_templates = list(map(self.char_to_mob, self.num_string))
    if self.show_ellipsis:
        dots = self.char_to_mob("...")
        dots.arrange(RIGHT, buff=2 * dots[0].get_width())
        submob_templates.append(dots)
    if self.unit is not None:
        submob_templates.append(self.char_to_mob(self.unit))

    # Set internals
    font_size = self.get_font_size()
    if len(submob_templates) == len(self.submobjects):
        for sm, smt in zip(self.submobjects, submob_templates):
            sm.become(smt)
            sm.scale(font_size / smt.font_size)
    else:
        self.set_submobjects([
            smt.copy().scale(font_size / smt.font_size)
            for smt in submob_templates
        ])

    digit_buff = self.digit_buff_per_font_unit * font_size
    self.arrange(RIGHT, buff=digit_buff, aligned_edge=DOWN)

    # Handle alignment of special characters
    for i, c in enumerate(self.num_string):
        if c == "–" and len(self.num_string) &gt; i + 1:
            self[i].align_to(self[i + 1], UP)
            self[i].shift(self[i + 1].get_height() * DOWN / 2)
        elif c == ",":
            self[i].shift(self[i].get_height() * DOWN / 2)
    if self.unit and self.unit.startswith("^"):
        self[-1].align_to(self, UP)

    if self.include_background_rectangle:
        self.add_background_rectangle()
</t>
<t tx="ekr.20250121054835.1146">def get_num_string(self, number: float | complex) -&gt; str:
    if isinstance(number, complex):
        formatter = self.get_complex_formatter()
    else:
        formatter = self.get_formatter()
    if self.num_decimal_places == 0 and isinstance(number, float):
        number = int(number)
    num_string = formatter.format(number)

    rounded_num = np.round(number, self.num_decimal_places)
    if num_string.startswith("-") and rounded_num == 0:
        if self.include_sign:
            num_string = "+" + num_string[1:]
        else:
            num_string = num_string[1:]
    num_string = num_string.replace("-", "–")
    return num_string
</t>
<t tx="ekr.20250121054835.1147">def char_to_mob(self, char: str) -&gt; Text:
    return char_to_cahced_mob(char, **self.text_config)
</t>
<t tx="ekr.20250121054835.1148">def interpolate(
    self,
    mobject1: Mobject,
    mobject2: Mobject,
    alpha: float,
    path_func: Callable[[np.ndarray, np.ndarray, float], np.ndarray] = straight_path
) -&gt; Self:
    super().interpolate(mobject1, mobject2, alpha, path_func)
    if hasattr(mobject1, "font_size") and hasattr(mobject2, "font_size"):
        self.font_size = interpolate(mobject1.font_size, mobject2.font_size, alpha)
</t>
<t tx="ekr.20250121054835.1149">def get_font_size(self) -&gt; float:
    return self.font_size
</t>
<t tx="ekr.20250121054835.115">def release_textures(self):
    for texture in self.textures:
        texture.release()
        del texture
    self.textures = []
    self.texture_names_to_ids = dict()
</t>
<t tx="ekr.20250121054835.1150">def get_formatter(self, **kwargs) -&gt; str:
    """
    Configuration is based first off instance attributes,
    but overwritten by any kew word argument.  Relevant
    key words:
    - include_sign
    - group_with_commas
    - num_decimal_places
    - field_name (e.g. 0 or 0.real)
    """
    config = dict([
        (attr, getattr(self, attr))
        for attr in [
            "include_sign",
            "group_with_commas",
            "num_decimal_places",
        ]
    ])
    config.update(kwargs)
    ndp = config["num_decimal_places"]
    return "".join([
        "{",
        config.get("field_name", ""),
        ":",
        "+" if config["include_sign"] else "",
        "," if config["group_with_commas"] else "",
        f".{ndp}f" if ndp &gt; 0 else "d",
        "}",
    ])
</t>
<t tx="ekr.20250121054835.1151">def get_complex_formatter(self, **kwargs) -&gt; str:
    return "".join([
        self.get_formatter(field_name="0.real"),
        self.get_formatter(field_name="0.imag", include_sign=True),
        "i"
    ])
</t>
<t tx="ekr.20250121054835.1152">def get_tex(self):
    return self.num_string
</t>
<t tx="ekr.20250121054835.1153">def set_value(self, number: float | complex) -&gt; Self:
    move_to_point = self.get_edge_center(self.edge_to_fix)
    style = self.family_members_with_points()[0].get_style()
    self.set_submobjects_from_number(number)
    self.move_to(move_to_point, self.edge_to_fix)
    self.set_style(**style)
    for submob in self.get_family():
        submob.uniforms.update(self.uniforms)
    return self
</t>
<t tx="ekr.20250121054835.1154">def _handle_scale_side_effects(self, scale_factor: float) -&gt; Self:
    self.font_size *= scale_factor
    return self
</t>
<t tx="ekr.20250121054835.1155">def get_value(self) -&gt; float | complex:
    return self.number
</t>
<t tx="ekr.20250121054835.1156">def increment_value(self, delta_t: float | complex = 1) -&gt; Self:
    self.set_value(self.get_value() + delta_t)
    return self
</t>
<t tx="ekr.20250121054835.1157">class Integer(DecimalNumber):
    @others
</t>
<t tx="ekr.20250121054835.1158">def __init__(
    self,
    number: int = 0,
    num_decimal_places: int = 0,
    **kwargs,
):
    super().__init__(number, num_decimal_places=num_decimal_places, **kwargs)
</t>
<t tx="ekr.20250121054835.1159">def get_value(self) -&gt; int:
    return int(np.round(super().get_value()))
</t>
<t tx="ekr.20250121054835.116">class VShaderWrapper(ShaderWrapper):
    @others
</t>
<t tx="ekr.20250121054835.1160">from __future__ import annotations

import numpy as np

from manimlib.constants import BLUE, BLUE_E, GREEN_E, GREY_B, GREY_D, MAROON_B, YELLOW
from manimlib.constants import DOWN, LEFT, RIGHT, UP
from manimlib.constants import MED_LARGE_BUFF, MED_SMALL_BUFF, SMALL_BUFF
from manimlib.mobject.geometry import Line
from manimlib.mobject.geometry import Rectangle
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.svg.brace import Brace
from manimlib.mobject.svg.tex_mobject import Tex
from manimlib.mobject.svg.tex_mobject import TexText
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.utils.color import color_gradient
from manimlib.utils.iterables import listify

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable
    from manimlib.typing import ManimColor


EPSILON = 0.0001


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1161">class SampleSpace(Rectangle):
    @others
</t>
<t tx="ekr.20250121054835.1162">def __init__(
    self,
    width: float = 3,
    height: float = 3,
    fill_color: ManimColor = GREY_D,
    fill_opacity: float = 1,
    stroke_width: float = 0.5,
    stroke_color: ManimColor = GREY_B,
    default_label_scale_val: float = 1,
    **kwargs,
):
    super().__init__(
        width, height,
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        stroke_color=stroke_color,
        **kwargs
    )
    self.default_label_scale_val = default_label_scale_val
</t>
<t tx="ekr.20250121054835.1163">def add_title(
    self,
    title: str = "Sample space",
    buff: float = MED_SMALL_BUFF
) -&gt; None:
    # TODO, should this really exist in SampleSpaceScene
    title_mob = TexText(title)
    if title_mob.get_width() &gt; self.get_width():
        title_mob.set_width(self.get_width())
    title_mob.next_to(self, UP, buff=buff)
    self.title = title_mob
    self.add(title_mob)
</t>
<t tx="ekr.20250121054835.1164">def add_label(self, label: str) -&gt; None:
    self.label = label
</t>
<t tx="ekr.20250121054835.1165">def complete_p_list(self, p_list: list[float]) -&gt; list[float]:
    new_p_list = listify(p_list)
    remainder = 1.0 - sum(new_p_list)
    if abs(remainder) &gt; EPSILON:
        new_p_list.append(remainder)
    return new_p_list
</t>
<t tx="ekr.20250121054835.1166">def get_division_along_dimension(
    self,
    p_list: list[float],
    dim: int,
    colors: Iterable[ManimColor],
    vect: np.ndarray
) -&gt; VGroup:
    p_list = self.complete_p_list(p_list)
    colors = color_gradient(colors, len(p_list))

    last_point = self.get_edge_center(-vect)
    parts = VGroup()
    for factor, color in zip(p_list, colors):
        part = SampleSpace()
        part.set_fill(color, 1)
        part.replace(self, stretch=True)
        part.stretch(factor, dim)
        part.move_to(last_point, -vect)
        last_point = part.get_edge_center(vect)
        parts.add(part)
    return parts
</t>
<t tx="ekr.20250121054835.1167">def get_horizontal_division(
    self,
    p_list: list[float],
    colors: Iterable[ManimColor] = [GREEN_E, BLUE_E],
    vect: np.ndarray = DOWN
) -&gt; VGroup:
    return self.get_division_along_dimension(p_list, 1, colors, vect)
</t>
<t tx="ekr.20250121054835.1168">def get_vertical_division(
    self,
    p_list: list[float],
    colors: Iterable[ManimColor] = [MAROON_B, YELLOW],
    vect: np.ndarray = RIGHT
) -&gt; VGroup:
    return self.get_division_along_dimension(p_list, 0, colors, vect)
</t>
<t tx="ekr.20250121054835.1169">def divide_horizontally(self, *args, **kwargs) -&gt; None:
    self.horizontal_parts = self.get_horizontal_division(*args, **kwargs)
    self.add(self.horizontal_parts)
</t>
<t tx="ekr.20250121054835.117">def __init__(
    self,
    ctx: moderngl.context.Context,
    vert_data: np.ndarray,
    shader_folder: Optional[str] = None,
    mobject_uniforms: Optional[UniformDict] = None,  # A dictionary mapping names of uniform variables
    texture_paths: Optional[dict[str, str]] = None,  # A dictionary mapping names to filepaths for textures.
    depth_test: bool = False,
    render_primitive: int = moderngl.TRIANGLES,
    code_replacements: dict[str, str] = dict(),
    stroke_behind: bool = False,
</t>
<t tx="ekr.20250121054835.1170">def divide_vertically(self, *args, **kwargs) -&gt; None:
    self.vertical_parts = self.get_vertical_division(*args, **kwargs)
    self.add(self.vertical_parts)
</t>
<t tx="ekr.20250121054835.1171">def get_subdivision_braces_and_labels(
    self,
    parts: VGroup,
    labels: str,
    direction: np.ndarray,
    buff: float = SMALL_BUFF,
) -&gt; VGroup:
    label_mobs = VGroup()
    braces = VGroup()
    for label, part in zip(labels, parts):
        brace = Brace(
            part, direction,
            buff=buff
        )
        if isinstance(label, Mobject):
            label_mob = label
        else:
            label_mob = Tex(label)
            label_mob.scale(self.default_label_scale_val)
        label_mob.next_to(brace, direction, buff)

        braces.add(brace)
        label_mobs.add(label_mob)
    parts.braces = braces
    parts.labels = label_mobs
    parts.label_kwargs = {
        "labels": label_mobs.copy(),
        "direction": direction,
        "buff": buff,
    }
    return VGroup(parts.braces, parts.labels)
</t>
<t tx="ekr.20250121054835.1172">def get_side_braces_and_labels(
    self,
    labels: str,
    direction: np.ndarray = LEFT,
    **kwargs
) -&gt; VGroup:
    assert hasattr(self, "horizontal_parts")
    parts = self.horizontal_parts
    return self.get_subdivision_braces_and_labels(parts, labels, direction, **kwargs)
</t>
<t tx="ekr.20250121054835.1173">def get_top_braces_and_labels(
    self,
    labels: str,
    **kwargs
) -&gt; VGroup:
    assert hasattr(self, "vertical_parts")
    parts = self.vertical_parts
    return self.get_subdivision_braces_and_labels(parts, labels, UP, **kwargs)
</t>
<t tx="ekr.20250121054835.1174">def get_bottom_braces_and_labels(
    self,
    labels: str,
    **kwargs
) -&gt; VGroup:
    assert hasattr(self, "vertical_parts")
    parts = self.vertical_parts
    return self.get_subdivision_braces_and_labels(parts, labels, DOWN, **kwargs)
</t>
<t tx="ekr.20250121054835.1175">def add_braces_and_labels(self) -&gt; None:
    for attr in "horizontal_parts", "vertical_parts":
        if not hasattr(self, attr):
            continue
        parts = getattr(self, attr)
        for subattr in "braces", "labels":
            if hasattr(parts, subattr):
                self.add(getattr(parts, subattr))
</t>
<t tx="ekr.20250121054835.1176">def __getitem__(self, index: int | slice) -&gt; VGroup:
    if hasattr(self, "horizontal_parts"):
        return self.horizontal_parts[index]
    elif hasattr(self, "vertical_parts"):
        return self.vertical_parts[index]
    return self.split()[index]
</t>
<t tx="ekr.20250121054835.1177">class BarChart(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1178">def __init__(
    self,
    values: Iterable[float],
    height: float = 4,
    width: float = 6,
    n_ticks: int = 4,
    include_x_ticks: bool = False,
    tick_width: float = 0.2,
    tick_height: float = 0.15,
    label_y_axis: bool = True,
    y_axis_label_height: float = 0.25,
    max_value: float = 1,
    bar_colors: list[ManimColor] = [BLUE, YELLOW],
    bar_fill_opacity: float = 0.8,
    bar_stroke_width: float = 3,
    bar_names: list[str] = [],
    bar_label_scale_val: float = 0.75,
    **kwargs
):
    super().__init__(**kwargs)
    self.height = height
    self.width = width
    self.n_ticks = n_ticks
    self.include_x_ticks = include_x_ticks
    self.tick_width = tick_width
    self.tick_height = tick_height
    self.label_y_axis = label_y_axis
    self.y_axis_label_height = y_axis_label_height
    self.max_value = max_value
    self.bar_colors = bar_colors
    self.bar_fill_opacity = bar_fill_opacity
    self.bar_stroke_width = bar_stroke_width
    self.bar_names = bar_names
    self.bar_label_scale_val = bar_label_scale_val

    if self.max_value is None:
        self.max_value = max(values)

    self.n_ticks_x = len(values)
    self.add_axes()
    self.add_bars(values)
    self.center()
</t>
<t tx="ekr.20250121054835.1179">def add_axes(self) -&gt; None:
    x_axis = Line(self.tick_width * LEFT / 2, self.width * RIGHT)
    y_axis = Line(MED_LARGE_BUFF * DOWN, self.height * UP)
    y_ticks = VGroup()
    heights = np.linspace(0, self.height, self.n_ticks + 1)
    values = np.linspace(0, self.max_value, self.n_ticks + 1)
    for y, value in zip(heights, values):
        y_tick = Line(LEFT, RIGHT)
        y_tick.set_width(self.tick_width)
        y_tick.move_to(y * UP)
        y_ticks.add(y_tick)
    y_axis.add(y_ticks)

    if self.include_x_ticks == True:
        x_ticks = VGroup()
        widths = np.linspace(0, self.width, self.n_ticks_x + 1)
        label_values = np.linspace(0, len(self.bar_names), self.n_ticks_x + 1)
        for x, value in zip(widths, label_values):
            x_tick = Line(UP, DOWN)
            x_tick.set_height(self.tick_height)
            x_tick.move_to(x * RIGHT)
            x_ticks.add(x_tick)
        x_axis.add(x_ticks)

    self.add(x_axis, y_axis)
    self.x_axis, self.y_axis = x_axis, y_axis

    if self.label_y_axis:
        labels = VGroup()
        for y_tick, value in zip(y_ticks, values):
            label = Tex(str(np.round(value, 2)))
            label.set_height(self.y_axis_label_height)
            label.next_to(y_tick, LEFT, SMALL_BUFF)
            labels.add(label)
        self.y_axis_labels = labels
        self.add(labels)
</t>
<t tx="ekr.20250121054835.118">):
    self.stroke_behind = stroke_behind
    super().__init__(
        ctx=ctx,
        vert_data=vert_data,
        shader_folder=shader_folder,
        mobject_uniforms=mobject_uniforms,
        texture_paths=texture_paths,
        depth_test=depth_test,
        render_primitive=render_primitive,
        code_replacements=code_replacements,
    )
    self.fill_canvas = VShaderWrapper.get_fill_canvas(self.ctx)
    self.add_texture('Texture', self.fill_canvas[0].color_attachments[0])
    self.add_texture('DepthTexture', self.fill_canvas[2].color_attachments[0])

def init_program_code(self) -&gt; None:
    self.program_code = {
        f"{vtype}_{name}": get_shader_code_from_file(
            os.path.join("quadratic_bezier", f"{vtype}", f"{name}.glsl")
        )
        for vtype in ["stroke", "fill", "depth"]
        for name in ["vert", "geom", "frag"]
    }
</t>
<t tx="ekr.20250121054835.1180">def add_bars(self, values: Iterable[float]) -&gt; None:
    buff = float(self.width) / (2 * len(values))
    bars = VGroup()
    for i, value in enumerate(values):
        bar = Rectangle(
            height=(value / self.max_value) * self.height,
            width=buff,
            stroke_width=self.bar_stroke_width,
            fill_opacity=self.bar_fill_opacity,
        )
        bar.move_to((2 * i + 0.5) * buff * RIGHT, DOWN + LEFT * 5)
        bars.add(bar)
    bars.set_color_by_gradient(*self.bar_colors)

    bar_labels = VGroup()
    for bar, name in zip(bars, self.bar_names):
        label = Tex(str(name))
        label.scale(self.bar_label_scale_val)
        label.next_to(bar, DOWN, SMALL_BUFF)
        bar_labels.add(label)

    self.add(bars, bar_labels)
    self.bars = bars
    self.bar_labels = bar_labels
</t>
<t tx="ekr.20250121054835.1181">def change_bar_values(self, values: Iterable[float]) -&gt; None:
    for bar, value in zip(self.bars, values):
        bar_bottom = bar.get_bottom()
        bar.stretch_to_fit_height(
            (value / self.max_value) * self.height
        )
        bar.move_to(bar_bottom, DOWN)
</t>
<t tx="ekr.20250121054835.1182">from __future__ import annotations

from colour import Color

from manimlib.config import manim_config
from manimlib.constants import BLACK, RED, YELLOW, WHITE
from manimlib.constants import DL, DOWN, DR, LEFT, RIGHT, UL, UR
from manimlib.constants import SMALL_BUFF
from manimlib.mobject.geometry import Line
from manimlib.mobject.geometry import Rectangle
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Sequence
    from manimlib.mobject.mobject import Mobject
    from manimlib.typing import ManimColor, Self


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1183">class SurroundingRectangle(Rectangle):
    @others
</t>
<t tx="ekr.20250121054835.1184">def __init__(
    self,
    mobject: Mobject,
    buff: float = SMALL_BUFF,
    color: ManimColor = YELLOW,
    **kwargs
):
    super().__init__(color=color, **kwargs)
    self.buff = buff
    self.surround(mobject)
    if mobject.is_fixed_in_frame():
        self.fix_in_frame()
</t>
<t tx="ekr.20250121054835.1185">def surround(self, mobject, buff=None) -&gt; Self:
    self.mobject = mobject
    self.buff = buff if buff is not None else self.buff
    super().surround(mobject, self.buff)
    return self
</t>
<t tx="ekr.20250121054835.1186">def set_buff(self, buff) -&gt; Self:
    self.buff = buff
    self.surround(self.mobject)
    return self
</t>
<t tx="ekr.20250121054835.1187">class BackgroundRectangle(SurroundingRectangle):
    @others
</t>
<t tx="ekr.20250121054835.1188">def __init__(
    self,
    mobject: Mobject,
    color: ManimColor = None,
    stroke_width: float = 0,
    stroke_opacity: float = 0,
    fill_opacity: float = 0.75,
    buff: float = 0,
    **kwargs
):
    if color is None:
        color = manim_config.camera.background_color
    super().__init__(
        mobject,
        color=color,
        stroke_width=stroke_width,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        buff=buff,
        **kwargs
    )
    self.original_fill_opacity = fill_opacity
</t>
<t tx="ekr.20250121054835.1189">def pointwise_become_partial(self, mobject: Mobject, a: float, b: float) -&gt; Self:
    self.set_fill(opacity=b * self.original_fill_opacity)
    return self
</t>
<t tx="ekr.20250121054835.119">def init_program(self):
    self.stroke_program = get_shader_program(
        self.ctx,
        vertex_shader=self.program_code["stroke_vert"],
        geometry_shader=self.program_code["stroke_geom"],
        fragment_shader=self.program_code["stroke_frag"],
    )
    self.fill_program = get_shader_program(
        self.ctx,
        vertex_shader=self.program_code["fill_vert"],
        geometry_shader=self.program_code["fill_geom"],
        fragment_shader=self.program_code["fill_frag"],
    )
    self.fill_border_program = get_shader_program(
        self.ctx,
        vertex_shader=self.program_code["stroke_vert"],
        geometry_shader=self.program_code["stroke_geom"],
        fragment_shader=self.program_code["stroke_frag"].replace(
            "// MODIFY FRAG COLOR",
            "frag_color.a *= 0.95; frag_color.rgb *= frag_color.a;",
        )
    )
    self.fill_depth_program = get_shader_program(
        self.ctx,
        vertex_shader=self.program_code["depth_vert"],
        geometry_shader=self.program_code["depth_geom"],
        fragment_shader=self.program_code["depth_frag"],
    )
    self.programs = [self.stroke_program, self.fill_program, self.fill_border_program, self.fill_depth_program]

    # Full vert format looks like this (total of 4x23 = 92 bytes):
    # point 3
    # stroke_rgba 4
    # stroke_width 1
    # joint_angle 1
    # fill_rgba 4
    # base_normal 3
    # fill_border_width 1
    self.stroke_vert_format = '3f 4f 1f 1f 16x 3f 4x'
    self.stroke_vert_attributes = ['point', 'stroke_rgba', 'stroke_width', 'joint_angle', 'unit_normal']

    self.fill_vert_format = '3f 24x 4f 3f 4x'
    self.fill_vert_attributes = ['point', 'fill_rgba', 'base_normal']

    self.fill_border_vert_format = '3f 20x 1f 4f 3f 1f'
    self.fill_border_vert_attributes = ['point', 'joint_angle', 'stroke_rgba', 'unit_normal', 'stroke_width']

    self.fill_depth_vert_format = '3f 40x 3f 4x'
    self.fill_depth_vert_attributes = ['point', 'base_normal']
</t>
<t tx="ekr.20250121054835.1190">def set_style(
    self,
    stroke_color: ManimColor | None = None,
    stroke_width: float | None = None,
    fill_color: ManimColor | None = None,
    fill_opacity: float | None = None,
    family: bool = True
) -&gt; Self:
    # Unchangeable style, except for fill_opacity
    VMobject.set_style(
        self,
        stroke_color=BLACK,
        stroke_width=0,
        fill_color=BLACK,
        fill_opacity=fill_opacity
    )
    return self
</t>
<t tx="ekr.20250121054835.1191">def get_fill_color(self) -&gt; Color:
    return Color(self.color)
</t>
<t tx="ekr.20250121054835.1192">class Cross(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1193">def __init__(
    self,
    mobject: Mobject,
    stroke_color: ManimColor = RED,
    stroke_width: float | Sequence[float] = [0, 6, 0],
    **kwargs
):
    super().__init__(
        Line(UL, DR),
        Line(UR, DL),
    )
    self.insert_n_curves(20)
    self.replace(mobject, stretch=True)
    self.set_stroke(stroke_color, width=stroke_width)
</t>
<t tx="ekr.20250121054835.1194">class Underline(Line):
    @others
</t>
<t tx="ekr.20250121054835.1195">def __init__(
    self,
    mobject: Mobject,
    buff: float = SMALL_BUFF,
    stroke_color=WHITE,
    stroke_width: float | Sequence[float] = [0, 3, 3, 0],
    stretch_factor=1.2,
    **kwargs
):
    super().__init__(LEFT, RIGHT, **kwargs)
    if not isinstance(stroke_width, (float, int)):
        self.insert_n_curves(len(stroke_width) - 2)
    self.set_stroke(stroke_color, stroke_width)
    self.set_width(mobject.get_width() * stretch_factor)
    self.next_to(mobject, DOWN, buff=buff)
</t>
<t tx="ekr.20250121054835.1196">from __future__ import annotations

import math

import numpy as np

from manimlib.constants import BLUE, BLUE_D, BLUE_E, GREY_A, BLACK
from manimlib.constants import IN, ORIGIN, OUT, RIGHT
from manimlib.constants import PI, TAU
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.types.surface import SGroup
from manimlib.mobject.types.surface import Surface
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.mobject.geometry import Polygon
from manimlib.mobject.geometry import Square
from manimlib.utils.bezier import interpolate
from manimlib.utils.iterables import adjacent_pairs
from manimlib.utils.space_ops import compass_directions
from manimlib.utils.space_ops import get_norm
from manimlib.utils.space_ops import z_to_vector

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from typing import Tuple, TypeVar
    from manimlib.typing import ManimColor, Vect3, Sequence

    T = TypeVar("T", bound=Mobject)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1197">class SurfaceMesh(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1198">def __init__(
    self,
    uv_surface: Surface,
    resolution: Tuple[int, int] = (21, 11),
    stroke_width: float = 1,
    stroke_color: ManimColor = GREY_A,
    normal_nudge: float = 1e-2,
    depth_test: bool = True,
    joint_type: str = 'no_joint',
    **kwargs
</t>
<t tx="ekr.20250121054835.1199">):
    self.uv_surface = uv_surface
    self.resolution = resolution
    self.normal_nudge = normal_nudge

    super().__init__(
        stroke_color=stroke_color,
        stroke_width=stroke_width,
        depth_test=depth_test,
        joint_type=joint_type,
        **kwargs
    )

def init_points(self) -&gt; None:
    uv_surface = self.uv_surface

    full_nu, full_nv = uv_surface.resolution
    part_nu, part_nv = self.resolution
    # 'indices' are treated as floats. Later, there will be
    # an interpolation between the floor and ceiling of these
    # indices
    u_indices = np.linspace(0, full_nu - 1, part_nu)
    v_indices = np.linspace(0, full_nv - 1, part_nv)

    points = uv_surface.get_points()
    normals = uv_surface.get_unit_normals()
    nudge = self.normal_nudge
    nudged_points = points + nudge * normals

    for ui in u_indices:
        path = VMobject()
        low_ui = full_nv * int(math.floor(ui))
        high_ui = full_nv * int(math.ceil(ui))
        path.set_points_smoothly(interpolate(
            nudged_points[low_ui:low_ui + full_nv],
            nudged_points[high_ui:high_ui + full_nv],
            ui % 1
        ))
        self.add(path)
    for vi in v_indices:
        path = VMobject()
        path.set_points_smoothly(interpolate(
            nudged_points[int(math.floor(vi))::full_nv],
            nudged_points[int(math.ceil(vi))::full_nv],
            vi % 1
        ))
        self.add(path)
</t>
<t tx="ekr.20250121054835.12">def construct(self):
    # You can index into Tex mobject (or other StringMobjects) by substrings
    equation = Tex(R"e^{\pi i} = -1", font_size=144)

    self.add(equation)
    self.play(FlashAround(equation["e"]))
    self.wait()
    self.play(Indicate(equation[R"\pi"]))
    self.wait()
    self.play(TransformFromCopy(
        equation[R"e^{\pi i}"].copy().set_opacity(0.5),
        equation["-1"],
        path_arc=-PI / 2,
        run_time=3
    ))
    self.play(FadeOut(equation))

    # Or regular expressions
    equation = Tex("A^2 + B^2 = C^2", font_size=144)

    self.play(Write(equation))
    for part in equation[re.compile(r"\w\^2")]:
        self.play(FlashAround(part))
    self.wait()
    self.play(FadeOut(equation))
        
    # Indexing by substrings like this may not work when
    # the order in which Latex draws symbols does not match
    # the order in which they show up in the string.
    # For example, here the infinity is drawn before the sigma
    # so we don't get the desired behavior.
    equation = Tex(R"\sum_{n = 1}^\infty \frac{1}{n^2} = \frac{\pi^2}{6}", font_size=72)
    self.play(FadeIn(equation))
    self.play(equation[R"\infty"].animate.set_color(RED))  # Doesn't hit the infinity
    self.wait()
    self.play(FadeOut(equation))

    # However you can always fix this by explicitly passing in
    # a string you might want to isolate later. Also, using
    # \over instead of \frac helps to avoid the issue for fractions
    equation = Tex(
        R"\sum_{n = 1}^\infty {1 \over n^2} = {\pi^2 \over 6}",
        # Explicitly mark "\infty" as a substring you might want to access
        isolate=[R"\infty"],
        font_size=72
    )
    self.play(FadeIn(equation))
    self.play(equation[R"\infty"].animate.set_color(RED))  # Got it!
    self.wait()
    self.play(FadeOut(equation))
</t>
<t tx="ekr.20250121054835.120">def init_vertex_objects(self):
    self.vbo = None
    self.stroke_vao = None
    self.fill_vao = None
    self.fill_border_vao = None
    self.vaos = []
</t>
<t tx="ekr.20250121054835.1200"># 3D shapes

class Sphere(Surface):
    @others
</t>
<t tx="ekr.20250121054835.1201">def __init__(
    self,
    u_range: Tuple[float, float] = (0, TAU),
    v_range: Tuple[float, float] = (0, PI),
    resolution: Tuple[int, int] = (101, 51),
    radius: float = 1.0,
    **kwargs,
</t>
<t tx="ekr.20250121054835.1202">):
    self.radius = radius
    super().__init__(
        u_range=u_range,
        v_range=v_range,
        resolution=resolution,
        **kwargs
    )

def uv_func(self, u: float, v: float) -&gt; np.ndarray:
    return self.radius * np.array([
        math.cos(u) * math.sin(v),
        math.sin(u) * math.sin(v),
        -math.cos(v)
    ])
</t>
<t tx="ekr.20250121054835.1203">class Torus(Surface):
    @others
</t>
<t tx="ekr.20250121054835.1204">def __init__(
    self,
    u_range: Tuple[float, float] = (0, TAU),
    v_range: Tuple[float, float] = (0, TAU),
    r1: float = 3.0,
    r2: float = 1.0,
    **kwargs,
</t>
<t tx="ekr.20250121054835.1205">):
    self.r1 = r1
    self.r2 = r2
    super().__init__(
        u_range=u_range,
        v_range=v_range,
        **kwargs,
    )

def uv_func(self, u: float, v: float) -&gt; np.ndarray:
    P = np.array([math.cos(u), math.sin(u), 0])
    return (self.r1 - self.r2 * math.cos(v)) * P - self.r2 * math.sin(v) * OUT
</t>
<t tx="ekr.20250121054835.1206">class Cylinder(Surface):
    @others
</t>
<t tx="ekr.20250121054835.1207">def __init__(
    self,
    u_range: Tuple[float, float] = (0, TAU),
    v_range: Tuple[float, float] = (-1, 1),
    resolution: Tuple[int, int] = (101, 11),
    height: float = 2,
    radius: float = 1,
    axis: Vect3 = OUT,
    **kwargs,
</t>
<t tx="ekr.20250121054835.1208">):
    self.height = height
    self.radius = radius
    self.axis = axis
    super().__init__(
        u_range=u_range,
        v_range=v_range,
        resolution=resolution,
        **kwargs
    )

def init_points(self):
    super().init_points()
    self.scale(self.radius)
    self.set_depth(self.height, stretch=True)
    self.apply_matrix(z_to_vector(self.axis))
</t>
<t tx="ekr.20250121054835.1209">def uv_func(self, u: float, v: float) -&gt; np.ndarray:
    return np.array([np.cos(u), np.sin(u), v])
</t>
<t tx="ekr.20250121054835.121">def generate_vaos(self):
    self.stroke_vao = self.ctx.vertex_array(
        program=self.stroke_program,
        content=[(self.vbo, self.stroke_vert_format, *self.stroke_vert_attributes)],
        mode=self.render_primitive,
    )
    self.fill_vao = self.ctx.vertex_array(
        program=self.fill_program,
        content=[(self.vbo, self.fill_vert_format, *self.fill_vert_attributes)],
        mode=self.render_primitive,
    )
    self.fill_border_vao = self.ctx.vertex_array(
        program=self.fill_border_program,
        content=[(self.vbo, self.fill_border_vert_format, *self.fill_border_vert_attributes)],
        mode=self.render_primitive,
    )
    self.fill_depth_vao = self.ctx.vertex_array(
        program=self.fill_depth_program,
        content=[(self.vbo, self.fill_depth_vert_format, *self.fill_depth_vert_attributes)],
        mode=self.render_primitive,
    )
    self.vaos = [self.stroke_vao, self.fill_vao, self.fill_border_vao, self.fill_depth_vao]
</t>
<t tx="ekr.20250121054835.1210">class Cone(Cylinder):
    @others
</t>
<t tx="ekr.20250121054835.1211">def __init__(
    self,
    u_range: Tuple[float, float] = (0, TAU),
    v_range: Tuple[float, float] = (0, 1),
    *args,
    **kwargs,
</t>
<t tx="ekr.20250121054835.1212">):
    super().__init__(u_range=u_range, v_range=v_range, *args, **kwargs)

def uv_func(self, u: float, v: float) -&gt; np.ndarray:
    return np.array([(1 - v) * np.cos(u), (1 - v) * np.sin(u), v])
</t>
<t tx="ekr.20250121054835.1213">class Line3D(Cylinder):
    @others
    ):
        axis = end - start
        super().__init__(
            height=get_norm(axis),
            radius=width / 2,
            axis=axis,
            resolution=resolution,
            **kwargs
        )
        self.shift((start + end) / 2)
</t>
<t tx="ekr.20250121054835.1214">def __init__(
    self,
    start: Vect3,
    end: Vect3,
    width: float = 0.05,
    resolution: Tuple[int, int] = (21, 25),
    **kwargs
</t>
<t tx="ekr.20250121054835.1215">class Disk3D(Surface):
    @others
</t>
<t tx="ekr.20250121054835.1216">def __init__(
    self,
    radius: float = 1,
    u_range: Tuple[float, float] = (0, 1),
    v_range: Tuple[float, float] = (0, TAU),
    resolution: Tuple[int, int] = (2, 100),
    **kwargs
</t>
<t tx="ekr.20250121054835.1217">):
    super().__init__(
        u_range=u_range,
        v_range=v_range,
        resolution=resolution,
        **kwargs,
    )
    self.scale(radius)

def uv_func(self, u: float, v: float) -&gt; np.ndarray:
    return np.array([
        u * math.cos(v),
        u * math.sin(v),
        0
    ])
</t>
<t tx="ekr.20250121054835.1218">class Square3D(Surface):
    @others
</t>
<t tx="ekr.20250121054835.1219">def __init__(
    self,
    side_length: float = 2.0,
    u_range: Tuple[float, float] = (-1, 1),
    v_range: Tuple[float, float] = (-1, 1),
    resolution: Tuple[int, int] = (2, 2),
    **kwargs,
</t>
<t tx="ekr.20250121054835.122">def set_backstroke(self, value: bool = True):
    self.stroke_behind = value
</t>
<t tx="ekr.20250121054835.1220">):
    super().__init__(
        u_range=u_range, 
        v_range=v_range, 
        resolution=resolution, 
        **kwargs
    )
    self.scale(side_length / 2)

def uv_func(self, u: float, v: float) -&gt; np.ndarray:
    return np.array([u, v, 0])
</t>
<t tx="ekr.20250121054835.1221">def square_to_cube_faces(square: T) -&gt; list[T]:
    radius = square.get_height() / 2
    square.move_to(radius * OUT)
    result = [square.copy()]
    result.extend([
        square.copy().rotate(PI / 2, axis=vect, about_point=ORIGIN)
        for vect in compass_directions(4)
    ])
    result.append(square.copy().rotate(PI, RIGHT, about_point=ORIGIN))
    return result
</t>
<t tx="ekr.20250121054835.1222">class Cube(SGroup):
    @others
    ):
        face = Square3D(
            resolution=square_resolution,
            side_length=side_length,
            color=color,
            opacity=opacity,
            shading=shading,
        )
        super().__init__(*square_to_cube_faces(face), **kwargs)
</t>
<t tx="ekr.20250121054835.1223">def __init__(
    self,
    color: ManimColor = BLUE,
    opacity: float = 1,
    shading: Tuple[float, float, float] = (0.1, 0.5, 0.1),
    square_resolution: Tuple[int, int] = (2, 2),
    side_length: float = 2,
    **kwargs,
</t>
<t tx="ekr.20250121054835.1224">class Prism(Cube):
    @others
</t>
<t tx="ekr.20250121054835.1225">def __init__(
    self,
    width: float = 3.0,
    height: float = 2.0,
    depth: float = 1.0,
    **kwargs
):
    super().__init__(**kwargs)
    for dim, value in enumerate([width, height, depth]):
        self.rescale_to_fit(value, dim, stretch=True)
</t>
<t tx="ekr.20250121054835.1226">class VGroup3D(VGroup):
    @others
    ):
        super().__init__(*vmobjects, **kwargs)
        self.set_shading(*shading)
        self.set_joint_type(joint_type)
        if depth_test:
            self.apply_depth_test()
</t>
<t tx="ekr.20250121054835.1227">def __init__(
    self,
    *vmobjects: VMobject,
    depth_test: bool = True,
    shading: Tuple[float, float, float] = (0.2, 0.2, 0.2),
    joint_type: str = "no_joint",
    **kwargs
</t>
<t tx="ekr.20250121054835.1228">class VCube(VGroup3D):
    @others
</t>
<t tx="ekr.20250121054835.1229">def __init__(
    self,
    side_length: float = 2.0,
    fill_color: ManimColor = BLUE_D,
    fill_opacity: float = 1,
    stroke_width: float = 0,
    **kwargs
):
    style = dict(
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        **kwargs
    )
    face = Square(side_length=side_length, **style)
    super().__init__(*square_to_cube_faces(face), **style)
</t>
<t tx="ekr.20250121054835.123">def refresh_id(self):
    super().refresh_id()
    self.id = hash(str(self.id) + str(self.stroke_behind))
</t>
<t tx="ekr.20250121054835.1230">class VPrism(VCube):
    @others
</t>
<t tx="ekr.20250121054835.1231">def __init__(
    self,
    width: float = 3.0,
    height: float = 2.0,
    depth: float = 1.0,
    **kwargs
):
    super().__init__(**kwargs)
    for dim, value in enumerate([width, height, depth]):
        self.rescale_to_fit(value, dim, stretch=True)
</t>
<t tx="ekr.20250121054835.1232">class Dodecahedron(VGroup3D):
    @others
    ):
        style = dict(
            fill_color=fill_color,
            fill_opacity=fill_opacity,
            stroke_color=stroke_color,
            stroke_width=stroke_width,
            shading=shading,
            **kwargs
        )

        # Start by creating two of the pentagons, meeting
        # back to back on the positive x-axis
        phi = (1 + math.sqrt(5)) / 2
        x, y, z = np.identity(3)
        pentagon1 = Polygon(
            np.array([phi, 1 / phi, 0]),
            np.array([1, 1, 1]),
            np.array([1 / phi, 0, phi]),
            np.array([1, -1, 1]),
            np.array([phi, -1 / phi, 0]),
            **style
        )
        pentagon2 = pentagon1.copy().stretch(-1, 2, about_point=ORIGIN)
        pentagon2.reverse_points()
        x_pair = VGroup(pentagon1, pentagon2)
        z_pair = x_pair.copy().apply_matrix(np.array([z, -x, -y]).T)
        y_pair = x_pair.copy().apply_matrix(np.array([y, z, x]).T)

        pentagons = [*x_pair, *y_pair, *z_pair]
        for pentagon in list(pentagons):
            pc = pentagon.copy()
            pc.apply_function(lambda p: -p)
            pc.reverse_points()
            pentagons.append(pc)

        super().__init__(*pentagons, **style)
</t>
<t tx="ekr.20250121054835.1233">def __init__(
    self,
    fill_color: ManimColor = BLUE_E,
    fill_opacity: float = 1,
    stroke_color: ManimColor = BLUE_E,
    stroke_width: float = 1,
    shading: Tuple[float, float, float] = (0.2, 0.2, 0.2),
    **kwargs,
</t>
<t tx="ekr.20250121054835.1234">class Prismify(VGroup3D):
    @others
</t>
<t tx="ekr.20250121054835.1235">def __init__(self, vmobject, depth=1.0, direction=IN, **kwargs):
    # At the moment, this assume stright edges
    vect = depth * direction
    pieces = [vmobject.copy()]
    points = vmobject.get_anchors()
    for p1, p2 in adjacent_pairs(points):
        wall = VMobject()
        wall.match_style(vmobject)
        wall.set_points_as_corners([p1, p2, p2 + vect, p1 + vect])
        pieces.append(wall)
    top = vmobject.copy()
    top.shift(vect)
    top.reverse_points()
    pieces.append(top)
    super().__init__(*pieces, **kwargs)
</t>
<t tx="ekr.20250121054835.1236">from __future__ import annotations

import numpy as np
from manimlib.mobject.mobject import Mobject
from manimlib.utils.iterables import listify

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from manimlib.typing import Self


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1237">class ValueTracker(Mobject):
    """
    Not meant to be displayed.  Instead the position encodes some
    number, often one which another animation or continual_animation
    uses for its update function, and by treating it as a mobject it can
    still be animated and manipulated just like anything else.
    """
    @others
</t>
<t tx="ekr.20250121054835.1238">value_type: type = np.float64

def __init__(
    self,
    value: float | complex | np.ndarray = 0,
    **kwargs
):
    self.value = value
    super().__init__(**kwargs)
</t>
<t tx="ekr.20250121054835.1239">def init_uniforms(self) -&gt; None:
    super().init_uniforms()
    self.uniforms["value"] = np.array(
        listify(self.value),
        dtype=self.value_type,
    )
</t>
<t tx="ekr.20250121054835.124"># Rendering
def render_stroke(self):
    if self.stroke_vao is None:
        return
    self.stroke_vao.render()
</t>
<t tx="ekr.20250121054835.1240">def get_value(self) -&gt; float | complex | np.ndarray:
    result = self.uniforms["value"]
    if len(result) == 1:
        return result[0]
    return result
</t>
<t tx="ekr.20250121054835.1241">def set_value(self, value: float | complex | np.ndarray) -&gt; Self:
    self.uniforms["value"][:] = value
    return self
</t>
<t tx="ekr.20250121054835.1242">def increment_value(self, d_value: float | complex) -&gt; None:
    self.set_value(self.get_value() + d_value)
</t>
<t tx="ekr.20250121054835.1243">class ExponentialValueTracker(ValueTracker):
    """
    Operates just like ValueTracker, except it encodes the value as the
    exponential of a position coordinate, which changes how interpolation
    behaves
    """
    @others
</t>
<t tx="ekr.20250121054835.1244">def get_value(self) -&gt; float | complex:
    return np.exp(ValueTracker.get_value(self))
</t>
<t tx="ekr.20250121054835.1245">def set_value(self, value: float | complex):
    return ValueTracker.set_value(self, np.log(value))
</t>
<t tx="ekr.20250121054835.1246">class ComplexValueTracker(ValueTracker):
    value_type: type = np.complex128
</t>
<t tx="ekr.20250121054835.1247">from __future__ import annotations

import itertools as it

import numpy as np
from scipy.integrate import solve_ivp

from manimlib.constants import FRAME_HEIGHT, FRAME_WIDTH
from manimlib.constants import WHITE
from manimlib.animation.indication import VShowPassingFlash
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.bezier import interpolate
from manimlib.utils.bezier import inverse_interpolate
from manimlib.utils.color import get_colormap_list
from manimlib.utils.color import get_color_map
from manimlib.utils.iterables import cartesian_product
from manimlib.utils.rate_functions import linear
from manimlib.utils.space_ops import get_norm

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, Iterable, Sequence, TypeVar, Tuple, Optional
    from manimlib.typing import ManimColor, Vect3, VectN, VectArray, Vect3Array, Vect4Array

    from manimlib.mobject.coordinate_systems import CoordinateSystem
    from manimlib.mobject.mobject import Mobject

    T = TypeVar("T")


#### Delete these two ###
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1248">def get_vectorized_rgb_gradient_function(
    min_value: T,
    max_value: T,
    color_map: str
) -&gt; Callable[[VectN], Vect3Array]:
    rgbs = np.array(get_colormap_list(color_map))

    def func(values):
        alphas = inverse_interpolate(
            min_value, max_value, np.array(values)
        )
        alphas = np.clip(alphas, 0, 1)
        scaled_alphas = alphas * (len(rgbs) - 1)
        indices = scaled_alphas.astype(int)
        next_indices = np.clip(indices + 1, 0, len(rgbs) - 1)
        inter_alphas = scaled_alphas % 1
        inter_alphas = inter_alphas.repeat(3).reshape((len(indices), 3))
        result = interpolate(rgbs[indices], rgbs[next_indices], inter_alphas)
        return result

    return func
</t>
<t tx="ekr.20250121054835.1249">def get_rgb_gradient_function(
    min_value: T,
    max_value: T,
    color_map: str
) -&gt; Callable[[float], Vect3]:
    vectorized_func = get_vectorized_rgb_gradient_function(min_value, max_value, color_map)
    return lambda value: vectorized_func(np.array([value]))[0]
</t>
<t tx="ekr.20250121054835.125">def render_fill(self):
    if self.fill_vao is None:
        return

    original_fbo = self.ctx.fbo
    fill_tx_fbo, fill_tx_vao, depth_tx_fbo = self.fill_canvas

    # Render to a separate texture, due to strange alpha compositing
    # for the blended winding calculation
    fill_tx_fbo.clear()
    fill_tx_fbo.use()

    # Be sure not to apply depth test while rendering fill
    # but set it back to where it was after
    apply_depth_test = bool(gl.glGetBooleanv(gl.GL_DEPTH_TEST))
    self.ctx.disable(moderngl.DEPTH_TEST)

    # With this blend function, the effect of blending alpha a with
    # -a / (1 - a) cancels out, so we can cancel positively and negatively
    # oriented triangles
    gl.glBlendFuncSeparate(
        gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA,
        gl.GL_ONE_MINUS_DST_ALPHA, gl.GL_ONE
    )
    self.fill_vao.render()

    if apply_depth_test:
        self.ctx.enable(moderngl.DEPTH_TEST)
        depth_tx_fbo.clear(1.0)
        depth_tx_fbo.use()
        gl.glBlendFunc(gl.GL_ONE, gl.GL_ONE)
        gl.glBlendEquation(gl.GL_MIN)
        self.fill_depth_vao.render()

    # Now add border, just taking the max alpha
    gl.glBlendFunc(gl.GL_ONE, gl.GL_ONE)
    gl.glBlendEquation(gl.GL_MAX)
    self.fill_border_vao.render()

    # Take the texture we were just drawing to, and render it to
    # the main scene. Account for how alphas have been premultiplied
    original_fbo.use()
    gl.glBlendFunc(gl.GL_ONE, gl.GL_ONE_MINUS_SRC_ALPHA)
    gl.glBlendEquation(gl.GL_FUNC_ADD)
    fill_tx_vao.render()

    # Return to original blending state
    gl.glBlendFunc(gl.GL_SRC_ALPHA, gl.GL_ONE_MINUS_SRC_ALPHA)
</t>
<t tx="ekr.20250121054835.1250">####


def ode_solution_points(function, state0, time, dt=0.01):
    solution = solve_ivp(
        lambda t, state: function(state),
        t_span=(0, time),
        y0=state0,
        t_eval=np.arange(0, time, dt)
    )
    return solution.y.T
</t>
<t tx="ekr.20250121054835.1251">def move_along_vector_field(
    mobject: Mobject,
    func: Callable[[Vect3], Vect3]
) -&gt; Mobject:
    mobject.add_updater(
        lambda m, dt: m.shift(
            func(m.get_center()) * dt
        )
    )
    return mobject
</t>
<t tx="ekr.20250121054835.1252">def move_submobjects_along_vector_field(
    mobject: Mobject,
    func: Callable[[Vect3], Vect3]
) -&gt; Mobject:
    def apply_nudge(mob, dt):
        for submob in mob:
            x, y = submob.get_center()[:2]
            if abs(x) &lt; FRAME_WIDTH and abs(y) &lt; FRAME_HEIGHT:
                submob.shift(func(submob.get_center()) * dt)

    mobject.add_updater(apply_nudge)
    return mobject
</t>
<t tx="ekr.20250121054835.1253">def move_points_along_vector_field(
    mobject: Mobject,
    func: Callable[[float, float], Iterable[float]],
    coordinate_system: CoordinateSystem
) -&gt; Mobject:
    cs = coordinate_system
    origin = cs.get_origin()

    def apply_nudge(mob, dt):
        mob.apply_function(
            lambda p: p + (cs.c2p(*func(*cs.p2c(p))) - origin) * dt
        )
    mobject.add_updater(apply_nudge)
    return mobject
</t>
<t tx="ekr.20250121054835.1254">def get_sample_coords(
    coordinate_system: CoordinateSystem,
    density: float = 1.0
) -&gt; it.product[tuple[Vect3, ...]]:
    ranges = []
    for range_args in coordinate_system.get_all_ranges():
        _min, _max, step = range_args
        step /= density
        ranges.append(np.arange(_min, _max + step, step))
    return np.array(list(it.product(*ranges)))
</t>
<t tx="ekr.20250121054835.1255">def vectorize(pointwise_function: Callable[[Tuple], Tuple]):
    def v_func(coords_array: VectArray) -&gt; VectArray:
        return np.array([pointwise_function(*coords) for coords in coords_array])

    return v_func
</t>
<t tx="ekr.20250121054835.1256"># Mobjects


class VectorField(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.1257">def __init__(
    self,
    # Vectorized function: Takes in an array of coordinates, returns an array of outputs.
    func: Callable[[VectArray], VectArray],
    # Typically a set of Axes or NumberPlane
    coordinate_system: CoordinateSystem,
    density: float = 2.0,
    magnitude_range: Optional[Tuple[float, float]] = None,
    color: Optional[ManimColor] = None,
    color_map_name: Optional[str] = "3b1b_colormap",
    color_map: Optional[Callable[[Sequence[float]], Vect4Array]] = None,
    stroke_opacity: float = 1.0,
    stroke_width: float = 3,
    tip_width_ratio: float = 4,
    tip_len_to_width: float = 0.01,
    max_vect_len: float | None = None,
    max_vect_len_to_step_size: float = 0.8,
    flat_stroke: bool = False,
    norm_to_opacity_func=None,  # TODO, check on this
    **kwargs
):
    self.func = func
    self.coordinate_system = coordinate_system
    self.stroke_width = stroke_width
    self.tip_width_ratio = tip_width_ratio
    self.tip_len_to_width = tip_len_to_width
    self.norm_to_opacity_func = norm_to_opacity_func

    # Search for sample_points
    self.sample_coords = get_sample_coords(coordinate_system, density)
    self.update_sample_points()

    if max_vect_len is None:
        step_size = get_norm(self.sample_points[1] - self.sample_points[0])
        self.max_displayed_vect_len = max_vect_len_to_step_size * step_size
    else:
        self.max_displayed_vect_len = max_vect_len * coordinate_system.get_x_unit_size()

    # Prepare the color map
    if magnitude_range is None:
        max_value = max(map(get_norm, func(self.sample_coords)))
        magnitude_range = (0, max_value)

    self.magnitude_range = magnitude_range

    if color is not None:
        self.color_map = None
    else:
        self.color_map = color_map or get_color_map(color_map_name)

    self.init_base_stroke_width_array(len(self.sample_coords))

    super().__init__(
        stroke_opacity=stroke_opacity,
        flat_stroke=flat_stroke,
        **kwargs
    )
    self.set_stroke(color, stroke_width)
    self.update_vectors()
</t>
<t tx="ekr.20250121054835.1258">def init_points(self):
    n_samples = len(self.sample_coords)
    self.set_points(np.zeros((8 * n_samples - 1, 3)))
    self.set_joint_type('no_joint')
</t>
<t tx="ekr.20250121054835.1259">def get_sample_points(
    self,
    center: np.ndarray,
    width: float,
    height: float,
    depth: float,
    x_density: float,
    y_density: float,
    z_density: float
) -&gt; np.ndarray:
    to_corner = np.array([width / 2, height / 2, depth / 2])
    spacings = 1.0 / np.array([x_density, y_density, z_density])
    to_corner = spacings * (to_corner / spacings).astype(int)
    lower_corner = center - to_corner
    upper_corner = center + to_corner + spacings
    return cartesian_product(*(
        np.arange(low, high, space)
        for low, high, space in zip(lower_corner, upper_corner, spacings)
    ))
</t>
<t tx="ekr.20250121054835.126"># Static method returning one shared value across all VShaderWrappers
@lru_cache
@staticmethod
def get_fill_canvas(ctx: moderngl.Context) -&gt; Tuple[Framebuffer, VertexArray, Framebuffer]:
    """
    Because VMobjects with fill are rendered in a funny way, using
    alpha blending to effectively compute the winding number around
    each pixel, they need to be rendered to a separate texture, which
    is then composited onto the ordinary frame buffer.

    This returns a texture, loaded into a frame buffer, and a vao
    which can display that texture as a simple quad onto a screen,
    along with the rgb value which is meant to be discarded.
    """
    size = manim_config.camera.resolution
    double_size = (2 * size[0], 2 * size[1])

    # Important to make sure dtype is floating point (not fixed point)
    # so that alpha values can be negative and are not clipped
    fill_texture = ctx.texture(size=double_size, components=4, dtype='f2')
    # Use another one to keep track of depth
    depth_texture = ctx.texture(size=size, components=1, dtype='f4')

    fill_texture_fbo = ctx.framebuffer(fill_texture)
    depth_texture_fbo = ctx.framebuffer(depth_texture)

    simple_vert = '''
        #version 330

        in vec2 texcoord;
        out vec2 uv;

        void main() {
            gl_Position = vec4((2.0 * texcoord - 1.0), 0.0, 1.0);
            uv = texcoord;
        }
    '''
    alpha_adjust_frag = '''
        #version 330

        uniform sampler2D Texture;
        uniform sampler2D DepthTexture;

        in vec2 uv;
        out vec4 color;

        void main() {
            color = texture(Texture, uv);
            if(color.a == 0) discard;

            if(color.a &lt; 0){
                color.a = -color.a / (1.0 - color.a);
                color.rgb *= (color.a - 1);
            }

            // Counteract scaling in fill frag
            color *= 1.06;

            gl_FragDepth = texture(DepthTexture, uv)[0];
        }
    '''
    fill_program = ctx.program(
        vertex_shader=simple_vert,
        fragment_shader=alpha_adjust_frag,
    )

    verts = np.array([[0, 0], [0, 1], [1, 0], [1, 1]])
    simple_vbo = ctx.buffer(verts.astype('f4').tobytes())
    fill_texture_vao = ctx.simple_vertex_array(
        fill_program, simple_vbo, 'texcoord',
        mode=moderngl.TRIANGLE_STRIP
    )

    return (fill_texture_fbo, fill_texture_vao, depth_texture_fbo)
</t>
<t tx="ekr.20250121054835.1260">def init_base_stroke_width_array(self, n_sample_points):
    arr = np.ones(8 * n_sample_points - 1)
    arr[4::8] = self.tip_width_ratio
    arr[5::8] = self.tip_width_ratio * 0.5
    arr[6::8] = 0
    arr[7::8] = 0
    self.base_stroke_width_array = arr
</t>
<t tx="ekr.20250121054835.1261">def set_sample_coords(self, sample_coords: VectArray):
    self.sample_coords = sample_coords
    return self
</t>
<t tx="ekr.20250121054835.1262">def set_stroke(self, color=None, width=None, opacity=None, behind=None, flat=None, recurse=True):
    super().set_stroke(color, None, opacity, behind, flat, recurse)
    if width is not None:
        self.set_stroke_width(float(width))
    return self
</t>
<t tx="ekr.20250121054835.1263">def set_stroke_width(self, width: float):
    if self.get_num_points() &gt; 0:
        self.get_stroke_widths()[:] = width * self.base_stroke_width_array
        self.stroke_width = width
    return self
</t>
<t tx="ekr.20250121054835.1264">def update_sample_points(self):
    self.sample_points = self.coordinate_system.c2p(*self.sample_coords.T)
</t>
<t tx="ekr.20250121054835.1265">def update_vectors(self):
    tip_width = self.tip_width_ratio * self.stroke_width
    tip_len = self.tip_len_to_width * tip_width

    # Outputs in the coordinate system
    outputs = self.func(self.sample_coords)
    output_norms = np.linalg.norm(outputs, axis=1)[:, np.newaxis]

    # Corresponding vector values in global coordinates
    out_vects = self.coordinate_system.c2p(*outputs.T) - self.coordinate_system.get_origin()
    out_vect_norms = np.linalg.norm(out_vects, axis=1)[:, np.newaxis]
    unit_outputs = np.zeros_like(out_vects)
    np.true_divide(out_vects, out_vect_norms, out=unit_outputs, where=(out_vect_norms &gt; 0))

    # How long should the arrows be drawn, in global coordinates
    max_len = self.max_displayed_vect_len
    if max_len &lt; np.inf:
        drawn_norms = max_len * np.tanh(out_vect_norms / max_len)
    else:
        drawn_norms = out_vect_norms

    # What's the distance from the base of an arrow to
    # the base of its head?
    dist_to_head_base = np.clip(drawn_norms - tip_len, 0, np.inf)  # Mixing units!

    # Set all points
    points = self.get_points()
    points[0::8] = self.sample_points
    points[2::8] = self.sample_points + dist_to_head_base * unit_outputs
    points[4::8] = points[2::8]
    points[6::8] = self.sample_points + drawn_norms * unit_outputs
    for i in (1, 3, 5):
        points[i::8] = 0.5 * (points[i - 1::8] + points[i + 1::8])
    points[7::8] = points[6:-1:8]

    # Adjust stroke widths
    width_arr = self.stroke_width * self.base_stroke_width_array
    width_scalars = np.clip(drawn_norms / tip_len, 0, 1)
    width_scalars = np.repeat(width_scalars, 8)[:-1]
    self.get_stroke_widths()[:] = width_scalars * width_arr

    # Potentially adjust opacity and color
    if self.color_map is not None:
        self.get_stroke_colors()  # Ensures the array is updated to appropriate length
        low, high = self.magnitude_range
        self.data['stroke_rgba'][:, :3] = self.color_map(
            inverse_interpolate(low, high, np.repeat(output_norms, 8)[:-1])
        )[:, :3]

    if self.norm_to_opacity_func is not None:
        self.get_stroke_opacities()[:] = self.norm_to_opacity_func(
            np.repeat(output_norms, 8)[:-1]
        )

    self.note_changed_data()
    return self
</t>
<t tx="ekr.20250121054835.1266">class TimeVaryingVectorField(VectorField):
    @others
</t>
<t tx="ekr.20250121054835.1267">def __init__(
    self,
    # Takes in an array of points and a float for time
    time_func: Callable[[VectArray, float], VectArray],
    coordinate_system: CoordinateSystem,
    **kwargs
):
    self.time = 0

    def func(coords):
        return time_func(coords, self.time)

    super().__init__(func, coordinate_system, **kwargs)
    self.add_updater(lambda m, dt: m.increment_time(dt))
    self.always.update_vectors()
</t>
<t tx="ekr.20250121054835.1268">def increment_time(self, dt):
    self.time += dt
</t>
<t tx="ekr.20250121054835.1269">class StreamLines(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.127">def render(self):
    if self.stroke_behind:
        self.render_stroke()
        self.render_fill()
    else:
        self.render_fill()
        self.render_stroke()
</t>
<t tx="ekr.20250121054835.1270">def __init__(
    self,
    func: Callable[[VectArray], VectArray],
    coordinate_system: CoordinateSystem,
    density: float = 1.0,
    n_repeats: int = 1,
    noise_factor: float | None = None,
    # Config for drawing lines
    solution_time: float = 3,
    dt: float = 0.05,
    arc_len: float = 3,
    max_time_steps: int = 200,
    n_samples_per_line: int = 10,
    cutoff_norm: float = 15,
    # Style info
    stroke_width: float = 1.0,
    stroke_color: ManimColor = WHITE,
    stroke_opacity: float = 1,
    color_by_magnitude: bool = True,
    magnitude_range: Tuple[float, float] = (0, 2.0),
    taper_stroke_width: bool = False,
    color_map: str = "3b1b_colormap",
    **kwargs
</t>
<t tx="ekr.20250121054835.1271">):
    super().__init__(**kwargs)
    self.func = func
    self.coordinate_system = coordinate_system
    self.density = density
    self.n_repeats = n_repeats
    self.noise_factor = noise_factor
    self.solution_time = solution_time
    self.dt = dt
    self.arc_len = arc_len
    self.max_time_steps = max_time_steps
    self.n_samples_per_line = n_samples_per_line
    self.cutoff_norm = cutoff_norm
    self.stroke_width = stroke_width
    self.stroke_color = stroke_color
    self.stroke_opacity = stroke_opacity
    self.color_by_magnitude = color_by_magnitude
    self.magnitude_range = magnitude_range
    self.taper_stroke_width = taper_stroke_width
    self.color_map = color_map

    self.draw_lines()
    self.init_style()

def point_func(self, points: Vect3Array) -&gt; Vect3:
    in_coords = np.array(self.coordinate_system.p2c(points)).T
    out_coords = self.func(in_coords)
    origin = self.coordinate_system.get_origin()
    return self.coordinate_system.c2p(*out_coords.T) - origin
</t>
<t tx="ekr.20250121054835.1272">def draw_lines(self) -&gt; None:
    lines = []
    origin = self.coordinate_system.get_origin()

    # Todo, it feels like coordinate system should just have
    # the ODE solver built into it, no?
    lines = []
    for coords in self.get_sample_coords():
        solution_coords = ode_solution_points(self.func, coords, self.solution_time, self.dt)
        line = VMobject()
        line.set_points_smoothly(self.coordinate_system.c2p(*solution_coords.T))
        # TODO, account for arc length somehow?
        line.virtual_time = self.solution_time
        lines.append(line)
    self.set_submobjects(lines)
</t>
<t tx="ekr.20250121054835.1273">def get_sample_coords(self):
    cs = self.coordinate_system
    sample_coords = get_sample_coords(cs, self.density)

    noise_factor = self.noise_factor
    if noise_factor is None:
        noise_factor = (cs.get_x_unit_size() / self.density) * 0.5

    return np.array([
        coords + noise_factor * np.random.random(coords.shape)
        for n in range(self.n_repeats)
        for coords in sample_coords
    ])
</t>
<t tx="ekr.20250121054835.1274">def init_style(self) -&gt; None:
    if self.color_by_magnitude:
        values_to_rgbs = get_vectorized_rgb_gradient_function(
            *self.magnitude_range, self.color_map,
        )
        cs = self.coordinate_system
        for line in self.submobjects:
            norms = [
                get_norm(self.func(*cs.p2c(point)))
                for point in line.get_points()
            ]
            rgbs = values_to_rgbs(norms)
            rgbas = np.zeros((len(rgbs), 4))
            rgbas[:, :3] = rgbs
            rgbas[:, 3] = self.stroke_opacity
            line.set_rgba_array(rgbas, "stroke_rgba")
    else:
        self.set_stroke(self.stroke_color, opacity=self.stroke_opacity)

    if self.taper_stroke_width:
        width = [0, self.stroke_width, 0]
    else:
        width = self.stroke_width
    self.set_stroke(width=width)
</t>
<t tx="ekr.20250121054835.1275">class AnimatedStreamLines(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1276">def __init__(
    self,
    stream_lines: StreamLines,
    lag_range: float = 4,
    rate_multiple: float = 1.0,
    line_anim_config: dict = dict(
        rate_func=linear,
        time_width=1.0,
    ),
    **kwargs
</t>
<t tx="ekr.20250121054835.1277">):
    super().__init__(**kwargs)
    self.stream_lines = stream_lines

    for line in stream_lines:
        line.anim = VShowPassingFlash(
            line,
            run_time=line.virtual_time / rate_multiple,
            **line_anim_config,
        )
        line.anim.begin()
        line.time = -lag_range * np.random.random()
        self.add(line.anim.mobject)

    self.add_updater(lambda m, dt: m.update(dt))

def update(self, dt: float) -&gt; None:
    stream_lines = self.stream_lines
    for line in stream_lines:
        line.time += dt
        adjusted_time = max(line.time, 0) % line.anim.run_time
        line.anim.update(adjusted_time / line.anim.run_time)
</t>
<t tx="ekr.20250121054835.1278"></t>
<t tx="ekr.20250121054835.1279">@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.128">from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Union, Tuple, Annotated, Literal, Iterable, Dict
    from colour import Color
    import numpy as np
    import re

    try:
        from typing import Self
    except ImportError:
        from typing_extensions import Self

    # Abbreviations for a common types
    ManimColor = Union[str, Color, None]
    RangeSpecifier = Tuple[float, float, float] | Tuple[float, float]


    Span = tuple[int, int]
    SingleSelector = Union[
        str,
        re.Pattern,
        tuple[Union[int, None], Union[int, None]],
    ]
    Selector = Union[SingleSelector, Iterable[SingleSelector]]

    UniformDict = Dict[str, float | bool | np.ndarray | tuple]

    # These are various alternate names for np.ndarray meant to specify
    # certain shapes.
    #
    # In theory, these annotations could be used to check arrays sizes
    # at runtime, but at the moment nothing actually uses them, and
    # the names are here primarily to enhance readibility and allow
    # for some stronger type checking if numpy has stronger typing
    # in the future
    FloatArray = np.ndarray[int, np.dtype[np.float64]]
    Vect2 = Annotated[FloatArray, Literal[2]]
    Vect3 = Annotated[FloatArray, Literal[3]]
    Vect4 = Annotated[FloatArray, Literal[4]]
    VectN = Annotated[FloatArray, Literal["N"]]
    Matrix3x3 = Annotated[FloatArray, Literal[3, 3]]
    VectArray = Annotated[FloatArray, Literal["N", 1]]
    Vect2Array = Annotated[FloatArray, Literal["N", 2]]
    Vect3Array = Annotated[FloatArray, Literal["N", 3]]
    Vect4Array = Annotated[FloatArray, Literal["N", 4]]
    VectNArray = Annotated[FloatArray, Literal["N", "M"]]
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1280">from __future__ import annotations

import math
import copy

import numpy as np

from manimlib.constants import DEFAULT_MOBJECT_TO_MOBJECT_BUFF, SMALL_BUFF
from manimlib.constants import DOWN, LEFT, ORIGIN, RIGHT, DL, DR, UL
from manimlib.constants import PI
from manimlib.animation.composition import AnimationGroup
from manimlib.animation.fading import FadeIn
from manimlib.animation.growing import GrowFromCenter
from manimlib.mobject.svg.tex_mobject import Tex
from manimlib.mobject.svg.tex_mobject import TexText
from manimlib.mobject.svg.text_mobject import Text
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.iterables import listify
from manimlib.utils.space_ops import get_norm

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable

    from manimlib.animation.animation import Animation
    from manimlib.mobject.mobject import Mobject
    from manimlib.typing import Vect3


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1281">class Brace(Tex):
    @others
</t>
<t tx="ekr.20250121054835.1282">def __init__(
    self,
    mobject: Mobject,
    direction: Vect3 = DOWN,
    buff: float = 0.2,
    tex_string: str = R"\underbrace{\qquad}",
    **kwargs
):
    super().__init__(tex_string, **kwargs)

    angle = -math.atan2(*direction[:2]) + PI
    mobject.rotate(-angle, about_point=ORIGIN)
    left = mobject.get_corner(DL)
    right = mobject.get_corner(DR)
    target_width = right[0] - left[0]

    self.tip_point_index = np.argmin(self.get_all_points()[:, 1])
    self.set_initial_width(target_width)
    self.shift(left - self.get_corner(UL) + buff * DOWN)
    for mob in mobject, self:
        mob.rotate(angle, about_point=ORIGIN)
</t>
<t tx="ekr.20250121054835.1283">def set_initial_width(self, width: float):
    width_diff = width - self.get_width()
    if width_diff &gt; 0:
        for tip, rect, vect in [(self[0], self[1], RIGHT), (self[5], self[4], LEFT)]:
            rect.set_width(
                width_diff / 2 + rect.get_width(),
                about_edge=vect, stretch=True
            )
            tip.shift(-width_diff / 2 * vect)
    else:
        self.set_width(width, stretch=True)
    return self
</t>
<t tx="ekr.20250121054835.1284">def put_at_tip(
    self,
    mob: Mobject,
    use_next_to: bool = True,
    **kwargs
):
    if use_next_to:
        mob.next_to(
            self.get_tip(),
            np.round(self.get_direction()),
            **kwargs
        )
    else:
        mob.move_to(self.get_tip())
        buff = kwargs.get("buff", DEFAULT_MOBJECT_TO_MOBJECT_BUFF)
        shift_distance = mob.get_width() / 2.0 + buff
        mob.shift(self.get_direction() * shift_distance)
    return self
</t>
<t tx="ekr.20250121054835.1285">def get_text(self, text: str, **kwargs) -&gt; Text:
    buff = kwargs.pop("buff", SMALL_BUFF)
    text_mob = Text(text, **kwargs)
    self.put_at_tip(text_mob, buff=buff)
    return text_mob
</t>
<t tx="ekr.20250121054835.1286">def get_tex(self, *tex: str, **kwargs) -&gt; Tex:
    buff = kwargs.pop("buff", SMALL_BUFF)
    tex_mob = Tex(*tex, **kwargs)
    self.put_at_tip(tex_mob, buff=buff)
    return tex_mob
</t>
<t tx="ekr.20250121054835.1287">def get_tip(self) -&gt; np.ndarray:
    # Very specific to the LaTeX representation
    # of a brace, but it's the only way I can think
    # of to get the tip regardless of orientation.
    return self.get_all_points()[self.tip_point_index]
</t>
<t tx="ekr.20250121054835.1288">def get_direction(self) -&gt; np.ndarray:
    vect = self.get_tip() - self.get_center()
    return vect / get_norm(vect)
</t>
<t tx="ekr.20250121054835.1289">class BraceLabel(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.129">from __future__ import annotations

import numpy as np

import moderngl_window as mglw
from moderngl_window.context.pyglet.window import Window as PygletWindow
from moderngl_window.timers.clock import Timer
from functools import wraps
import screeninfo

from manimlib.constants import ASPECT_RATIO
from manimlib.constants import FRAME_SHAPE

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, TypeVar, Optional
    from manimlib.scene.scene import Scene

    T = TypeVar("T")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1290">label_constructor: type = Tex

def __init__(
    self,
    obj: VMobject | list[VMobject],
    text: str | Iterable[str],
    brace_direction: np.ndarray = DOWN,
    label_scale: float = 1.0,
    label_buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFF,
    **kwargs
) -&gt; None:
    super().__init__(**kwargs)
    self.brace_direction = brace_direction
    self.label_scale = label_scale
    self.label_buff = label_buff

    if isinstance(obj, list):
        obj = VGroup(*obj)
    self.brace = Brace(obj, brace_direction, **kwargs)

    self.label = self.label_constructor(*listify(text), **kwargs)
    self.label.scale(self.label_scale)

    self.brace.put_at_tip(self.label, buff=self.label_buff)
    self.set_submobjects([self.brace, self.label])
</t>
<t tx="ekr.20250121054835.1291">def creation_anim(
    self,
    label_anim: Animation = FadeIn,
    brace_anim: Animation = GrowFromCenter
) -&gt; AnimationGroup:
    return AnimationGroup(brace_anim(self.brace), label_anim(self.label))
</t>
<t tx="ekr.20250121054835.1292">def shift_brace(self, obj: VMobject | list[VMobject], **kwargs):
    if isinstance(obj, list):
        obj = VMobject(*obj)
    self.brace = Brace(obj, self.brace_direction, **kwargs)
    self.brace.put_at_tip(self.label)
    self.submobjects[0] = self.brace
    return self
</t>
<t tx="ekr.20250121054835.1293">def change_label(self, *text: str, **kwargs):
    self.label = self.label_constructor(*text, **kwargs)
    if self.label_scale != 1:
        self.label.scale(self.label_scale)

    self.brace.put_at_tip(self.label)
    self.submobjects[1] = self.label
    return self
</t>
<t tx="ekr.20250121054835.1294">def change_brace_label(self, obj: VMobject | list[VMobject], *text: str):
    self.shift_brace(obj)
    self.change_label(*text)
    return self
</t>
<t tx="ekr.20250121054835.1295">def copy(self):
    copy_mobject = copy.copy(self)
    copy_mobject.brace = self.brace.copy()
    copy_mobject.label = self.label.copy()
    copy_mobject.set_submobjects([copy_mobject.brace, copy_mobject.label])

    return copy_mobject
</t>
<t tx="ekr.20250121054835.1296">class BraceText(BraceLabel):
    label_constructor: type = TexText
</t>
<t tx="ekr.20250121054835.1297">from __future__ import annotations

import numpy as np
import itertools as it
import random

from manimlib.animation.composition import AnimationGroup
from manimlib.animation.rotation import Rotating
from manimlib.constants import BLACK
from manimlib.constants import BLUE_A
from manimlib.constants import BLUE_B
from manimlib.constants import BLUE_C
from manimlib.constants import BLUE_D
from manimlib.constants import DOWN
from manimlib.constants import DOWN
from manimlib.constants import FRAME_WIDTH
from manimlib.constants import GREEN
from manimlib.constants import GREEN_SCREEN
from manimlib.constants import GREEN_E
from manimlib.constants import GREY
from manimlib.constants import GREY_A
from manimlib.constants import GREY_B
from manimlib.constants import GREY_E
from manimlib.constants import LEFT
from manimlib.constants import LEFT
from manimlib.constants import MED_LARGE_BUFF
from manimlib.constants import MED_SMALL_BUFF
from manimlib.constants import ORIGIN
from manimlib.constants import OUT
from manimlib.constants import PI
from manimlib.constants import RED
from manimlib.constants import RED_E
from manimlib.constants import RIGHT
from manimlib.constants import SMALL_BUFF
from manimlib.constants import SMALL_BUFF
from manimlib.constants import UP
from manimlib.constants import UL
from manimlib.constants import UR
from manimlib.constants import DL
from manimlib.constants import DR
from manimlib.constants import WHITE
from manimlib.constants import YELLOW
from manimlib.constants import TAU
from manimlib.mobject.boolean_ops import Difference
from manimlib.mobject.boolean_ops import Union
from manimlib.mobject.geometry import Arc
from manimlib.mobject.geometry import Circle
from manimlib.mobject.geometry import Dot
from manimlib.mobject.geometry import Line
from manimlib.mobject.geometry import Polygon
from manimlib.mobject.geometry import Rectangle
from manimlib.mobject.geometry import Square
from manimlib.mobject.geometry import AnnularSector
from manimlib.mobject.numbers import Integer
from manimlib.mobject.shape_matchers import SurroundingRectangle
from manimlib.mobject.svg.svg_mobject import SVGMobject
from manimlib.mobject.svg.special_tex import TexTextFromPresetString
from manimlib.mobject.three_dimensions import Prismify
from manimlib.mobject.three_dimensions import VCube
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.mobject.svg.text_mobject import Text
from manimlib.utils.bezier import interpolate
from manimlib.utils.iterables import adjacent_pairs
from manimlib.utils.rate_functions import linear
from manimlib.utils.space_ops import angle_of_vector
from manimlib.utils.space_ops import compass_directions
from manimlib.utils.space_ops import get_norm
from manimlib.utils.space_ops import midpoint
from manimlib.utils.space_ops import rotate_vector

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Tuple, Sequence, Callable
    from manimlib.typing import ManimColor, Vect3


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1298">class Checkmark(TexTextFromPresetString):
    tex: str = R"\ding{51}"
    default_color: ManimColor = GREEN
</t>
<t tx="ekr.20250121054835.1299">class Exmark(TexTextFromPresetString):
    tex: str = R"\ding{55}"
    default_color: ManimColor = RED
</t>
<t tx="ekr.20250121054835.13">class UpdatersExample(Scene):
    @others
</t>
<t tx="ekr.20250121054835.130">class Window(PygletWindow):
    @others
</t>
<t tx="ekr.20250121054835.1300">class Lightbulb(SVGMobject):
    @others
</t>
<t tx="ekr.20250121054835.1301">file_name = "lightbulb"

def __init__(
    self,
    height: float = 1.0,
    color: ManimColor = YELLOW,
    stroke_width: float = 3.0,
    fill_opacity: float = 0.0,
    **kwargs
):
    super().__init__(
        height=height,
        color=color,
        stroke_width=stroke_width,
        fill_opacity=fill_opacity,
        **kwargs
    )
    self.insert_n_curves(25)
</t>
<t tx="ekr.20250121054835.1302">class Speedometer(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.1303">def __init__(
    self,
    arc_angle: float = 4 * PI / 3,
    num_ticks: int = 8,
    tick_length: float = 0.2,
    needle_width: float = 0.1,
    needle_height: float = 0.8,
    needle_color: ManimColor = YELLOW,
    **kwargs,
):
    super().__init__(**kwargs)

    self.arc_angle = arc_angle
    self.num_ticks = num_ticks
    self.tick_length = tick_length
    self.needle_width = needle_width
    self.needle_height = needle_height
    self.needle_color = needle_color

    start_angle = PI / 2 + arc_angle / 2
    end_angle = PI / 2 - arc_angle / 2
    self.arc = Arc(
        start_angle=start_angle,
        angle=-self.arc_angle
    )
    self.add(self.arc)
    tick_angle_range = np.linspace(start_angle, end_angle, num_ticks)
    for index, angle in enumerate(tick_angle_range):
        vect = rotate_vector(RIGHT, angle)
        tick = Line((1 - tick_length) * vect, vect)
        label = Integer(10 * index)
        label.set_height(tick_length)
        label.shift((1 + tick_length) * vect)
        self.add(tick, label)

    needle = Polygon(
        LEFT, UP, RIGHT,
        stroke_width=0,
        fill_opacity=1,
        fill_color=self.needle_color
    )
    needle.stretch_to_fit_width(needle_width)
    needle.stretch_to_fit_height(needle_height)
    needle.rotate(start_angle - np.pi / 2, about_point=ORIGIN)
    self.add(needle)
    self.needle = needle

    self.center_offset = self.get_center()
</t>
<t tx="ekr.20250121054835.1304">def get_center(self):
    result = VMobject.get_center(self)
    if hasattr(self, "center_offset"):
        result -= self.center_offset
    return result
</t>
<t tx="ekr.20250121054835.1305">def get_needle_tip(self):
    return self.needle.get_anchors()[1]
</t>
<t tx="ekr.20250121054835.1306">def get_needle_angle(self):
    return angle_of_vector(
        self.get_needle_tip() - self.get_center()
    )
</t>
<t tx="ekr.20250121054835.1307">def rotate_needle(self, angle):
    self.needle.rotate(angle, about_point=self.arc.get_arc_center())
    return self
</t>
<t tx="ekr.20250121054835.1308">def move_needle_to_velocity(self, velocity):
    max_velocity = 10 * (self.num_ticks - 1)
    proportion = float(velocity) / max_velocity
    start_angle = np.pi / 2 + self.arc_angle / 2
    target_angle = start_angle - self.arc_angle * proportion
    self.rotate_needle(target_angle - self.get_needle_angle())
    return self
</t>
<t tx="ekr.20250121054835.1309">class Laptop(VGroup):
    @others
    ):
        super().__init__(**kwargs)

        body = VCube(side_length=1)
        for dim, scale_factor in enumerate(body_dimensions):
            body.stretch(scale_factor, dim=dim)
        body.set_width(width)
        body.set_fill(shaded_body_color, opacity=1)
        body.sort(lambda p: p[2])
        body[-1].set_fill(body_color)
        screen_plate = body.copy()
        keyboard = VGroup(*[
            VGroup(*[
                Square(**key_color_kwargs)
                for x in range(12 - y % 2)
            ]).arrange(RIGHT, buff=SMALL_BUFF)
            for y in range(4)
        ]).arrange(DOWN, buff=MED_SMALL_BUFF)
        keyboard.stretch_to_fit_width(
            keyboard_width_to_body_width * body.get_width(),
        )
        keyboard.stretch_to_fit_height(
            keyboard_height_to_body_height * body.get_height(),
        )
        keyboard.next_to(body, OUT, buff=0.1 * SMALL_BUFF)
        keyboard.shift(MED_SMALL_BUFF * UP)
        body.add(keyboard)

        screen_plate.stretch(screen_thickness /
                             body_dimensions[2], dim=2)
        screen = Rectangle(
            stroke_width=0,
            fill_color=BLACK,
            fill_opacity=1,
        )
        screen.replace(screen_plate, stretch=True)
        screen.scale(screen_width_to_screen_plate_width)
        screen.next_to(screen_plate, OUT, buff=0.1 * SMALL_BUFF)
        screen_plate.add(screen)
        screen_plate.next_to(body, UP, buff=0)
        screen_plate.rotate(
            open_angle, RIGHT,
            about_point=screen_plate.get_bottom()
        )
        self.screen_plate = screen_plate
        self.screen = screen

        axis = Line(
            body.get_corner(UP + LEFT + OUT),
            body.get_corner(UP + RIGHT + OUT),
            color=BLACK,
            stroke_width=2
        )
        self.axis = axis

        self.add(body, screen_plate, axis)
</t>
<t tx="ekr.20250121054835.131">fullscreen: bool = False
resizable: bool = True
gl_version: tuple[int, int] = (3, 3)
vsync: bool = True
cursor: bool = True

def __init__(
    self,
    scene: Optional[Scene] = None,
    position_string: str = "UR",
    monitor_index: int = 1,
    full_screen: bool = False,
    size: Optional[tuple[int, int]] = None,
    position: Optional[tuple[int, int]] = None,
    samples: int = 0
):
    self.scene = scene
    self.monitor = self.get_monitor(monitor_index)
    self.default_size = size or self.get_default_size(full_screen)
    self.default_position = position or self.position_from_string(position_string)
    self.pressed_keys = set()

    super().__init__(samples=samples)
    self.to_default_position()

    if self.scene:
        self.init_for_scene(scene)
</t>
<t tx="ekr.20250121054835.1310">def __init__(
    self,
    width: float = 3,
    body_dimensions: Tuple[float, float, float] = (4.0, 3.0, 0.05),
    screen_thickness: float = 0.01,
    keyboard_width_to_body_width: float = 0.9,
    keyboard_height_to_body_height: float = 0.5,
    screen_width_to_screen_plate_width: float = 0.9,
    key_color_kwargs: dict = dict(
        stroke_width=0,
        fill_color=BLACK,
        fill_opacity=1,
    ),
    fill_opacity: float = 1.0,
    stroke_width: float = 0.0,
    body_color: ManimColor = GREY_B,
    shaded_body_color: ManimColor = GREY,
    open_angle: float = np.pi / 4,
    **kwargs
</t>
<t tx="ekr.20250121054835.1311">class VideoIcon(SVGMobject):
    @others
</t>
<t tx="ekr.20250121054835.1312">file_name: str = "video_icon"

def __init__(
    self,
    width: float = 1.2,
    color=BLUE_A,
    **kwargs
):
    super().__init__(color=color, **kwargs)
    self.set_width(width)
</t>
<t tx="ekr.20250121054835.1313">class VideoSeries(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1314">def __init__(
    self,
    num_videos: int = 11,
    gradient_colors: Sequence[ManimColor] = [BLUE_B, BLUE_D],
    width: float = FRAME_WIDTH - MED_LARGE_BUFF,
    **kwargs
):
    super().__init__(
        *(VideoIcon() for x in range(num_videos)),
        **kwargs
    )
    self.arrange(RIGHT)
    self.set_width(width)
    self.set_color_by_gradient(*gradient_colors)
</t>
<t tx="ekr.20250121054835.1315">class Clock(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1316">def __init__(
    self,
    stroke_color: ManimColor = WHITE,
    stroke_width: float = 3.0,
    hour_hand_height: float = 0.3,
    minute_hand_height: float = 0.6,
    tick_length: float = 0.1,
    **kwargs,
):
    style = dict(stroke_color=stroke_color, stroke_width=stroke_width)
    circle = Circle(**style)
    ticks = []
    for x, point in enumerate(compass_directions(12, UP)):
        length = tick_length
        if x % 3 == 0:
            length *= 2
        ticks.append(Line(point, (1 - length) * point, **style))
    self.hour_hand = Line(ORIGIN, hour_hand_height * UP, **style)
    self.minute_hand = Line(ORIGIN, minute_hand_height * UP, **style)

    super().__init__(
        circle, self.hour_hand, self.minute_hand,
        *ticks
    )
</t>
<t tx="ekr.20250121054835.1317">class ClockPassesTime(AnimationGroup):
    @others
</t>
<t tx="ekr.20250121054835.1318">def __init__(
    self,
    clock: Clock,
    run_time: float = 5.0,
    hours_passed: float = 12.0,
    rate_func: Callable[[float], float] = linear,
    **kwargs
):
    rot_kwargs = dict(
        axis=OUT,
        about_point=clock.get_center()
    )
    hour_radians = -hours_passed * 2 * PI / 12
    super().__init__(
        Rotating(
            clock.hour_hand,
            angle=hour_radians,
            **rot_kwargs
        ),
        Rotating(
            clock.minute_hand,
            angle=12 * hour_radians,
            **rot_kwargs
        ),
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.1319">class Bubble(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.132">def init_for_scene(self, scene: Scene):
    """
    Resets the state and updates the scene associated to this window.

    This is necessary when we want to reuse an *existing* window after a
    `scene.reload()` was requested, which will create new scene instances.
    """
    self.pressed_keys.clear()
    self._has_undrawn_event = True

    self.scene = scene
    self.title = str(scene)

    self.init_mgl_context()

    self.timer = Timer()
    self.config = mglw.WindowConfig(ctx=self.ctx, wnd=self, timer=self.timer)
    mglw.activate_context(window=self, ctx=self.ctx)
    self.timer.start()

    # This line seems to resync the viewport
    self.on_resize(*self.size)
</t>
<t tx="ekr.20250121054835.1320">file_name: str = "Bubbles_speech.svg"
bubble_center_adjustment_factor = 0.125

def __init__(
    self,
    content: str | VMobject | None = None,
    buff: float = 1.0,
    filler_shape: Tuple[float, float] = (3.0, 2.0),
    pin_point: Vect3 | None = None,
    direction: Vect3 = LEFT,
    add_content: bool = True,
    fill_color: ManimColor = BLACK,
    fill_opacity: float = 0.8,
    stroke_color: ManimColor = WHITE,
    stroke_width: float = 3.0,
    **kwargs
</t>
<t tx="ekr.20250121054835.1321">):
    super().__init__(**kwargs)
    self.direction = direction

    if content is None:
        content = Rectangle(*filler_shape)
        content.set_fill(opacity=0)
        content.set_stroke(width=0)
    elif isinstance(content, str):
        content = Text(content)
    self.content = content

    self.body = self.get_body(content, direction, buff)
    self.body.set_fill(fill_color, fill_opacity)
    self.body.set_stroke(stroke_color, stroke_width)
    self.add(self.body)

    if add_content:
        self.add(self.content)

    if pin_point is not None:
        self.pin_to(pin_point)

def get_body(self, content: VMobject, direction: Vect3, buff: float) -&gt; VMobject:
    body = SVGMobject(self.file_name)
    if direction[0] &gt; 0:
        body.flip()
    # Resize
    width = content.get_width()
    height = content.get_height()
    target_width = width + min(buff, height)
    target_height = 1.35 * (height + buff)  # Magic number?
    body.set_shape(target_width, target_height)
    body.move_to(content)
    body.shift(self.bubble_center_adjustment_factor * body.get_height() * DOWN)
    return body
</t>
<t tx="ekr.20250121054835.1322">def get_tip(self):
    return self.get_corner(DOWN + self.direction)
</t>
<t tx="ekr.20250121054835.1323">def get_bubble_center(self):
    factor = self.bubble_center_adjustment_factor
    return self.get_center() + factor * self.get_height() * UP
</t>
<t tx="ekr.20250121054835.1324">def move_tip_to(self, point):
    self.shift(point - self.get_tip())
    return self
</t>
<t tx="ekr.20250121054835.1325">def flip(self, axis=UP, only_body=True, **kwargs):
    super().flip(axis=axis, **kwargs)
    if only_body:
        # Flip in place, don't use kwargs
        self.content.flip(axis=axis)
    if abs(axis[1]) &gt; 0:
        self.direction = -np.array(self.direction)
    return self
</t>
<t tx="ekr.20250121054835.1326">def pin_to(self, mobject, auto_flip=False):
    mob_center = mobject.get_center()
    want_to_flip = np.sign(mob_center[0]) != np.sign(self.direction[0])
    if want_to_flip and auto_flip:
        self.flip()
    boundary_point = mobject.get_bounding_box_point(UP - self.direction)
    vector_from_center = 1.0 * (boundary_point - mob_center)
    self.move_tip_to(mob_center + vector_from_center)
    return self
</t>
<t tx="ekr.20250121054835.1327">def position_mobject_inside(self, mobject, buff=MED_LARGE_BUFF):
    mobject.set_max_width(self.body.get_width() - 2 * buff)
    mobject.set_max_height(self.body.get_height() / 1.5 - 2 * buff)
    mobject.shift(self.get_bubble_center() - mobject.get_center())
    return mobject
</t>
<t tx="ekr.20250121054835.1328">def add_content(self, mobject):
    self.position_mobject_inside(mobject)
    self.content = mobject
    return self.content
</t>
<t tx="ekr.20250121054835.1329">def write(self, text):
    self.add_content(Text(text))
    return self
</t>
<t tx="ekr.20250121054835.133">def get_monitor(self, index):
    try:
        monitors = screeninfo.get_monitors()
        return monitors[min(index, len(monitors) - 1)]
    except screeninfo.ScreenInfoError:
        # Default fallback
        return screeninfo.Monitor(width=1920, height=1080)
</t>
<t tx="ekr.20250121054835.1330">def resize_to_content(self, buff=1.0):  # TODO
    self.body.match_points(self.get_body(
        self.content, self.direction, buff
    ))
</t>
<t tx="ekr.20250121054835.1331">def clear(self):
    self.remove(self.content)
    return self
</t>
<t tx="ekr.20250121054835.1332">class SpeechBubble(Bubble):
    @others
</t>
<t tx="ekr.20250121054835.1333">def __init__(
    self,
    content: str | VMobject | None = None,
    buff: float = MED_SMALL_BUFF,
    filler_shape: Tuple[float, float] = (2.0, 1.0),
    stem_height_to_bubble_height: float = 0.5,
    stem_top_x_props: Tuple[float, float] = (0.2, 0.3),
    **kwargs
</t>
<t tx="ekr.20250121054835.1334">):
    self.stem_height_to_bubble_height = stem_height_to_bubble_height
    self.stem_top_x_props = stem_top_x_props
    super().__init__(content, buff, filler_shape, **kwargs)

def get_body(self, content: VMobject, direction: Vect3, buff: float) -&gt; VMobject:
    rect = SurroundingRectangle(content, buff=buff)
    rect.round_corners()
    lp = rect.get_corner(DL)
    rp = rect.get_corner(DR)
    stem_height = self.stem_height_to_bubble_height * rect.get_height()
    low_prop, high_prop = self.stem_top_x_props
    triangle = Polygon(
        interpolate(lp, rp, low_prop),
        interpolate(lp, rp, high_prop),
        lp + stem_height * DOWN,
    )
    result = Union(rect, triangle)
    result.insert_n_curves(20)
    if direction[0] &gt; 0:
        result.flip()

    return result
</t>
<t tx="ekr.20250121054835.1335">class ThoughtBubble(Bubble):
    @others
</t>
<t tx="ekr.20250121054835.1336">def __init__(
    self,
    content: str | VMobject | None = None,
    buff: float = SMALL_BUFF,
    filler_shape: Tuple[float, float] = (2.0, 1.0),
    bulge_radius: float = 0.35,
    bulge_overlap: float = 0.25,
    noise_factor: float = 0.1,
    circle_radii: list[float] = [0.1, 0.15, 0.2],
    **kwargs
</t>
<t tx="ekr.20250121054835.1337">):
    self.bulge_radius = bulge_radius
    self.bulge_overlap = bulge_overlap
    self.noise_factor = noise_factor
    self.circle_radii = circle_radii
    super().__init__(content, buff, filler_shape, **kwargs)

def get_body(self, content: VMobject, direction: Vect3, buff: float) -&gt; VMobject:
    rect = SurroundingRectangle(content, buff)
    perimeter = rect.get_arc_length()
    radius = self.bulge_radius
    step = (1 - self.bulge_overlap) * (2 * radius)
    nf = self.noise_factor
    corners = [rect.get_corner(v) for v in [DL, UL, UR, DR]]
    points = []
    for c1, c2 in adjacent_pairs(corners):
        n_alphas = int(get_norm(c1 - c2) / step) + 1
        for alpha in np.linspace(0, 1, n_alphas):
            points.append(interpolate(
                c1, c2, alpha + nf * (step / n_alphas) * (random.random() - 0.5)
            ))

    cloud = Union(rect, *(
        # Add bulges
        Circle(radius=radius * (1 + nf * random.random())).move_to(point)
        for point in points
    ))
    cloud.set_stroke(WHITE, 2)

    circles = VGroup(Circle(radius=radius) for radius in self.circle_radii)
    circ_buff = 0.25 * self.circle_radii[0]
    circles.arrange(UR, buff=circ_buff)
    circles[1].shift(circ_buff * DR)
    circles.next_to(cloud, DOWN, 4 * circ_buff, aligned_edge=LEFT)
    circles.set_stroke(WHITE, 2)

    result = VGroup(*circles, cloud)

    if direction[0] &gt; 0:
        result.flip()

    return result
</t>
<t tx="ekr.20250121054835.1338">class OldSpeechBubble(Bubble):
    file_name: str = "Bubbles_speech.svg"
</t>
<t tx="ekr.20250121054835.1339">class DoubleSpeechBubble(Bubble):
    file_name: str = "Bubbles_double_speech.svg"
</t>
<t tx="ekr.20250121054835.134">def get_default_size(self, full_screen=False):
    width = self.monitor.width // (1 if full_screen else 2)
    height = int(width // ASPECT_RATIO)
    return (width, height)
</t>
<t tx="ekr.20250121054835.1340">class OldThoughtBubble(Bubble):
    @others
</t>
<t tx="ekr.20250121054835.1341">file_name: str = "Bubbles_thought.svg"

def get_body(self, content: VMobject, direction: Vect3, buff: float) -&gt; VMobject:
    body = super().get_body(content, direction, buff)
    body.sort(lambda p: p[1])
    return body
</t>
<t tx="ekr.20250121054835.1342">def make_green_screen(self):
    self.body[-1].set_fill(GREEN_SCREEN, opacity=1)
    return self
</t>
<t tx="ekr.20250121054835.1343">class VectorizedEarth(SVGMobject):
    @others
</t>
<t tx="ekr.20250121054835.1344">file_name: str = "earth"

def __init__(
    self,
    height: float = 2.0,
    **kwargs
):
    super().__init__(height=height, **kwargs)
    self.insert_n_curves(20)
    circle = Circle(
        stroke_width=3,
        stroke_color=GREEN,
        fill_opacity=1,
        fill_color=BLUE_C,
    )
    circle.replace(self)
    self.add_to_back(circle)
</t>
<t tx="ekr.20250121054835.1345">class Piano(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1346">def __init__(
    self,
    n_white_keys = 52,
    black_pattern = [0, 2, 3, 5, 6],
    white_keys_per_octave = 7,
    white_key_dims = (0.15, 1.0),
    black_key_dims = (0.1, 0.66),
    key_buff = 0.02,
    white_key_color = WHITE,
    black_key_color = GREY_E,
    total_width = 13,
    **kwargs
</t>
<t tx="ekr.20250121054835.1347">):
    self.n_white_keys = n_white_keys
    self.black_pattern = black_pattern
    self.white_keys_per_octave = white_keys_per_octave
    self.white_key_dims = white_key_dims
    self.black_key_dims = black_key_dims
    self.key_buff = key_buff
    self.white_key_color = white_key_color
    self.black_key_color = black_key_color
    self.total_width = total_width

    super().__init__(**kwargs)
    self.add_white_keys()
    self.add_black_keys()
    self.sort_keys()
    self[:-1].reverse_points()
    self.set_width(self.total_width)

def add_white_keys(self):
    key = Rectangle(*self.white_key_dims)
    key.set_fill(self.white_key_color, 1)
    key.set_stroke(width=0)
    self.white_keys = key.get_grid(1, self.n_white_keys, buff=self.key_buff)
    self.add(*self.white_keys)
</t>
<t tx="ekr.20250121054835.1348">def add_black_keys(self):
    key = Rectangle(*self.black_key_dims)
    key.set_fill(self.black_key_color, 1)
    key.set_stroke(width=0)

    self.black_keys = VGroup()
    for i in range(len(self.white_keys) - 1):
        if i % self.white_keys_per_octave not in self.black_pattern:
            continue
        wk1 = self.white_keys[i]
        wk2 = self.white_keys[i + 1]
        bk = key.copy()
        bk.move_to(midpoint(wk1.get_top(), wk2.get_top()), UP)
        big_bk = bk.copy()
        big_bk.stretch((bk.get_width() + self.key_buff) / bk.get_width(), 0)
        big_bk.stretch((bk.get_height() + self.key_buff) / bk.get_height(), 1)
        big_bk.move_to(bk, UP)
        for wk in wk1, wk2:
            wk.become(Difference(wk, big_bk).match_style(wk))
        self.black_keys.add(bk)
    self.add(*self.black_keys)
</t>
<t tx="ekr.20250121054835.1349">def sort_keys(self):
    self.sort(lambda p: p[0])
</t>
<t tx="ekr.20250121054835.135">def position_from_string(self, position_string):
    # Alternatively, it might be specified with a string like
    # UR, OO, DL, etc. specifying what corner it should go to
    char_to_n = {"L": 0, "U": 0, "O": 1, "R": 2, "D": 2}
    size = self.default_size
    width_diff = self.monitor.width - size[0]
    height_diff = self.monitor.height - size[1]
    x_step = char_to_n[position_string[1]] * width_diff // 2
    y_step = char_to_n[position_string[0]] * height_diff // 2
    return (self.monitor.x + x_step, -self.monitor.y + y_step)
</t>
<t tx="ekr.20250121054835.1350">class Piano3D(VGroup):
    @others
    ):
        piano_2d = Piano(**piano_2d_config)
        super().__init__(*(
            Prismify(key, key_depth)
            for key in piano_2d
        ))
        self.set_stroke(stroke_color, stroke_width)
        self.set_shading(*shading)
        self.apply_depth_test()

        # Elevate black keys
        for i, key in enumerate(self):
            if piano_2d[i] in piano_2d.black_keys:
                key.shift(black_key_shift * OUT)
                key.set_color(BLACK)
</t>
<t tx="ekr.20250121054835.1351">def __init__(
    self,
    shading: Tuple[float, float, float] = (1.0, 0.2, 0.2),
    stroke_width: float = 0.25,
    stroke_color: ManimColor = BLACK,
    key_depth: float = 0.1,
    black_key_shift: float = 0.05,
    piano_2d_config: dict = dict(
        white_key_color=GREY_A,
        key_buff=0.001
    ),
    **kwargs
</t>
<t tx="ekr.20250121054835.1352">class DieFace(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1353">def __init__(
    self,
    value: int,
    side_length: float = 1.0,
    corner_radius: float = 0.15,
    stroke_color: ManimColor = WHITE,
    stroke_width: float = 2.0,
    fill_color: ManimColor = GREY_E,
    dot_radius: float = 0.08,
    dot_color: ManimColor = WHITE,
    dot_coalesce_factor: float = 0.5
):
    dot = Dot(radius=dot_radius, fill_color=dot_color)
    square = Square(
        side_length=side_length,
        stroke_color=stroke_color,
        stroke_width=stroke_width,
        fill_color=fill_color,
        fill_opacity=1.0,
    )
    square.round_corners(corner_radius)

    if not (1 &lt;= value &lt;= 6):
        raise Exception("DieFace only accepts integer inputs between 1 and 6")

    edge_group = [
        (ORIGIN,),
        (UL, DR),
        (UL, ORIGIN, DR),
        (UL, UR, DL, DR),
        (UL, UR, ORIGIN, DL, DR),
        (UL, UR, LEFT, RIGHT, DL, DR),
    ][value - 1]

    arrangement = VGroup(*(
        dot.copy().move_to(square.get_bounding_box_point(vect))
        for vect in edge_group
    ))
    arrangement.space_out_submobjects(dot_coalesce_factor)

    super().__init__(square, arrangement)
    self.dots = arrangement
    self.value = value
    self.index = value
</t>
<t tx="ekr.20250121054835.1354">class Dartboard(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1355">radius = 3
n_sectors = 20

def __init__(self, **kwargs):
    super().__init__(**kwargs)
    n_sectors = self.n_sectors
    angle = TAU / n_sectors

    segments = VGroup(*[
        VGroup(*[
            AnnularSector(
                inner_radius=in_r,
                outer_radius=out_r,
                start_angle=n * angle,
                angle=angle,
                fill_color=color,
            )
            for n, color in zip(
                range(n_sectors),
                it.cycle(colors)
            )
        ])
        for colors, in_r, out_r in [
            ([GREY_B, GREY_E], 0, 1),
            ([GREEN_E, RED_E], 0.5, 0.55),
            ([GREEN_E, RED_E], 0.95, 1),
        ]
    ])
    segments.rotate(-angle / 2)
    bullseyes = VGroup(*[
        Circle(radius=r)
        for r in [0.07, 0.035]
    ])
    bullseyes.set_fill(opacity=1)
    bullseyes.set_stroke(width=0)
    bullseyes[0].set_color(GREEN_E)
    bullseyes[1].set_color(RED_E)

    self.bullseye = bullseyes[1]
    self.add(*segments, *bullseyes)
    self.scale(self.radius)
</t>
<t tx="ekr.20250121054835.1356">from __future__ import annotations

from functools import reduce
import operator as op
import re

from manimlib.constants import BLACK, WHITE
from manimlib.mobject.svg.svg_mobject import SVGMobject
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.utils.tex_file_writing import latex_to_svg

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable, List, Dict
    from manimlib.typing import ManimColor


SCALE_FACTOR_PER_FONT_POINT = 0.001


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1357">class SingleStringTex(SVGMobject):
    @others
</t>
<t tx="ekr.20250121054835.1358">height: float | None = None

def __init__(
    self,
    tex_string: str,
    height: float | None = None,
    fill_color: ManimColor = WHITE,
    fill_opacity: float = 1.0,
    stroke_width: float = 0,
    svg_default: dict = dict(fill_color=WHITE),
    path_string_config: dict = dict(),
    font_size: int = 48,
    alignment: str = R"\centering",
    math_mode: bool = True,
    organize_left_to_right: bool = False,
    template: str = "",
    additional_preamble: str = "",
    **kwargs
</t>
<t tx="ekr.20250121054835.1359">):
    self.tex_string = tex_string
    self.svg_default = dict(svg_default)
    self.path_string_config = dict(path_string_config)
    self.font_size = font_size
    self.alignment = alignment
    self.math_mode = math_mode
    self.organize_left_to_right = organize_left_to_right
    self.template = template
    self.additional_preamble = additional_preamble

    super().__init__(
        height=height,
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        path_string_config=path_string_config,
        **kwargs
    )

    if self.height is None:
        self.scale(SCALE_FACTOR_PER_FONT_POINT * self.font_size)
    if self.organize_left_to_right:
        self.organize_submobjects_left_to_right()

@property
def hash_seed(self) -&gt; tuple:
    return (
        self.__class__.__name__,
        self.svg_default,
        self.path_string_config,
        self.tex_string,
        self.alignment,
        self.math_mode,
        self.template,
        self.additional_preamble
    )
</t>
<t tx="ekr.20250121054835.136">def focus(self):
    """
    Puts focus on this window by hiding and showing it again.

    Note that the pyglet `activate()` method didn't work as expected here,
    so that's why we have to use this workaround. This will produce a small
    flicker on the window but at least reliably focuses it. It may also
    offset the window position slightly.
    """
    self._window.set_visible(False)
    self._window.set_visible(True)
</t>
<t tx="ekr.20250121054835.1360">def get_svg_string_by_content(self, content: str) -&gt; str:
    return latex_to_svg(content, self.template, self.additional_preamble)
</t>
<t tx="ekr.20250121054835.1361">def get_tex_file_body(self, tex_string: str) -&gt; str:
    new_tex = self.get_modified_expression(tex_string)
    if self.math_mode:
        new_tex = "\\begin{align*}\n" + new_tex + "\n\\end{align*}"
    return self.alignment + "\n" + new_tex
</t>
<t tx="ekr.20250121054835.1362">def get_modified_expression(self, tex_string: str) -&gt; str:
    return self.modify_special_strings(tex_string.strip())
</t>
<t tx="ekr.20250121054835.1363">def modify_special_strings(self, tex: str) -&gt; str:
    tex = tex.strip()
    should_add_filler = reduce(op.or_, [
        # Fraction line needs something to be over
        tex == "\\over",
        tex == "\\overline",
        # Makesure sqrt has overbar
        tex == "\\sqrt",
        tex == "\\sqrt{",
        # Need to add blank subscript or superscript
        tex.endswith("_"),
        tex.endswith("^"),
        tex.endswith("dot"),
    ])
    if should_add_filler:
        filler = "{\\quad}"
        tex += filler

    should_add_double_filler = reduce(op.or_, [
        tex == "\\overset",
        # TODO: these can't be used since they change
        # the latex draw order.
        # tex == "\\frac", # you can use \\over as a alternative 
        # tex == "\\dfrac",
        # tex == "\\binom",
    ])
    if should_add_double_filler:
        filler = "{\\quad}{\\quad}"
        tex += filler

    if tex == "\\substack":
        tex = "\\quad"

    if tex == "":
        tex = "\\quad"

    # To keep files from starting with a line break
    if tex.startswith("\\\\"):
        tex = tex.replace("\\\\", "\\quad\\\\")

    tex = self.balance_braces(tex)

    # Handle imbalanced \left and \right
    num_lefts, num_rights = [
        len([
            s for s in tex.split(substr)[1:]
            if s and s[0] in "(){}[]|.\\"
        ])
        for substr in ("\\left", "\\right")
    ]
    if num_lefts != num_rights:
        tex = tex.replace("\\left", "\\big")
        tex = tex.replace("\\right", "\\big")

    for context in ["array"]:
        begin_in = ("\\begin{%s}" % context) in tex
        end_in = ("\\end{%s}" % context) in tex
        if begin_in ^ end_in:
            # Just turn this into a blank string,
            # which means caller should leave a
            # stray \\begin{...} with other symbols
            tex = ""
    return tex
</t>
<t tx="ekr.20250121054835.1364">def balance_braces(self, tex: str) -&gt; str:
    """
    Makes Tex resiliant to unmatched braces
    """
    num_unclosed_brackets = 0
    for i in range(len(tex)):
        if i &gt; 0 and tex[i - 1] == "\\":
            # So as to not count '\{' type expressions
            continue
        char = tex[i]
        if char == "{":
            num_unclosed_brackets += 1
        elif char == "}":
            if num_unclosed_brackets == 0:
                tex = "{" + tex
            else:
                num_unclosed_brackets -= 1
    tex += num_unclosed_brackets * "}"
    return tex
</t>
<t tx="ekr.20250121054835.1365">def get_tex(self) -&gt; str:
    return self.tex_string
</t>
<t tx="ekr.20250121054835.1366">def organize_submobjects_left_to_right(self):
    self.sort(lambda p: p[0])
    return self
</t>
<t tx="ekr.20250121054835.1367">class OldTex(SingleStringTex):
    @others
</t>
<t tx="ekr.20250121054835.1368">def __init__(
    self,
    *tex_strings: str,
    arg_separator: str = "",
    isolate: List[str] = [],
    tex_to_color_map: Dict[str, ManimColor] = {},
    **kwargs
):
    self.tex_strings = self.break_up_tex_strings(
        tex_strings,
        substrings_to_isolate=[*isolate, *tex_to_color_map.keys()]
    )
    full_string = arg_separator.join(self.tex_strings)

    super().__init__(full_string, **kwargs)
    self.break_up_by_substrings(self.tex_strings)
    self.set_color_by_tex_to_color_map(tex_to_color_map)

    if self.organize_left_to_right:
        self.organize_submobjects_left_to_right()
</t>
<t tx="ekr.20250121054835.1369">def break_up_tex_strings(self, tex_strings: Iterable[str], substrings_to_isolate: List[str] = []) -&gt; Iterable[str]:
    # Separate out any strings specified in the isolate
    # or tex_to_color_map lists.
    if len(substrings_to_isolate) == 0:
        return tex_strings
    patterns = (
        "({})".format(re.escape(ss))
        for ss in substrings_to_isolate
    )
    pattern = "|".join(patterns)
    pieces = []
    for s in tex_strings:
        if pattern:
            pieces.extend(re.split(pattern, s))
        else:
            pieces.append(s)
    return list(filter(lambda s: s, pieces))
</t>
<t tx="ekr.20250121054835.137">def to_default_position(self):
    self.position = self.default_position
    # Hack. Sometimes, namely when configured to open in a separate window,
    # the window needs to be resized to display correctly.
    w, h = self.default_size
    self.size = (w - 1, h - 1)
    self.size = (w, h)
</t>
<t tx="ekr.20250121054835.1370">def break_up_by_substrings(self, tex_strings: Iterable[str]):
    """
    Reorganize existing submojects one layer
    deeper based on the structure of tex_strings (as a list
    of tex_strings)
    """
    if len(list(tex_strings)) == 1:
        submob = self.copy()
        self.set_submobjects([submob])
        return self
    new_submobjects = []
    curr_index = 0
    for tex_string in tex_strings:
        tex_string = tex_string.strip()
        if len(tex_string) == 0:
            continue
        sub_tex_mob = SingleStringTex(tex_string, math_mode=self.math_mode)
        num_submobs = len(sub_tex_mob)
        if num_submobs == 0:
            continue
        new_index = curr_index + num_submobs
        sub_tex_mob.set_submobjects(self.submobjects[curr_index:new_index])
        new_submobjects.append(sub_tex_mob)
        curr_index = new_index
    self.set_submobjects(new_submobjects)
    return self
</t>
<t tx="ekr.20250121054835.1371">def get_parts_by_tex(
    self,
    tex: str,
    substring: bool = True,
    case_sensitive: bool = True
) -&gt; VGroup:
    def test(tex1, tex2):
        if not case_sensitive:
            tex1 = tex1.lower()
            tex2 = tex2.lower()
        if substring:
            return tex1 in tex2
        else:
            return tex1 == tex2

    return VGroup(*filter(
        lambda m: isinstance(m, SingleStringTex) and test(tex, m.get_tex()),
        self.submobjects
    ))
</t>
<t tx="ekr.20250121054835.1372">def get_part_by_tex(self, tex: str, **kwargs) -&gt; SingleStringTex | None:
    all_parts = self.get_parts_by_tex(tex, **kwargs)
    return all_parts[0] if all_parts else None
</t>
<t tx="ekr.20250121054835.1373">def set_color_by_tex(self, tex: str, color: ManimColor, **kwargs):
    self.get_parts_by_tex(tex, **kwargs).set_color(color)
    return self
</t>
<t tx="ekr.20250121054835.1374">def set_color_by_tex_to_color_map(
    self,
    tex_to_color_map: dict[str, ManimColor],
    **kwargs
):
    for tex, color in list(tex_to_color_map.items()):
        self.set_color_by_tex(tex, color, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.1375">def index_of_part(self, part: SingleStringTex, start: int = 0) -&gt; int:
    return self.submobjects.index(part, start)
</t>
<t tx="ekr.20250121054835.1376">def index_of_part_by_tex(self, tex: str, start: int = 0, **kwargs) -&gt; int:
    part = self.get_part_by_tex(tex, **kwargs)
    return self.index_of_part(part, start)
</t>
<t tx="ekr.20250121054835.1377">def slice_by_tex(
    self,
    start_tex: str | None = None,
    stop_tex: str | None = None,
    **kwargs
) -&gt; VGroup:
    if start_tex is None:
        start_index = 0
    else:
        start_index = self.index_of_part_by_tex(start_tex, **kwargs)

    if stop_tex is None:
        return self[start_index:]
    else:
        stop_index = self.index_of_part_by_tex(stop_tex, start=start_index, **kwargs)
        return self[start_index:stop_index]
</t>
<t tx="ekr.20250121054835.1378">def sort_alphabetically(self) -&gt; None:
    self.submobjects.sort(key=lambda m: m.get_tex())
</t>
<t tx="ekr.20250121054835.1379">def set_bstroke(self, color: ManimColor = BLACK, width: float = 4):
    self.set_stroke(color, width, background=True)
    return self
</t>
<t tx="ekr.20250121054835.138"># Delegate event handling to scene
def pixel_coords_to_space_coords(
    self,
    px: int,
    py: int,
    relative: bool = False
) -&gt; np.ndarray:
    if self.scene is None or not hasattr(self.scene, "frame"):
        return np.zeros(3)

    pixel_shape = np.array(self.size)
    fixed_frame_shape = np.array(FRAME_SHAPE)
    frame = self.scene.frame

    coords = np.zeros(3)
    coords[:2] = (fixed_frame_shape / pixel_shape) * np.array([px, py])
    if not relative:
        coords[:2] -= 0.5 * fixed_frame_shape
    return frame.from_fixed_frame_point(coords, relative)
</t>
<t tx="ekr.20250121054835.1380">class OldTexText(OldTex):
    @others
</t>
<t tx="ekr.20250121054835.1381">def __init__(
    self,
    *tex_strings: str,
    math_mode: bool = False,
    arg_separator: str = "",
    **kwargs
):
    super().__init__(
        *tex_strings,
        math_mode=math_mode,
        arg_separator=arg_separator,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.1382">from __future__ import annotations

from manimlib.constants import MED_SMALL_BUFF, WHITE, GREY_C
from manimlib.constants import DOWN, LEFT, RIGHT, UP
from manimlib.constants import FRAME_WIDTH
from manimlib.constants import MED_LARGE_BUFF, SMALL_BUFF
from manimlib.mobject.geometry import Line
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.svg.tex_mobject import TexText


from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from manimlib.typing import ManimColor, Vect3


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1383">class BulletedList(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.1384">def __init__(
    self,
    *items: str,
    buff: float = MED_LARGE_BUFF,
    aligned_edge: Vect3 = LEFT,
    **kwargs
):  
    labelled_content = [R"\item " + item for item in items]
    tex_string = "\n".join([
        R"\begin{itemize}",
        *labelled_content,
        R"\end{itemize}"
    ])
    tex_text = TexText(tex_string, isolate=labelled_content, **kwargs)
    lines = (tex_text.select_part(part) for part in labelled_content)

    super().__init__(*lines)

    self.arrange(DOWN, buff=buff, aligned_edge=aligned_edge)
</t>
<t tx="ekr.20250121054835.1385">def fade_all_but(self, index: int, opacity: float = 0.25) -&gt; None:
    for i, part in enumerate(self.submobjects):
        part.set_fill(opacity=(1.0 if i == index else opacity))
</t>
<t tx="ekr.20250121054835.1386">class TexTextFromPresetString(TexText):
    @others
</t>
<t tx="ekr.20250121054835.1387">tex: str = ""
default_color: ManimColor = WHITE

def __init__(self, **kwargs):
    super().__init__(
        self.tex,
        color=kwargs.pop("color", self.default_color),
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.1388">class Title(TexText):
    @others
    ):
        super().__init__(*text_parts, font_size=font_size, **kwargs)
        self.to_edge(UP, buff=MED_SMALL_BUFF)
        if include_underline:
            underline = Line(LEFT, RIGHT, **underline_style)
            underline.next_to(self, DOWN, buff=underline_buff)
            if match_underline_width_to_text:
                underline.match_width(self)
            else:
                underline.set_width(underline_width)
            self.add(underline)
            self.underline = underline
</t>
<t tx="ekr.20250121054835.1389">def __init__(
    self,
    *text_parts: str,
    font_size: int = 72,
    include_underline: bool = True,
    underline_width: float = FRAME_WIDTH - 2,
    # This will override underline_width
    match_underline_width_to_text: bool = False,
    underline_buff: float = SMALL_BUFF,
    underline_style: dict = dict(stroke_width=2, stroke_color=GREY_C),
    **kwargs
</t>
<t tx="ekr.20250121054835.139">def has_undrawn_event(self) -&gt; bool:
    return self._has_undrawn_event
</t>
<t tx="ekr.20250121054835.1390">from __future__ import annotations

from abc import ABC, abstractmethod
import itertools as it
import re
from scipy.optimize import linear_sum_assignment
from scipy.spatial.distance import cdist

from manimlib.constants import WHITE
from manimlib.logger import log
from manimlib.mobject.svg.svg_mobject import SVGMobject
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.utils.color import color_to_hex
from manimlib.utils.color import hex_to_int
from manimlib.utils.color import int_to_hex

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable
    from manimlib.typing import ManimColor, Span, Selector


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1391">class StringMobject(SVGMobject, ABC):
    """
    An abstract base class for `Tex` and `MarkupText`
    
    This class aims to optimize the logic of "slicing submobjects
    via substrings". This could be much clearer and more user-friendly
    than slicing through numerical indices explicitly.
    
    Users are expected to specify substrings in `isolate` parameter
    if they want to do anything with their corresponding submobjects.
    `isolate` parameter can be either a string, a `re.Pattern` object,
    or a 2-tuple containing integers or None, or a collection of the above.
    Note, substrings specified cannot *partly* overlap with each other.
    
    Each instance of `StringMobject` may generate 2 svg files.
    The additional one is generated with some color commands inserted,
    so that each submobject of the original `SVGMobject` will be labelled
    by the color of its paired submobject from the additional `SVGMobject`.
    """
    @others
</t>
<t tx="ekr.20250121054835.1392">height = None

def __init__(
    self,
    string: str,
    fill_color: ManimColor = WHITE,
    fill_border_width: float = 0.5,
    stroke_color: ManimColor = WHITE,
    stroke_width: float = 0,
    base_color: ManimColor = WHITE,
    isolate: Selector = (),
    protect: Selector = (),
    # When set to true, only the labelled svg is
    # rendered, and its contents are used directly
    # for the body of this String Mobject
    use_labelled_svg: bool = False,
    **kwargs
</t>
<t tx="ekr.20250121054835.1393">):
    self.string = string
    self.base_color = base_color or WHITE
    self.isolate = isolate
    self.protect = protect
    self.use_labelled_svg = use_labelled_svg

    self.parse()
    svg_string = self.get_svg_string()
    super().__init__(svg_string=svg_string, **kwargs)
    self.set_stroke(stroke_color, stroke_width)
    self.set_fill(fill_color, border_width=fill_border_width)
    self.labels = [submob.label for submob in self.submobjects]

def get_svg_string(self, is_labelled: bool = False) -&gt; str:
    content = self.get_content(is_labelled or self.use_labelled_svg)
    return self.get_svg_string_by_content(content)
</t>
<t tx="ekr.20250121054835.1394">@abstractmethod
def get_svg_string_by_content(self, content: str) -&gt; str:
    return ""
</t>
<t tx="ekr.20250121054835.1395">def assign_labels_by_color(self, mobjects: list[VMobject]) -&gt; None:
    """
    Assuming each mobject in the list `mobjects` has a fill color
    meant to represent a numerical label, this assigns those
    those numerical labels to each mobject as an attribute
    """
    labels_count = len(self.labelled_spans)
    if labels_count == 1:
        for mob in mobjects:
            mob.label = 0
        return

    unrecognizable_colors = []
    for mob in mobjects:
        label = hex_to_int(color_to_hex(mob.get_fill_color()))
        if label &gt;= labels_count:
            unrecognizable_colors.append(label)
            label = 0
        mob.label = label

    if unrecognizable_colors:
        log.warning(
            "Unrecognizable color labels detected (%s). " + \
            "The result could be unexpected.",
            ", ".join(
                int_to_hex(color)
                for color in unrecognizable_colors
            )
        )
</t>
<t tx="ekr.20250121054835.1396">def mobjects_from_svg_string(self, svg_string: str) -&gt; list[VMobject]:
    submobs = super().mobjects_from_svg_string(svg_string)

    if self.use_labelled_svg:
        # This means submobjects are colored according to spans
        self.assign_labels_by_color(submobs)
        return submobs

    # Otherwise, submobs are not colored, so generate a new list
    # of submobject which are and use those for labels
    unlabelled_submobs = submobs
    labelled_content = self.get_content(is_labelled=True)
    labelled_file = self.get_svg_string_by_content(labelled_content)
    labelled_submobs = super().mobjects_from_svg_string(labelled_file)
    self.labelled_submobs = labelled_submobs
    self.unlabelled_submobs = unlabelled_submobs

    self.assign_labels_by_color(labelled_submobs)
    self.rearrange_submobjects_by_positions(labelled_submobs, unlabelled_submobs)
    for usm, lsm in zip(unlabelled_submobs, labelled_submobs):
        usm.label = lsm.label

    if len(unlabelled_submobs) != len(labelled_submobs):
        log.warning(
            "Cannot align submobjects of the labelled svg " + \
            "to the original svg. Skip the labelling process."
        )
        for usm in unlabelled_submobs:
            usm.label = 0
        return unlabelled_submobs

    return unlabelled_submobs
</t>
<t tx="ekr.20250121054835.1397">def rearrange_submobjects_by_positions(
    self, labelled_submobs: list[VMobject], unlabelled_submobs: list[VMobject],
) -&gt; None:
    """
    Rearrange `labeleled_submobjects` so that each submobject
    is labelled by the nearest one of `unlabelled_submobs`.
    The correctness cannot be ensured, since the svg may
    change significantly after inserting color commands.
    """
    if len(labelled_submobs) == 0:
        return

    labelled_svg = VGroup(*labelled_submobs)
    labelled_svg.replace(VGroup(*unlabelled_submobs))
    distance_matrix = cdist(
        [submob.get_center() for submob in unlabelled_submobs],
        [submob.get_center() for submob in labelled_submobs]
    )
    _, indices = linear_sum_assignment(distance_matrix)
    labelled_submobs[:] = [labelled_submobs[index] for index in indices]
</t>
<t tx="ekr.20250121054835.1398"># Toolkits

def find_spans_by_selector(self, selector: Selector) -&gt; list[Span]:
    def find_spans_by_single_selector(sel):
        if isinstance(sel, str):
            return [
                match_obj.span()
                for match_obj in re.finditer(re.escape(sel), self.string)
            ]
        if isinstance(sel, re.Pattern):
            return [
                match_obj.span()
                for match_obj in sel.finditer(self.string)
            ]
        if isinstance(sel, tuple) and len(sel) == 2 and all(
            isinstance(index, int) or index is None
            for index in sel
        ):
            l = len(self.string)
            span = tuple(
                default_index if index is None else
                min(index, l) if index &gt;= 0 else max(index + l, 0)
                for index, default_index in zip(sel, (0, l))
            )
            return [span]
        return None

    result = find_spans_by_single_selector(selector)
    if result is None:
        result = []
        for sel in selector:
            spans = find_spans_by_single_selector(sel)
            if spans is None:
                raise TypeError(f"Invalid selector: '{sel}'")
            result.extend(spans)
    return list(filter(lambda span: span[0] &lt;= span[1], result))
</t>
<t tx="ekr.20250121054835.1399">@staticmethod
def span_contains(span_0: Span, span_1: Span) -&gt; bool:
    return span_0[0] &lt;= span_1[0] and span_0[1] &gt;= span_1[1]
</t>
<t tx="ekr.20250121054835.14">def construct(self):
    square = Square()
    square.set_fill(BLUE_E, 1)

    # On all frames, the constructor Brace(square, UP) will
    # be called, and the mobject brace will set its data to match
    # that of the newly constructed object
    brace = always_redraw(Brace, square, UP)

    label = TexText("Width = 0.00")
    number = label.make_number_changeable("0.00")

    # This ensures that the method deicmal.next_to(square)
    # is called on every frame
    label.always.next_to(brace, UP)
    # You could also write the following equivalent line
    # label.add_updater(lambda m: m.next_to(brace, UP))

    # If the argument itself might change, you can use f_always,
    # for which the arguments following the initial Mobject method
    # should be functions returning arguments to that method.
    # The following line ensures thst decimal.set_value(square.get_y())
    # is called every frame
    number.f_always.set_value(square.get_width)
    # You could also write the following equivalent line
    # number.add_updater(lambda m: m.set_value(square.get_width()))

    self.add(square, brace, label)

    # Notice that the brace and label track with the square
    self.play(
        square.animate.scale(2),
        rate_func=there_and_back,
        run_time=2,
    )
    self.wait()
    self.play(
        square.animate.set_width(5, stretch=True),
        run_time=3,
    )
    self.wait()
    self.play(
        square.animate.set_width(2),
        run_time=3
    )
    self.wait()

    # In general, you can alway call Mobject.add_updater, and pass in
    # a function that you want to be called on every frame.  The function
    # should take in either one argument, the mobject, or two arguments,
    # the mobject and the amount of time since the last frame.
    now = self.time
    w0 = square.get_width()
    square.add_updater(
        lambda m: m.set_width(w0 * math.sin(self.time - now) + w0)
    )
    self.wait(4 * PI)
</t>
<t tx="ekr.20250121054835.140">def swap_buffers(self):
    super().swap_buffers()
    self._has_undrawn_event = False
</t>
<t tx="ekr.20250121054835.1400"># Parsing

def parse(self) -&gt; None:
    def get_substr(span: Span) -&gt; str:
        return self.string[slice(*span)]

    configured_items = self.get_configured_items()
    isolated_spans = self.find_spans_by_selector(self.isolate)
    protected_spans = self.find_spans_by_selector(self.protect)
    command_matches = self.get_command_matches(self.string)

    def get_key(category, i, flag):
        def get_span_by_category(category, i):
            if category == 0:
                return configured_items[i][0]
            if category == 1:
                return isolated_spans[i]
            if category == 2:
                return protected_spans[i]
            return command_matches[i].span()

        index, paired_index = get_span_by_category(category, i)[::flag]
        return (
            index,
            flag * (2 if index != paired_index else -1),
            -paired_index,
            flag * category,
            flag * i
        )

    index_items = sorted([
        (category, i, flag)
        for category, item_length in enumerate((
            len(configured_items),
            len(isolated_spans),
            len(protected_spans),
            len(command_matches)
        ))
        for i in range(item_length)
        for flag in (1, -1)
    ], key=lambda t: get_key(*t))

    inserted_items = []
    labelled_items = []
    overlapping_spans = []
    level_mismatched_spans = []

    label = 1
    protect_level = 0
    bracket_stack = [0]
    bracket_count = 0
    open_command_stack = []
    open_stack = []
    for category, i, flag in index_items:
        if category &gt;= 2:
            protect_level += flag
            if flag == 1 or category == 2:
                continue
            inserted_items.append((i, 0))
            command_match = command_matches[i]
            command_flag = self.get_command_flag(command_match)
            if command_flag == 1:
                bracket_count += 1
                bracket_stack.append(bracket_count)
                open_command_stack.append((len(inserted_items), i))
                continue
            if command_flag == 0:
                continue
            pos, i_ = open_command_stack.pop()
            bracket_stack.pop()
            open_command_match = command_matches[i_]
            attr_dict = self.get_attr_dict_from_command_pair(
                open_command_match, command_match
            )
            if attr_dict is None:
                continue
            span = (open_command_match.end(), command_match.start())
            labelled_items.append((span, attr_dict))
            inserted_items.insert(pos, (label, 1))
            inserted_items.insert(-1, (label, -1))
            label += 1
            continue
        if flag == 1:
            open_stack.append((
                len(inserted_items), category, i,
                protect_level, bracket_stack.copy()
            ))
            continue
        span, attr_dict = configured_items[i] \
            if category == 0 else (isolated_spans[i], {})
        pos, category_, i_, protect_level_, bracket_stack_ \
            = open_stack.pop()
        if category_ != category or i_ != i:
            overlapping_spans.append(span)
            continue
        if protect_level_ or protect_level:
            continue
        if bracket_stack_ != bracket_stack:
            level_mismatched_spans.append(span)
            continue
        labelled_items.append((span, attr_dict))
        inserted_items.insert(pos, (label, 1))
        inserted_items.append((label, -1))
        label += 1
    labelled_items.insert(0, ((0, len(self.string)), {}))
    inserted_items.insert(0, (0, 1))
    inserted_items.append((0, -1))

    if overlapping_spans:
        log.warning(
            "Partly overlapping substrings detected: %s",
            ", ".join(
                f"'{get_substr(span)}'"
                for span in overlapping_spans
            )
        )
    if level_mismatched_spans:
        log.warning(
            "Cannot handle substrings: %s",
            ", ".join(
                f"'{get_substr(span)}'"
                for span in level_mismatched_spans
            )
        )

    def reconstruct_string(
        start_item: tuple[int, int],
        end_item: tuple[int, int],
        command_replace_func: Callable[[re.Match], str],
        command_insert_func: Callable[[int, int, dict[str, str]], str]
    ) -&gt; str:
        def get_edge_item(i: int, flag: int) -&gt; tuple[Span, str]:
            if flag == 0:
                match_obj = command_matches[i]
                return (
                    match_obj.span(),
                    command_replace_func(match_obj)
                )
            span, attr_dict = labelled_items[i]
            index = span[flag &lt; 0]
            return (
                (index, index),
                command_insert_func(i, flag, attr_dict)
            )

        items = [
            get_edge_item(i, flag)
            for i, flag in inserted_items[slice(
                inserted_items.index(start_item),
                inserted_items.index(end_item) + 1
            )]
        ]
        pieces = [
            get_substr((start, end))
            for start, end in zip(
                [interval_end for (_, interval_end), _ in items[:-1]],
                [interval_start for (interval_start, _), _ in items[1:]]
            )
        ]
        interval_pieces = [piece for _, piece in items[1:-1]]
        return "".join(it.chain(*zip(pieces, (*interval_pieces, ""))))

    self.labelled_spans = [span for span, _ in labelled_items]
    self.reconstruct_string = reconstruct_string
</t>
<t tx="ekr.20250121054835.1401">def get_content(self, is_labelled: bool) -&gt; str:
    content = self.reconstruct_string(
        (0, 1), (0, -1),
        self.replace_for_content,
        lambda label, flag, attr_dict: self.get_command_string(
            attr_dict,
            is_end=flag &lt; 0,
            label_hex=int_to_hex(label) if is_labelled else None
        )
    )
    prefix, suffix = self.get_content_prefix_and_suffix(
        is_labelled=is_labelled
    )
    return "".join((prefix, content, suffix))
</t>
<t tx="ekr.20250121054835.1402">@staticmethod
@abstractmethod
def get_command_matches(string: str) -&gt; list[re.Match]:
    return []
</t>
<t tx="ekr.20250121054835.1403">@staticmethod
@abstractmethod
def get_command_flag(match_obj: re.Match) -&gt; int:
    return 0
</t>
<t tx="ekr.20250121054835.1404">@staticmethod
@abstractmethod
def replace_for_content(match_obj: re.Match) -&gt; str:
    return ""
</t>
<t tx="ekr.20250121054835.1405">@staticmethod
@abstractmethod
def replace_for_matching(match_obj: re.Match) -&gt; str:
    return ""
</t>
<t tx="ekr.20250121054835.1406">@staticmethod
@abstractmethod
def get_attr_dict_from_command_pair(
    open_command: re.Match, close_command: re.Match,
) -&gt; dict[str, str] | None:
    return None
</t>
<t tx="ekr.20250121054835.1407">@abstractmethod
def get_configured_items(self) -&gt; list[tuple[Span, dict[str, str]]]:
    return []
</t>
<t tx="ekr.20250121054835.1408">@staticmethod
@abstractmethod
def get_command_string(
    attr_dict: dict[str, str], is_end: bool, label_hex: str | None
) -&gt; str:
    return ""
</t>
<t tx="ekr.20250121054835.1409">@abstractmethod
def get_content_prefix_and_suffix(
    self, is_labelled: bool
) -&gt; tuple[str, str]:
    return "", ""
</t>
<t tx="ekr.20250121054835.141">@staticmethod
def note_undrawn_event(func: Callable[..., T]) -&gt; Callable[..., T]:
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        func(self, *args, **kwargs)
        self._has_undrawn_event = True
    return wrapper
</t>
<t tx="ekr.20250121054835.1410"># Selector

def get_submob_indices_list_by_span(
    self, arbitrary_span: Span
) -&gt; list[int]:
    return [
        submob_index
        for submob_index, label in enumerate(self.labels)
        if self.span_contains(arbitrary_span, self.labelled_spans[label])
    ]
</t>
<t tx="ekr.20250121054835.1411">def get_specified_part_items(self) -&gt; list[tuple[str, list[int]]]:
    return [
        (
            self.string[slice(*span)],
            self.get_submob_indices_list_by_span(span)
        )
        for span in self.labelled_spans[1:]
    ]
</t>
<t tx="ekr.20250121054835.1412">def get_specified_substrings(self) -&gt; list[str]:
    substrs = [
        self.string[slice(*span)]
        for span in self.labelled_spans[1:]
    ]
    # Use dict.fromkeys to remove duplicates while retaining order
    return list(dict.fromkeys(substrs).keys())
</t>
<t tx="ekr.20250121054835.1413">def get_group_part_items(self) -&gt; list[tuple[str, list[int]]]:
    if not self.labels:
        return []

    def get_neighbouring_pairs(vals):
        return list(zip(vals[:-1], vals[1:]))

    range_lens, group_labels = zip(*(
        (len(list(grouper)), val)
        for val, grouper in it.groupby(self.labels)
    ))
    submob_indices_lists = [
        list(range(*submob_range))
        for submob_range in get_neighbouring_pairs(
            [0, *it.accumulate(range_lens)]
        )
    ]
    labelled_spans = self.labelled_spans
    start_items = [
        (group_labels[0], 1),
        *(
            (curr_label, 1)
            if self.span_contains(
                labelled_spans[prev_label], labelled_spans[curr_label]
            )
            else (prev_label, -1)
            for prev_label, curr_label in get_neighbouring_pairs(
                group_labels
            )
        )
    ]
    end_items = [
        *(
            (curr_label, -1)
            if self.span_contains(
                labelled_spans[next_label], labelled_spans[curr_label]
            )
            else (next_label, 1)
            for curr_label, next_label in get_neighbouring_pairs(
                group_labels
            )
        ),
        (group_labels[-1], -1)
    ]
    group_substrs = [
        re.sub(r"\s+", "", self.reconstruct_string(
            start_item, end_item,
            self.replace_for_matching,
            lambda label, flag, attr_dict: ""
        ))
        for start_item, end_item in zip(start_items, end_items)
    ]
    return list(zip(group_substrs, submob_indices_lists))
</t>
<t tx="ekr.20250121054835.1414">def get_submob_indices_lists_by_selector(
    self, selector: Selector
) -&gt; list[list[int]]:
    return list(filter(
        lambda indices_list: indices_list,
        [
            self.get_submob_indices_list_by_span(span)
            for span in self.find_spans_by_selector(selector)
        ]
    ))
</t>
<t tx="ekr.20250121054835.1415">def build_parts_from_indices_lists(
    self, indices_lists: list[list[int]]
) -&gt; VGroup:
    return VGroup(*(
        VGroup(*(
            self.submobjects[submob_index]
            for submob_index in indices_list
        ))
        for indices_list in indices_lists
    ))
</t>
<t tx="ekr.20250121054835.1416">def build_groups(self) -&gt; VGroup:
    return self.build_parts_from_indices_lists([
        indices_list
        for _, indices_list in self.get_group_part_items()
    ])
</t>
<t tx="ekr.20250121054835.1417">def select_parts(self, selector: Selector) -&gt; VGroup:
    specified_substrings = self.get_specified_substrings()
    if isinstance(selector, (str, re.Pattern)) and selector not in specified_substrings:
        return self.select_unisolated_substring(selector)
    indices_list = self.get_submob_indices_lists_by_selector(selector)
    return self.build_parts_from_indices_lists(indices_list)
</t>
<t tx="ekr.20250121054835.1418">def __getitem__(self, value: int | slice | Selector) -&gt; VMobject:
    if isinstance(value, (int, slice)):
        return super().__getitem__(value)
    return self.select_parts(value)
</t>
<t tx="ekr.20250121054835.1419">def select_part(self, selector: Selector, index: int = 0) -&gt; VMobject:
    return self.select_parts(selector)[index]
</t>
<t tx="ekr.20250121054835.142">@note_undrawn_event
def on_mouse_motion(self, x: int, y: int, dx: int, dy: int) -&gt; None:
    super().on_mouse_motion(x, y, dx, dy)
    if not self.scene:
        return
    point = self.pixel_coords_to_space_coords(x, y)
    d_point = self.pixel_coords_to_space_coords(dx, dy, relative=True)
    self.scene.on_mouse_motion(point, d_point)
</t>
<t tx="ekr.20250121054835.1420">def substr_to_path_count(self, substr: str) -&gt; int:
    return len(re.sub(r"\s", "", substr))
</t>
<t tx="ekr.20250121054835.1421">def get_symbol_substrings(self):
    return list(re.sub(r"\s", "", self.string))
</t>
<t tx="ekr.20250121054835.1422">def select_unisolated_substring(self, pattern: str | re.Pattern) -&gt; VGroup:
    if isinstance(pattern, str):
        pattern = re.compile(re.escape(pattern))
    result = []
    for match in re.finditer(pattern, self.string):
        index = match.start()
        start = self.substr_to_path_count(self.string[:index])
        substr = match.group()
        end = start + self.substr_to_path_count(substr)
        result.append(self[start:end])
    return VGroup(*result)
</t>
<t tx="ekr.20250121054835.1423">def set_parts_color(self, selector: Selector, color: ManimColor):
    self.select_parts(selector).set_color(color)
    return self
</t>
<t tx="ekr.20250121054835.1424">def set_parts_color_by_dict(self, color_map: dict[Selector, ManimColor]):
    for selector, color in color_map.items():
        self.set_parts_color(selector, color)
    return self
</t>
<t tx="ekr.20250121054835.1425">def get_string(self) -&gt; str:
    return self.string
</t>
<t tx="ekr.20250121054835.1426">from __future__ import annotations

from xml.etree import ElementTree as ET

import numpy as np
import svgelements as se
import io
from pathlib import Path

from manimlib.constants import RIGHT
from manimlib.logger import log
from manimlib.mobject.geometry import Circle
from manimlib.mobject.geometry import Line
from manimlib.mobject.geometry import Polygon
from manimlib.mobject.geometry import Polyline
from manimlib.mobject.geometry import Rectangle
from manimlib.mobject.geometry import RoundedRectangle
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.images import get_full_vector_image_path
from manimlib.utils.iterables import hash_obj

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from manimlib.typing import ManimColor, Vect3Array


SVG_HASH_TO_MOB_MAP: dict[int, list[VMobject]] = {}
PATH_TO_POINTS: dict[str, Vect3Array] = {}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1427">def _convert_point_to_3d(x: float, y: float) -&gt; np.ndarray:
    return np.array([x, y, 0.0])
</t>
<t tx="ekr.20250121054835.1428">class SVGMobject(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.1429">file_name: str = ""
height: float | None = 2.0
width: float | None = None

def __init__(
    self,
    file_name: str = "",
    svg_string: str = "",
    should_center: bool = True,
    height: float | None = None,
    width: float | None = None,
    # Style that overrides the original svg
    color: ManimColor = None,
    fill_color: ManimColor = None,
    fill_opacity: float | None = None,
    stroke_width: float | None = 0.0,
    stroke_color: ManimColor = None,
    stroke_opacity: float | None = None,
    # Style that fills only when not specified
    # If None, regarded as default values from svg standard
    svg_default: dict = dict(
        color=None,
        opacity=None,
        fill_color=None,
        fill_opacity=None,
        stroke_width=None,
        stroke_color=None,
        stroke_opacity=None,
    ),
    path_string_config: dict = dict(),
    **kwargs
</t>
<t tx="ekr.20250121054835.143">@note_undrawn_event
def on_mouse_drag(self, x: int, y: int, dx: int, dy: int, buttons: int, modifiers: int) -&gt; None:
    super().on_mouse_drag(x, y, dx, dy, buttons, modifiers)
    if not self.scene:
        return
    point = self.pixel_coords_to_space_coords(x, y)
    d_point = self.pixel_coords_to_space_coords(dx, dy, relative=True)
    self.scene.on_mouse_drag(point, d_point, buttons, modifiers)
</t>
<t tx="ekr.20250121054835.1430">):
    if svg_string != "":
        self.svg_string = svg_string
    elif file_name != "":
        self.svg_string = self.file_name_to_svg_string(file_name)
    elif self.file_name != "":
        self.file_name_to_svg_string(self.file_name)
    else:
        raise Exception("Must specify either a file_name or svg_string SVGMobject")

    self.svg_default = dict(svg_default)
    self.path_string_config = dict(path_string_config)

    super().__init__(**kwargs)
    self.init_svg_mobject()
    self.ensure_positive_orientation()

    # Rather than passing style into super().__init__
    # do it after svg has been taken in
    self.set_style(
        fill_color=color or fill_color,
        fill_opacity=fill_opacity,
        stroke_color=color or stroke_color,
        stroke_width=stroke_width,
        stroke_opacity=stroke_opacity,
    )

    # Initialize position
    height = height or self.height
    width = width or self.width

    if should_center:
        self.center()
    if height is not None:
        self.set_height(height)
    if width is not None:
        self.set_width(width)

def init_svg_mobject(self) -&gt; None:
    hash_val = hash_obj(self.hash_seed)
    if hash_val in SVG_HASH_TO_MOB_MAP:
        submobs = [sm.copy() for sm in SVG_HASH_TO_MOB_MAP[hash_val]]
    else:
        submobs = self.mobjects_from_svg_string(self.svg_string)
        SVG_HASH_TO_MOB_MAP[hash_val] = [sm.copy() for sm in submobs]

    self.add(*submobs)
    self.flip(RIGHT)  # Flip y
</t>
<t tx="ekr.20250121054835.1431">@property
def hash_seed(self) -&gt; tuple:
    # Returns data which can uniquely represent the result of `init_points`.
    # The hashed value of it is stored as a key in `SVG_HASH_TO_MOB_MAP`.
    return (
        self.__class__.__name__,
        self.svg_default,
        self.path_string_config,
        self.svg_string
    )
</t>
<t tx="ekr.20250121054835.1432">def mobjects_from_svg_string(self, svg_string: str) -&gt; list[VMobject]:
    element_tree = ET.ElementTree(ET.fromstring(svg_string))
    new_tree = self.modify_xml_tree(element_tree)

    # New svg based on tree contents
    data_stream = io.BytesIO()
    new_tree.write(data_stream)
    data_stream.seek(0)
    svg = se.SVG.parse(data_stream)
    data_stream.close()

    return self.mobjects_from_svg(svg)
</t>
<t tx="ekr.20250121054835.1433">def file_name_to_svg_string(self, file_name: str) -&gt; str:
    return Path(get_full_vector_image_path(file_name)).read_text()
</t>
<t tx="ekr.20250121054835.1434">def modify_xml_tree(self, element_tree: ET.ElementTree) -&gt; ET.ElementTree:
    config_style_attrs = self.generate_config_style_dict()
    style_keys = (
        "fill",
        "fill-opacity",
        "stroke",
        "stroke-opacity",
        "stroke-width",
        "style"
    )
    root = element_tree.getroot()
    style_attrs = {
        k: v
        for k, v in root.attrib.items()
        if k in style_keys
    }

    # Ignore other attributes in case that svgelements cannot parse them
    SVG_XMLNS = "{http://www.w3.org/2000/svg}"
    new_root = ET.Element("svg")
    config_style_node = ET.SubElement(new_root, f"{SVG_XMLNS}g", config_style_attrs)
    root_style_node = ET.SubElement(config_style_node, f"{SVG_XMLNS}g", style_attrs)
    root_style_node.extend(root)
    return ET.ElementTree(new_root)
</t>
<t tx="ekr.20250121054835.1435">def generate_config_style_dict(self) -&gt; dict[str, str]:
    keys_converting_dict = {
        "fill": ("color", "fill_color"),
        "fill-opacity": ("opacity", "fill_opacity"),
        "stroke": ("color", "stroke_color"),
        "stroke-opacity": ("opacity", "stroke_opacity"),
        "stroke-width": ("stroke_width",)
    }
    svg_default_dict = self.svg_default
    result = {}
    for svg_key, style_keys in keys_converting_dict.items():
        for style_key in style_keys:
            if svg_default_dict[style_key] is None:
                continue
            result[svg_key] = str(svg_default_dict[style_key])
    return result
</t>
<t tx="ekr.20250121054835.1436">def mobjects_from_svg(self, svg: se.SVG) -&gt; list[VMobject]:
    result = []
    for shape in svg.elements():
        if isinstance(shape, (se.Group, se.Use)):
            continue
        elif isinstance(shape, se.Path):
            mob = self.path_to_mobject(shape)
        elif isinstance(shape, se.SimpleLine):
            mob = self.line_to_mobject(shape)
        elif isinstance(shape, se.Rect):
            mob = self.rect_to_mobject(shape)
        elif isinstance(shape, (se.Circle, se.Ellipse)):
            mob = self.ellipse_to_mobject(shape)
        elif isinstance(shape, se.Polygon):
            mob = self.polygon_to_mobject(shape)
        elif isinstance(shape, se.Polyline):
            mob = self.polyline_to_mobject(shape)
        # elif isinstance(shape, se.Text):
        #     mob = self.text_to_mobject(shape)
        elif type(shape) == se.SVGElement:
            continue
        else:
            log.warning("Unsupported element type: %s", type(shape))
            continue
        if not mob.has_points():
            continue
        if isinstance(shape, se.GraphicObject):
            self.apply_style_to_mobject(mob, shape)
        if isinstance(shape, se.Transformable) and shape.apply:
            self.handle_transform(mob, shape.transform)
        result.append(mob)
    return result
</t>
<t tx="ekr.20250121054835.1437">@staticmethod
def handle_transform(mob: VMobject, matrix: se.Matrix) -&gt; VMobject:
    mat = np.array([
        [matrix.a, matrix.c],
        [matrix.b, matrix.d]
    ])
    vec = np.array([matrix.e, matrix.f, 0.0])
    mob.apply_matrix(mat)
    mob.shift(vec)
    return mob
</t>
<t tx="ekr.20250121054835.1438">@staticmethod
def apply_style_to_mobject(
    mob: VMobject,
    shape: se.GraphicObject
) -&gt; VMobject:
    mob.set_style(
        stroke_width=shape.stroke_width,
        stroke_color=shape.stroke.hexrgb,
        stroke_opacity=shape.stroke.opacity,
        fill_color=shape.fill.hexrgb,
        fill_opacity=shape.fill.opacity
    )
    return mob
</t>
<t tx="ekr.20250121054835.1439">def path_to_mobject(self, path: se.Path) -&gt; VMobjectFromSVGPath:
    return VMobjectFromSVGPath(path, **self.path_string_config)
</t>
<t tx="ekr.20250121054835.144">@note_undrawn_event
def on_mouse_press(self, x: int, y: int, button: int, mods: int) -&gt; None:
    super().on_mouse_press(x, y, button, mods)
    if not self.scene:
        return
    point = self.pixel_coords_to_space_coords(x, y)
    self.scene.on_mouse_press(point, button, mods)
</t>
<t tx="ekr.20250121054835.1440">def line_to_mobject(self, line: se.SimpleLine) -&gt; Line:
    return Line(
        start=_convert_point_to_3d(line.x1, line.y1),
        end=_convert_point_to_3d(line.x2, line.y2)
    )
</t>
<t tx="ekr.20250121054835.1441">def rect_to_mobject(self, rect: se.Rect) -&gt; Rectangle:
    if rect.rx == 0 or rect.ry == 0:
        mob = Rectangle(
            width=rect.width,
            height=rect.height,
        )
    else:
        mob = RoundedRectangle(
            width=rect.width,
            height=rect.height * rect.rx / rect.ry,
            corner_radius=rect.rx
        )
        mob.stretch_to_fit_height(rect.height)
    mob.shift(_convert_point_to_3d(
        rect.x + rect.width / 2,
        rect.y + rect.height / 2
    ))
    return mob
</t>
<t tx="ekr.20250121054835.1442">def ellipse_to_mobject(self, ellipse: se.Circle | se.Ellipse) -&gt; Circle:
    mob = Circle(radius=ellipse.rx)
    mob.stretch_to_fit_height(2 * ellipse.ry)
    mob.shift(_convert_point_to_3d(
        ellipse.cx, ellipse.cy
    ))
    return mob
</t>
<t tx="ekr.20250121054835.1443">def polygon_to_mobject(self, polygon: se.Polygon) -&gt; Polygon:
    points = [
        _convert_point_to_3d(*point)
        for point in polygon
    ]
    return Polygon(*points)
</t>
<t tx="ekr.20250121054835.1444">def polyline_to_mobject(self, polyline: se.Polyline) -&gt; Polyline:
    points = [
        _convert_point_to_3d(*point)
        for point in polyline
    ]
    return Polyline(*points)
</t>
<t tx="ekr.20250121054835.1445">def text_to_mobject(self, text: se.Text):
    pass
</t>
<t tx="ekr.20250121054835.1446">class VMobjectFromSVGPath(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.1447">def __init__(
    self,
    path_obj: se.Path,
    **kwargs
):
    # Get rid of arcs
    path_obj.approximate_arcs_with_quads()
    self.path_obj = path_obj
    super().__init__(**kwargs)
</t>
<t tx="ekr.20250121054835.1448">def init_points(self) -&gt; None:
    # After a given svg_path has been converted into points, the result
    # will be saved so that future calls for the same pathdon't need to
    # retrace the same computation.
    path_string = self.path_obj.d()
    if path_string not in PATH_TO_POINTS:
        self.handle_commands()
        # Save for future use
        PATH_TO_POINTS[path_string] = self.get_points().copy()
    else:
        points = PATH_TO_POINTS[path_string]
        self.set_points(points)
</t>
<t tx="ekr.20250121054835.1449">def handle_commands(self) -&gt; None:
    segment_class_to_func_map = {
        se.Move: (self.start_new_path, ("end",)),
        se.Close: (self.close_path, ()),
        se.Line: (lambda p: self.add_line_to(p, allow_null_line=False), ("end",)),
        se.QuadraticBezier: (lambda c, e: self.add_quadratic_bezier_curve_to(c, e, allow_null_curve=False), ("control", "end")),
        se.CubicBezier: (self.add_cubic_bezier_curve_to, ("control1", "control2", "end"))
    }
    for segment in self.path_obj:
        segment_class = segment.__class__
        func, attr_names = segment_class_to_func_map[segment_class]
        points = [
            _convert_point_to_3d(*segment.__getattribute__(attr_name))
            for attr_name in attr_names
        ]
        func(*points)

    # Get rid of the side effect of trailing "Z M" commands.
    if self.has_new_path_started():
        self.resize_points(self.get_num_points() - 2)
</t>
<t tx="ekr.20250121054835.145">@note_undrawn_event
def on_mouse_release(self, x: int, y: int, button: int, mods: int) -&gt; None:
    super().on_mouse_release(x, y, button, mods)
    if not self.scene:
        return
    point = self.pixel_coords_to_space_coords(x, y)
    self.scene.on_mouse_release(point, button, mods)
</t>
<t tx="ekr.20250121054835.1450">from __future__ import annotations

import re
from pathlib import Path

from manimlib.mobject.svg.string_mobject import StringMobject
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.color import color_to_hex
from manimlib.utils.color import hex_to_int
from manimlib.utils.tex_file_writing import latex_to_svg
from manimlib.utils.tex import num_tex_symbols
from manimlib.logger import log

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from manimlib.typing import ManimColor, Span, Selector, Self


SCALE_FACTOR_PER_FONT_POINT = 0.001


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1451">class Tex(StringMobject):
    @others
</t>
<t tx="ekr.20250121054835.1452">tex_environment: str = "align*"

def __init__(
    self,
    *tex_strings: str,
    font_size: int = 48,
    alignment: str = R"\centering",
    template: str = "",
    additional_preamble: str = "",
    tex_to_color_map: dict = dict(),
    t2c: dict = dict(),
    isolate: Selector = [],
    use_labelled_svg: bool = True,
    **kwargs
</t>
<t tx="ekr.20250121054835.1453">):
    # Combine multi-string arg, but mark them to isolate
    if len(tex_strings) &gt; 1:
        if isinstance(isolate, (str, re.Pattern, tuple)):
            isolate = [isolate]
        isolate = [*isolate, *tex_strings]

    tex_string = (" ".join(tex_strings)).strip()

    # Prevent from passing an empty string.
    if not tex_string.strip():
        tex_string = R"\\"

    self.font_size = font_size
    self.tex_string = tex_string
    self.alignment = alignment
    self.template = template
    self.additional_preamble = additional_preamble
    self.tex_to_color_map = dict(**t2c, **tex_to_color_map)

    super().__init__(
        tex_string,
        use_labelled_svg=use_labelled_svg,
        isolate=isolate,
        **kwargs
    )

    self.set_color_by_tex_to_color_map(self.tex_to_color_map)
    self.scale(SCALE_FACTOR_PER_FONT_POINT * font_size)

def get_svg_string_by_content(self, content: str) -&gt; str:
    return latex_to_svg(content, self.template, self.additional_preamble, short_tex=self.tex_string)
</t>
<t tx="ekr.20250121054835.1454">def _handle_scale_side_effects(self, scale_factor: float) -&gt; Self:
    self.font_size *= scale_factor
    return self
</t>
<t tx="ekr.20250121054835.1455"># Parsing

@staticmethod
def get_command_matches(string: str) -&gt; list[re.Match]:
    # Lump together adjacent brace pairs
    pattern = re.compile(r"""
        (?P&lt;command&gt;\\(?:[a-zA-Z]+|.))
        |(?P&lt;open&gt;{+)
        |(?P&lt;close&gt;}+)
    """, flags=re.X | re.S)
    result = []
    open_stack = []
    for match_obj in pattern.finditer(string):
        if match_obj.group("open"):
            open_stack.append((match_obj.span(), len(result)))
        elif match_obj.group("close"):
            close_start, close_end = match_obj.span()
            while True:
                if not open_stack:
                    raise ValueError("Missing '{' inserted")
                (open_start, open_end), index = open_stack.pop()
                n = min(open_end - open_start, close_end - close_start)
                result.insert(index, pattern.fullmatch(
                    string, pos=open_end - n, endpos=open_end
                ))
                result.append(pattern.fullmatch(
                    string, pos=close_start, endpos=close_start + n
                ))
                close_start += n
                if close_start &lt; close_end:
                    continue
                open_end -= n
                if open_start &lt; open_end:
                    open_stack.append(((open_start, open_end), index))
                break
        else:
            result.append(match_obj)
    if open_stack:
        raise ValueError("Missing '}' inserted")
    return result
</t>
<t tx="ekr.20250121054835.1456">@staticmethod
def get_command_flag(match_obj: re.Match) -&gt; int:
    if match_obj.group("open"):
        return 1
    if match_obj.group("close"):
        return -1
    return 0
</t>
<t tx="ekr.20250121054835.1457">@staticmethod
def replace_for_content(match_obj: re.Match) -&gt; str:
    return match_obj.group()
</t>
<t tx="ekr.20250121054835.1458">@staticmethod
def replace_for_matching(match_obj: re.Match) -&gt; str:
    if match_obj.group("command"):
        return match_obj.group()
    return ""
</t>
<t tx="ekr.20250121054835.1459">@staticmethod
def get_attr_dict_from_command_pair(
    open_command: re.Match, close_command: re.Match
) -&gt; dict[str, str] | None:
    if len(open_command.group()) &gt;= 2:
        return {}
    return None
</t>
<t tx="ekr.20250121054835.146">@note_undrawn_event
def on_mouse_scroll(self, x: int, y: int, x_offset: float, y_offset: float) -&gt; None:
    super().on_mouse_scroll(x, y, x_offset, y_offset)
    if not self.scene:
        return
    point = self.pixel_coords_to_space_coords(x, y)
    offset = self.pixel_coords_to_space_coords(x_offset, y_offset, relative=True)
    self.scene.on_mouse_scroll(point, offset, x_offset, y_offset)
</t>
<t tx="ekr.20250121054835.1460">def get_configured_items(self) -&gt; list[tuple[Span, dict[str, str]]]:
    return [
        (span, {})
        for selector in self.tex_to_color_map
        for span in self.find_spans_by_selector(selector)
    ]
</t>
<t tx="ekr.20250121054835.1461">@staticmethod
def get_color_command(rgb_hex: str) -&gt; str:
    rgb = hex_to_int(rgb_hex)
    rg, b = divmod(rgb, 256)
    r, g = divmod(rg, 256)
    return f"\\color[RGB]{{{r}, {g}, {b}}}"
</t>
<t tx="ekr.20250121054835.1462">@staticmethod
def get_command_string(
    attr_dict: dict[str, str], is_end: bool, label_hex: str | None
) -&gt; str:
    if label_hex is None:
        return ""
    if is_end:
        return "}}"
    return "{{" + Tex.get_color_command(label_hex)
</t>
<t tx="ekr.20250121054835.1463">def get_content_prefix_and_suffix(
    self, is_labelled: bool
) -&gt; tuple[str, str]:
    prefix_lines = []
    suffix_lines = []
    if not is_labelled:
        prefix_lines.append(self.get_color_command(
            color_to_hex(self.base_color)
        ))
    if self.alignment:
        prefix_lines.append(self.alignment)
    if self.tex_environment:
        prefix_lines.append(f"\\begin{{{self.tex_environment}}}")
        suffix_lines.append(f"\\end{{{self.tex_environment}}}")
    return (
        "".join([line + "\n" for line in prefix_lines]),
        "".join(["\n" + line for line in suffix_lines])
    )
</t>
<t tx="ekr.20250121054835.1464"># Method alias

def get_parts_by_tex(self, selector: Selector) -&gt; VGroup:
    return self.select_parts(selector)
</t>
<t tx="ekr.20250121054835.1465">def get_part_by_tex(self, selector: Selector, index: int = 0) -&gt; VMobject:
    return self.select_part(selector, index)
</t>
<t tx="ekr.20250121054835.1466">def set_color_by_tex(self, selector: Selector, color: ManimColor):
    return self.set_parts_color(selector, color)
</t>
<t tx="ekr.20250121054835.1467">def set_color_by_tex_to_color_map(
    self, color_map: dict[Selector, ManimColor]
):
    return self.set_parts_color_by_dict(color_map)
</t>
<t tx="ekr.20250121054835.1468">def get_tex(self) -&gt; str:
    return self.get_string()
</t>
<t tx="ekr.20250121054835.1469"># Specific to Tex
def substr_to_path_count(self, substr: str) -&gt; int:
    tex = self.get_tex()
    if len(self) != num_tex_symbols(tex):
        log.warning(f"Estimated size of {tex} does not match true size")
    return num_tex_symbols(substr)
</t>
<t tx="ekr.20250121054835.147">@note_undrawn_event
def on_key_press(self, symbol: int, modifiers: int) -&gt; None:
    self.pressed_keys.add(symbol)  # Modifiers?
    super().on_key_press(symbol, modifiers)
    if not self.scene:
        return
    self.scene.on_key_press(symbol, modifiers)
</t>
<t tx="ekr.20250121054835.1470">def get_symbol_substrings(self):
    pattern = "|".join((
        # Tex commands
        r"\\[a-zA-Z]+",
        # And most single characters, with these exceptions
        r"[^\^\{\}\s\_\$\\\&amp;]",
    ))
    return re.findall(pattern, self.string)
</t>
<t tx="ekr.20250121054835.1471">def make_number_changeable(
    self,
    value: float | int | str,
    index: int = 0,
    replace_all: bool = False,
    **config,
) -&gt; VMobject:
    substr = str(value)
    parts = self.select_parts(substr)
    if len(parts) == 0:
        log.warning(f"{value} not found in Tex.make_number_changeable call")
        return VMobject()
    if index &gt; len(parts) - 1:
        log.warning(f"Requested {index}th occurance of {value}, but only {len(parts)} exist")
        return VMobject()
    if not replace_all:
        parts = [parts[index]]

    from manimlib.mobject.numbers import DecimalNumber

    decimal_mobs = []
    for part in parts:
        if "." in substr:
            num_decimal_places = len(substr.split(".")[1])
        else:
            num_decimal_places = 0
        decimal_mob = DecimalNumber(
            float(value),
            num_decimal_places=num_decimal_places,
            **config,
        )
        decimal_mob.replace(part)
        decimal_mob.match_style(part)
        if len(part) &gt; 1:
            self.remove(*part[1:])
        self.replace_submobject(self.submobjects.index(part[0]), decimal_mob)
        decimal_mobs.append(decimal_mob)

        # Replace substr with something that looks like a tex command. This
        # is to ensure Tex.substr_to_path_count counts it correctly.
        self.string = self.string.replace(substr, R"\decimalmob", 1)

    if replace_all:
        return VGroup(*decimal_mobs)
    return decimal_mobs[index]
</t>
<t tx="ekr.20250121054835.1472">class TexText(Tex):
    tex_environment: str = ""
</t>
<t tx="ekr.20250121054835.1473">from __future__ import annotations

from contextlib import contextmanager
import os
from pathlib import Path
import re
import tempfile
from functools import lru_cache

import manimpango
import pygments
import pygments.formatters
import pygments.lexers

from manimlib.config import manim_config
from manimlib.constants import DEFAULT_PIXEL_WIDTH, FRAME_WIDTH
from manimlib.constants import NORMAL
from manimlib.logger import log
from manimlib.mobject.svg.string_mobject import StringMobject
from manimlib.utils.cache import cache_on_disk
from manimlib.utils.color import color_to_hex
from manimlib.utils.color import int_to_hex
from manimlib.utils.simple_functions import hash_string

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable

    from manimlib.mobject.types.vectorized_mobject import VGroup
    from manimlib.typing import ManimColor, Span, Selector


TEXT_MOB_SCALE_FACTOR = 0.0076
DEFAULT_LINE_SPACING_SCALE = 0.6
# Ensure the canvas is large enough to hold all glyphs.
DEFAULT_CANVAS_WIDTH = 16384
DEFAULT_CANVAS_HEIGHT = 16384


# Temporary handler
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1474">class _Alignment:
    @others
</t>
<t tx="ekr.20250121054835.1475">VAL_DICT = {
    "LEFT": 0,
    "CENTER": 1,
    "RIGHT": 2
}

def __init__(self, s: str):
    self.value = _Alignment.VAL_DICT[s.upper()]
</t>
<t tx="ekr.20250121054835.1476">@lru_cache(maxsize=128)
@cache_on_disk
def markup_to_svg(
    markup_str: str,
    justify: bool = False,
    indent: float = 0,
    alignment: str = "CENTER",
    line_width: float | None = None,
) -&gt; str:
    validate_error = manimpango.MarkupUtils.validate(markup_str)
    if validate_error:
        raise ValueError(
            f"Invalid markup string \"{markup_str}\"\n" + \
            f"{validate_error}"
        )

    # `manimpango` is under construction,
    # so the following code is intended to suit its interface
    alignment = _Alignment(alignment)
    if line_width is None:
        pango_width = -1
    else:
        pango_width = line_width / FRAME_WIDTH * DEFAULT_PIXEL_WIDTH

    # Write the result to a temporary svg file, and return it's contents.
    temp_file = Path(tempfile.gettempdir(), hash_string(markup_str)).with_suffix(".svg")
    manimpango.MarkupUtils.text2svg(
        text=markup_str,
        font="",                     # Already handled
        slant="NORMAL",              # Already handled
        weight="NORMAL",             # Already handled
        size=1,                      # Already handled
        _=0,                         # Empty parameter
        disable_liga=False,
        file_name=str(temp_file),
        START_X=0,
        START_Y=0,
        width=DEFAULT_CANVAS_WIDTH,
        height=DEFAULT_CANVAS_HEIGHT,
        justify=justify,
        indent=indent,
        line_spacing=None,           # Already handled
        alignment=alignment,
        pango_width=pango_width
    )
    result = temp_file.read_text()
    os.remove(temp_file)
    return result
</t>
<t tx="ekr.20250121054835.1477">class MarkupText(StringMobject):
    @others
</t>
<t tx="ekr.20250121054835.1478"># See https://docs.gtk.org/Pango/pango_markup.html
MARKUP_TAGS = {
    "b": {"font_weight": "bold"},
    "big": {"font_size": "larger"},
    "i": {"font_style": "italic"},
    "s": {"strikethrough": "true"},
    "sub": {"baseline_shift": "subscript", "font_scale": "subscript"},
    "sup": {"baseline_shift": "superscript", "font_scale": "superscript"},
    "small": {"font_size": "smaller"},
    "tt": {"font_family": "monospace"},
    "u": {"underline": "single"},
}
MARKUP_ENTITY_DICT = {
    "&lt;": "&amp;lt;",
    "&gt;": "&amp;gt;",
    "&amp;": "&amp;amp;",
    "\"": "&amp;quot;",
    "'": "&amp;apos;"
}

def __init__(
    self,
    text: str,
    font_size: int = 48,
    height: float | None = None,
    justify: bool = False,
    indent: float = 0,
    alignment: str = "",
    line_width: float | None = None,
    font: str = "",
    slant: str = NORMAL,
    weight: str = NORMAL,
    gradient: Iterable[ManimColor] | None = None,
    line_spacing_height: float | None = None,
    text2color: dict = {},
    text2font: dict = {},
    text2gradient: dict = {},
    text2slant: dict = {},
    text2weight: dict = {},
    # For convenience, one can use shortened names
    lsh: float | None = None,  # Overrides line_spacing_height
    t2c: dict = {},  # Overrides text2color if nonempty
    t2f: dict = {},  # Overrides text2font if nonempty
    t2g: dict = {},  # Overrides text2gradient if nonempty
    t2s: dict = {},  # Overrides text2slant if nonempty
    t2w: dict = {},  # Overrides text2weight if nonempty
    global_config: dict = {},
    local_configs: dict = {},
    disable_ligatures: bool = True,
    isolate: Selector = re.compile(r"\w+", re.U),
    **kwargs
</t>
<t tx="ekr.20250121054835.1479">):
    text_config = manim_config.text
    self.text = text
    self.font_size = font_size
    self.justify = justify
    self.indent = indent
    self.alignment = alignment or text_config.alignment
    self.line_width = line_width
    self.font = font or text_config.font
    self.slant = slant
    self.weight = weight

    self.lsh = line_spacing_height or lsh
    self.t2c = text2color or t2c
    self.t2f = text2font or t2f
    self.t2g = text2gradient or t2g
    self.t2s = text2slant or t2s
    self.t2w = text2weight or t2w

    self.global_config = global_config
    self.local_configs = local_configs
    self.disable_ligatures = disable_ligatures
    self.isolate = isolate

    super().__init__(text, height=height, **kwargs)

    if self.t2g:
        log.warning("""
            Manim currently cannot parse gradient from svg.
            Please set gradient via `set_color_by_gradient`.
        """)
    if gradient:
        self.set_color_by_gradient(*gradient)
    if self.t2c:
        self.set_color_by_text_to_color_map(self.t2c)
    if height is None:
        self.scale(TEXT_MOB_SCALE_FACTOR)

def get_svg_string_by_content(self, content: str) -&gt; str:
    self.content = content
    return markup_to_svg(
        content,
        justify=self.justify,
        indent=self.indent,
        alignment=self.alignment,
        line_width=self.line_width
    )
</t>
<t tx="ekr.20250121054835.148">@note_undrawn_event
def on_key_release(self, symbol: int, modifiers: int) -&gt; None:
    self.pressed_keys.difference_update({symbol})  # Modifiers?
    super().on_key_release(symbol, modifiers)
    if not self.scene:
        return
    self.scene.on_key_release(symbol, modifiers)
</t>
<t tx="ekr.20250121054835.1480"># Toolkits

@staticmethod
def escape_markup_char(substr: str) -&gt; str:
    return MarkupText.MARKUP_ENTITY_DICT.get(substr, substr)
</t>
<t tx="ekr.20250121054835.1481">@staticmethod
def unescape_markup_char(substr: str) -&gt; str:
    return {
        v: k
        for k, v in MarkupText.MARKUP_ENTITY_DICT.items()
    }.get(substr, substr)
</t>
<t tx="ekr.20250121054835.1482"># Parsing

@staticmethod
def get_command_matches(string: str) -&gt; list[re.Match]:
    pattern = re.compile(r"""
        (?P&lt;tag&gt;
            &lt;
            (?P&lt;close_slash&gt;/)?
            (?P&lt;tag_name&gt;\w+)\s*
            (?P&lt;attr_list&gt;(?:\w+\s*\=\s*(?P&lt;quot&gt;["']).*?(?P=quot)\s*)*)
            (?P&lt;elision_slash&gt;/)?
            &gt;
        )
        |(?P&lt;passthrough&gt;
            &lt;\?.*?\?&gt;|&lt;!--.*?--&gt;|&lt;!\[CDATA\[.*?\]\]&gt;|&lt;!DOCTYPE.*?&gt;
        )
        |(?P&lt;entity&gt;&amp;(?P&lt;unicode&gt;\#(?P&lt;hex&gt;x)?)?(?P&lt;content&gt;.*?);)
        |(?P&lt;char&gt;[&gt;"'])
    """, flags=re.X | re.S)
    return list(pattern.finditer(string))
</t>
<t tx="ekr.20250121054835.1483">@staticmethod
def get_command_flag(match_obj: re.Match) -&gt; int:
    if match_obj.group("tag"):
        if match_obj.group("close_slash"):
            return -1
        if not match_obj.group("elision_slash"):
            return 1
    return 0
</t>
<t tx="ekr.20250121054835.1484">@staticmethod
def replace_for_content(match_obj: re.Match) -&gt; str:
    if match_obj.group("tag"):
        return ""
    if match_obj.group("char"):
        return MarkupText.escape_markup_char(match_obj.group("char"))
    return match_obj.group()
</t>
<t tx="ekr.20250121054835.1485">@staticmethod
def replace_for_matching(match_obj: re.Match) -&gt; str:
    if match_obj.group("tag") or match_obj.group("passthrough"):
        return ""
    if match_obj.group("entity"):
        if match_obj.group("unicode"):
            base = 10
            if match_obj.group("hex"):
                base = 16
            return chr(int(match_obj.group("content"), base))
        return MarkupText.unescape_markup_char(match_obj.group("entity"))
    return match_obj.group()
</t>
<t tx="ekr.20250121054835.1486">@staticmethod
def get_attr_dict_from_command_pair(
    open_command: re.Match, close_command: re.Match
) -&gt; dict[str, str] | None:
    pattern = r"""
        (?P&lt;attr_name&gt;\w+)
        \s*\=\s*
        (?P&lt;quot&gt;["'])(?P&lt;attr_val&gt;.*?)(?P=quot)
    """
    tag_name = open_command.group("tag_name")
    if tag_name == "span":
        return {
            match_obj.group("attr_name"): match_obj.group("attr_val")
            for match_obj in re.finditer(
                pattern, open_command.group("attr_list"), re.S | re.X
            )
        }
    return MarkupText.MARKUP_TAGS.get(tag_name, {})
</t>
<t tx="ekr.20250121054835.1487">def get_configured_items(self) -&gt; list[tuple[Span, dict[str, str]]]:
    return [
        *(
            (span, {key: val})
            for t2x_dict, key in (
                (self.t2c, "foreground"),
                (self.t2f, "font_family"),
                (self.t2s, "font_style"),
                (self.t2w, "font_weight")
            )
            for selector, val in t2x_dict.items()
            for span in self.find_spans_by_selector(selector)
        ),
        *(
            (span, local_config)
            for selector, local_config in self.local_configs.items()
            for span in self.find_spans_by_selector(selector)
        )
    ]
</t>
<t tx="ekr.20250121054835.1488">@staticmethod
def get_command_string(
    attr_dict: dict[str, str], is_end: bool, label_hex: str | None
) -&gt; str:
    if is_end:
        return "&lt;/span&gt;"

    if label_hex is not None:
        converted_attr_dict = {"foreground": label_hex}
        for key, val in attr_dict.items():
            if key in (
                "background", "bgcolor",
                "underline_color", "overline_color", "strikethrough_color"
            ):
                converted_attr_dict[key] = "black"
            elif key not in ("foreground", "fgcolor", "color"):
                converted_attr_dict[key] = val
    else:
        converted_attr_dict = attr_dict.copy()
    attrs_str = " ".join([
        f"{key}='{val}'"
        for key, val in converted_attr_dict.items()
    ])
    return f"&lt;span {attrs_str}&gt;"
</t>
<t tx="ekr.20250121054835.1489">def get_content_prefix_and_suffix(
    self, is_labelled: bool
) -&gt; tuple[str, str]:
    global_attr_dict = {
        "foreground": color_to_hex(self.base_color),
        "font_family": self.font,
        "font_style": self.slant,
        "font_weight": self.weight,
        "font_size": str(round(self.font_size * 1024)),
    }
    # `line_height` attribute is supported since Pango 1.50.
    pango_version = manimpango.pango_version()
    if tuple(map(int, pango_version.split("."))) &lt; (1, 50):
        if self.lsh is not None:
            log.warning(
                "Pango version %s found (&lt; 1.50), "
                "unable to set `line_height` attribute",
                pango_version
            )
    else:
        line_spacing_scale = self.lsh or DEFAULT_LINE_SPACING_SCALE
        global_attr_dict["line_height"] = str(
            ((line_spacing_scale) + 1) * 0.6
        )
    if self.disable_ligatures:
        global_attr_dict["font_features"] = "liga=0,dlig=0,clig=0,hlig=0"

    global_attr_dict.update(self.global_config)
    return tuple(
        self.get_command_string(
            global_attr_dict,
            is_end=is_end,
            label_hex=int_to_hex(0) if is_labelled else None
        )
        for is_end in (False, True)
    )
</t>
<t tx="ekr.20250121054835.149">@note_undrawn_event
def on_resize(self, width: int, height: int) -&gt; None:
    super().on_resize(width, height)
    if not self.scene:
        return
    self.scene.on_resize(width, height)
</t>
<t tx="ekr.20250121054835.1490"># Method alias

def get_parts_by_text(self, selector: Selector) -&gt; VGroup:
    return self.select_parts(selector)
</t>
<t tx="ekr.20250121054835.1491">def get_part_by_text(self, selector: Selector, **kwargs) -&gt; VGroup:
    return self.select_part(selector, **kwargs)
</t>
<t tx="ekr.20250121054835.1492">def set_color_by_text(self, selector: Selector, color: ManimColor):
    return self.set_parts_color(selector, color)
</t>
<t tx="ekr.20250121054835.1493">def set_color_by_text_to_color_map(
    self, color_map: dict[Selector, ManimColor]
):
    return self.set_parts_color_by_dict(color_map)
</t>
<t tx="ekr.20250121054835.1494">def get_text(self) -&gt; str:
    return self.get_string()
</t>
<t tx="ekr.20250121054835.1495">class Text(MarkupText):
    @others
</t>
<t tx="ekr.20250121054835.1496">def __init__(
    self,
    text: str,
    # For backward compatibility
    isolate: Selector = (re.compile(r"\w+", re.U), re.compile(r"\S+", re.U)),
    use_labelled_svg: bool = True,
    path_string_config: dict = dict(
        use_simple_quadratic_approx=True,
    ),
    **kwargs
</t>
<t tx="ekr.20250121054835.1497">):
    super().__init__(
        text,
        isolate=isolate,
        use_labelled_svg=use_labelled_svg,
        path_string_config=path_string_config,
        **kwargs
    )

@staticmethod
def get_command_matches(string: str) -&gt; list[re.Match]:
    pattern = re.compile(r"""[&lt;&gt;&amp;"']""")
    return list(pattern.finditer(string))
</t>
<t tx="ekr.20250121054835.1498">@staticmethod
def get_command_flag(match_obj: re.Match) -&gt; int:
    return 0
</t>
<t tx="ekr.20250121054835.1499">@staticmethod
def replace_for_content(match_obj: re.Match) -&gt; str:
    return Text.escape_markup_char(match_obj.group())
</t>
<t tx="ekr.20250121054835.15">class CoordinateSystemExample(Scene):
    @others
</t>
<t tx="ekr.20250121054835.150">@note_undrawn_event
def on_show(self) -&gt; None:
    super().on_show()
    if not self.scene:
        return
    self.scene.on_show()
</t>
<t tx="ekr.20250121054835.1500">@staticmethod
def replace_for_matching(match_obj: re.Match) -&gt; str:
    return match_obj.group()
</t>
<t tx="ekr.20250121054835.1501">class Code(MarkupText):
    @others
</t>
<t tx="ekr.20250121054835.1502">def __init__(
    self,
    code: str,
    font: str = "Consolas",
    font_size: int = 24,
    lsh: float = 1.0,
    fill_color: ManimColor = None,
    stroke_color: ManimColor = None,
    language: str = "python",
    # Visit https://pygments.org/demo/ to have a preview of more styles.
    code_style: str = "monokai",
    **kwargs
):
    lexer = pygments.lexers.get_lexer_by_name(language)
    formatter = pygments.formatters.PangoMarkupFormatter(
        style=code_style
    )
    markup = pygments.highlight(code, lexer, formatter)
    markup = re.sub(r"&lt;/?tt&gt;", "", markup)
    super().__init__(
        markup,
        font=font,
        font_size=font_size,
        lsh=lsh,
        stroke_color=stroke_color,
        fill_color=fill_color,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.1503">@contextmanager
def register_font(font_file: str | Path):
    """Temporarily add a font file to Pango's search path.
    This searches for the font_file at various places. The order it searches it described below.
    1. Absolute path.
    2. Downloads dir.

    Parameters
    ----------
    font_file :
        The font file to add.
    Examples
    --------
    Use ``with register_font(...)`` to add a font file to search
    path.
    .. code-block:: python
        with register_font("path/to/font_file.ttf"):
           a = Text("Hello", font="Custom Font Name")
    Raises
    ------
    FileNotFoundError:
        If the font doesn't exists.
    AttributeError:
        If this method is used on macOS.
    Notes
    -----
    This method of adding font files also works with :class:`CairoText`.
    .. important ::
        This method is available for macOS for ``ManimPango&gt;=v0.2.3``. Using this
        method with previous releases will raise an :class:`AttributeError` on macOS.
    """

    file_path = Path(font_file).resolve()
    if not file_path.exists():
        error = f"Can't find {font_file}."
        raise FileNotFoundError(error)
    try:
        assert manimpango.register_font(str(file_path))
        yield
    finally:
        manimpango.unregister_font(str(file_path))
</t>
<t tx="ekr.20250121054835.1504"></t>
<t tx="ekr.20250121054835.1505">@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1506">from __future__ import annotations

import moderngl
import numpy as np

from manimlib.constants import GREY_C, YELLOW
from manimlib.constants import ORIGIN, NULL_POINTS
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.types.point_cloud_mobject import PMobject
from manimlib.utils.iterables import resize_with_interpolation

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import numpy.typing as npt
    from typing import Sequence, Tuple
    from manimlib.typing import ManimColor, Vect3, Vect3Array, Self


DEFAULT_DOT_RADIUS = 0.05
DEFAULT_GLOW_DOT_RADIUS = 0.2
DEFAULT_GRID_HEIGHT = 6
DEFAULT_BUFF_RATIO = 0.5


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1507">class DotCloud(PMobject):
    @others
</t>
<t tx="ekr.20250121054835.1508">shader_folder: str = "true_dot"
render_primitive: int = moderngl.POINTS
data_dtype: Sequence[Tuple[str, type, Tuple[int]]] = [
    ('point', np.float32, (3,)),
    ('radius', np.float32, (1,)),
    ('rgba', np.float32, (4,)),
]

def __init__(
    self,
    points: Vect3Array = NULL_POINTS,
    color: ManimColor = GREY_C,
    opacity: float = 1.0,
    radius: float = DEFAULT_DOT_RADIUS,
    glow_factor: float = 0.0,
    anti_alias_width: float = 2.0,
    **kwargs
):
    self.radius = radius
    self.glow_factor = glow_factor
    self.anti_alias_width = anti_alias_width

    super().__init__(
        color=color,
        opacity=opacity,
        **kwargs
    )
    self.set_radius(self.radius)

    if points is not None:
        self.set_points(points)
</t>
<t tx="ekr.20250121054835.1509">def init_uniforms(self) -&gt; None:
    super().init_uniforms()
    self.uniforms["glow_factor"] = self.glow_factor
    self.uniforms["anti_alias_width"] = self.anti_alias_width
</t>
<t tx="ekr.20250121054835.151">@note_undrawn_event
def on_hide(self) -&gt; None:
    super().on_hide()
    if not self.scene:
        return
    self.scene.on_hide()
</t>
<t tx="ekr.20250121054835.1510">def to_grid(
    self,
    n_rows: int,
    n_cols: int,
    n_layers: int = 1,
    buff_ratio: float | None = None,
    h_buff_ratio: float = 1.0,
    v_buff_ratio: float = 1.0,
    d_buff_ratio: float = 1.0,
    height: float = DEFAULT_GRID_HEIGHT,
) -&gt; Self:
    n_points = n_rows * n_cols * n_layers
    points = np.repeat(range(n_points), 3, axis=0).reshape((n_points, 3))
    points[:, 0] = points[:, 0] % n_cols
    points[:, 1] = (points[:, 1] // n_cols) % n_rows
    points[:, 2] = points[:, 2] // (n_rows * n_cols)
    self.set_points(points.astype(float))

    if buff_ratio is not None:
        v_buff_ratio = buff_ratio
        h_buff_ratio = buff_ratio
        d_buff_ratio = buff_ratio

    radius = self.get_radius()
    ns = [n_cols, n_rows, n_layers]
    brs = [h_buff_ratio, v_buff_ratio, d_buff_ratio]
    self.set_radius(0)
    for n, br, dim in zip(ns, brs, range(3)):
        self.rescale_to_fit(2 * radius * (1 + br) * (n - 1), dim, stretch=True)
    self.set_radius(radius)
    if height is not None:
        self.set_height(height)
    self.center()
    return self
</t>
<t tx="ekr.20250121054835.1511">@Mobject.affects_data
def set_radii(self, radii: npt.ArrayLike) -&gt; Self:
    n_points = self.get_num_points()
    radii = np.array(radii).reshape((len(radii), 1))
    self.data["radius"][:] = resize_with_interpolation(radii, n_points)
    self.refresh_bounding_box()
    return self
</t>
<t tx="ekr.20250121054835.1512">def get_radii(self) -&gt; np.ndarray:
    return self.data["radius"]
</t>
<t tx="ekr.20250121054835.1513">@Mobject.affects_data
def set_radius(self, radius: float) -&gt; Self:
    data = self.data if self.get_num_points() &gt; 0 else self._data_defaults
    data["radius"][:] = radius
    self.refresh_bounding_box()
    return self
</t>
<t tx="ekr.20250121054835.1514">def get_radius(self) -&gt; float:
    return self.get_radii().max()
</t>
<t tx="ekr.20250121054835.1515">def scale_radii(self, scale_factor: float) -&gt; Self:
    self.set_radius(scale_factor * self.get_radii())
    return self
</t>
<t tx="ekr.20250121054835.1516">def set_glow_factor(self, glow_factor: float) -&gt; Self:
    self.uniforms["glow_factor"] = glow_factor
    return self
</t>
<t tx="ekr.20250121054835.1517">def get_glow_factor(self) -&gt; float:
    return self.uniforms["glow_factor"]
</t>
<t tx="ekr.20250121054835.1518">def compute_bounding_box(self) -&gt; Vect3Array:
    bb = super().compute_bounding_box()
    radius = self.get_radius()
    bb[0] += np.full((3,), -radius)
    bb[2] += np.full((3,), radius)
    return bb
</t>
<t tx="ekr.20250121054835.1519">def scale(
    self,
    scale_factor: float | npt.ArrayLike,
    scale_radii: bool = True,
    **kwargs
) -&gt; Self:
    super().scale(scale_factor, **kwargs)
    if scale_radii:
        self.set_radii(scale_factor * self.get_radii())
    return self
</t>
<t tx="ekr.20250121054835.152">@note_undrawn_event
def on_close(self) -&gt; None:
    super().on_close()
    if not self.scene:
        return
    self.scene.on_close()
</t>
<t tx="ekr.20250121054835.1520">def make_3d(
    self,
    reflectiveness: float = 0.5,
    gloss: float = 0.1,
    shadow: float = 0.2
) -&gt; Self:
    self.set_shading(reflectiveness, gloss, shadow)
    self.apply_depth_test()
    return self
</t>
<t tx="ekr.20250121054835.1521">class TrueDot(DotCloud):
    @others
</t>
<t tx="ekr.20250121054835.1522">def __init__(self, center: Vect3 = ORIGIN, **kwargs):
    super().__init__(points=np.array([center]), **kwargs)
</t>
<t tx="ekr.20250121054835.1523">class GlowDots(DotCloud):
    @others
</t>
<t tx="ekr.20250121054835.1524">def __init__(
    self,
    points: Vect3Array = NULL_POINTS,
    color: ManimColor = YELLOW,
    radius: float = DEFAULT_GLOW_DOT_RADIUS,
    glow_factor: float = 2.0,
    **kwargs,
):
    super().__init__(
        points,
        color=color,
        radius=radius,
        glow_factor=glow_factor,
        **kwargs,
    )
</t>
<t tx="ekr.20250121054835.1525">class GlowDot(GlowDots):
    @others
</t>
<t tx="ekr.20250121054835.1526">def __init__(self, center: Vect3 = ORIGIN, **kwargs):
    super().__init__(points=np.array([center]), **kwargs)
</t>
<t tx="ekr.20250121054835.1527">from __future__ import annotations

import numpy as np
import moderngl
from PIL import Image

from manimlib.constants import DL, DR, UL, UR
from manimlib.mobject.mobject import Mobject
from manimlib.utils.bezier import inverse_interpolate
from manimlib.utils.images import get_full_raster_image_path
from manimlib.utils.iterables import listify
from manimlib.utils.iterables import resize_with_interpolation

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Sequence, Tuple
    from manimlib.typing import Vect3


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1528">class ImageMobject(Mobject):
    @others
</t>
<t tx="ekr.20250121054835.1529">shader_folder: str = "image"
data_dtype: Sequence[Tuple[str, type, Tuple[int]]] = [
    ('point', np.float32, (3,)),
    ('im_coords', np.float32, (2,)),
    ('opacity', np.float32, (1,)),
]
render_primitive: int = moderngl.TRIANGLES

def __init__(
    self,
    filename: str,
    height: float = 4.0,
    **kwargs
):
    self.height = height
    self.image_path = get_full_raster_image_path(filename)
    self.image = Image.open(self.image_path)
    super().__init__(texture_paths={"Texture": self.image_path}, **kwargs)
</t>
<t tx="ekr.20250121054835.153">def is_key_pressed(self, symbol: int) -&gt; bool:
    return (symbol in self.pressed_keys)
</t>
<t tx="ekr.20250121054835.1530">def init_data(self) -&gt; None:
    super().init_data(length=6)
    self.data["point"][:] = [UL, DL, UR, DR, UR, DL]
    self.data["im_coords"][:] = [(0, 0), (0, 1), (1, 0), (1, 1), (1, 0), (0, 1)]
    self.data["opacity"][:] = self.opacity
</t>
<t tx="ekr.20250121054835.1531">def init_points(self) -&gt; None:
    size = self.image.size
    self.set_width(2 * size[0] / size[1], stretch=True)
    self.set_height(self.height)
</t>
<t tx="ekr.20250121054835.1532">@Mobject.affects_data
def set_opacity(self, opacity: float, recurse: bool = True):
    self.data["opacity"][:, 0] = resize_with_interpolation(
        np.array(listify(opacity)),
        self.get_num_points()
    )
    return self
</t>
<t tx="ekr.20250121054835.1533">def set_color(self, color, opacity=None, recurse=None):
    return self
</t>
<t tx="ekr.20250121054835.1534">def point_to_rgb(self, point: Vect3) -&gt; Vect3:
    x0, y0 = self.get_corner(UL)[:2]
    x1, y1 = self.get_corner(DR)[:2]
    x_alpha = inverse_interpolate(x0, x1, point[0])
    y_alpha = inverse_interpolate(y0, y1, point[1])
    if not (0 &lt;= x_alpha &lt;= 1) and (0 &lt;= y_alpha &lt;= 1):
        # TODO, raise smarter exception
        raise Exception("Cannot sample color from outside an image")

    pw, ph = self.image.size
    rgb = self.image.getpixel((
        int((pw - 1) * x_alpha),
        int((ph - 1) * y_alpha),
    ))[:3]
    return np.array(rgb) / 255
</t>
<t tx="ekr.20250121054835.1535">from __future__ import annotations

import numpy as np

from manimlib.mobject.mobject import Mobject
from manimlib.utils.color import color_gradient
from manimlib.utils.color import color_to_rgba
from manimlib.utils.iterables import resize_with_interpolation

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable
    from manimlib.typing import ManimColor, Vect3, Vect3Array, Vect4Array, Self


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1536">class PMobject(Mobject):
    @others
</t>
<t tx="ekr.20250121054835.1537">def set_points(self, points: Vect3Array):
    if len(points) == 0:
        points = np.zeros((0, 3))
    super().set_points(points)
    self.resize_points(len(points))
    return self
</t>
<t tx="ekr.20250121054835.1538">def add_points(
    self,
    points: Vect3Array,
    rgbas: Vect4Array | None = None,
    color: ManimColor | None = None,
    opacity: float | None = None
) -&gt; Self:
    """
    points must be a Nx3 numpy array, as must rgbas if it is not None
    """
    self.append_points(points)
    # rgbas array will have been resized with points
    if color is not None:
        if opacity is None:
            opacity = self.data["rgba"][-1, 3]
        rgbas = np.repeat(
            [color_to_rgba(color, opacity)],
            len(points),
            axis=0
        )
    if rgbas is not None:
        self.data["rgba"][-len(rgbas):] = rgbas
    return self
</t>
<t tx="ekr.20250121054835.1539">def add_point(self, point: Vect3, rgba=None, color=None, opacity=None) -&gt; Self:
    rgbas = None if rgba is None else [rgba]
    self.add_points([point], rgbas, color, opacity)
    return self
</t>
<t tx="ekr.20250121054835.154"></t>
<t tx="ekr.20250121054835.1540">@Mobject.affects_data
def set_color_by_gradient(self, *colors: ManimColor) -&gt; Self:
    self.data["rgba"][:] = np.array(list(map(
        color_to_rgba,
        color_gradient(colors, self.get_num_points())
    )))
    return self
</t>
<t tx="ekr.20250121054835.1541">@Mobject.affects_data
def match_colors(self, pmobject: PMobject) -&gt; Self:
    self.data["rgba"][:] = resize_with_interpolation(
        pmobject.data["rgba"], self.get_num_points()
    )
    return self
</t>
<t tx="ekr.20250121054835.1542">@Mobject.affects_data
def filter_out(self, condition: Callable[[np.ndarray], bool]) -&gt; Self:
    for mob in self.family_members_with_points():
        mob.data = mob.data[~np.apply_along_axis(condition, 1, mob.get_points())]
    return self
</t>
<t tx="ekr.20250121054835.1543">@Mobject.affects_data
def sort_points(self, function: Callable[[Vect3], None] = lambda p: p[0]) -&gt; Self:
    """
    function is any map from R^3 to R
    """
    for mob in self.family_members_with_points():
        indices = np.argsort(
            np.apply_along_axis(function, 1, mob.get_points())
        )
        mob.data[:] = mob.data[indices]
    return self
</t>
<t tx="ekr.20250121054835.1544">@Mobject.affects_data
def ingest_submobjects(self) -&gt; Self:
    self.data = np.vstack([
        sm.data for sm in self.get_family()
    ])
    return self
</t>
<t tx="ekr.20250121054835.1545">def point_from_proportion(self, alpha: float) -&gt; np.ndarray:
    index = alpha * (self.get_num_points() - 1)
    return self.get_points()[int(index)]
</t>
<t tx="ekr.20250121054835.1546">@Mobject.affects_data
def pointwise_become_partial(self, pmobject: PMobject, a: float, b: float) -&gt; Self:
    lower_index = int(a * pmobject.get_num_points())
    upper_index = int(b * pmobject.get_num_points())
    self.data = pmobject.data[lower_index:upper_index].copy()
    return self
</t>
<t tx="ekr.20250121054835.1547">class PGroup(PMobject):
    @others
</t>
<t tx="ekr.20250121054835.1548">def __init__(self, *pmobs: PMobject, **kwargs):
    if not all([isinstance(m, PMobject) for m in pmobs]):
        raise Exception("All submobjects must be of type PMobject")
    super().__init__(**kwargs)
    self.add(*pmobs)
</t>
<t tx="ekr.20250121054835.1549">from __future__ import annotations

import moderngl
import numpy as np

from manimlib.constants import GREY
from manimlib.constants import OUT
from manimlib.mobject.mobject import Mobject
from manimlib.utils.bezier import integer_interpolate
from manimlib.utils.bezier import interpolate
from manimlib.utils.bezier import inverse_interpolate
from manimlib.utils.images import get_full_raster_image_path
from manimlib.utils.iterables import listify
from manimlib.utils.iterables import resize_with_interpolation
from manimlib.utils.simple_functions import clip
from manimlib.utils.space_ops import normalize_along_axis
from manimlib.utils.space_ops import cross

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, Iterable, Sequence, Tuple

    from manimlib.camera.camera import Camera
    from manimlib.typing import ManimColor, Vect3, Vect3Array, Self


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.155">@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1550">class Surface(Mobject):
    @others
</t>
<t tx="ekr.20250121054835.1551">render_primitive: int = moderngl.TRIANGLES
shader_folder: str = "surface"
data_dtype: np.dtype = np.dtype([
    ('point', np.float32, (3,)),
    ('du_point', np.float32, (3,)),
    ('dv_point', np.float32, (3,)),
    ('rgba', np.float32, (4,)),
])
pointlike_data_keys = ['point', 'du_point', 'dv_point']

def __init__(
    self,
    color: ManimColor = GREY,
    shading: Tuple[float, float, float] = (0.3, 0.2, 0.4),
    depth_test: bool = True,
    u_range: Tuple[float, float] = (0.0, 1.0),
    v_range: Tuple[float, float] = (0.0, 1.0),
    # Resolution counts number of points sampled, which for
    # each coordinate is one more than the the number of
    # rows/columns of approximating squares
    resolution: Tuple[int, int] = (101, 101),
    prefered_creation_axis: int = 1,
    # For du and dv steps.  Much smaller and numerical error
    # can crop up in the shaders.
    epsilon: float = 1e-4,
    **kwargs
</t>
<t tx="ekr.20250121054835.1552">):
    self.u_range = u_range
    self.v_range = v_range
    self.resolution = resolution
    self.prefered_creation_axis = prefered_creation_axis
    self.epsilon = epsilon

    super().__init__(
        **kwargs,
        color=color,
        shading=shading,
        depth_test=depth_test,
    )
    self.compute_triangle_indices()

def uv_func(self, u: float, v: float) -&gt; tuple[float, float, float]:
    # To be implemented in subclasses
    return (u, v, 0.0)
</t>
<t tx="ekr.20250121054835.1553">@Mobject.affects_data
def init_points(self):
    dim = self.dim
    nu, nv = self.resolution
    u_range = np.linspace(*self.u_range, nu)
    v_range = np.linspace(*self.v_range, nv)

    # Get three lists:
    # - Points generated by pure uv values
    # - Those generated by values nudged by du
    # - Those generated by values nudged by dv
    uv_grid = np.array([[[u, v] for v in v_range] for u in u_range])
    uv_plus_du = uv_grid.copy()
    uv_plus_du[:, :, 0] += self.epsilon
    uv_plus_dv = uv_grid.copy()
    uv_plus_dv[:, :, 1] += self.epsilon

    points, du_points, dv_points = [
        np.apply_along_axis(
            lambda p: self.uv_func(*p), 2, grid
        ).reshape((nu * nv, dim))
        for grid in (uv_grid, uv_plus_du, uv_plus_dv)
    ]
    self.set_points(points)
    self.data['du_point'][:] = du_points
    self.data['dv_point'][:] = dv_points
</t>
<t tx="ekr.20250121054835.1554">def uv_to_point(self, u, v):
    nu, nv = self.resolution
    uv_grid = np.reshape(self.get_points(), (nu, nv, self.dim))

    alpha1 = clip(inverse_interpolate(*self.u_range[:2], u), 0, 1)
    alpha2 = clip(inverse_interpolate(*self.v_range[:2], v), 0, 1)
    scaled_u = alpha1 * (nu - 1)
    scaled_v = alpha2 * (nv - 1)
    u_int = int(scaled_u)
    v_int = int(scaled_v)
    u_int_plus = min(u_int + 1, nu - 1)
    v_int_plus = min(v_int + 1, nv - 1)

    a = uv_grid[u_int, v_int, :]
    b = uv_grid[u_int, v_int_plus, :]
    c = uv_grid[u_int_plus, v_int, :]
    d = uv_grid[u_int_plus, v_int_plus, :]

    u_res = scaled_u % 1
    v_res = scaled_v % 1
    return interpolate(
        interpolate(a, b, v_res),
        interpolate(c, d, v_res),
        u_res
    )
</t>
<t tx="ekr.20250121054835.1555">def apply_points_function(self, *args, **kwargs) -&gt; Self:
    super().apply_points_function(*args, **kwargs)
    self.get_unit_normals()
    return self
</t>
<t tx="ekr.20250121054835.1556">def compute_triangle_indices(self) -&gt; np.ndarray:
    # TODO, if there is an event which changes
    # the resolution of the surface, make sure
    # this is called.
    nu, nv = self.resolution
    if nu == 0 or nv == 0:
        self.triangle_indices = np.zeros(0, dtype=int)
        return self.triangle_indices
    index_grid = np.arange(nu * nv).reshape((nu, nv))
    indices = np.zeros(6 * (nu - 1) * (nv - 1), dtype=int)
    indices[0::6] = index_grid[:-1, :-1].flatten()  # Top left
    indices[1::6] = index_grid[+1:, :-1].flatten()  # Bottom left
    indices[2::6] = index_grid[:-1, +1:].flatten()  # Top right
    indices[3::6] = index_grid[:-1, +1:].flatten()  # Top right
    indices[4::6] = index_grid[+1:, :-1].flatten()  # Bottom left
    indices[5::6] = index_grid[+1:, +1:].flatten()  # Bottom right
    self.triangle_indices = indices
    return self.triangle_indices
</t>
<t tx="ekr.20250121054835.1557">def get_triangle_indices(self) -&gt; np.ndarray:
    return self.triangle_indices
</t>
<t tx="ekr.20250121054835.1558">def get_unit_normals(self) -&gt; Vect3Array:
    points = self.get_points()
    crosses = cross(
        self.data['du_point'] - points,
        self.data['dv_point'] - points,
    )
    return normalize_along_axis(crosses, 1)
</t>
<t tx="ekr.20250121054835.1559">@Mobject.affects_data
def pointwise_become_partial(
    self,
    smobject: "Surface",
    a: float,
    b: float,
    axis: int | None = None
) -&gt; Self:
    assert isinstance(smobject, Surface)
    if axis is None:
        axis = self.prefered_creation_axis
    if a &lt;= 0 and b &gt;= 1:
        self.match_points(smobject)
        return self

    nu, nv = smobject.resolution
    self.data['point'][:] = self.get_partial_points_array(
        smobject.data['point'], a, b,
        (nu, nv, 3),
        axis=axis
    )
    return self
</t>
<t tx="ekr.20250121054835.156">from __future__ import annotations

from copy import deepcopy

from manimlib.mobject.mobject import _AnimationBuilder
from manimlib.mobject.mobject import Mobject
from manimlib.utils.iterables import remove_list_redundancies
from manimlib.utils.rate_functions import smooth
from manimlib.utils.simple_functions import clip

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable

    from manimlib.scene.scene import Scene


DEFAULT_ANIMATION_RUN_TIME = 1.0
DEFAULT_ANIMATION_LAG_RATIO = 0


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1560">def get_partial_points_array(
    self,
    points: Vect3Array,
    a: float,
    b: float,
    resolution: Sequence[int],
    axis: int
) -&gt; Vect3Array:
    if len(points) == 0:
        return points
    nu, nv = resolution[:2]
    points = points.reshape(resolution).copy()
    max_index = resolution[axis] - 1
    lower_index, lower_residue = integer_interpolate(0, max_index, a)
    upper_index, upper_residue = integer_interpolate(0, max_index, b)
    if axis == 0:
        points[:lower_index] = interpolate(
            points[lower_index],
            points[lower_index + 1],
            lower_residue
        )
        points[upper_index + 1:] = interpolate(
            points[upper_index],
            points[upper_index + 1],
            upper_residue
        )
    else:
        shape = (nu, 1, resolution[2])
        points[:, :lower_index] = interpolate(
            points[:, lower_index],
            points[:, lower_index + 1],
            lower_residue
        ).reshape(shape)
        points[:, upper_index + 1:] = interpolate(
            points[:, upper_index],
            points[:, upper_index + 1],
            upper_residue
        ).reshape(shape)
    return points.reshape((nu * nv, *resolution[2:]))
</t>
<t tx="ekr.20250121054835.1561">@Mobject.affects_data
def sort_faces_back_to_front(self, vect: Vect3 = OUT) -&gt; Self:
    tri_is = self.triangle_indices
    points = self.get_points()

    dots = (points[tri_is[::3]] * vect).sum(1)
    indices = np.argsort(dots)
    for k in range(3):
        tri_is[k::3] = tri_is[k::3][indices]
    return self
</t>
<t tx="ekr.20250121054835.1562">def always_sort_to_camera(self, camera: Camera) -&gt; Self:
    def updater(surface: Surface):
        vect = camera.get_location() - surface.get_center()
        surface.sort_faces_back_to_front(vect)
    self.add_updater(updater)
    return self
</t>
<t tx="ekr.20250121054835.1563">def get_shader_vert_indices(self) -&gt; np.ndarray:
    return self.get_triangle_indices()
</t>
<t tx="ekr.20250121054835.1564">class ParametricSurface(Surface):
    @others
</t>
<t tx="ekr.20250121054835.1565">def __init__(
    self,
    uv_func: Callable[[float, float], Iterable[float]],
    u_range: tuple[float, float] = (0, 1),
    v_range: tuple[float, float] = (0, 1),
    **kwargs
</t>
<t tx="ekr.20250121054835.1566">):
    self.passed_uv_func = uv_func
    super().__init__(u_range=u_range, v_range=v_range, **kwargs)

def uv_func(self, u, v):
    return self.passed_uv_func(u, v)
</t>
<t tx="ekr.20250121054835.1567">class SGroup(Surface):
    @others
</t>
<t tx="ekr.20250121054835.1568">def __init__(
    self,
    *parametric_surfaces: Surface,
    **kwargs
):
    super().__init__(resolution=(0, 0), **kwargs)
    self.add(*parametric_surfaces)
</t>
<t tx="ekr.20250121054835.1569">def init_points(self):
    pass  # Needed?
</t>
<t tx="ekr.20250121054835.157">class Animation(object):
    @others
</t>
<t tx="ekr.20250121054835.1570">class TexturedSurface(Surface):
    @others
</t>
<t tx="ekr.20250121054835.1571">shader_folder: str = "textured_surface"
data_dtype: Sequence[Tuple[str, type, Tuple[int]]] = [
    ('point', np.float32, (3,)),
    ('du_point', np.float32, (3,)),
    ('dv_point', np.float32, (3,)),
    ('im_coords', np.float32, (2,)),
    ('opacity', np.float32, (1,)),
]

def __init__(
    self,
    uv_surface: Surface,
    image_file: str,
    dark_image_file: str | None = None,
    **kwargs
):
    if not isinstance(uv_surface, Surface):
        raise Exception("uv_surface must be of type Surface")
    # Set texture information
    if dark_image_file is None:
        dark_image_file = image_file
        self.num_textures = 1
    else:
        self.num_textures = 2

    texture_paths = {
        "LightTexture": get_full_raster_image_path(image_file),
        "DarkTexture": get_full_raster_image_path(dark_image_file),
    }

    self.uv_surface = uv_surface
    self.uv_func = uv_surface.uv_func
    self.u_range: Tuple[float, float] = uv_surface.u_range
    self.v_range: Tuple[float, float] = uv_surface.v_range
    self.resolution: Tuple[int, int] = uv_surface.resolution
    super().__init__(
        texture_paths=texture_paths,
        shading=tuple(uv_surface.shading),
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.1572">@Mobject.affects_data
def init_points(self):
    surf = self.uv_surface
    nu, nv = surf.resolution
    self.resize_points(surf.get_num_points())
    self.resolution = surf.resolution
    self.data['point'][:] = surf.data['point']
    self.data['du_point'][:] = surf.data['du_point']
    self.data['dv_point'][:] = surf.data['dv_point']
    self.data['opacity'][:, 0] = surf.data["rgba"][:, 3]
    self.data["im_coords"] = np.array([
        [u, v]
        for u in np.linspace(0, 1, nu)
        for v in np.linspace(1, 0, nv)  # Reverse y-direction
    ])
</t>
<t tx="ekr.20250121054835.1573">def init_uniforms(self):
    super().init_uniforms()
    self.uniforms["num_textures"] = self.num_textures
</t>
<t tx="ekr.20250121054835.1574">@Mobject.affects_data
def set_opacity(self, opacity: float | Iterable[float], recurse=True) -&gt; Self:
    op_arr = np.array(listify(opacity))
    self.data["opacity"][:, 0] = resize_with_interpolation(op_arr, len(self.data))
    return self
</t>
<t tx="ekr.20250121054835.1575">def set_color(
    self,
    color: ManimColor | Iterable[ManimColor] | None,
    opacity: float | Iterable[float] | None = None,
    recurse: bool = True
) -&gt; Self:
    if opacity is not None:
        self.set_opacity(opacity)
    return self
</t>
<t tx="ekr.20250121054835.1576">def pointwise_become_partial(
    self,
    tsmobject: "TexturedSurface",
    a: float,
    b: float,
    axis: int = 1
) -&gt; Self:
    super().pointwise_become_partial(tsmobject, a, b, axis)
    im_coords = self.data["im_coords"]
    im_coords[:] = tsmobject.data["im_coords"]
    if a &lt;= 0 and b &gt;= 1:
        return self
    nu, nv = tsmobject.resolution
    im_coords[:] = self.get_partial_points_array(
        im_coords, a, b, (nu, nv, 2), axis
    )
    return self
</t>
<t tx="ekr.20250121054835.1577">from __future__ import annotations

from functools import wraps

import numpy as np

from manimlib.constants import GREY_A, GREY_C, GREY_E
from manimlib.constants import BLACK
from manimlib.constants import DEFAULT_STROKE_WIDTH
from manimlib.constants import DEG
from manimlib.constants import ORIGIN, OUT
from manimlib.constants import PI
from manimlib.constants import TAU
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.mobject import Group
from manimlib.mobject.mobject import Point
from manimlib.utils.bezier import bezier
from manimlib.utils.bezier import get_quadratic_approximation_of_cubic
from manimlib.utils.bezier import approx_smooth_quadratic_bezier_handles
from manimlib.utils.bezier import smooth_quadratic_path
from manimlib.utils.bezier import interpolate
from manimlib.utils.bezier import integer_interpolate
from manimlib.utils.bezier import inverse_interpolate
from manimlib.utils.bezier import find_intersection
from manimlib.utils.bezier import outer_interpolate
from manimlib.utils.bezier import partial_quadratic_bezier_points
from manimlib.utils.bezier import quadratic_bezier_points_for_arc
from manimlib.utils.color import color_gradient
from manimlib.utils.color import rgb_to_hex
from manimlib.utils.iterables import make_even
from manimlib.utils.iterables import resize_array
from manimlib.utils.iterables import resize_with_interpolation
from manimlib.utils.iterables import resize_preserving_order
from manimlib.utils.space_ops import angle_between_vectors
from manimlib.utils.space_ops import cross2d
from manimlib.utils.space_ops import earclip_triangulation
from manimlib.utils.space_ops import get_norm
from manimlib.utils.space_ops import get_unit_normal
from manimlib.utils.space_ops import line_intersects_path
from manimlib.utils.space_ops import midpoint
from manimlib.utils.space_ops import rotation_between_vectors
from manimlib.utils.space_ops import rotation_matrix_transpose
from manimlib.utils.space_ops import poly_line_length
from manimlib.utils.space_ops import z_to_vector
from manimlib.shader_wrapper import VShaderWrapper

from typing import TYPE_CHECKING
from typing import Generic, TypeVar, Iterable
SubVmobjectType = TypeVar('SubVmobjectType', bound='VMobject')

if TYPE_CHECKING:
    from typing import Callable, Tuple, Any, Optional
    from manimlib.typing import ManimColor, Vect3, Vect4, Vect3Array, Self
    from moderngl.context import Context

DEFAULT_STROKE_COLOR = GREY_A
DEFAULT_FILL_COLOR = GREY_C


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1578">class VMobject(Mobject):
    @others
</t>
<t tx="ekr.20250121054835.1579">data_dtype: np.dtype = np.dtype([
    ('point', np.float32, (3,)),
    ('stroke_rgba', np.float32, (4,)),
    ('stroke_width', np.float32, (1,)),
    ('joint_angle', np.float32, (1,)),
    ('fill_rgba', np.float32, (4,)),
    ('base_normal', np.float32, (3,)),  # Base points and unit normal vectors are interleaved in this array
    ('fill_border_width', np.float32, (1,)),
])
pre_function_handle_to_anchor_scale_factor: float = 0.01
make_smooth_after_applying_functions: bool = False
# TODO, do we care about accounting for varying zoom levels?
tolerance_for_point_equality: float = 1e-8
joint_type_map: dict = {
    "no_joint": 0,
    "auto": 1,
    "bevel": 2,
    "miter": 3,
}

def __init__(
    self,
    color: ManimColor = None,  # If set, this will override stroke_color and fill_color
    fill_color: ManimColor = None,
    fill_opacity: float | Iterable[float] | None = 0.0,
    stroke_color: ManimColor = None,
    stroke_opacity: float | Iterable[float] | None = 1.0,
    stroke_width: float | Iterable[float] | None = DEFAULT_STROKE_WIDTH,
    stroke_behind: bool = False,
    background_image_file: str | None = None,
    long_lines: bool = False,
    # Could also be "no_joint", "bevel", "miter"
    joint_type: str = "auto",
    flat_stroke: bool = False,
    scale_stroke_with_zoom: bool = False,
    use_simple_quadratic_approx: bool = False,
    # Measured in pixel widths
    anti_alias_width: float = 1.5,
    fill_border_width: float = 0.0,
    **kwargs
):
    self.fill_color = fill_color or color or DEFAULT_FILL_COLOR
    self.fill_opacity = fill_opacity
    self.stroke_color = stroke_color or color or DEFAULT_STROKE_COLOR
    self.stroke_opacity = stroke_opacity
    self.stroke_width = stroke_width
    self.stroke_behind = stroke_behind
    self.background_image_file = background_image_file
    self.long_lines = long_lines
    self.joint_type = joint_type
    self.flat_stroke = flat_stroke
    self.scale_stroke_with_zoom = scale_stroke_with_zoom
    self.use_simple_quadratic_approx = use_simple_quadratic_approx
    self.anti_alias_width = anti_alias_width
    self.fill_border_width = fill_border_width

    self.needs_new_joint_angles = True
    self.needs_new_unit_normal = True
    self.subpath_end_indices = None
    self.outer_vert_indices = np.zeros(0, dtype=int)

    super().__init__(**kwargs)
</t>
<t tx="ekr.20250121054835.158">def __init__(
    self,
    mobject: Mobject,
    run_time: float = DEFAULT_ANIMATION_RUN_TIME,
    # Tuple of times, between which the animation will run
    time_span: tuple[float, float] | None = None,
    # If 0, the animation is applied to all submobjects at the same time
    # If 1, it is applied to each successively.
    # If 0 &lt; lag_ratio &lt; 1, its applied to each with lagged start times
    lag_ratio: float = DEFAULT_ANIMATION_LAG_RATIO,
    rate_func: Callable[[float], float] = smooth,
    name: str = "",
    # Does this animation add or remove a mobject form the screen
    remover: bool = False,
    # What to enter into the update function upon completion
    final_alpha_value: float = 1.0,
    # If set to True, the mobject itself will have its internal updaters called,
    # but the start or target mobjects would not be suspended. To completely suspend
    # updating, call mobject.suspend_updating() before the animation
    suspend_mobject_updating: bool = False,
):
    self.mobject = mobject
    self.run_time = run_time
    self.time_span = time_span
    self.rate_func = rate_func
    self.name = name or self.__class__.__name__ + str(self.mobject)
    self.remover = remover
    self.final_alpha_value = final_alpha_value
    self.lag_ratio = lag_ratio
    self.suspend_mobject_updating = suspend_mobject_updating

    assert isinstance(mobject, Mobject)
</t>
<t tx="ekr.20250121054835.1580">def get_group_class(self):
    return VGroup
</t>
<t tx="ekr.20250121054835.1581">def init_uniforms(self):
    super().init_uniforms()
    self.uniforms.update(
        anti_alias_width=self.anti_alias_width,
        joint_type=self.joint_type_map[self.joint_type],
        flat_stroke=float(self.flat_stroke),
        scale_stroke_with_zoom=float(self.scale_stroke_with_zoom)
    )
</t>
<t tx="ekr.20250121054835.1582">def add(self, *vmobjects: VMobject) -&gt; Self:
    if not all((isinstance(m, VMobject) for m in vmobjects)):
        raise Exception("All submobjects must be of type VMobject")
    return super().add(*vmobjects)
</t>
<t tx="ekr.20250121054835.1583"># Colors
def init_colors(self):
    self.set_stroke(
        color=self.stroke_color,
        width=self.stroke_width,
        opacity=self.stroke_opacity,
        behind=self.stroke_behind,
    )
    self.set_fill(
        color=self.fill_color,
        opacity=self.fill_opacity,
        border_width=self.fill_border_width,
    )
    self.set_shading(*self.shading)
    self.set_flat_stroke(self.flat_stroke)
    self.color = self.get_color()
    return self
</t>
<t tx="ekr.20250121054835.1584">def set_fill(
    self,
    color: ManimColor | Iterable[ManimColor] = None,
    opacity: float | Iterable[float] | None = None,
    border_width: float | None = None,
    recurse: bool = True
) -&gt; Self:
    self.set_rgba_array_by_color(color, opacity, 'fill_rgba', recurse)
    if border_width is not None:
        self.border_width = border_width
        for mob in self.get_family(recurse):
            data = mob.data if mob.has_points() &gt; 0 else mob._data_defaults
            data["fill_border_width"] = border_width
    return self
</t>
<t tx="ekr.20250121054835.1585">def set_stroke(
    self,
    color: ManimColor | Iterable[ManimColor] = None,
    width: float | Iterable[float] | None = None,
    opacity: float | Iterable[float] | None = None,
    behind: bool | None = None,
    flat: bool | None = None,
    recurse: bool = True
) -&gt; Self:
    self.set_rgba_array_by_color(color, opacity, 'stroke_rgba', recurse)

    if width is not None:
        for mob in self.get_family(recurse):
            data = mob.data if mob.get_num_points() &gt; 0 else mob._data_defaults
            if isinstance(width, (float, int)):
                data['stroke_width'][:, 0] = width
            else:
                data['stroke_width'][:, 0] = resize_with_interpolation(
                    np.array(width), len(data)
                ).flatten()

    if behind is not None:
        for mob in self.get_family(recurse):
            if mob.stroke_behind != behind:
                mob.stroke_behind = behind
                mob.refresh_shader_wrapper_id()

    if flat is not None:
        self.set_flat_stroke(flat)

    return self
</t>
<t tx="ekr.20250121054835.1586">def set_backstroke(
    self,
    color: ManimColor | Iterable[ManimColor] = BLACK,
    width: float | Iterable[float] = 3,
) -&gt; Self:
    self.set_stroke(color, width, behind=True)
    return self
</t>
<t tx="ekr.20250121054835.1587">@Mobject.affects_family_data
def set_style(
    self,
    fill_color: ManimColor | Iterable[ManimColor] | None = None,
    fill_opacity: float | Iterable[float] | None = None,
    fill_rgba: Vect4 | None = None,
    fill_border_width: float | None = None,
    stroke_color: ManimColor | Iterable[ManimColor] | None = None,
    stroke_opacity: float | Iterable[float] | None = None,
    stroke_rgba: Vect4 | None = None,
    stroke_width: float | Iterable[float] | None = None,
    stroke_behind: bool | None = None,
    flat_stroke: Optional[bool] = None,
    shading: Tuple[float, float, float] | None = None,
    recurse: bool = True
) -&gt; Self:
    for mob in self.get_family(recurse):
        if fill_rgba is not None:
            mob.data['fill_rgba'][:] = resize_with_interpolation(fill_rgba, len(mob.data['fill_rgba']))
        else:
            mob.set_fill(
                color=fill_color,
                opacity=fill_opacity,
                border_width=fill_border_width,
                recurse=False
            )

        if stroke_rgba is not None:
            mob.data['stroke_rgba'][:] = resize_with_interpolation(stroke_rgba, len(mob.data['stroke_rgba']))
            mob.set_stroke(
                width=stroke_width,
                behind=stroke_behind,
                flat=flat_stroke,
                recurse=False,
            )
        else:
            mob.set_stroke(
                color=stroke_color,
                width=stroke_width,
                opacity=stroke_opacity,
                flat=flat_stroke,
                behind=stroke_behind,
                recurse=False,
            )

        if shading is not None:
            mob.set_shading(*shading, recurse=False)
    return self
</t>
<t tx="ekr.20250121054835.1588">def get_style(self) -&gt; dict[str, Any]:
    data = self.data if self.get_num_points() &gt; 0 else self._data_defaults
    return {
        "fill_rgba": data['fill_rgba'].copy(),
        "fill_border_width": data['fill_border_width'].copy(),
        "stroke_rgba": data['stroke_rgba'].copy(),
        "stroke_width": data['stroke_width'].copy(),
        "stroke_behind": self.stroke_behind,
        "flat_stroke": self.get_flat_stroke(),
        "shading": self.get_shading(),
    }
</t>
<t tx="ekr.20250121054835.1589">def match_style(self, vmobject: VMobject, recurse: bool = True) -&gt; Self:
    self.set_style(**vmobject.get_style(), recurse=False)
    if recurse:
        # Does its best to match up submobject lists, and
        # match styles accordingly
        submobs1, submobs2 = self.submobjects, vmobject.submobjects
        if len(submobs1) == 0:
            return self
        elif len(submobs2) == 0:
            submobs2 = [vmobject]
        for sm1, sm2 in zip(*make_even(submobs1, submobs2)):
            sm1.match_style(sm2)
    return self
</t>
<t tx="ekr.20250121054835.159">def __str__(self) -&gt; str:
    return self.name
</t>
<t tx="ekr.20250121054835.1590">def set_color(
    self,
    color: ManimColor | Iterable[ManimColor] | None,
    opacity: float | Iterable[float] | None = None,
    recurse: bool = True
) -&gt; Self:
    self.set_fill(color, opacity=opacity, recurse=recurse)
    self.set_stroke(color, opacity=opacity, recurse=recurse)
    return self
</t>
<t tx="ekr.20250121054835.1591">def set_opacity(
    self,
    opacity: float | Iterable[float] | None,
    recurse: bool = True
) -&gt; Self:
    self.set_fill(opacity=opacity, recurse=recurse)
    self.set_stroke(opacity=opacity, recurse=recurse)
    return self
</t>
<t tx="ekr.20250121054835.1592">def set_anti_alias_width(self, anti_alias_width: float, recurse: bool = True) -&gt; Self:
    self.set_uniform(recurse, anti_alias_width=anti_alias_width)
    return self
</t>
<t tx="ekr.20250121054835.1593">def fade(self, darkness: float = 0.5, recurse: bool = True) -&gt; Self:
    mobs = self.get_family() if recurse else [self]
    for mob in mobs:
        factor = 1.0 - darkness
        mob.set_fill(
            opacity=factor * mob.get_fill_opacity(),
            recurse=False,
        )
        mob.set_stroke(
            opacity=factor * mob.get_stroke_opacity(),
            recurse=False,
        )
    return self
</t>
<t tx="ekr.20250121054835.1594">def get_fill_colors(self) -&gt; list[str]:
    return [
        rgb_to_hex(rgba[:3])
        for rgba in self.data['fill_rgba']
    ]
</t>
<t tx="ekr.20250121054835.1595">def get_fill_opacities(self) -&gt; np.ndarray:
    return self.data['fill_rgba'][:, 3]
</t>
<t tx="ekr.20250121054835.1596">def get_stroke_colors(self) -&gt; list[str]:
    return [
        rgb_to_hex(rgba[:3])
        for rgba in self.data['stroke_rgba']
    ]
</t>
<t tx="ekr.20250121054835.1597">def get_stroke_opacities(self) -&gt; np.ndarray:
    return self.data['stroke_rgba'][:, 3]
</t>
<t tx="ekr.20250121054835.1598">def get_stroke_widths(self) -&gt; np.ndarray:
    return self.data['stroke_width'][:, 0]
</t>
<t tx="ekr.20250121054835.1599"># TODO, it's weird for these to return the first of various lists
# rather than the full information
def get_fill_color(self) -&gt; str:
    """
    If there are multiple colors (for gradient)
    this returns the first one
    """
    data = self.data if self.has_points() else self._data_defaults
    return rgb_to_hex(data["fill_rgba"][0, :3])
</t>
<t tx="ekr.20250121054835.16">def construct(self):
    axes = Axes(
        # x-axis ranges from -1 to 10, with a default step size of 1
        x_range=(-1, 10),
        # y-axis ranges from -2 to 2 with a step size of 0.5
        y_range=(-2, 2, 0.5),
        # The axes will be stretched so as to match the specified
        # height and width
        height=6,
        width=10,
        # Axes is made of two NumberLine mobjects.  You can specify
        # their configuration with axis_config
        axis_config=dict(
            stroke_color=GREY_A,
            stroke_width=2,
            numbers_to_exclude=[0],
        ),
        # Alternatively, you can specify configuration for just one
        # of them, like this.
        y_axis_config=dict(
            big_tick_numbers=[-2, 2],
        )
    )
    # Keyword arguments of add_coordinate_labels can be used to
    # configure the DecimalNumber mobjects which it creates and
    # adds to the axes
    axes.add_coordinate_labels(
        font_size=20,
        num_decimal_places=1,
    )
    self.add(axes)

    # Axes descends from the CoordinateSystem class, meaning
    # you can call call axes.coords_to_point, abbreviated to
    # axes.c2p, to associate a set of coordinates with a point,
    # like so:
    dot = Dot(color=RED)
    dot.move_to(axes.c2p(0, 0))
    self.play(FadeIn(dot, scale=0.5))
    self.play(dot.animate.move_to(axes.c2p(3, 2)))
    self.wait()
    self.play(dot.animate.move_to(axes.c2p(5, 0.5)))
    self.wait()

    # Similarly, you can call axes.point_to_coords, or axes.p2c
    # print(axes.p2c(dot.get_center()))

    # We can draw lines from the axes to better mark the coordinates
    # of a given point.
    # Here, the always_redraw command means that on each new frame
    # the lines will be redrawn
    h_line = always_redraw(lambda: axes.get_h_line(dot.get_left()))
    v_line = always_redraw(lambda: axes.get_v_line(dot.get_bottom()))

    self.play(
        ShowCreation(h_line),
        ShowCreation(v_line),
    )
    self.play(dot.animate.move_to(axes.c2p(3, -2)))
    self.wait()
    self.play(dot.animate.move_to(axes.c2p(1, 1)))
    self.wait()

    # If we tie the dot to a particular set of coordinates, notice
    # that as we move the axes around it respects the coordinate
    # system defined by them.
    f_always(dot.move_to, lambda: axes.c2p(1, 1))
    self.play(
        axes.animate.scale(0.75).to_corner(UL),
        run_time=2,
    )
    self.wait()
    self.play(FadeOut(VGroup(axes, dot, h_line, v_line)))
</t>
<t tx="ekr.20250121054835.160">def begin(self) -&gt; None:
    # This is called right as an animation is being
    # played.  As much initialization as possible,
    # especially any mobject copying, should live in
    # this method
    if self.time_span is not None:
        start, end = self.time_span
        self.run_time = max(end, self.run_time)
    self.mobject.set_animating_status(True)
    self.starting_mobject = self.create_starting_mobject()
    if self.suspend_mobject_updating:
        self.mobject_was_updating = not self.mobject.updating_suspended
        self.mobject.suspend_updating()
    self.families = list(self.get_all_families_zipped())
    self.interpolate(0)
</t>
<t tx="ekr.20250121054835.1600">def get_fill_opacity(self) -&gt; float:
    """
    If there are multiple opacities, this returns the
    first
    """
    data = self.data if self.has_points() else self._data_defaults
    return data["fill_rgba"][0, 3]
</t>
<t tx="ekr.20250121054835.1601">def get_stroke_color(self) -&gt; str:
    data = self.data if self.has_points() else self._data_defaults
    return rgb_to_hex(data["stroke_rgba"][0, :3])
</t>
<t tx="ekr.20250121054835.1602">def get_stroke_width(self) -&gt; float:
    data = self.data if self.has_points() else self._data_defaults
    return data["stroke_width"][0, 0]
</t>
<t tx="ekr.20250121054835.1603">def get_stroke_opacity(self) -&gt; float:
    data = self.data if self.has_points() else self._data_defaults
    return data["stroke_rgba"][0, 3]
</t>
<t tx="ekr.20250121054835.1604">def get_color(self) -&gt; str:
    if self.has_fill():
        return self.get_fill_color()
    return self.get_stroke_color()
</t>
<t tx="ekr.20250121054835.1605">def get_anti_alias_width(self):
    return self.uniforms["anti_alias_width"]
</t>
<t tx="ekr.20250121054835.1606">def has_stroke(self) -&gt; bool:
    data = self.data if len(self.data) &gt; 0 else self._data_defaults
    return any(data['stroke_width']) and any(data['stroke_rgba'][:, 3])
</t>
<t tx="ekr.20250121054835.1607">def has_fill(self) -&gt; bool:
    data = self.data if len(self.data) &gt; 0 else self._data_defaults
    return any(data['fill_rgba'][:, 3])
</t>
<t tx="ekr.20250121054835.1608">def get_opacity(self) -&gt; float:
    if self.has_fill():
        return self.get_fill_opacity()
    return self.get_stroke_opacity()
</t>
<t tx="ekr.20250121054835.1609">def set_flat_stroke(self, flat_stroke: bool = True, recurse: bool = True) -&gt; Self:
    self.set_uniform(recurse, flat_stroke=float(flat_stroke))
    return self
</t>
<t tx="ekr.20250121054835.161">def finish(self) -&gt; None:
    self.interpolate(self.final_alpha_value)
    self.mobject.set_animating_status(False)
    if self.suspend_mobject_updating and self.mobject_was_updating:
        self.mobject.resume_updating()
</t>
<t tx="ekr.20250121054835.1610">def get_flat_stroke(self) -&gt; bool:
    return self.uniforms["flat_stroke"] == 1.0
</t>
<t tx="ekr.20250121054835.1611">def set_scale_stroke_with_zoom(self, scale_stroke_with_zoom: bool = True, recurse: bool = True) -&gt; Self:
    self.set_uniform(recurse, scale_stroke_with_zoom=float(scale_stroke_with_zoom))
    pass
</t>
<t tx="ekr.20250121054835.1612">def get_scale_stroke_with_zoom(self) -&gt; bool:
    return self.uniforms["flat_stroke"] == 1.0
</t>
<t tx="ekr.20250121054835.1613">def set_joint_type(self, joint_type: str, recurse: bool = True) -&gt; Self:
    for mob in self.get_family(recurse):
        mob.uniforms["joint_type"] = self.joint_type_map[joint_type]
    return self
</t>
<t tx="ekr.20250121054835.1614">def get_joint_type(self) -&gt; float:
    return self.uniforms["joint_type"]
</t>
<t tx="ekr.20250121054835.1615">def apply_depth_test(
    self,
    anti_alias_width: float = 0,
    recurse: bool = True
) -&gt; Self:
    super().apply_depth_test(recurse)
    self.set_anti_alias_width(anti_alias_width)
    return self
</t>
<t tx="ekr.20250121054835.1616">def deactivate_depth_test(
    self,
    anti_alias_width: float = 1.0,
    recurse: bool = True
) -&gt; Self:
    super().deactivate_depth_test(recurse)
    self.set_anti_alias_width(anti_alias_width)
    return self
</t>
<t tx="ekr.20250121054835.1617">def use_winding_fill(self, value: bool = True, recurse: bool = True) -&gt; Self:
    # Only keeping this here because some old scene call it
    return self
</t>
<t tx="ekr.20250121054835.1618"># Points
def set_anchors_and_handles(
    self,
    anchors: Vect3Array,
    handles: Vect3Array,
) -&gt; Self:
    if len(anchors) == 0:
        self.clear_points()
        return self
    assert len(anchors) == len(handles) + 1
    points = resize_array(self.get_points(), 2 * len(anchors) - 1)
    points[0::2] = anchors
    points[1::2] = handles
    self.set_points(points)
    return self
</t>
<t tx="ekr.20250121054835.1619">def start_new_path(self, point: Vect3) -&gt; Self:
    # Path ends are signaled by a handle point sitting directly
    # on top of the previous anchor
    if self.has_points():
        self.append_points([self.get_last_point(), point])
    else:
        self.set_points([point])
    return self
</t>
<t tx="ekr.20250121054835.162">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    if self.is_remover():
        scene.remove(self.mobject)
</t>
<t tx="ekr.20250121054835.1620">def add_cubic_bezier_curve(
    self,
    anchor1: Vect3,
    handle1: Vect3,
    handle2: Vect3,
    anchor2: Vect3
) -&gt; Self:
    self.start_new_path(anchor1)
    self.add_cubic_bezier_curve_to(handle1, handle2, anchor2)
    return self
</t>
<t tx="ekr.20250121054835.1621">def add_cubic_bezier_curve_to(
    self,
    handle1: Vect3,
    handle2: Vect3,
    anchor: Vect3,
) -&gt; Self:
    """
    Add cubic bezier curve to the path.
    """
    self.throw_error_if_no_points()
    last = self.get_last_point()
    # Note, this assumes all points are on the xy-plane
    v1 = handle1 - last
    v2 = anchor - handle2
    angle = angle_between_vectors(v1, v2)
    if self.use_simple_quadratic_approx and angle &lt; 45 * DEG:
        quad_approx = [last, find_intersection(last, v1, anchor, -v2), anchor]
    else:
        quad_approx = get_quadratic_approximation_of_cubic(
            last, handle1, handle2, anchor
        )
    if self.consider_points_equal(quad_approx[1], last):
        # This is to prevent subpaths from accidentally being marked closed
        quad_approx[1] = midpoint(*quad_approx[1:3])
    self.append_points(quad_approx[1:])
    return self
</t>
<t tx="ekr.20250121054835.1622">def add_quadratic_bezier_curve_to(self, handle: Vect3, anchor: Vect3, allow_null_curve=True) -&gt; Self:
    self.throw_error_if_no_points()
    last_point = self.get_last_point()
    if not allow_null_curve and self.consider_points_equal(last_point, anchor):
        return self
    if self.consider_points_equal(handle, last_point):
        # This is to prevent subpaths from accidentally being marked closed
        handle = midpoint(handle, anchor)
    self.append_points([handle, anchor])
    return self
</t>
<t tx="ekr.20250121054835.1623">def add_line_to(self, point: Vect3, allow_null_line: bool = True) -&gt; Self:
    self.throw_error_if_no_points()
    last_point = self.get_last_point()
    if not allow_null_line and self.consider_points_equal(last_point, point):
        return self
    alphas = np.linspace(0, 1, 5 if self.long_lines else 3)
    self.append_points(outer_interpolate(last_point, point, alphas[1:]))
    return self
</t>
<t tx="ekr.20250121054835.1624">def add_smooth_curve_to(self, point: Vect3) -&gt; Self:
    if self.has_new_path_started():
        self.add_line_to(point)
    else:
        self.throw_error_if_no_points()
        new_handle = self.get_reflection_of_last_handle()
        self.add_quadratic_bezier_curve_to(new_handle, point)
    return self
</t>
<t tx="ekr.20250121054835.1625">def add_smooth_cubic_curve_to(self, handle: Vect3, point: Vect3) -&gt; Self:
    self.throw_error_if_no_points()
    if self.get_num_points() == 1:
        new_handle = handle
    else:
        new_handle = self.get_reflection_of_last_handle()
    self.add_cubic_bezier_curve_to(new_handle, handle, point)
    return self
</t>
<t tx="ekr.20250121054835.1626">def add_arc_to(self, point: Vect3, angle: float, n_components: int | None = None, threshold: float = 1e-3) -&gt; Self:
    self.throw_error_if_no_points()
    if abs(angle) &lt; threshold:
        self.add_line_to(point)
        return self

    # Assign default value for n_components
    if n_components is None:
        n_components = int(np.ceil(8 * abs(angle) / TAU))

    arc_points = quadratic_bezier_points_for_arc(angle, n_components)
    target_vect = point - self.get_end()
    curr_vect = arc_points[-1] - arc_points[0]

    arc_points = arc_points @ rotation_between_vectors(curr_vect, target_vect).T
    arc_points *= get_norm(target_vect) / get_norm(curr_vect)
    arc_points += (self.get_end() - arc_points[0])
    self.append_points(arc_points[1:])
    return self
</t>
<t tx="ekr.20250121054835.1627">def has_new_path_started(self) -&gt; bool:
    points = self.get_points()
    if len(points) == 0:
        return False
    elif len(points) == 1:
        return True
    return self.consider_points_equal(points[-3], points[-2])
</t>
<t tx="ekr.20250121054835.1628">def get_last_point(self) -&gt; Vect3:
    return self.get_points()[-1]
</t>
<t tx="ekr.20250121054835.1629">def get_reflection_of_last_handle(self) -&gt; Vect3:
    points = self.get_points()
    return 2 * points[-1] - points[-2]
</t>
<t tx="ekr.20250121054835.163">def create_starting_mobject(self) -&gt; Mobject:
    # Keep track of where the mobject starts
    return self.mobject.copy()
</t>
<t tx="ekr.20250121054835.1630">def close_path(self, smooth: bool = False) -&gt; Self:
    if self.is_closed():
        return self
    ends = self.get_subpath_end_indices()
    last_path_start = self.get_points()[0 if len(ends) == 1 else ends[-2] + 2]
    if smooth:
        self.add_smooth_curve_to(last_path_start)
    else:
        self.add_line_to(last_path_start)
    return self
</t>
<t tx="ekr.20250121054835.1631">def is_closed(self) -&gt; bool:
    points = self.get_points()
    ends = self.get_subpath_end_indices()
    last_path_start = points[0 if len(ends) == 1 else ends[-2] + 2]
    return self.consider_points_equal(last_path_start, points[-1])
</t>
<t tx="ekr.20250121054835.1632">def subdivide_curves_by_condition(
    self,
    tuple_to_subdivisions: Callable,
    recurse: bool = True
) -&gt; Self:
    for vmob in self.get_family(recurse):
        if not vmob.has_points():
            continue
        new_points = [vmob.get_points()[0]]
        for tup in vmob.get_bezier_tuples():
            n_divisions = tuple_to_subdivisions(*tup)
            if n_divisions &gt; 0:
                alphas = np.linspace(0, 1, n_divisions + 2)
                new_points.extend([
                    partial_quadratic_bezier_points(tup, a1, a2)[1:]
                    for a1, a2 in zip(alphas, alphas[1:])
                ])
            else:
                new_points.append(tup[1:])
        vmob.set_points(np.vstack(new_points))
    return self
</t>
<t tx="ekr.20250121054835.1633">def subdivide_sharp_curves(
    self,
    angle_threshold: float = 30 * DEG,
    recurse: bool = True
) -&gt; Self:
    def tuple_to_subdivisions(b0, b1, b2):
        angle = angle_between_vectors(b1 - b0, b2 - b1)
        return int(angle / angle_threshold)

    self.subdivide_curves_by_condition(tuple_to_subdivisions, recurse)
    return self
</t>
<t tx="ekr.20250121054835.1634">def subdivide_intersections(self, recurse: bool = True, n_subdivisions: int = 1) -&gt; Self:
    path = self.get_anchors()
    def tuple_to_subdivisions(b0, b1, b2):
        if line_intersects_path(b0, b1, path):
            return n_subdivisions
        return 0

    self.subdivide_curves_by_condition(tuple_to_subdivisions, recurse)
    return self
</t>
<t tx="ekr.20250121054835.1635">def add_points_as_corners(self, points: Iterable[Vect3]) -&gt; Self:
    for point in points:
        self.add_line_to(point)
    return self
</t>
<t tx="ekr.20250121054835.1636">def set_points_as_corners(self, points: Iterable[Vect3]) -&gt; Self:
    anchors = np.array(points)
    handles = 0.5 * (anchors[:-1] + anchors[1:])
    self.set_anchors_and_handles(anchors, handles)
    return self
</t>
<t tx="ekr.20250121054835.1637">def set_points_smoothly(
    self,
    points: Iterable[Vect3],
    approx: bool = True
) -&gt; Self:
    self.set_points_as_corners(points)
    self.make_smooth(approx=approx)
    return self
</t>
<t tx="ekr.20250121054835.1638">def is_smooth(self, angle_tol=1 * DEG) -&gt; bool:
    angles = np.abs(self.get_joint_angles()[0::2])
    return (angles &lt; angle_tol).all()
</t>
<t tx="ekr.20250121054835.1639">def change_anchor_mode(self, mode: str) -&gt; Self:
    assert mode in ("jagged", "approx_smooth", "true_smooth")
    if self.get_num_points() == 0:
        return self
    subpaths = self.get_subpaths()
    self.clear_points()
    for subpath in subpaths:
        anchors = subpath[::2]
        new_subpath = np.array(subpath)
        if mode == "jagged":
            new_subpath[1::2] = 0.5 * (anchors[:-1] + anchors[1:])
        elif mode == "approx_smooth":
            new_subpath[1::2] = approx_smooth_quadratic_bezier_handles(anchors)
        elif mode == "true_smooth":
            new_subpath = smooth_quadratic_path(anchors)
        # Shift any handles which ended up on top of
        # the previous anchor
        a0 = new_subpath[0:-1:2]
        h = new_subpath[1::2]
        a1 = new_subpath[2::2]
        false_ends = np.equal(a0, h).all(1)
        h[false_ends] = 0.5 * (a0[false_ends] + a1[false_ends])
        self.add_subpath(new_subpath)
    return self
</t>
<t tx="ekr.20250121054835.164">def get_all_mobjects(self) -&gt; tuple[Mobject, Mobject]:
    """
    Ordering must match the ording of arguments to interpolate_submobject
    """
    return self.mobject, self.starting_mobject
</t>
<t tx="ekr.20250121054835.1640">def make_smooth(self, approx=True, recurse=True) -&gt; Self:
    """
    Edits the path so as to pass smoothly through all
    the current anchor points.

    If approx is False, this may increase the total
    number of points.
    """
    mode = "approx_smooth" if approx else "true_smooth"
    for submob in self.get_family(recurse):
        if submob.is_smooth():
            continue
        submob.change_anchor_mode(mode)
    return self
</t>
<t tx="ekr.20250121054835.1641">def make_approximately_smooth(self, recurse=True) -&gt; Self:
    self.make_smooth(approx=True, recurse=recurse)
    return self
</t>
<t tx="ekr.20250121054835.1642">def make_jagged(self, recurse=True) -&gt; Self:
    for submob in self.get_family(recurse):
        submob.change_anchor_mode("jagged")
    return self
</t>
<t tx="ekr.20250121054835.1643">def add_subpath(self, points: Vect3Array) -&gt; Self:
    assert len(points) % 2 == 1 or len(points) == 0
    if not self.has_points():
        self.set_points(points)
        return self
    if not self.consider_points_equal(points[0], self.get_points()[-1]):
        self.start_new_path(points[0])
    self.append_points(points[1:])
    return self
</t>
<t tx="ekr.20250121054835.1644">def append_vectorized_mobject(self, vmobject: VMobject) -&gt; Self:
    self.add_subpath(vmobject.get_points())
    n = vmobject.get_num_points()
    self.data[-n:] = vmobject.data
    return self
</t>
<t tx="ekr.20250121054835.1645">#
def consider_points_equal(self, p0: Vect3, p1: Vect3) -&gt; bool:
    return all(abs(p1 - p0) &lt; self.tolerance_for_point_equality)
</t>
<t tx="ekr.20250121054835.1646"># Information about the curve
def get_bezier_tuples_from_points(self, points: Vect3Array) -&gt; Iterable[Vect3Array]:
    n_curves = (len(points) - 1) // 2
    return (points[2 * i:2 * i + 3] for i in range(n_curves))
</t>
<t tx="ekr.20250121054835.1647">def get_bezier_tuples(self) -&gt; Iterable[Vect3Array]:
    return self.get_bezier_tuples_from_points(self.get_points())
</t>
<t tx="ekr.20250121054835.1648">def get_subpath_end_indices_from_points(self, points: Vect3Array) -&gt; np.ndarray:
    atol = 1e-4  # TODO, this is too unsystematic
    a0, h, a1 = points[0:-1:2], points[1::2], points[2::2]
    # An anchor point is considered the end of a path
    # if its following handle is sitting on top of it.
    # To disambiguate this from cases with many null
    # curves in a row, we also check that the following
    # anchor is genuinely distinct
    is_end = (a0 == h).all(1) &amp; (abs(h - a1) &gt; atol).any(1)
    end_indices = (2 * n for n, end in enumerate(is_end) if end)
    return np.array([*end_indices, len(points) - 1])
</t>
<t tx="ekr.20250121054835.1649">def get_subpath_end_indices(self) -&gt; np.ndarray:
    if self.subpath_end_indices is None:
        self.subpath_end_indices = self.get_subpath_end_indices_from_points(self.get_points())
    return self.subpath_end_indices
</t>
<t tx="ekr.20250121054835.165">def get_all_families_zipped(self) -&gt; zip[tuple[Mobject]]:
    return zip(*[
        mob.get_family()
        for mob in self.get_all_mobjects()
    ])
</t>
<t tx="ekr.20250121054835.1650">def get_subpaths_from_points(self, points: Vect3Array) -&gt; list[Vect3Array]:
    if len(points) == 0:
        return []
    end_indices = self.get_subpath_end_indices_from_points(points)
    start_indices = [0, *(end_indices[:-1] + 2)]
    return [points[i1:i2 + 1] for i1, i2 in zip(start_indices, end_indices)]
</t>
<t tx="ekr.20250121054835.1651">def get_subpaths(self) -&gt; list[Vect3Array]:
    return self.get_subpaths_from_points(self.get_points())
</t>
<t tx="ekr.20250121054835.1652">def get_nth_curve_points(self, n: int) -&gt; Vect3Array:
    assert n &lt; self.get_num_curves()
    return self.get_points()[2 * n:2 * n + 3]
</t>
<t tx="ekr.20250121054835.1653">def get_nth_curve_function(self, n: int) -&gt; Callable[[float], Vect3]:
    return bezier(self.get_nth_curve_points(n))
</t>
<t tx="ekr.20250121054835.1654">def get_num_curves(self) -&gt; int:
    return self.get_num_points() // 2
</t>
<t tx="ekr.20250121054835.1655">def quick_point_from_proportion(self, alpha: float) -&gt; Vect3:
    # Assumes all curves have the same length, so is inaccurate
    num_curves = self.get_num_curves()
    if num_curves == 0:
        return self.get_center()
    n, residue = integer_interpolate(0, num_curves, alpha)
    curve_func = self.get_nth_curve_function(n)
    return curve_func(residue)
</t>
<t tx="ekr.20250121054835.1656">def curve_and_prop_of_partial_point(self, alpha) -&gt; Tuple[int, float]:
    """
    If you want a point a proportion alpha along the curve, this
    gives you the index of the appropriate bezier curve, together
    with the proportion along that curve you'd need to travel
    """
    if alpha == 0:
        return (0, 0.0)
    partials: list[float] = [0]
    for tup in self.get_bezier_tuples():
        if self.consider_points_equal(tup[0], tup[1]):
            # Don't consider null curves
            arclen = 0
        else:
            # Approximate length with straight line from start to end
            arclen = get_norm(tup[2] - tup[0])
        partials.append(partials[-1] + arclen)
    full = partials[-1]
    if full == 0:
        return len(partials), 1.0
    # First index where the partial length is more than alpha times the full length
    index = next(
        (i for i, x in enumerate(partials) if x &gt;= full * alpha),
        len(partials) - 1  # Default
    )
    residue = float(inverse_interpolate(
        partials[index - 1] / full, partials[index] / full, alpha
    ))
    return index - 1, residue
</t>
<t tx="ekr.20250121054835.1657">def point_from_proportion(self, alpha: float) -&gt; Vect3:
    if alpha &lt;= 0:
        return self.get_start()
    elif alpha &gt;= 1:
        return self.get_end()
    if self.get_num_points() == 0:
        return self.get_center()
    index, residue = self.curve_and_prop_of_partial_point(alpha)
    return self.get_nth_curve_function(index)(residue)
</t>
<t tx="ekr.20250121054835.1658">def get_anchors_and_handles(self) -&gt; list[Vect3]:
    """
    returns anchors1, handles, anchors2,
    where (anchors1[i], handles[i], anchors2[i])
    will be three points defining a quadratic bezier curve
    for any i in range(0, len(anchors1))
    """
    points = self.get_points()
    return [points[0:-1:2], points[1::2], points[2::2]]
</t>
<t tx="ekr.20250121054835.1659">def get_start_anchors(self) -&gt; Vect3Array:
    return self.get_points()[0:-1:2]
</t>
<t tx="ekr.20250121054835.166">def update_mobjects(self, dt: float) -&gt; None:
    """
    Updates things like starting_mobject, and (for
    Transforms) target_mobject.
    """
    for mob in self.get_all_mobjects_to_update():
        mob.update(dt)
</t>
<t tx="ekr.20250121054835.1660">def get_end_anchors(self) -&gt; Vect3:
    return self.get_points()[2::2]
</t>
<t tx="ekr.20250121054835.1661">def get_anchors(self) -&gt; Vect3Array:
    return self.get_points()[::2]
</t>
<t tx="ekr.20250121054835.1662">def get_points_without_null_curves(self, atol: float = 1e-9) -&gt; Vect3Array:
    new_points = [self.get_points()[0]]
    for tup in self.get_bezier_tuples():
        if get_norm(tup[1] - tup[0]) &gt; atol or get_norm(tup[2] - tup[0]) &gt; atol:
            new_points.append(tup[1:])
    return np.vstack(new_points)
</t>
<t tx="ekr.20250121054835.1663">def get_arc_length(self, n_sample_points: int | None = None) -&gt; float:
    if n_sample_points is not None:
        points = np.array([
            self.quick_point_from_proportion(a)
            for a in np.linspace(0, 1, n_sample_points)
        ])
        return poly_line_length(points)
    points = self.get_points()
    inner_len = poly_line_length(points[::2])
    outer_len = poly_line_length(points)
    return interpolate(inner_len, outer_len, 1 / 3)
</t>
<t tx="ekr.20250121054835.1664">def get_area_vector(self) -&gt; Vect3:
    # Returns a vector whose length is the area bound by
    # the polygon formed by the anchor points, pointing
    # in a direction perpendicular to the polygon according
    # to the right hand rule.
    if not self.has_points():
        return np.zeros(3)

    p0 = self.get_anchors()
    p1 = np.vstack([p0[1:], p0[0]])

    # Each term goes through all edges [(x0, y0, z0), (x1, y1, z1)]
    sums = p0 + p1
    diffs = p1 - p0
    return 0.5 * np.array([
        (sums[:, 1] * diffs[:, 2]).sum(),  # Add up (y0 + y1)*(z1 - z0)
        (sums[:, 2] * diffs[:, 0]).sum(),  # Add up (z0 + z1)*(x1 - x0)
        (sums[:, 0] * diffs[:, 1]).sum(),  # Add up (x0 + x1)*(y1 - y0)
    ])
</t>
<t tx="ekr.20250121054835.1665">def get_unit_normal(self, refresh: bool = False) -&gt; Vect3:
    if self.get_num_points() &lt; 3:
        return OUT

    if not self.needs_new_unit_normal and not refresh:
        return self.data["base_normal"][1, :]

    area_vect = self.get_area_vector()
    area = get_norm(area_vect)
    if area &gt; 0:
        normal = area_vect / area
    else:
        p = self.get_points()
        normal = get_unit_normal(p[1] - p[0], p[2] - p[1])
    self.data["base_normal"][1::2] = normal
    self.needs_new_unit_normal = False
    return normal
</t>
<t tx="ekr.20250121054835.1666">def refresh_unit_normal(self) -&gt; Self:
    self.needs_new_unit_normal = True
    return self
</t>
<t tx="ekr.20250121054835.1667">def rotate(
    self,
    angle: float,
    axis: Vect3 = OUT,
    about_point: Vect3 | None = None,
    **kwargs
) -&gt; Self:
    super().rotate(angle, axis, about_point, **kwargs)
    for mob in self.get_family():
        mob.refresh_unit_normal()
    return self
</t>
<t tx="ekr.20250121054835.1668">def ensure_positive_orientation(self, recurse=True) -&gt; Self:
    for mob in self.get_family(recurse):
        if mob.get_unit_normal()[2] &lt; 0:
            mob.reverse_points()
    return self
</t>
<t tx="ekr.20250121054835.1669"># Alignment
def align_points(self, vmobject: VMobject) -&gt; Self:
    if self.get_num_points() == len(vmobject.get_points()):
        for mob in [self, vmobject]:
            mob.get_joint_angles()
        return self

    for mob in self, vmobject:
        # If there are no points, add one to
        # where the "center" is
        if not mob.has_points():
            mob.start_new_path(mob.get_center())

    # Figure out what the subpaths are, and align
    subpaths1 = self.get_subpaths()
    subpaths2 = vmobject.get_subpaths()
    for subpaths in [subpaths1, subpaths2]:
        subpaths.sort(key=lambda sp: -sum(
            get_norm(p2 - p1)
            for p1, p2 in zip(sp, sp[1:])
        ))
    n_subpaths = max(len(subpaths1), len(subpaths2))

    # Start building new ones
    new_subpaths1 = []
    new_subpaths2 = []

    def get_nth_subpath(path_list, n):
        if n &gt;= len(path_list):
            return np.vstack([path_list[0][:-1], path_list[0][::-1]])
        return path_list[n]

    for n in range(n_subpaths):
        sp1 = get_nth_subpath(subpaths1, n)
        sp2 = get_nth_subpath(subpaths2, n)
        diff1 = max(0, (len(sp2) - len(sp1)) // 2)
        diff2 = max(0, (len(sp1) - len(sp2)) // 2)
        sp1 = self.insert_n_curves_to_point_list(diff1, sp1)
        sp2 = self.insert_n_curves_to_point_list(diff2, sp2)
        if n &gt; 0:
            # Add intermediate anchor to mark path end
            new_subpaths1.append(new_subpaths1[-1][-1])
            new_subpaths2.append(new_subpaths2[-1][-1])
        new_subpaths1.append(sp1)
        new_subpaths2.append(sp2)

    for mob, paths in [(self, new_subpaths1), (vmobject, new_subpaths2)]:
        new_points = np.vstack(paths)
        mob.resize_points(len(new_points), resize_func=resize_preserving_order)
        mob.set_points(new_points)
        mob.get_joint_angles()
    return self
</t>
<t tx="ekr.20250121054835.167">def get_all_mobjects_to_update(self) -&gt; list[Mobject]:
    # The surrounding scene typically handles
    # updating of self.mobject.
    items = list(filter(
        lambda m: m is not self.mobject,
        self.get_all_mobjects()
    ))
    items = remove_list_redundancies(items)
    return items
</t>
<t tx="ekr.20250121054835.1670">def insert_n_curves(self, n: int, recurse: bool = True) -&gt; Self:
    for mob in self.get_family(recurse):
        if mob.get_num_curves() &gt; 0:
            new_points = mob.insert_n_curves_to_point_list(n, mob.get_points())
            mob.set_points(new_points)
    return self
</t>
<t tx="ekr.20250121054835.1671">def insert_n_curves_to_point_list(self, n: int, points: Vect3Array) -&gt; Vect3Array:
    if len(points) == 1:
        return np.repeat(points, 2 * n + 1, 0)

    bezier_tuples = list(self.get_bezier_tuples_from_points(points))
    atol = self.tolerance_for_point_equality
    norms = [
        0 if get_norm(tup[1] - tup[0]) &lt; atol else get_norm(tup[2] - tup[0])
        for tup in bezier_tuples
    ]
    # Calculate insertions per curve (ipc)
    ipc = np.zeros(len(bezier_tuples), dtype=int)
    for _ in range(n):
        index = np.argmax(norms)
        ipc[index] += 1
        norms[index] *= ipc[index] / (ipc[index] + 1)

    new_points = [points[0]]
    for tup, n_inserts in zip(bezier_tuples, ipc):
        # What was once a single quadratic curve defined
        # by "tup" will now be broken into n_inserts + 1
        # smaller quadratic curves
        alphas = np.linspace(0, 1, n_inserts + 2)
        for a1, a2 in zip(alphas, alphas[1:]):
            new_points.extend(partial_quadratic_bezier_points(tup, a1, a2)[1:])
    return np.vstack(new_points)
</t>
<t tx="ekr.20250121054835.1672">def pointwise_become_partial(self, vmobject: VMobject, a: float, b: float) -&gt; Self:
    assert isinstance(vmobject, VMobject)
    vm_points = vmobject.get_points()
    self.data["joint_angle"] = vmobject.data["joint_angle"]
    if a &lt;= 0 and b &gt;= 1:
        self.set_points(vm_points, refresh=False)
        return self
    num_curves = vmobject.get_num_curves()

    # Partial curve includes three portions:
    # - A start, which is some ending portion of an inner quadratic
    # - A middle section, which matches the curve exactly
    # - An end, which is the starting portion of a later inner quadratic

    lower_index, lower_residue = integer_interpolate(0, num_curves, a)
    upper_index, upper_residue = integer_interpolate(0, num_curves, b)
    i1 = 2 * lower_index
    i2 = 2 * lower_index + 3
    i3 = 2 * upper_index
    i4 = 2 * upper_index + 3

    new_points = vm_points.copy()
    if num_curves == 0:
        new_points[:] = 0
        return self
    if lower_index == upper_index:
        tup = partial_quadratic_bezier_points(vm_points[i1:i2], lower_residue, upper_residue)
        new_points[:i1] = tup[0]
        new_points[i1:i4] = tup
        new_points[i4:] = tup[2]
    else:
        low_tup = partial_quadratic_bezier_points(vm_points[i1:i2], lower_residue, 1)
        high_tup = partial_quadratic_bezier_points(vm_points[i3:i4], 0, upper_residue)
        new_points[0:i1] = low_tup[0]
        new_points[i1:i2] = low_tup
        # Keep new_points i2:i3 as they are
        new_points[i3:i4] = high_tup
        new_points[i4:] = high_tup[2]
    self.data["joint_angle"][:i1] = 0
    self.data["joint_angle"][i4:] = 0
    self.set_points(new_points, refresh=False)
    return self
</t>
<t tx="ekr.20250121054835.1673">def get_subcurve(self, a: float, b: float) -&gt; Self:
    vmob = self.copy()
    vmob.pointwise_become_partial(self, a, b)
    return vmob
</t>
<t tx="ekr.20250121054835.1674">def get_outer_vert_indices(self) -&gt; np.ndarray:
    """
    Returns the pattern (0, 1, 2, 2, 3, 4, 4, 5, 6, ...)
    """
    n_curves = self.get_num_curves()
    if len(self.outer_vert_indices) != 3 * n_curves:
        # Creates the pattern (0, 1, 2, 2, 3, 4, 4, 5, 6, ...)
        self.outer_vert_indices = (np.arange(1, 3 * n_curves + 1) * 2) // 3
    return self.outer_vert_indices
</t>
<t tx="ekr.20250121054835.1675"># Data for shaders that may need refreshing

def get_triangulation(self) -&gt; np.ndarray:
    # Figure out how to triangulate the interior to know
    # how to send the points as to the vertex shader.
    # First triangles come directly from the points
    points = self.get_points()

    if len(points) &lt;= 1:
        return np.zeros(0, dtype='i4')

    normal_vector = self.get_unit_normal()

    # Rotate points such that unit normal vector is OUT
    if not np.isclose(normal_vector, OUT).all():
        points = np.dot(points, z_to_vector(normal_vector))

    v01s = points[1::2] - points[0:-1:2]
    v12s = points[2::2] - points[1::2]
    curve_orientations = np.sign(cross2d(v01s, v12s))

    concave_parts = curve_orientations &lt; 0

    # These are the vertices to which we'll apply a polygon triangulation
    indices = np.arange(len(points), dtype=int)
    inner_vert_indices = np.hstack([
        indices[0::2],
        indices[1::2][concave_parts],
    ])
    inner_vert_indices.sort()
    # Even indices correspond to anchors, and `end_indices // 2`
    # shows which anchors are considered end points
    end_indices = self.get_subpath_end_indices()
    counts = np.arange(1, len(inner_vert_indices) + 1)
    rings = counts[inner_vert_indices % 2 == 0][end_indices // 2]

    # Triangulate
    inner_verts = points[inner_vert_indices]
    inner_tri_indices = inner_vert_indices[
        earclip_triangulation(inner_verts, rings)
    ]
    # Remove null triangles, coming from adjascent points
    iti = inner_tri_indices
    null1 = (iti[0::3] + 1 == iti[1::3]) &amp; (iti[0::3] + 2 == iti[2::3])
    null2 = (iti[0::3] - 1 == iti[1::3]) &amp; (iti[0::3] - 2 == iti[2::3])
    inner_tri_indices = iti[~(null1 | null2).repeat(3)]

    ovi = self.get_outer_vert_indices()
    tri_indices = np.hstack([ovi, inner_tri_indices])
    return tri_indices
</t>
<t tx="ekr.20250121054835.1676">def refresh_joint_angles(self) -&gt; Self:
    for mob in self.get_family():
        mob.needs_new_joint_angles = True
    return self
</t>
<t tx="ekr.20250121054835.1677">def get_joint_angles(self, refresh: bool = False) -&gt; np.ndarray:
    """
    The 'joint product' is a 4-vector holding the cross and dot
    product between tangent vectors at a joint
    """
    if not self.needs_new_joint_angles and not refresh:
        return self.data["joint_angle"][:, 0]

    if "joint_angle" in self.locked_data_keys:
        return self.data["joint_angle"][:, 0]

    self.needs_new_joint_angles = False
    self._data_has_changed = True

    # Rotate points such that positive z direction is the normal
    points = self.get_points() @ rotation_between_vectors(OUT, self.get_unit_normal())

    if len(points) &lt; 3:
        return self.data["joint_angle"][:, 0]

    # Find all the unit tangent vectors at each joint
    a0, h, a1 = points[0:-1:2], points[1::2], points[2::2]
    a0_to_h = h - a0
    h_to_a1 = a1 - h

    # Tangent vectors into each vertex
    v_in = np.zeros(points.shape)
    # Tangent vectors out of each vertex
    v_out = np.zeros(points.shape)

    v_in[1::2] = a0_to_h
    v_in[2::2] = h_to_a1
    v_out[0:-1:2] = a0_to_h
    v_out[1::2] = h_to_a1

    # Joint up closed loops, or mark unclosed paths as such
    ends = self.get_subpath_end_indices()
    starts = [0, *(e + 2 for e in ends[:-1])]
    for start, end in zip(starts, ends):
        if start == end:
            continue
        if (points[start] == points[end]).all():
            v_in[start] = v_out[end - 1]
            v_out[end] = v_in[start + 1]
        else:
            v_in[start] = v_out[start]
            v_out[end] = v_in[end]

    # Find the angles between vectors into each vertex, and out of it
    angles_in = np.arctan2(v_in[:, 1], v_in[:, 0])
    angles_out = np.arctan2(v_out[:, 1], v_out[:, 0])
    angle_diffs = angles_out - angles_in
    angle_diffs[angle_diffs &lt; -PI] += TAU
    angle_diffs[angle_diffs &gt; PI] -= TAU
    self.data["joint_angle"][:, 0] = angle_diffs
    return self.data["joint_angle"][:, 0]
</t>
<t tx="ekr.20250121054835.1678">def lock_matching_data(self, vmobject1: VMobject, vmobject2: VMobject) -&gt; Self:
    for mob in [self, vmobject1, vmobject2]:
        mob.get_joint_angles()
    super().lock_matching_data(vmobject1, vmobject2)
    return self
</t>
<t tx="ekr.20250121054835.1679">def triggers_refresh(func: Callable):
    @wraps(func)
    def wrapper(self, *args, refresh=True, **kwargs):
        func(self, *args, **kwargs)
        if refresh:
            self.subpath_end_indices = None
            self.refresh_joint_angles()
            self.refresh_unit_normal()
        return self
    return wrapper
</t>
<t tx="ekr.20250121054835.168">def copy(self):
    return deepcopy(self)
</t>
<t tx="ekr.20250121054835.1680">@triggers_refresh
def set_points(self, points: Vect3Array) -&gt; Self:
    assert len(points) == 0 or len(points) % 2 == 1
    return super().set_points(points)
</t>
<t tx="ekr.20250121054835.1681">@triggers_refresh
def append_points(self, points: Vect3Array) -&gt; Self:
    assert len(points) % 2 == 0
    return super().append_points(points)
</t>
<t tx="ekr.20250121054835.1682">def reverse_points(self, recurse: bool = True) -&gt; Self:
    # This will reset which anchors are
    # considered path ends
    for mob in self.get_family(recurse):
        if not mob.has_points():
            continue
        inner_ends = mob.get_subpath_end_indices()[:-1]
        mob.data["point"][inner_ends + 1] = mob.data["point"][inner_ends + 2]
        mob.data["base_normal"][1::2] *= -1  # Invert normal vector
        self.subpath_end_indices = None
    return super().reverse_points()
</t>
<t tx="ekr.20250121054835.1683">@triggers_refresh
def set_data(self, data: np.ndarray) -&gt; Self:
    return super().set_data(data)
</t>
<t tx="ekr.20250121054835.1684"># TODO, how to be smart about tangents here?
@triggers_refresh
def apply_function(
    self,
    function: Callable[[Vect3], Vect3],
    make_smooth: bool = False,
    **kwargs
) -&gt; Self:
    super().apply_function(function, **kwargs)
    if self.make_smooth_after_applying_functions or make_smooth:
        self.make_smooth(approx=True)
    return self
</t>
<t tx="ekr.20250121054835.1685">@triggers_refresh
def stretch(self, *args, **kwargs) -&gt; Self:
    return super().stretch(*args, **kwargs)
</t>
<t tx="ekr.20250121054835.1686">@triggers_refresh
def apply_matrix(self, *args, **kwargs) -&gt; Self:
    return super().apply_matrix(*args, **kwargs)
</t>
<t tx="ekr.20250121054835.1687">def rotate(
    self,
    angle: float,
    axis: Vect3 = OUT,
    about_point: Vect3 | None = None,
    **kwargs
) -&gt; Self:
    rot_matrix_T = rotation_matrix_transpose(angle, axis)
    self.apply_points_function(
        lambda points: np.dot(points, rot_matrix_T),
        about_point,
        **kwargs
    )
    for mob in self.get_family():
        mob.get_unit_normal(refresh=True)
    return self
</t>
<t tx="ekr.20250121054835.1688">def set_animating_status(self, is_animating: bool, recurse: bool = True):
    super().set_animating_status(is_animating, recurse)
    for submob in self.get_family(recurse):
        submob.get_joint_angles(refresh=True)
    return self
</t>
<t tx="ekr.20250121054835.1689"># For shaders

def init_shader_wrapper(self, ctx: Context):
    self.shader_wrapper = VShaderWrapper(
        ctx=ctx,
        vert_data=self.data,
        mobject_uniforms=self.uniforms,
        code_replacements=self.shader_code_replacements,
        stroke_behind=self.stroke_behind,
        depth_test=self.depth_test
    )
</t>
<t tx="ekr.20250121054835.169">def update_rate_info(
    self,
    run_time: float | None = None,
    rate_func: Callable[[float], float] | None = None,
    lag_ratio: float | None = None,
):
    self.run_time = run_time or self.run_time
    self.rate_func = rate_func or self.rate_func
    self.lag_ratio = lag_ratio or self.lag_ratio
    return self
</t>
<t tx="ekr.20250121054835.1690">def refresh_shader_wrapper_id(self):
    for submob in self.get_family():
        if submob.shader_wrapper is not None:
            submob.shader_wrapper.stroke_behind = submob.stroke_behind
    super().refresh_shader_wrapper_id()
    return self
</t>
<t tx="ekr.20250121054835.1691">def get_shader_data(self) -&gt; np.ndarray:
    # Do we want this elsewhere? Say whenever points are refreshed or something?
    self.get_joint_angles()
    self.data["base_normal"][0::2] = self.data["point"][0]
    return super().get_shader_data()
</t>
<t tx="ekr.20250121054835.1692">def get_shader_vert_indices(self) -&gt; Optional[np.ndarray]:
    return self.get_outer_vert_indices()
</t>
<t tx="ekr.20250121054835.1693">class VGroup(Group, VMobject, Generic[SubVmobjectType]):
    @others
</t>
<t tx="ekr.20250121054835.1694">def __init__(self, *vmobjects: SubVmobjectType | Iterable[SubVmobjectType], **kwargs):
    super().__init__(**kwargs)
    if any(isinstance(vmob, Mobject) and not isinstance(vmob, VMobject) for vmob in vmobjects):
        raise Exception("Only VMobjects can be passed into VGroup")
    self._ingest_args(*vmobjects)
    if self.submobjects:
        self.uniforms.update(self.submobjects[0].uniforms)
</t>
<t tx="ekr.20250121054835.1695">def __add__(self, other: VMobject) -&gt; Self:
    assert isinstance(other, VMobject)
    return self.add(other)
</t>
<t tx="ekr.20250121054835.1696"># This is just here to make linters happy with references to things like VGroup(...)[0]
def __getitem__(self, index) -&gt; SubVmobjectType:
    return super().__getitem__(index)
</t>
<t tx="ekr.20250121054835.1697">class VectorizedPoint(Point, VMobject):
    @others
</t>
<t tx="ekr.20250121054835.1698">def __init__(
    self,
    location: np.ndarray = ORIGIN,
    color: ManimColor = BLACK,
    fill_opacity: float = 0.0,
    stroke_width: float = 0.0,
    **kwargs
):
    Point.__init__(self, location, **kwargs)
    VMobject.__init__(
        self,
        color=color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        **kwargs
    )
    self.set_points(np.array([location]))
</t>
<t tx="ekr.20250121054835.1699">class CurvesAsSubmobjects(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.17">        # Other coordinate systems you can play around with include
        # ThreeDAxes, NumberPlane, and ComplexPlane.


class GraphExample(Scene):
    @others
</t>
<t tx="ekr.20250121054835.170"># Methods for interpolation, the mean of an Animation
def interpolate(self, alpha: float) -&gt; None:
    self.interpolate_mobject(alpha)
</t>
<t tx="ekr.20250121054835.1700">def __init__(self, vmobject: VMobject, **kwargs):
    super().__init__(**kwargs)
    for tup in vmobject.get_bezier_tuples():
        part = VMobject()
        part.set_points(tup)
        part.match_style(vmobject)
        self.add(part)
</t>
<t tx="ekr.20250121054835.1701">class DashedVMobject(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.1702">def __init__(
    self,
    vmobject: VMobject,
    num_dashes: int = 15,
    positive_space_ratio: float = 0.5,
    **kwargs
):
    super().__init__(**kwargs)

    if num_dashes &gt; 0:
        # End points of the unit interval for division
        alphas = np.linspace(0, 1, num_dashes + 1)

        # This determines the length of each "dash"
        full_d_alpha = (1.0 / num_dashes)
        partial_d_alpha = full_d_alpha * positive_space_ratio

        # Rescale so that the last point of vmobject will
        # be the end of the last dash
        alphas /= (1 - full_d_alpha + partial_d_alpha)

        self.add(*[
            vmobject.get_subcurve(alpha, alpha + partial_d_alpha)
            for alpha in alphas[:-1]
        ])
    # Family is already taken care of by get_subcurve
    # implementation
    self.match_style(vmobject, recurse=False)
</t>
<t tx="ekr.20250121054835.1703">class VHighlight(VGroup):
    @others
    ):
        outline = vmobject.replicate(n_layers)
        outline.set_fill(opacity=0)
        added_widths = np.linspace(0, max_stroke_addition, n_layers + 1)[1:]
        colors = color_gradient(color_bounds, n_layers)
        for part, added_width, color in zip(reversed(outline), added_widths, colors):
            for sm in part.family_members_with_points():
                sm.set_stroke(
                    width=sm.get_stroke_width() + added_width,
                    color=color,
                )
        super().__init__(*outline)
</t>
<t tx="ekr.20250121054835.1704">def __init__(
    self,
    vmobject: VMobject,
    n_layers: int = 5,
    color_bounds: Tuple[ManimColor] = (GREY_C, GREY_E),
    max_stroke_addition: float = 5.0,
</t>
<t tx="ekr.20250121054835.1705"></t>
<t tx="ekr.20250121054835.1706">@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1707">from __future__ import annotations

import itertools as it
import numpy as np
import pyperclip
from IPython.core.getipython import get_ipython
from pyglet.window import key as PygletWindowKeys

from manimlib.animation.fading import FadeIn
from manimlib.config import manim_config
from manimlib.constants import DL, DOWN, DR, LEFT, ORIGIN, RIGHT, UL, UP, UR
from manimlib.constants import FRAME_WIDTH, FRAME_HEIGHT, SMALL_BUFF
from manimlib.constants import PI
from manimlib.constants import DEG
from manimlib.constants import MANIM_COLORS, WHITE, GREY_A, GREY_C
from manimlib.mobject.geometry import Line
from manimlib.mobject.geometry import Rectangle
from manimlib.mobject.geometry import Square
from manimlib.mobject.mobject import Group
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.numbers import DecimalNumber
from manimlib.mobject.svg.tex_mobject import Tex
from manimlib.mobject.svg.text_mobject import Text
from manimlib.mobject.types.dot_cloud import DotCloud
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VHighlight
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.scene.scene import Scene
from manimlib.scene.scene import SceneState
from manimlib.utils.family_ops import extract_mobject_family_members
from manimlib.utils.space_ops import get_norm
from manimlib.utils.tex_file_writing import LatexError

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from manimlib.typing import Vect3


SELECT_KEY = manim_config.key_bindings.select
UNSELECT_KEY = manim_config.key_bindings.unselect
GRAB_KEY = manim_config.key_bindings.grab
X_GRAB_KEY = manim_config.key_bindings.x_grab
Y_GRAB_KEY = manim_config.key_bindings.y_grab
GRAB_KEYS = [GRAB_KEY, X_GRAB_KEY, Y_GRAB_KEY]
RESIZE_KEY = manim_config.key_bindings.resize  # TODO
COLOR_KEY = manim_config.key_bindings.color
INFORMATION_KEY = manim_config.key_bindings.information
CURSOR_KEY = manim_config.key_bindings.cursor

# For keyboard interactions

ARROW_SYMBOLS: list[int] = [
    PygletWindowKeys.LEFT,
    PygletWindowKeys.UP,
    PygletWindowKeys.RIGHT,
    PygletWindowKeys.DOWN,
]

ALL_MODIFIERS = PygletWindowKeys.MOD_CTRL | PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_SHIFT

# Note, a lot of the functionality here is still buggy and very much a work in progress.


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1708">class InteractiveScene(Scene):
    """
    To select mobjects on screen, hold ctrl and move the mouse to highlight a region,
    or just tap ctrl to select the mobject under the cursor.
    
    Pressing command + t will toggle between modes where you either select top level
    mobjects part of the scene, or low level pieces.
    
    Hold 'g' to grab the selection and move it around
    Hold 'h' to drag it constrained in the horizontal direction
    Hold 'v' to drag it constrained in the vertical direction
    Hold 't' to resize selection, adding 'shift' to resize with respect to a corner
    
    Command + 'c' copies the ids of selections to clipboard
    Command + 'v' will paste either:
        - The copied mobject
        - A Tex mobject based on copied LaTeX
        - A Text mobject based on copied Text
    Command + 'z' restores selection back to its original state
    Command + 's' saves the selected mobjects to file
    """
    @others
</t>
<t tx="ekr.20250121054835.1709">corner_dot_config = dict(
    color=WHITE,
    radius=0.05,
    glow_factor=2.0,
)
selection_rectangle_stroke_color = WHITE
selection_rectangle_stroke_width = 1.0
palette_colors = MANIM_COLORS
selection_nudge_size = 0.05
cursor_location_config = dict(
    font_size=24,
    fill_color=GREY_C,
    num_decimal_places=3,
)
time_label_config = dict(
    font_size=24,
    fill_color=GREY_C,
    num_decimal_places=1,
)
crosshair_width = 0.2
crosshair_style = dict(
    stroke_color=GREY_A,
    stroke_width=[3, 0, 3],
)

def setup(self):
    self.selection = Group()
    self.selection_highlight = self.get_selection_highlight()
    self.selection_rectangle = self.get_selection_rectangle()
    self.crosshair = self.get_crosshair()
    self.information_label = self.get_information_label()
    self.color_palette = self.get_color_palette()
    self.unselectables = [
        self.selection,
        self.selection_highlight,
        self.selection_rectangle,
        self.crosshair,
        self.information_label,
        self.camera.frame
    ]
    self.select_top_level_mobs = True
    self.regenerate_selection_search_set()

    self.is_selecting = False
    self.is_grabbing = False

    self.add(self.selection_highlight)
</t>
<t tx="ekr.20250121054835.171">def update(self, alpha: float) -&gt; None:
    """
    This method shouldn't exist, but it's here to
    keep many old scenes from breaking
    """
    self.interpolate(alpha)
</t>
<t tx="ekr.20250121054835.1710">def get_selection_rectangle(self):
    rect = Rectangle(
        stroke_color=self.selection_rectangle_stroke_color,
        stroke_width=self.selection_rectangle_stroke_width,
    )
    rect.fix_in_frame()
    rect.fixed_corner = ORIGIN
    rect.add_updater(self.update_selection_rectangle)
    return rect
</t>
<t tx="ekr.20250121054835.1711">def update_selection_rectangle(self, rect: Rectangle):
    p1 = rect.fixed_corner
    p2 = self.frame.to_fixed_frame_point(self.mouse_point.get_center())
    rect.set_points_as_corners([
        p1, np.array([p2[0], p1[1], 0]),
        p2, np.array([p1[0], p2[1], 0]),
        p1,
    ])
    return rect
</t>
<t tx="ekr.20250121054835.1712">def get_selection_highlight(self):
    result = Group()
    result.tracked_mobjects = []
    result.add_updater(self.update_selection_highlight)
    return result
</t>
<t tx="ekr.20250121054835.1713">def update_selection_highlight(self, highlight: Mobject):
    if set(highlight.tracked_mobjects) == set(self.selection):
        return

    # Otherwise, refresh contents of highlight
    highlight.tracked_mobjects = list(self.selection)
    highlight.set_submobjects([
        self.get_highlight(mob)
        for mob in self.selection
    ])
    try:
        index = min((
            i for i, mob in enumerate(self.mobjects)
            for sm in self.selection
            if sm in mob.get_family()
        ))
        self.mobjects.remove(highlight)
        self.mobjects.insert(index - 1, highlight)
    except ValueError:
        pass
</t>
<t tx="ekr.20250121054835.1714">def get_crosshair(self):
    lines = VMobject().replicate(2)
    lines[0].set_points([LEFT, ORIGIN, RIGHT])
    lines[1].set_points([UP, ORIGIN, DOWN])
    crosshair = VGroup(*lines)

    crosshair.set_width(self.crosshair_width)
    crosshair.set_style(**self.crosshair_style)
    crosshair.set_animating_status(True)
    crosshair.fix_in_frame()
    return crosshair
</t>
<t tx="ekr.20250121054835.1715">def get_color_palette(self):
    palette = VGroup(*(
        Square(fill_color=color, fill_opacity=1, side_length=1)
        for color in self.palette_colors
    ))
    palette.set_stroke(width=0)
    palette.arrange(RIGHT, buff=0.5)
    palette.set_width(FRAME_WIDTH - 0.5)
    palette.to_edge(DOWN, buff=SMALL_BUFF)
    palette.fix_in_frame()
    return palette
</t>
<t tx="ekr.20250121054835.1716">def get_information_label(self):
    loc_label = VGroup(*(
        DecimalNumber(**self.cursor_location_config)
        for n in range(3)
    ))

    def update_coords(loc_label):
        for mob, coord in zip(loc_label, self.mouse_point.get_location()):
            mob.set_value(coord)
        loc_label.arrange(RIGHT, buff=loc_label.get_height())
        loc_label.to_corner(DR, buff=SMALL_BUFF)
        loc_label.fix_in_frame()
        return loc_label

    loc_label.add_updater(update_coords)

    time_label = DecimalNumber(0, **self.time_label_config)
    time_label.to_corner(DL, buff=SMALL_BUFF)
    time_label.fix_in_frame()
    time_label.add_updater(lambda m, dt: m.increment_value(dt))

    return VGroup(loc_label, time_label)
</t>
<t tx="ekr.20250121054835.1717"># Overrides
def get_state(self):
    return SceneState(self, ignore=[
        self.selection_highlight,
        self.selection_rectangle,
        self.crosshair,
    ])
</t>
<t tx="ekr.20250121054835.1718">def restore_state(self, scene_state: SceneState):
    super().restore_state(scene_state)
    self.mobjects.insert(0, self.selection_highlight)
</t>
<t tx="ekr.20250121054835.1719">def add(self, *mobjects: Mobject):
    super().add(*mobjects)
    self.regenerate_selection_search_set()
</t>
<t tx="ekr.20250121054835.172">def time_spanned_alpha(self, alpha: float) -&gt; float:
    if self.time_span is not None:
        start, end = self.time_span
        return clip(alpha * self.run_time - start, 0, end - start) / (end - start)
    return alpha
</t>
<t tx="ekr.20250121054835.1720">def remove(self, *mobjects: Mobject):
    super().remove(*mobjects)
    self.regenerate_selection_search_set()
</t>
<t tx="ekr.20250121054835.1721"># Related to selection

def toggle_selection_mode(self):
    self.select_top_level_mobs = not self.select_top_level_mobs
    self.refresh_selection_scope()
    self.regenerate_selection_search_set()
</t>
<t tx="ekr.20250121054835.1722">def get_selection_search_set(self) -&gt; list[Mobject]:
    return self.selection_search_set
</t>
<t tx="ekr.20250121054835.1723">def regenerate_selection_search_set(self):
    selectable = list(filter(
        lambda m: m not in self.unselectables,
        self.mobjects
    ))
    if self.select_top_level_mobs:
        self.selection_search_set = selectable
    else:
        self.selection_search_set = [
            submob
            for mob in selectable
            for submob in mob.family_members_with_points()
        ]
</t>
<t tx="ekr.20250121054835.1724">def refresh_selection_scope(self):
    curr = list(self.selection)
    if self.select_top_level_mobs:
        self.selection.set_submobjects([
            mob
            for mob in self.mobjects
            if any(sm in mob.get_family() for sm in curr)
        ])
        self.selection.refresh_bounding_box(recurse_down=True)
    else:
        self.selection.set_submobjects(
            extract_mobject_family_members(
                curr, exclude_pointless=True,
            )
        )
</t>
<t tx="ekr.20250121054835.1725">def get_corner_dots(self, mobject: Mobject) -&gt; Mobject:
    dots = DotCloud(**self.corner_dot_config)
    radius = float(self.corner_dot_config["radius"])
    if mobject.get_depth() &lt; 1e-2:
        vects = [DL, UL, UR, DR]
    else:
        vects = np.array(list(it.product(*3 * [[-1, 1]])))
    dots.add_updater(lambda d: d.set_points([
        mobject.get_corner(v) + v * radius
        for v in vects
    ]))
    return dots
</t>
<t tx="ekr.20250121054835.1726">def get_highlight(self, mobject: Mobject) -&gt; Mobject:
    if isinstance(mobject, VMobject) and mobject.has_points() and not self.select_top_level_mobs:
        length = max([mobject.get_height(), mobject.get_width()])
        result = VHighlight(
            mobject,
            max_stroke_addition=min([50 * length, 10]),
        )
        result.add_updater(lambda m: m.replace(mobject, stretch=True))
        return result
    elif isinstance(mobject, DotCloud):
        return Mobject()
    else:
        return self.get_corner_dots(mobject)
</t>
<t tx="ekr.20250121054835.1727">def add_to_selection(self, *mobjects: Mobject):
    mobs = list(filter(
        lambda m: m not in self.unselectables and m not in self.selection,
        mobjects
    ))
    if len(mobs) == 0:
        return
    self.selection.add(*mobs)
    for mob in mobs:
        mob.set_animating_status(True)
</t>
<t tx="ekr.20250121054835.1728">def toggle_from_selection(self, *mobjects: Mobject):
    for mob in mobjects:
        if mob in self.selection:
            self.selection.remove(mob)
            mob.set_animating_status(False)
            mob.refresh_bounding_box()
        else:
            self.add_to_selection(mob)
</t>
<t tx="ekr.20250121054835.1729">def clear_selection(self):
    for mob in self.selection:
        mob.set_animating_status(False)
        mob.refresh_bounding_box()
    self.selection.set_submobjects([])
</t>
<t tx="ekr.20250121054835.173">def interpolate_mobject(self, alpha: float) -&gt; None:
    for i, mobs in enumerate(self.families):
        sub_alpha = self.get_sub_alpha(self.time_spanned_alpha(alpha), i, len(self.families))
        self.interpolate_submobject(*mobs, sub_alpha)
</t>
<t tx="ekr.20250121054835.1730">def disable_interaction(self, *mobjects: Mobject):
    for mob in mobjects:
        for sm in mob.get_family():
            self.unselectables.append(sm)
    self.regenerate_selection_search_set()
</t>
<t tx="ekr.20250121054835.1731">def enable_interaction(self, *mobjects: Mobject):
    for mob in mobjects:
        for sm in mob.get_family():
            if sm in self.unselectables:
                self.unselectables.remove(sm)
</t>
<t tx="ekr.20250121054835.1732"># Functions for keyboard actions

def copy_selection(self):
    names = []
    shell = get_ipython()
    for mob in self.selection:
        name = str(id(mob))
        if shell is None:
            continue
        for key, value in shell.user_ns.items():
            if mob is value:
                name = key
        names.append(name)
    pyperclip.copy(", ".join(names))
</t>
<t tx="ekr.20250121054835.1733">def paste_selection(self):
    clipboard_str = pyperclip.paste()
    # Try pasting a mobject
    try:
        ids = map(int, clipboard_str.split(","))
        mobs = map(self.id_to_mobject, ids)
        mob_copies = [m.copy() for m in mobs if m is not None]
        self.clear_selection()
        self.play(*(
            FadeIn(mc, run_time=0.5, scale=1.5)
            for mc in mob_copies
        ))
        self.add_to_selection(*mob_copies)
        return
    except ValueError:
        pass
    # Otherwise, treat as tex or text
    if set("\\^=+").intersection(clipboard_str):  # Proxy to text for LaTeX
        try:
            new_mob = Tex(clipboard_str)
        except LatexError:
            return
    else:
        new_mob = Text(clipboard_str)
    self.clear_selection()
    self.add(new_mob)
    self.add_to_selection(new_mob)
</t>
<t tx="ekr.20250121054835.1734">def delete_selection(self):
    self.remove(*self.selection)
    self.clear_selection()
</t>
<t tx="ekr.20250121054835.1735">def enable_selection(self):
    self.is_selecting = True
    self.add(self.selection_rectangle)
    self.selection_rectangle.fixed_corner = self.frame.to_fixed_frame_point(
        self.mouse_point.get_center()
    )
</t>
<t tx="ekr.20250121054835.1736">def gather_new_selection(self):
    self.is_selecting = False
    if self.selection_rectangle in self.mobjects:
        self.remove(self.selection_rectangle)
        additions = []
        for mob in reversed(self.get_selection_search_set()):
            if self.selection_rectangle.is_touching(mob):
                additions.append(mob)
                if self.selection_rectangle.get_arc_length() &lt; 1e-2:
                    break
        self.toggle_from_selection(*additions)
</t>
<t tx="ekr.20250121054835.1737">def prepare_grab(self):
    mp = self.mouse_point.get_center()
    self.mouse_to_selection = mp - self.selection.get_center()
    self.is_grabbing = True
</t>
<t tx="ekr.20250121054835.1738">def prepare_resizing(self, about_corner=False):
    center = self.selection.get_center()
    mp = self.mouse_point.get_center()
    if about_corner:
        self.scale_about_point = self.selection.get_corner(center - mp)
    else:
        self.scale_about_point = center
    self.scale_ref_vect = mp - self.scale_about_point
    self.scale_ref_width = self.selection.get_width()
    self.scale_ref_height = self.selection.get_height()
</t>
<t tx="ekr.20250121054835.1739">def toggle_color_palette(self):
    if len(self.selection) == 0:
        return
    if self.color_palette not in self.mobjects:
        self.save_state()
        self.add(self.color_palette)
    else:
        self.remove(self.color_palette)
</t>
<t tx="ekr.20250121054835.174">def interpolate_submobject(
    self,
    submobject: Mobject,
    starting_submobject: Mobject,
    alpha: float
):
    # Typically ipmlemented by subclass
    pass
</t>
<t tx="ekr.20250121054835.1740">def display_information(self, show=True):
    if show:
        self.add(self.information_label)
    else:
        self.remove(self.information_label)
</t>
<t tx="ekr.20250121054835.1741">def group_selection(self):
    group = self.get_group(*self.selection)
    self.add(group)
    self.clear_selection()
    self.add_to_selection(group)
</t>
<t tx="ekr.20250121054835.1742">def ungroup_selection(self):
    pieces = []
    for mob in list(self.selection):
        self.remove(mob)
        pieces.extend(list(mob))
    self.clear_selection()
    self.add(*pieces)
    self.add_to_selection(*pieces)
</t>
<t tx="ekr.20250121054835.1743">def nudge_selection(self, vect: np.ndarray, large: bool = False):
    nudge = self.selection_nudge_size
    if large:
        nudge *= 10
    self.selection.shift(nudge * vect)
</t>
<t tx="ekr.20250121054835.1744"># Key actions
def on_key_press(self, symbol: int, modifiers: int) -&gt; None:
    super().on_key_press(symbol, modifiers)
    char = chr(symbol)
    if char == SELECT_KEY and (modifiers &amp; ALL_MODIFIERS) == 0:
        self.enable_selection()
    if char == UNSELECT_KEY:
        self.clear_selection()
    elif char in GRAB_KEYS and (modifiers &amp; ALL_MODIFIERS) == 0:
        self.prepare_grab()
    elif char == RESIZE_KEY and (modifiers &amp; PygletWindowKeys.MOD_SHIFT):
        self.prepare_resizing(about_corner=((modifiers &amp; PygletWindowKeys.MOD_SHIFT) &gt; 0))
    elif symbol == PygletWindowKeys.LSHIFT:
        if self.window.is_key_pressed(ord("t")):
            self.prepare_resizing(about_corner=True)
    elif char == COLOR_KEY and (modifiers &amp; ALL_MODIFIERS) == 0:
        self.toggle_color_palette()
    elif char == INFORMATION_KEY and (modifiers &amp; ALL_MODIFIERS) == 0:
        self.display_information()
    elif char == "c" and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL)):
        self.copy_selection()
    elif char == "v" and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL)):
        self.paste_selection()
    elif char == "x" and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL)):
        self.copy_selection()
        self.delete_selection()
    elif symbol == PygletWindowKeys.BACKSPACE:
        self.delete_selection()
    elif char == "a" and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL)):
        self.clear_selection()
        self.add_to_selection(*self.mobjects)
    elif char == "g" and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL)):
        self.group_selection()
    elif char == "g" and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL | PygletWindowKeys.MOD_SHIFT)):
        self.ungroup_selection()
    elif char == "t" and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL)):
        self.toggle_selection_mode()
    elif char == "d" and (modifiers &amp; PygletWindowKeys.MOD_SHIFT):
        self.copy_frame_positioning()
    elif char == "c" and (modifiers &amp; PygletWindowKeys.MOD_SHIFT):
        self.copy_cursor_position()
    elif symbol in ARROW_SYMBOLS:
        self.nudge_selection(
            vect=[LEFT, UP, RIGHT, DOWN][ARROW_SYMBOLS.index(symbol)],
            large=(modifiers &amp; PygletWindowKeys.MOD_SHIFT),
        )
    # Adding crosshair
    if char == CURSOR_KEY:
        if self.crosshair in self.mobjects:
            self.remove(self.crosshair)
        else:
            self.add(self.crosshair)
    if char == SELECT_KEY:
        self.add(self.crosshair)

    # Conditions for saving state
    if char in [GRAB_KEY, X_GRAB_KEY, Y_GRAB_KEY, RESIZE_KEY]:
        self.save_state()
</t>
<t tx="ekr.20250121054835.1745">def on_key_release(self, symbol: int, modifiers: int) -&gt; None:
    super().on_key_release(symbol, modifiers)
    if chr(symbol) == SELECT_KEY:
        self.gather_new_selection()
    if chr(symbol) in GRAB_KEYS:
        self.is_grabbing = False
    elif chr(symbol) == INFORMATION_KEY:
        self.display_information(False)
    elif symbol == PygletWindowKeys.LSHIFT and self.window.is_key_pressed(ord(RESIZE_KEY)):
        self.prepare_resizing(about_corner=False)
</t>
<t tx="ekr.20250121054835.1746"># Mouse actions
def handle_grabbing(self, point: Vect3):
    diff = point - self.mouse_to_selection
    if self.window.is_key_pressed(ord(GRAB_KEY)):
        self.selection.move_to(diff)
    elif self.window.is_key_pressed(ord(X_GRAB_KEY)):
        self.selection.set_x(diff[0])
    elif self.window.is_key_pressed(ord(Y_GRAB_KEY)):
        self.selection.set_y(diff[1])
</t>
<t tx="ekr.20250121054835.1747">def handle_resizing(self, point: Vect3):
    if not hasattr(self, "scale_about_point"):
        return
    vect = point - self.scale_about_point
    if self.window.is_key_pressed(PygletWindowKeys.LCTRL):
        for i in (0, 1):
            scalar = vect[i] / self.scale_ref_vect[i]
            self.selection.rescale_to_fit(
                scalar * [self.scale_ref_width, self.scale_ref_height][i],
                dim=i,
                about_point=self.scale_about_point,
                stretch=True,
            )
    else:
        scalar = get_norm(vect) / get_norm(self.scale_ref_vect)
        self.selection.set_width(
            scalar * self.scale_ref_width,
            about_point=self.scale_about_point
        )
</t>
<t tx="ekr.20250121054835.1748">def handle_sweeping_selection(self, point: Vect3):
    mob = self.point_to_mobject(
        point,
        search_set=self.get_selection_search_set(),
        buff=SMALL_BUFF
    )
    if mob is not None:
        self.add_to_selection(mob)
</t>
<t tx="ekr.20250121054835.1749">def choose_color(self, point: Vect3):
    # Search through all mobject on the screen, not just the palette
    to_search = [
        sm
        for mobject in self.mobjects
        for sm in mobject.family_members_with_points()
        if mobject not in self.unselectables
    ]
    mob = self.point_to_mobject(point, to_search)
    if mob is not None:
        self.selection.set_color(mob.get_color())
    self.remove(self.color_palette)
</t>
<t tx="ekr.20250121054835.175">def get_sub_alpha(
    self,
    alpha: float,
    index: int,
    num_submobjects: int
) -&gt; float:
    # TODO, make this more understanable, and/or combine
    # its functionality with AnimationGroup's method
    # build_animations_with_timings
    lag_ratio = self.lag_ratio
    full_length = (num_submobjects - 1) * lag_ratio + 1
    value = alpha * full_length
    lower = index * lag_ratio
    raw_sub_alpha = clip((value - lower), 0, 1)
    return self.rate_func(raw_sub_alpha)
</t>
<t tx="ekr.20250121054835.1750">def on_mouse_motion(self, point: Vect3, d_point: Vect3) -&gt; None:
    super().on_mouse_motion(point, d_point)
    self.crosshair.move_to(self.frame.to_fixed_frame_point(point))
    if self.is_grabbing:
        self.handle_grabbing(point)
    elif self.window.is_key_pressed(ord(RESIZE_KEY)):
        self.handle_resizing(point)
    elif self.window.is_key_pressed(ord(SELECT_KEY)) and self.window.is_key_pressed(PygletWindowKeys.LSHIFT):
        self.handle_sweeping_selection(point)
</t>
<t tx="ekr.20250121054835.1751">def on_mouse_drag(
    self,
    point: Vect3,
    d_point: Vect3,
    buttons: int,
    modifiers: int
) -&gt; None:
    super().on_mouse_drag(point, d_point, buttons, modifiers)
    self.crosshair.move_to(self.frame.to_fixed_frame_point(point))
</t>
<t tx="ekr.20250121054835.1752">def on_mouse_release(self, point: Vect3, button: int, mods: int) -&gt; None:
    super().on_mouse_release(point, button, mods)
    if self.color_palette in self.mobjects:
        self.choose_color(point)
    else:
        self.clear_selection()
</t>
<t tx="ekr.20250121054835.1753"># Copying code to recreate state
def copy_frame_positioning(self):
    frame = self.frame
    center = frame.get_center()
    height = frame.get_height()
    angles = frame.get_euler_angles()

    call = f"reorient("
    theta, phi, gamma = (angles / DEG).astype(int)
    call += f"{theta}, {phi}, {gamma}"
    if any(center != 0):
        call += f", {tuple(np.round(center, 2))}"
    if height != FRAME_HEIGHT:
        call += ", {:.2f}".format(height)
    call += ")"
    pyperclip.copy(call)
</t>
<t tx="ekr.20250121054835.1754">def copy_cursor_position(self):
    pyperclip.copy(str(tuple(self.mouse_point.get_center().round(2))))
</t>
<t tx="ekr.20250121054835.1755">from __future__ import annotations

from collections import OrderedDict
import platform
import random
import time
from functools import wraps
from contextlib import contextmanager
from contextlib import ExitStack

from pyglet.window import key as PygletWindowKeys

import numpy as np
from tqdm.auto import tqdm as ProgressDisplay

from manimlib.animation.animation import prepare_animation
from manimlib.camera.camera import Camera
from manimlib.camera.camera_frame import CameraFrame
from manimlib.config import manim_config
from manimlib.event_handler import EVENT_DISPATCHER
from manimlib.event_handler.event_type import EventType
from manimlib.logger import log
from manimlib.mobject.mobject import _AnimationBuilder
from manimlib.mobject.mobject import Group
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.mobject import Point
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.scene.scene_embed import InteractiveSceneEmbed
from manimlib.scene.scene_embed import CheckpointManager
from manimlib.scene.scene_file_writer import SceneFileWriter
from manimlib.utils.dict_ops import merge_dicts_recursively
from manimlib.utils.family_ops import extract_mobject_family_members
from manimlib.utils.family_ops import recursive_mobject_remove
from manimlib.utils.iterables import batch_by_property
from manimlib.window import Window

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, Iterable, TypeVar, Optional
    from manimlib.typing import Vect3

    T = TypeVar('T')

    from PIL.Image import Image

    from manimlib.animation.animation import Animation


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1756">class Scene(object):
    @others
</t>
<t tx="ekr.20250121054835.1757">random_seed: int = 0
pan_sensitivity: float = 0.5
scroll_sensitivity: float = 20
drag_to_pan: bool = True
max_num_saved_states: int = 50
default_camera_config: dict = dict()
default_file_writer_config: dict = dict()
samples = 0
# Euler angles, in degrees
default_frame_orientation = (0, 0)

def __init__(
    self,
    window: Optional[Window] = None,
    camera_config: dict = dict(),
    file_writer_config: dict = dict(),
    skip_animations: bool = False,
    always_update_mobjects: bool = False,
    start_at_animation_number: int | None = None,
    end_at_animation_number: int | None = None,
    show_animation_progress: bool = False,
    leave_progress_bars: bool = False,
    preview_while_skipping: bool = True,
    presenter_mode: bool = False,
    default_wait_time: float = 1.0,
</t>
<t tx="ekr.20250121054835.1758">):
    self.skip_animations = skip_animations
    self.always_update_mobjects = always_update_mobjects
    self.start_at_animation_number = start_at_animation_number
    self.end_at_animation_number = end_at_animation_number
    self.show_animation_progress = show_animation_progress
    self.leave_progress_bars = leave_progress_bars
    self.preview_while_skipping = preview_while_skipping
    self.presenter_mode = presenter_mode
    self.default_wait_time = default_wait_time

    self.camera_config = merge_dicts_recursively(
        manim_config.camera,         # Global default
        self.default_camera_config,  # Updated configuration that subclasses may specify
        camera_config,               # Updated configuration from instantiation
    )
    self.file_writer_config = merge_dicts_recursively(
        manim_config.file_writer,
        self.default_file_writer_config,
        file_writer_config,
    )

    self.window = window
    if self.window:
        self.window.init_for_scene(self)
        # Make sure camera and Pyglet window sync
        self.camera_config["fps"] = 30

    # Core state of the scene
    self.camera: Camera = Camera(
        window=self.window,
        samples=self.samples,
        **self.camera_config
    )
    self.frame: CameraFrame = self.camera.frame
    self.frame.reorient(*self.default_frame_orientation)
    self.frame.make_orientation_default()

    self.file_writer = SceneFileWriter(self, **self.file_writer_config)
    self.mobjects: list[Mobject] = [self.camera.frame]
    self.render_groups: list[Mobject] = []
    self.id_to_mobject_map: dict[int, Mobject] = dict()
    self.num_plays: int = 0
    self.time: float = 0
    self.skip_time: float = 0
    self.original_skipping_status: bool = self.skip_animations
    self.undo_stack = []
    self.redo_stack = []

    if self.start_at_animation_number is not None:
        self.skip_animations = True
    if self.file_writer.has_progress_display():
        self.show_animation_progress = False

    # Items associated with interaction
    self.mouse_point = Point()
    self.mouse_drag_point = Point()
    self.hold_on_wait = self.presenter_mode
    self.quit_interaction = False

    # Much nicer to work with deterministic scenes
    if self.random_seed is not None:
        random.seed(self.random_seed)
        np.random.seed(self.random_seed)

def __str__(self) -&gt; str:
    return self.__class__.__name__
</t>
<t tx="ekr.20250121054835.1759">def get_window(self) -&gt; Window | None:
    return self.window
</t>
<t tx="ekr.20250121054835.176"># Getters and setters
def set_run_time(self, run_time: float):
    self.run_time = run_time
    return self
</t>
<t tx="ekr.20250121054835.1760">def run(self) -&gt; None:
    self.virtual_animation_start_time: float = 0
    self.real_animation_start_time: float = time.time()
    self.file_writer.begin()

    self.setup()
    try:
        self.construct()
        self.interact()
    except EndScene:
        pass
    except KeyboardInterrupt:
        # Get rid keyboard interupt symbols
        print("", end="\r")
        self.file_writer.ended_with_interrupt = True
    self.tear_down()
</t>
<t tx="ekr.20250121054835.1761">def setup(self) -&gt; None:
    """
    This is meant to be implement by any scenes which
    are comonly subclassed, and have some common setup
    involved before the construct method is called.
    """
    pass
</t>
<t tx="ekr.20250121054835.1762">def construct(self) -&gt; None:
    # Where all the animation happens
    # To be implemented in subclasses
    pass
</t>
<t tx="ekr.20250121054835.1763">def tear_down(self) -&gt; None:
    self.stop_skipping()
    self.file_writer.finish()
    if self.window:
        self.window.destroy()
        self.window = None
</t>
<t tx="ekr.20250121054835.1764">def interact(self) -&gt; None:
    """
    If there is a window, enter a loop
    which updates the frame while under
    the hood calling the pyglet event loop
    """
    if self.window is None:
        return
    log.info(
        "\nTips: Using the keys `d`, `f`, or `z` " +
        "you can interact with the scene. " +
        "Press `command + q` or `esc` to quit"
    )
    self.skip_animations = False
    while not self.is_window_closing():
        self.update_frame(1 / self.camera.fps)
</t>
<t tx="ekr.20250121054835.1765">def embed(
    self,
    close_scene_on_exit: bool = True,
    show_animation_progress: bool = False,
) -&gt; None:
    if not self.window:
        # Embed is only relevant for interactive development with a Window
        return
    self.show_animation_progress = show_animation_progress
    self.stop_skipping()
    self.update_frame(force_draw=True)

    InteractiveSceneEmbed(self).launch()

    # End scene when exiting an embed
    if close_scene_on_exit:
        raise EndScene()
</t>
<t tx="ekr.20250121054835.1766"># Only these methods should touch the camera

def get_image(self) -&gt; Image:
    if self.window is not None:
        self.camera.use_window_fbo(False)
        self.camera.capture(*self.render_groups)
    image = self.camera.get_image()
    if self.window is not None:
        self.camera.use_window_fbo(True)
    return image
</t>
<t tx="ekr.20250121054835.1767">def show(self) -&gt; None:
    self.update_frame(force_draw=True)
    self.get_image().show()
</t>
<t tx="ekr.20250121054835.1768">def update_frame(self, dt: float = 0, force_draw: bool = False) -&gt; None:
    self.increment_time(dt)
    self.update_mobjects(dt)
    if self.skip_animations and not force_draw:
        return

    if self.is_window_closing():
        raise EndScene()

    if self.window and dt == 0 and not self.window.has_undrawn_event() and not force_draw:
        # In this case, there's no need for new rendering, but we
        # shoudl still listen for new events
        self.window._window.dispatch_events()
        return

    self.camera.capture(*self.render_groups)

    if self.window and not self.skip_animations:
        vt = self.time - self.virtual_animation_start_time
        rt = time.time() - self.real_animation_start_time
        time.sleep(max(vt - rt, 0))
</t>
<t tx="ekr.20250121054835.1769">def emit_frame(self) -&gt; None:
    if not self.skip_animations:
        self.file_writer.write_frame(self.camera)
</t>
<t tx="ekr.20250121054835.177">def get_run_time(self) -&gt; float:
    if self.time_span:
        return max(self.run_time, self.time_span[1])
    return self.run_time
</t>
<t tx="ekr.20250121054835.1770"># Related to updating

def update_mobjects(self, dt: float) -&gt; None:
    for mobject in self.mobjects:
        mobject.update(dt)
</t>
<t tx="ekr.20250121054835.1771">def should_update_mobjects(self) -&gt; bool:
    return self.always_update_mobjects or any(
        mob.has_updaters() for mob in self.mobjects
    )
</t>
<t tx="ekr.20250121054835.1772"># Related to time

def get_time(self) -&gt; float:
    return self.time
</t>
<t tx="ekr.20250121054835.1773">def increment_time(self, dt: float) -&gt; None:
    self.time += dt
</t>
<t tx="ekr.20250121054835.1774"># Related to internal mobject organization

def get_top_level_mobjects(self) -&gt; list[Mobject]:
    # Return only those which are not in the family
    # of another mobject from the scene
    mobjects = self.get_mobjects()
    families = [m.get_family() for m in mobjects]

    def is_top_level(mobject):
        num_families = sum([
            (mobject in family)
            for family in families
        ])
        return num_families == 1
    return list(filter(is_top_level, mobjects))
</t>
<t tx="ekr.20250121054835.1775">def get_mobject_family_members(self) -&gt; list[Mobject]:
    return extract_mobject_family_members(self.mobjects)
</t>
<t tx="ekr.20250121054835.1776">def assemble_render_groups(self):
    """
    Rendering can be more efficient when mobjects of the
    same type are grouped together, so this function creates
    Groups of all clusters of adjacent Mobjects in the scene
    """
    batches = batch_by_property(
        self.mobjects,
        lambda m: str(type(m)) + str(m.get_shader_wrapper(self.camera.ctx).get_id()) + str(m.z_index)
    )

    for group in self.render_groups:
        group.clear()
    self.render_groups = [
        batch[0].get_group_class()(*batch)
        for batch, key in batches
    ]
</t>
<t tx="ekr.20250121054835.1777">@staticmethod
def affects_mobject_list(func: Callable[..., T]) -&gt; Callable[..., T]:
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        func(self, *args, **kwargs)
        self.assemble_render_groups()
        return self
    return wrapper
</t>
<t tx="ekr.20250121054835.1778">@affects_mobject_list
def add(self, *new_mobjects: Mobject):
    """
    Mobjects will be displayed, from background to
    foreground in the order with which they are added.
    """
    self.remove(*new_mobjects)
    self.mobjects += new_mobjects

    # Reorder based on z_index
    id_to_scene_order = {id(m): idx for idx, m in enumerate(self.mobjects)}
    self.mobjects.sort(key=lambda m: (m.z_index, id_to_scene_order[id(m)]))

    self.id_to_mobject_map.update({
        id(sm): sm
        for m in new_mobjects
        for sm in m.get_family()
    })
    return self
</t>
<t tx="ekr.20250121054835.1779">def add_mobjects_among(self, values: Iterable):
    """
    This is meant mostly for quick prototyping,
    e.g. to add all mobjects defined up to a point,
    call self.add_mobjects_among(locals().values())
    """
    self.add(*filter(
        lambda m: isinstance(m, Mobject),
        values
    ))
    return self
</t>
<t tx="ekr.20250121054835.178">def set_rate_func(self, rate_func: Callable[[float], float]):
    self.rate_func = rate_func
    return self
</t>
<t tx="ekr.20250121054835.1780">@affects_mobject_list
def replace(self, mobject: Mobject, *replacements: Mobject):
    if mobject in self.mobjects:
        index = self.mobjects.index(mobject)
        self.mobjects = [
            *self.mobjects[:index],
            *replacements,
            *self.mobjects[index + 1:]
        ]
    return self
</t>
<t tx="ekr.20250121054835.1781">@affects_mobject_list
def remove(self, *mobjects_to_remove: Mobject):
    """
    Removes anything in mobjects from scenes mobject list, but in the event that one
    of the items to be removed is a member of the family of an item in mobject_list,
    the other family members are added back into the list.

    For example, if the scene includes Group(m1, m2, m3), and we call scene.remove(m1),
    the desired behavior is for the scene to then include m2 and m3 (ungrouped).
    """
    to_remove = set(extract_mobject_family_members(mobjects_to_remove))
    new_mobjects, _ = recursive_mobject_remove(self.mobjects, to_remove)
    self.mobjects = new_mobjects
</t>
<t tx="ekr.20250121054835.1782">def bring_to_front(self, *mobjects: Mobject):
    self.add(*mobjects)
    return self
</t>
<t tx="ekr.20250121054835.1783">@affects_mobject_list
def bring_to_back(self, *mobjects: Mobject):
    self.remove(*mobjects)
    self.mobjects = list(mobjects) + self.mobjects
    return self
</t>
<t tx="ekr.20250121054835.1784">@affects_mobject_list
def clear(self):
    self.mobjects = []
    return self
</t>
<t tx="ekr.20250121054835.1785">def get_mobjects(self) -&gt; list[Mobject]:
    return list(self.mobjects)
</t>
<t tx="ekr.20250121054835.1786">def get_mobject_copies(self) -&gt; list[Mobject]:
    return [m.copy() for m in self.mobjects]
</t>
<t tx="ekr.20250121054835.1787">def point_to_mobject(
    self,
    point: np.ndarray,
    search_set: Iterable[Mobject] | None = None,
    buff: float = 0
) -&gt; Mobject | None:
    """
    E.g. if clicking on the scene, this returns the top layer mobject
    under a given point
    """
    if search_set is None:
        search_set = self.mobjects
    for mobject in reversed(search_set):
        if mobject.is_point_touching(point, buff=buff):
            return mobject
    return None
</t>
<t tx="ekr.20250121054835.1788">def get_group(self, *mobjects):
    if all(isinstance(m, VMobject) for m in mobjects):
        return VGroup(*mobjects)
    else:
        return Group(*mobjects)
</t>
<t tx="ekr.20250121054835.1789">def id_to_mobject(self, id_value):
    return self.id_to_mobject_map[id_value]
</t>
<t tx="ekr.20250121054835.179">def get_rate_func(self) -&gt; Callable[[float], float]:
    return self.rate_func
</t>
<t tx="ekr.20250121054835.1790">def ids_to_group(self, *id_values):
    return self.get_group(*filter(
        lambda x: x is not None,
        map(self.id_to_mobject, id_values)
    ))
</t>
<t tx="ekr.20250121054835.1791">def i2g(self, *id_values):
    return self.ids_to_group(*id_values)
</t>
<t tx="ekr.20250121054835.1792">def i2m(self, id_value):
    return self.id_to_mobject(id_value)
</t>
<t tx="ekr.20250121054835.1793"># Related to skipping

def update_skipping_status(self) -&gt; None:
    if self.start_at_animation_number is not None:
        if self.num_plays == self.start_at_animation_number:
            self.skip_time = self.time
            if not self.original_skipping_status:
                self.stop_skipping()
    if self.end_at_animation_number is not None:
        if self.num_plays &gt;= self.end_at_animation_number:
            raise EndScene()
</t>
<t tx="ekr.20250121054835.1794">def stop_skipping(self) -&gt; None:
    self.virtual_animation_start_time = self.time
    self.real_animation_start_time = time.time()
    self.skip_animations = False
</t>
<t tx="ekr.20250121054835.1795"># Methods associated with running animations

def get_time_progression(
    self,
    run_time: float,
    n_iterations: int | None = None,
    desc: str = "",
    override_skip_animations: bool = False
) -&gt; list[float] | np.ndarray | ProgressDisplay:
    if self.skip_animations and not override_skip_animations:
        return [run_time]

    times = np.arange(0, run_time, 1 / self.camera.fps) + 1 / self.camera.fps

    self.file_writer.set_progress_display_description(sub_desc=desc)

    if self.show_animation_progress:
        return ProgressDisplay(
            times,
            total=n_iterations,
            leave=self.leave_progress_bars,
            ascii=True if platform.system() == 'Windows' else None,
            desc=desc,
            bar_format="{l_bar} {n_fmt:3}/{total_fmt:3} {rate_fmt}{postfix}",
        )
    else:
        return times
</t>
<t tx="ekr.20250121054835.1796">def get_run_time(self, animations: Iterable[Animation]) -&gt; float:
    return np.max([animation.get_run_time() for animation in animations])
</t>
<t tx="ekr.20250121054835.1797">def get_animation_time_progression(
    self,
    animations: Iterable[Animation]
) -&gt; list[float] | np.ndarray | ProgressDisplay:
    animations = list(animations)
    run_time = self.get_run_time(animations)
    description = f"{self.num_plays} {animations[0]}"
    if len(animations) &gt; 1:
        description += ", etc."
    time_progression = self.get_time_progression(run_time, desc=description)
    return time_progression
</t>
<t tx="ekr.20250121054835.1798">def get_wait_time_progression(
    self,
    duration: float,
    stop_condition: Callable[[], bool] | None = None
) -&gt; list[float] | np.ndarray | ProgressDisplay:
    kw = {"desc": f"{self.num_plays} Waiting"}
    if stop_condition is not None:
        kw["n_iterations"] = -1  # So it doesn't show % progress
        kw["override_skip_animations"] = True
    return self.get_time_progression(duration, **kw)
</t>
<t tx="ekr.20250121054835.1799">def pre_play(self):
    if self.presenter_mode and self.num_plays == 0:
        self.hold_loop()

    self.update_skipping_status()

    if not self.skip_animations:
        self.file_writer.begin_animation()

    if self.window:
        self.virtual_animation_start_time = self.time
        self.real_animation_start_time = time.time()
</t>
<t tx="ekr.20250121054835.18">def construct(self):
    axes = Axes((-3, 10), (-1, 8), height=6)
    axes.add_coordinate_labels()

    self.play(Write(axes, lag_ratio=0.01, run_time=1))

    # Axes.get_graph will return the graph of a function
    sin_graph = axes.get_graph(
        lambda x: 2 * math.sin(x),
        color=BLUE,
    )
    # By default, it draws it so as to somewhat smoothly interpolate
    # between sampled points (x, f(x)).  If the graph is meant to have
    # a corner, though, you can set use_smoothing to False
    relu_graph = axes.get_graph(
        lambda x: max(x, 0),
        use_smoothing=False,
        color=YELLOW,
    )
    # For discontinuous functions, you can specify the point of
    # discontinuity so that it does not try to draw over the gap.
    step_graph = axes.get_graph(
        lambda x: 2.0 if x &gt; 3 else 1.0,
        discontinuities=[3],
        color=GREEN,
    )

    # Axes.get_graph_label takes in either a string or a mobject.
    # If it's a string, it treats it as a LaTeX expression.  By default
    # it places the label next to the graph near the right side, and
    # has it match the color of the graph
    sin_label = axes.get_graph_label(sin_graph, "\\sin(x)")
    relu_label = axes.get_graph_label(relu_graph, Text("ReLU"))
    step_label = axes.get_graph_label(step_graph, Text("Step"), x=4)

    self.play(
        ShowCreation(sin_graph),
        FadeIn(sin_label, RIGHT),
    )
    self.wait(2)
    self.play(
        ReplacementTransform(sin_graph, relu_graph),
        FadeTransform(sin_label, relu_label),
    )
    self.wait()
    self.play(
        ReplacementTransform(relu_graph, step_graph),
        FadeTransform(relu_label, step_label),
    )
    self.wait()

    parabola = axes.get_graph(lambda x: 0.25 * x**2)
    parabola.set_stroke(BLUE)
    self.play(
        FadeOut(step_graph),
        FadeOut(step_label),
        ShowCreation(parabola)
    )
    self.wait()

    # You can use axes.input_to_graph_point, abbreviated
    # to axes.i2gp, to find a particular point on a graph
    dot = Dot(color=RED)
    dot.move_to(axes.i2gp(2, parabola))
    self.play(FadeIn(dot, scale=0.5))

    # A value tracker lets us animate a parameter, usually
    # with the intent of having other mobjects update based
    # on the parameter
    x_tracker = ValueTracker(2)
    dot.add_updater(lambda d: d.move_to(axes.i2gp(x_tracker.get_value(), parabola)))

    self.play(x_tracker.animate.set_value(4), run_time=3)
    self.play(x_tracker.animate.set_value(-2), run_time=3)
    self.wait()
</t>
<t tx="ekr.20250121054835.180">def set_name(self, name: str):
    self.name = name
    return self
</t>
<t tx="ekr.20250121054835.1800">def post_play(self):
    if not self.skip_animations:
        self.file_writer.end_animation()

    if self.preview_while_skipping and self.skip_animations and self.window is not None:
        # Show some quick frames along the way
        self.update_frame(dt=0, force_draw=True)

    self.num_plays += 1
</t>
<t tx="ekr.20250121054835.1801">def begin_animations(self, animations: Iterable[Animation]) -&gt; None:
    all_mobjects = set(self.get_mobject_family_members())
    for animation in animations:
        animation.begin()
        # Anything animated that's not already in the
        # scene gets added to the scene.  Note, for
        # animated mobjects that are in the family of
        # those on screen, this can result in a restructuring
        # of the scene.mobjects list, which is usually desired.
        if animation.mobject not in all_mobjects:
            self.add(animation.mobject)
            all_mobjects = all_mobjects.union(animation.mobject.get_family())
</t>
<t tx="ekr.20250121054835.1802">def progress_through_animations(self, animations: Iterable[Animation]) -&gt; None:
    last_t = 0
    for t in self.get_animation_time_progression(animations):
        dt = t - last_t
        last_t = t
        for animation in animations:
            animation.update_mobjects(dt)
            alpha = t / animation.run_time
            animation.interpolate(alpha)
        self.update_frame(dt)
        self.emit_frame()
</t>
<t tx="ekr.20250121054835.1803">def finish_animations(self, animations: Iterable[Animation]) -&gt; None:
    for animation in animations:
        animation.finish()
        animation.clean_up_from_scene(self)
    if self.skip_animations:
        self.update_mobjects(self.get_run_time(animations))
    else:
        self.update_mobjects(0)
</t>
<t tx="ekr.20250121054835.1804">@affects_mobject_list
def play(
    self,
    *proto_animations: Animation | _AnimationBuilder,
    run_time: float | None = None,
    rate_func: Callable[[float], float] | None = None,
    lag_ratio: float | None = None,
) -&gt; None:
    if len(proto_animations) == 0:
        log.warning("Called Scene.play with no animations")
        return
    animations = list(map(prepare_animation, proto_animations))
    for anim in animations:
        anim.update_rate_info(run_time, rate_func, lag_ratio)
    self.pre_play()
    self.begin_animations(animations)
    self.progress_through_animations(animations)
    self.finish_animations(animations)
    self.post_play()
</t>
<t tx="ekr.20250121054835.1805">def wait(
    self,
    duration: Optional[float] = None,
    stop_condition: Callable[[], bool] = None,
    note: str = None,
    ignore_presenter_mode: bool = False
):
    if duration is None:
        duration = self.default_wait_time
    self.pre_play()
    self.update_mobjects(dt=0)  # Any problems with this?
    if self.presenter_mode and not self.skip_animations and not ignore_presenter_mode:
        if note:
            log.info(note)
        self.hold_loop()
    else:
        time_progression = self.get_wait_time_progression(duration, stop_condition)
        last_t = 0
        for t in time_progression:
            dt = t - last_t
            last_t = t
            self.update_frame(dt)
            self.emit_frame()
            if stop_condition is not None and stop_condition():
                break
    self.post_play()
</t>
<t tx="ekr.20250121054835.1806">def hold_loop(self):
    while self.hold_on_wait:
        self.update_frame(dt=1 / self.camera.fps)
    self.hold_on_wait = True
</t>
<t tx="ekr.20250121054835.1807">def wait_until(
    self,
    stop_condition: Callable[[], bool],
    max_time: float = 60
):
    self.wait(max_time, stop_condition=stop_condition)
</t>
<t tx="ekr.20250121054835.1808">def force_skipping(self):
    self.original_skipping_status = self.skip_animations
    self.skip_animations = True
    return self
</t>
<t tx="ekr.20250121054835.1809">def revert_to_original_skipping_status(self):
    if hasattr(self, "original_skipping_status"):
        self.skip_animations = self.original_skipping_status
    return self
</t>
<t tx="ekr.20250121054835.181">def is_remover(self) -&gt; bool:
    return self.remover
</t>
<t tx="ekr.20250121054835.1810">def add_sound(
    self,
    sound_file: str,
    time_offset: float = 0,
    gain: float | None = None,
    gain_to_background: float | None = None
):
    if self.skip_animations:
        return
    time = self.get_time() + time_offset
    self.file_writer.add_sound(sound_file, time, gain, gain_to_background)
</t>
<t tx="ekr.20250121054835.1811"># Helpers for interactive development

def get_state(self) -&gt; SceneState:
    return SceneState(self)
</t>
<t tx="ekr.20250121054835.1812">@affects_mobject_list
def restore_state(self, scene_state: SceneState):
    scene_state.restore_scene(self)
</t>
<t tx="ekr.20250121054835.1813">def save_state(self) -&gt; None:
    state = self.get_state()
    if self.undo_stack and state.mobjects_match(self.undo_stack[-1]):
        return
    self.redo_stack = []
    self.undo_stack.append(state)
    if len(self.undo_stack) &gt; self.max_num_saved_states:
        self.undo_stack.pop(0)
</t>
<t tx="ekr.20250121054835.1814">def undo(self):
    if self.undo_stack:
        self.redo_stack.append(self.get_state())
        self.restore_state(self.undo_stack.pop())
</t>
<t tx="ekr.20250121054835.1815">def redo(self):
    if self.redo_stack:
        self.undo_stack.append(self.get_state())
        self.restore_state(self.redo_stack.pop())
</t>
<t tx="ekr.20250121054835.1816">@contextmanager
def temp_skip(self):
    prev_status = self.skip_animations
    self.skip_animations = True
    try:
        yield
    finally:
        if not prev_status:
            self.stop_skipping()
</t>
<t tx="ekr.20250121054835.1817">@contextmanager
def temp_progress_bar(self):
    prev_progress = self.show_animation_progress
    self.show_animation_progress = True
    try:
        yield
    finally:
        self.show_animation_progress = prev_progress
</t>
<t tx="ekr.20250121054835.1818">@contextmanager
def temp_record(self):
    self.camera.use_window_fbo(False)
    self.file_writer.begin_insert()
    try:
        yield
    finally:
        self.file_writer.end_insert()
        self.camera.use_window_fbo(True)
</t>
<t tx="ekr.20250121054835.1819">def temp_config_change(self, skip=False, record=False, progress_bar=False):
    stack = ExitStack()
    if skip:
        stack.enter_context(self.temp_skip())
    if record:
        stack.enter_context(self.temp_record())
    if progress_bar:
        stack.enter_context(self.temp_progress_bar())
    return stack
</t>
<t tx="ekr.20250121054835.182">def prepare_animation(anim: Animation | _AnimationBuilder):
    if isinstance(anim, _AnimationBuilder):
        return anim.build()

    if isinstance(anim, Animation):
        return anim

    raise TypeError(f"Object {anim} cannot be converted to an animation")
</t>
<t tx="ekr.20250121054835.1820">def is_window_closing(self):
    return self.window and (self.window.is_closing or self.quit_interaction)
</t>
<t tx="ekr.20250121054835.1821"># Event handling
def set_floor_plane(self, plane: str = "xy"):
    if plane == "xy":
        self.frame.set_euler_axes("zxz")
    elif plane == "xz":
        self.frame.set_euler_axes("zxy")
    else:
        raise Exception("Only `xz` and `xy` are valid floor planes")
</t>
<t tx="ekr.20250121054835.1822">def on_mouse_motion(
    self,
    point: Vect3,
    d_point: Vect3
) -&gt; None:
    assert self.window is not None
    self.mouse_point.move_to(point)

    event_data = {"point": point, "d_point": d_point}
    propagate_event = EVENT_DISPATCHER.dispatch(EventType.MouseMotionEvent, **event_data)
    if propagate_event is not None and propagate_event is False:
        return

    frame = self.camera.frame
    # Handle perspective changes
    if self.window.is_key_pressed(ord(manim_config.key_bindings.pan_3d)):
        ff_d_point = frame.to_fixed_frame_point(d_point, relative=True)
        ff_d_point *= self.pan_sensitivity
        frame.increment_theta(-ff_d_point[0])
        frame.increment_phi(ff_d_point[1])
    # Handle frame movements
    elif self.window.is_key_pressed(ord(manim_config.key_bindings.pan)):
        frame.shift(-d_point)
</t>
<t tx="ekr.20250121054835.1823">def on_mouse_drag(
    self,
    point: Vect3,
    d_point: Vect3,
    buttons: int,
    modifiers: int
) -&gt; None:
    self.mouse_drag_point.move_to(point)
    if self.drag_to_pan:
        self.frame.shift(-d_point)

    event_data = {"point": point, "d_point": d_point, "buttons": buttons, "modifiers": modifiers}
    propagate_event = EVENT_DISPATCHER.dispatch(EventType.MouseDragEvent, **event_data)
    if propagate_event is not None and propagate_event is False:
        return
</t>
<t tx="ekr.20250121054835.1824">def on_mouse_press(
    self,
    point: Vect3,
    button: int,
    mods: int
) -&gt; None:
    self.mouse_drag_point.move_to(point)
    event_data = {"point": point, "button": button, "mods": mods}
    propagate_event = EVENT_DISPATCHER.dispatch(EventType.MousePressEvent, **event_data)
    if propagate_event is not None and propagate_event is False:
        return
</t>
<t tx="ekr.20250121054835.1825">def on_mouse_release(
    self,
    point: Vect3,
    button: int,
    mods: int
) -&gt; None:
    event_data = {"point": point, "button": button, "mods": mods}
    propagate_event = EVENT_DISPATCHER.dispatch(EventType.MouseReleaseEvent, **event_data)
    if propagate_event is not None and propagate_event is False:
        return
</t>
<t tx="ekr.20250121054835.1826">def on_mouse_scroll(
    self,
    point: Vect3,
    offset: Vect3,
    x_pixel_offset: float,
    y_pixel_offset: float
) -&gt; None:
    event_data = {"point": point, "offset": offset}
    propagate_event = EVENT_DISPATCHER.dispatch(EventType.MouseScrollEvent, **event_data)
    if propagate_event is not None and propagate_event is False:
        return

    rel_offset = y_pixel_offset / self.camera.get_pixel_height()
    self.frame.scale(
        1 - self.scroll_sensitivity * rel_offset,
        about_point=point
    )
</t>
<t tx="ekr.20250121054835.1827">def on_key_release(
    self,
    symbol: int,
    modifiers: int
) -&gt; None:
    event_data = {"symbol": symbol, "modifiers": modifiers}
    propagate_event = EVENT_DISPATCHER.dispatch(EventType.KeyReleaseEvent, **event_data)
    if propagate_event is not None and propagate_event is False:
        return
</t>
<t tx="ekr.20250121054835.1828">def on_key_press(
    self,
    symbol: int,
    modifiers: int
) -&gt; None:
    try:
        char = chr(symbol)
    except OverflowError:
        log.warning("The value of the pressed key is too large.")
        return

    event_data = {"symbol": symbol, "modifiers": modifiers}
    propagate_event = EVENT_DISPATCHER.dispatch(EventType.KeyPressEvent, **event_data)
    if propagate_event is not None and propagate_event is False:
        return

    if char == manim_config.key_bindings.reset:
        self.play(self.camera.frame.animate.to_default_state())
    elif char == "z" and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL)):
        self.undo()
    elif char == "z" and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL | PygletWindowKeys.MOD_SHIFT)):
        self.redo()
    # command + q
    elif char == manim_config.key_bindings.quit and (modifiers &amp; (PygletWindowKeys.MOD_COMMAND | PygletWindowKeys.MOD_CTRL)):
        self.quit_interaction = True
    # Space or right arrow
    elif char == " " or symbol == PygletWindowKeys.RIGHT:
        self.hold_on_wait = False
</t>
<t tx="ekr.20250121054835.1829">def on_resize(self, width: int, height: int) -&gt; None:
    pass
</t>
<t tx="ekr.20250121054835.183">from __future__ import annotations

from manimlib.animation.animation import Animation
from manimlib.animation.animation import prepare_animation
from manimlib.mobject.mobject import _AnimationBuilder
from manimlib.mobject.mobject import Group
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.bezier import integer_interpolate
from manimlib.utils.bezier import interpolate
from manimlib.utils.iterables import remove_list_redundancies
from manimlib.utils.simple_functions import clip

from typing import TYPE_CHECKING, Union, Iterable
AnimationType = Union[Animation, _AnimationBuilder]

if TYPE_CHECKING:
    from typing import Callable, Optional

    from manimlib.mobject.mobject import Mobject
    from manimlib.scene.scene import Scene


DEFAULT_LAGGED_START_LAG_RATIO = 0.05


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1830">def on_show(self) -&gt; None:
    pass
</t>
<t tx="ekr.20250121054835.1831">def on_hide(self) -&gt; None:
    pass
</t>
<t tx="ekr.20250121054835.1832">def on_close(self) -&gt; None:
    pass
</t>
<t tx="ekr.20250121054835.1833">def focus(self) -&gt; None:
    """
    Puts focus on the ManimGL window.
    """
    if not self.window:
        return
    self.window.focus()
</t>
<t tx="ekr.20250121054835.1834">class SceneState():
    @others
</t>
<t tx="ekr.20250121054835.1835">def __init__(self, scene: Scene, ignore: list[Mobject] | None = None):
    self.time = scene.time
    self.num_plays = scene.num_plays
    self.mobjects_to_copies = OrderedDict.fromkeys(scene.mobjects)
    if ignore:
        for mob in ignore:
            self.mobjects_to_copies.pop(mob, None)

    last_m2c = scene.undo_stack[-1].mobjects_to_copies if scene.undo_stack else dict()
    for mob in self.mobjects_to_copies:
        # If it hasn't changed since the last state, just point to the
        # same copy as before
        if mob in last_m2c and last_m2c[mob].looks_identical(mob):
            self.mobjects_to_copies[mob] = last_m2c[mob]
        else:
            self.mobjects_to_copies[mob] = mob.copy()
</t>
<t tx="ekr.20250121054835.1836">def __eq__(self, state: SceneState):
    return all((
        self.time == state.time,
        self.num_plays == state.num_plays,
        self.mobjects_to_copies == state.mobjects_to_copies
    ))
</t>
<t tx="ekr.20250121054835.1837">def mobjects_match(self, state: SceneState):
    return self.mobjects_to_copies == state.mobjects_to_copies
</t>
<t tx="ekr.20250121054835.1838">def n_changes(self, state: SceneState):
    m2c = state.mobjects_to_copies
    return sum(
        1 - int(mob in m2c and mob.looks_identical(m2c[mob]))
        for mob in self.mobjects_to_copies
    )
</t>
<t tx="ekr.20250121054835.1839">def restore_scene(self, scene: Scene):
    scene.time = self.time
    scene.num_plays = self.num_plays
    scene.mobjects = [
        mob.become(mob_copy)
        for mob, mob_copy in self.mobjects_to_copies.items()
    ]
</t>
<t tx="ekr.20250121054835.184">class AnimationGroup(Animation):
    @others
</t>
<t tx="ekr.20250121054835.1840">class EndScene(Exception):
    pass
</t>
<t tx="ekr.20250121054835.1841">class ThreeDScene(Scene):
    @others
</t>
<t tx="ekr.20250121054835.1842">samples = 4
default_frame_orientation = (-30, 70)
always_depth_test = True

def add(self, *mobjects: Mobject, set_depth_test: bool = True, perp_stroke: bool = True):
    for mob in mobjects:
        if set_depth_test and not mob.is_fixed_in_frame() and self.always_depth_test:
            mob.apply_depth_test()
        if isinstance(mob, VMobject) and mob.has_stroke() and perp_stroke:
            mob.set_flat_stroke(False)
    super().add(*mobjects)
</t>
<t tx="ekr.20250121054835.1843">from __future__ import annotations

import inspect
import pyperclip
import traceback

from IPython.terminal import pt_inputhooks
from IPython.terminal.embed import InteractiveShellEmbed

from manimlib.animation.fading import VFadeInThenOut
from manimlib.config import manim_config
from manimlib.constants import RED
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.frame import FullScreenRectangle
from manimlib.module_loader import ModuleLoader


from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from manimlib.scene.scene import Scene


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1844">class InteractiveSceneEmbed:
    @others
</t>
<t tx="ekr.20250121054835.1845">def __init__(self, scene: Scene):
    self.scene = scene
    self.checkpoint_manager = CheckpointManager()

    self.shell = self.get_ipython_shell_for_embedded_scene()
    self.enable_gui()
    self.ensure_frame_update_post_cell()
    self.ensure_flash_on_error()
    if manim_config.embed.autoreload:
        self.auto_reload()
</t>
<t tx="ekr.20250121054835.1846">def launch(self):
    self.shell()
</t>
<t tx="ekr.20250121054835.1847">def get_ipython_shell_for_embedded_scene(self) -&gt; InteractiveShellEmbed:
    """
    Create embedded IPython terminal configured to have access to
    the local namespace of the caller
    """
    # Triple back should take us to the context in a user's scene definition
    # which is calling "self.embed"
    caller_frame = inspect.currentframe().f_back.f_back.f_back

    # Update the module's namespace to include local variables
    module = ModuleLoader.get_module(caller_frame.f_globals["__file__"])
    module.__dict__.update(caller_frame.f_locals)
    module.__dict__.update(self.get_shortcuts())
    exception_mode = manim_config.embed.exception_mode

    return InteractiveShellEmbed(
        user_module=module,
        display_banner=False,
        xmode=exception_mode
    )
</t>
<t tx="ekr.20250121054835.1848">def get_shortcuts(self):
    """
    A few custom shortcuts useful to have in the interactive shell namespace
    """
    scene = self.scene
    return dict(
        play=scene.play,
        wait=scene.wait,
        add=scene.add,
        remove=scene.remove,
        clear=scene.clear,
        focus=scene.focus,
        save_state=scene.save_state,
        undo=scene.undo,
        redo=scene.redo,
        i2g=scene.i2g,
        i2m=scene.i2m,
        checkpoint_paste=self.checkpoint_paste,
        clear_checkpoints=self.checkpoint_manager.clear_checkpoints,
        reload=self.reload_scene  # Defined below
    )
</t>
<t tx="ekr.20250121054835.1849">def enable_gui(self):
    """Enables gui interactions during the embed"""
    def inputhook(context):
        while not context.input_is_ready():
            if not self.scene.is_window_closing():
                self.scene.update_frame(dt=0)
        if self.scene.is_window_closing():
            self.shell.ask_exit()

    pt_inputhooks.register("manim", inputhook)
    self.shell.enable_gui("manim")
</t>
<t tx="ekr.20250121054835.185">def __init__(
    self,
    *args: AnimationType | Iterable[AnimationType],
    run_time: float = -1,  # If negative, default to sum of inputed animation runtimes
    lag_ratio: float = 0.0,
    group: Optional[Mobject] = None,
    group_type: Optional[type] = None,
    **kwargs
):
    animations = args[0] if isinstance(args[0], Iterable) else args
    self.animations = [prepare_animation(anim) for anim in animations]
    self.build_animations_with_timings(lag_ratio)
    self.max_end_time = max((awt[2] for awt in self.anims_with_timings), default=0)
    self.run_time = self.max_end_time if run_time &lt; 0 else run_time
    self.lag_ratio = lag_ratio
    mobs = remove_list_redundancies([a.mobject for a in self.animations])
    if group is not None:
        self.group = group
    if group_type is not None:
        self.group = group_type(*mobs)
    elif all(isinstance(anim.mobject, VMobject) for anim in animations):
        self.group = VGroup(*mobs)
    else:
        self.group = Group(*mobs)

    super().__init__(
        self.group,
        run_time=self.run_time,
        lag_ratio=lag_ratio,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.1850">def ensure_frame_update_post_cell(self):
    """Ensure the scene updates its frame after each ipython cell"""
    def post_cell_func(*args, **kwargs):
        if not self.scene.is_window_closing():
            self.scene.update_frame(dt=0, force_draw=True)

    self.shell.events.register("post_run_cell", post_cell_func)
</t>
<t tx="ekr.20250121054835.1851">def ensure_flash_on_error(self):
    """Flash border, and potentially play sound, on exceptions"""
    def custom_exc(shell, etype, evalue, tb, tb_offset=None):
        # Show the error don't just swallow it
        shell.showtraceback((etype, evalue, tb), tb_offset=tb_offset)
        rect = FullScreenRectangle().set_stroke(RED, 30).set_fill(opacity=0)
        rect.fix_in_frame()
        self.scene.play(VFadeInThenOut(rect, run_time=0.5))

    self.shell.set_custom_exc((Exception,), custom_exc)
</t>
<t tx="ekr.20250121054835.1852">def reload_scene(self, embed_line: int | None = None) -&gt; None:
    """
    Reloads the scene just like the `manimgl` command would do with the
    same arguments that were provided for the initial startup. This allows
    for quick iteration during scene development since we don't have to exit
    the IPython kernel and re-run the `manimgl` command again. The GUI stays
    open during the reload.

    If `embed_line` is provided, the scene will be reloaded at that line
    number. This corresponds to the `linemarker` param of the
    `extract_scene.insert_embed_line_to_module()` method.

    Before reload, the scene is cleared and the entire state is reset, such
    that we can start from a clean slate. This is taken care of by the
    run_scenes function in __main__.py, which will catch the error raised by the
    `exit_raise` magic command that we invoke here.

    Note that we cannot define a custom exception class for this error,
    since the IPython kernel will swallow any exception. While we can catch
    such an exception in our custom exception handler registered with the
    `set_custom_exc` method, we cannot break out of the IPython shell by
    this means.
    """
    # Update the global run configuration.
    run_config = manim_config.run
    run_config.is_reload = True
    if embed_line:
        run_config.embed_line = embed_line

    print("Reloading...")
    self.shell.run_line_magic("exit_raise", "")
</t>
<t tx="ekr.20250121054835.1853">def auto_reload(self):
    """Enables reload the shell's module before all calls"""
    def pre_cell_func(*args, **kwargs):
        new_mod = ModuleLoader.get_module(self.shell.user_module.__file__, is_during_reload=True)
        self.shell.user_ns.update(vars(new_mod))

    self.shell.events.register("pre_run_cell", pre_cell_func)
</t>
<t tx="ekr.20250121054835.1854">def checkpoint_paste(
    self,
    skip: bool = False,
    record: bool = False,
    progress_bar: bool = True
):
    with self.scene.temp_config_change(skip, record, progress_bar):
        self.checkpoint_manager.checkpoint_paste(self.shell, self.scene)
</t>
<t tx="ekr.20250121054835.1855">class CheckpointManager:
    @others
</t>
<t tx="ekr.20250121054835.1856">def __init__(self):
    self.checkpoint_states: dict[str, list[tuple[Mobject, Mobject]]] = dict()
</t>
<t tx="ekr.20250121054835.1857">def checkpoint_paste(self, shell, scene):
    """
    Used during interactive development to run (or re-run)
    a block of scene code.

    If the copied selection starts with a comment, this will
    revert to the state of the scene the first time this function
    was called on a block of code starting with that comment.
    """
    code_string = pyperclip.paste()
    checkpoint_key = self.get_leading_comment(code_string)
    self.handle_checkpoint_key(scene, checkpoint_key)
    shell.run_cell(code_string)
</t>
<t tx="ekr.20250121054835.1858">@staticmethod
def get_leading_comment(code_string: str) -&gt; str:
    leading_line = code_string.partition("\n")[0].lstrip()
    if leading_line.startswith("#"):
        return leading_line
    return ""
</t>
<t tx="ekr.20250121054835.1859">def handle_checkpoint_key(self, scene, key: str):
    if not key:
        return
    elif key in self.checkpoint_states:
        # Revert to checkpoint
        scene.restore_state(self.checkpoint_states[key])

        # Clear out any saved states that show up later
        all_keys = list(self.checkpoint_states.keys())
        index = all_keys.index(key)
        for later_key in all_keys[index + 1:]:
            self.checkpoint_states.pop(later_key)
    else:
        self.checkpoint_states[key] = scene.get_state()
</t>
<t tx="ekr.20250121054835.186">def get_all_mobjects(self) -&gt; Mobject:
    return self.group
</t>
<t tx="ekr.20250121054835.1860">def clear_checkpoints(self):
    self.checkpoint_states = dict()
</t>
<t tx="ekr.20250121054835.1861">from __future__ import annotations

import os
import platform
import shutil
import subprocess as sp
import sys

import numpy as np
from pydub import AudioSegment
from tqdm.auto import tqdm as ProgressDisplay
from pathlib import Path

from manimlib.logger import log
from manimlib.mobject.mobject import Mobject
from manimlib.utils.file_ops import guarantee_existence
from manimlib.utils.sounds import get_full_sound_file_path

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from PIL.Image import Image

    from manimlib.camera.camera import Camera
    from manimlib.scene.scene import Scene


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1862">class SceneFileWriter(object):
    @others
</t>
<t tx="ekr.20250121054835.1863">def __init__(
    self,
    scene: Scene,
    write_to_movie: bool = False,
    subdivide_output: bool = False,
    png_mode: str = "RGBA",
    save_last_frame: bool = False,
    movie_file_extension: str = ".mp4",
    # Where should this be written
    output_directory: str = ".",
    file_name: str | None = None,
    open_file_upon_completion: bool = False,
    show_file_location_upon_completion: bool = False,
    quiet: bool = False,
    total_frames: int = 0,
    progress_description_len: int = 40,
    # Name of the binary used for ffmpeg
    ffmpeg_bin: str = "ffmpeg",
    video_codec: str = "libx264",
    pixel_format: str = "yuv420p",
    saturation: float = 1.0,
    gamma: float = 1.0,
):
    self.scene: Scene = scene
    self.write_to_movie = write_to_movie
    self.subdivide_output = subdivide_output
    self.png_mode = png_mode
    self.save_last_frame = save_last_frame
    self.movie_file_extension = movie_file_extension
    self.output_directory = output_directory
    self.file_name = file_name
    self.open_file_upon_completion = open_file_upon_completion
    self.show_file_location_upon_completion = show_file_location_upon_completion
    self.quiet = quiet
    self.total_frames = total_frames
    self.progress_description_len = progress_description_len
    self.ffmpeg_bin = ffmpeg_bin
    self.video_codec = video_codec
    self.pixel_format = pixel_format
    self.saturation = saturation
    self.gamma = gamma

    # State during file writing
    self.writing_process: sp.Popen | None = None
    self.progress_display: ProgressDisplay | None = None
    self.ended_with_interrupt: bool = False

    self.init_output_directories()
    self.init_audio()
</t>
<t tx="ekr.20250121054835.1864"># Output directories and files
def init_output_directories(self) -&gt; None:
    if self.save_last_frame:
        self.image_file_path = self.init_image_file_path()
    if self.write_to_movie:
        self.movie_file_path = self.init_movie_file_path()
    if self.subdivide_output:
        self.partial_movie_directory = self.init_partial_movie_directory()
</t>
<t tx="ekr.20250121054835.1865">def init_image_file_path(self) -&gt; Path:
    return self.get_output_file_rootname().with_suffix(".png")
</t>
<t tx="ekr.20250121054835.1866">def init_movie_file_path(self) -&gt; Path:
    return self.get_output_file_rootname().with_suffix(self.movie_file_extension)
</t>
<t tx="ekr.20250121054835.1867">def init_partial_movie_directory(self):
    return guarantee_existence(self.get_output_file_rootname())
</t>
<t tx="ekr.20250121054835.1868">def get_output_file_rootname(self) -&gt; Path:
    return Path(
        guarantee_existence(self.output_directory),
        self.get_output_file_name()
    )
</t>
<t tx="ekr.20250121054835.1869">def get_output_file_name(self) -&gt; str:
    if self.file_name:
        return self.file_name
    # Otherwise, use the name of the scene, potentially
    # appending animation numbers
    name = str(self.scene)
    saan = self.scene.start_at_animation_number
    eaan = self.scene.end_at_animation_number
    if saan is not None:
        name += f"_{saan}"
    if eaan is not None:
        name += f"_{eaan}"
    return name
</t>
<t tx="ekr.20250121054835.187">def begin(self) -&gt; None:
    self.group.set_animating_status(True)
    for anim in self.animations:
        anim.begin()
</t>
<t tx="ekr.20250121054835.1870"># Directory getters
def get_image_file_path(self) -&gt; str:
    return self.image_file_path
</t>
<t tx="ekr.20250121054835.1871">def get_next_partial_movie_path(self) -&gt; str:
    result = Path(self.partial_movie_directory, f"{self.scene.num_plays:05}")
    return result.with_suffix(self.movie_file_extension)
</t>
<t tx="ekr.20250121054835.1872">def get_movie_file_path(self) -&gt; str:
    return self.movie_file_path
</t>
<t tx="ekr.20250121054835.1873"># Sound
def init_audio(self) -&gt; None:
    self.includes_sound: bool = False
</t>
<t tx="ekr.20250121054835.1874">def create_audio_segment(self) -&gt; None:
    self.audio_segment = AudioSegment.silent()
</t>
<t tx="ekr.20250121054835.1875">def add_audio_segment(
    self,
    new_segment: AudioSegment,
    time: float | None = None,
    gain_to_background: float | None = None
) -&gt; None:
    if not self.includes_sound:
        self.includes_sound = True
        self.create_audio_segment()
    segment = self.audio_segment
    curr_end = segment.duration_seconds
    if time is None:
        time = curr_end
    if time &lt; 0:
        raise Exception("Adding sound at timestamp &lt; 0")

    new_end = time + new_segment.duration_seconds
    diff = new_end - curr_end
    if diff &gt; 0:
        segment = segment.append(
            AudioSegment.silent(int(np.ceil(diff * 1000))),
            crossfade=0,
        )
    self.audio_segment = segment.overlay(
        new_segment,
        position=int(1000 * time),
        gain_during_overlay=gain_to_background,
    )
</t>
<t tx="ekr.20250121054835.1876">def add_sound(
    self,
    sound_file: str,
    time: float | None = None,
    gain: float | None = None,
    gain_to_background: float | None = None
) -&gt; None:
    file_path = get_full_sound_file_path(sound_file)
    new_segment = AudioSegment.from_file(file_path)
    if gain:
        new_segment = new_segment.apply_gain(gain)
    self.add_audio_segment(new_segment, time, gain_to_background)
</t>
<t tx="ekr.20250121054835.1877"># Writers
def begin(self) -&gt; None:
    if not self.subdivide_output and self.write_to_movie:
        self.open_movie_pipe(self.get_movie_file_path())
</t>
<t tx="ekr.20250121054835.1878">def begin_animation(self) -&gt; None:
    if self.subdivide_output and self.write_to_movie:
        self.open_movie_pipe(self.get_next_partial_movie_path())
</t>
<t tx="ekr.20250121054835.1879">def end_animation(self) -&gt; None:
    if self.subdivide_output and self.write_to_movie:
        self.close_movie_pipe()
</t>
<t tx="ekr.20250121054835.188">    # self.init_run_time()

def finish(self) -&gt; None:
    self.group.set_animating_status(False)
    for anim in self.animations:
        anim.finish()
</t>
<t tx="ekr.20250121054835.1880">def finish(self) -&gt; None:
    if not self.subdivide_output and self.write_to_movie:
        self.close_movie_pipe()
        if self.includes_sound:
            self.add_sound_to_video()
        self.print_file_ready_message(self.get_movie_file_path())
    if self.save_last_frame:
        self.scene.update_frame(force_draw=True)
        self.save_final_image(self.scene.get_image())
    if self.should_open_file():
        self.open_file()
</t>
<t tx="ekr.20250121054835.1881">def open_movie_pipe(self, file_path: str) -&gt; None:
    stem, ext = os.path.splitext(file_path)
    self.final_file_path = file_path
    self.temp_file_path = stem + "_temp" + ext

    fps = self.scene.camera.fps
    width, height = self.scene.camera.get_pixel_shape()

    vf_arg = 'vflip'
    vf_arg += f',eq=saturation={self.saturation}:gamma={self.gamma}'

    command = [
        self.ffmpeg_bin,
        '-y',  # overwrite output file if it exists
        '-f', 'rawvideo',
        '-s', f'{width}x{height}',  # size of one frame
        '-pix_fmt', 'rgba',
        '-r', str(fps),  # frames per second
        '-i', '-',  # The input comes from a pipe
        '-vf', vf_arg,
        '-an',  # Tells ffmpeg not to expect any audio
        '-loglevel', 'error',
    ]
    if self.video_codec:
        command += ['-vcodec', self.video_codec]
    if self.pixel_format:
        command += ['-pix_fmt', self.pixel_format]
    command += [self.temp_file_path]
    self.writing_process = sp.Popen(command, stdin=sp.PIPE)

    if not self.quiet:
        self.progress_display = ProgressDisplay(
            range(self.total_frames),
            leave=False,
            ascii=True if platform.system() == 'Windows' else None,
            dynamic_ncols=True,
        )
        self.set_progress_display_description()
</t>
<t tx="ekr.20250121054835.1882">def use_fast_encoding(self):
    self.video_codec = "libx264rgb"
    self.pixel_format = "rgb32"
</t>
<t tx="ekr.20250121054835.1883">def get_insert_file_path(self, index: int) -&gt; Path:
    movie_path = Path(self.get_movie_file_path())
    scene_name = movie_path.stem
    insert_dir = Path(movie_path.parent, "inserts")
    guarantee_existence(insert_dir)
    return Path(insert_dir, f"{scene_name}_{index}").with_suffix(self.movie_file_extension)
</t>
<t tx="ekr.20250121054835.1884">def begin_insert(self):
    # Begin writing process
    self.write_to_movie = True
    self.init_output_directories()
    index = 0
    while (insert_path := self.get_insert_file_path(index)).exists():
        index += 1
    self.inserted_file_path = insert_path
    self.open_movie_pipe(self.inserted_file_path)
</t>
<t tx="ekr.20250121054835.1885">def end_insert(self):
    self.close_movie_pipe()
    self.write_to_movie = False
    self.print_file_ready_message(self.inserted_file_path)
</t>
<t tx="ekr.20250121054835.1886">def has_progress_display(self):
    return self.progress_display is not None
</t>
<t tx="ekr.20250121054835.1887">def set_progress_display_description(self, file: str = "", sub_desc: str = "") -&gt; None:
    if self.progress_display is None:
        return

    desc_len = self.progress_description_len
    if not file:
        file = os.path.split(self.get_movie_file_path())[1]
    full_desc = f"{file} {sub_desc}"
    if len(full_desc) &gt; desc_len:
        full_desc = full_desc[:desc_len - 3] + "..."
    else:
        full_desc += " " * (desc_len - len(full_desc))
    self.progress_display.set_description(full_desc)
</t>
<t tx="ekr.20250121054835.1888">def write_frame(self, camera: Camera) -&gt; None:
    if self.write_to_movie:
        raw_bytes = camera.get_raw_fbo_data()
        self.writing_process.stdin.write(raw_bytes)
        if self.progress_display is not None:
            self.progress_display.update()
</t>
<t tx="ekr.20250121054835.1889">def close_movie_pipe(self) -&gt; None:
    self.writing_process.stdin.close()
    self.writing_process.wait()
    self.writing_process.terminate()
    if self.progress_display is not None:
        self.progress_display.close()

    if not self.ended_with_interrupt:
        shutil.move(self.temp_file_path, self.final_file_path)
    else:
        self.movie_file_path = self.temp_file_path
</t>
<t tx="ekr.20250121054835.189">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    for anim in self.animations:
        anim.clean_up_from_scene(scene)
</t>
<t tx="ekr.20250121054835.1890">def add_sound_to_video(self) -&gt; None:
    movie_file_path = self.get_movie_file_path()
    stem, ext = os.path.splitext(movie_file_path)
    sound_file_path = stem + ".wav"
    # Makes sure sound file length will match video file
    self.add_audio_segment(AudioSegment.silent(0))
    self.audio_segment.export(
        sound_file_path,
        bitrate='312k',
    )
    temp_file_path = stem + "_temp" + ext
    commands = [
        self.ffmpeg_bin,
        "-i", movie_file_path,
        "-i", sound_file_path,
        '-y',  # overwrite output file if it exists
        "-c:v", "copy",
        "-c:a", "aac",
        "-b:a", "320k",
        # select video stream from first file
        "-map", "0:v:0",
        # select audio stream from second file
        "-map", "1:a:0",
        '-loglevel', 'error',
        # "-shortest",
        temp_file_path,
    ]
    sp.call(commands)
    shutil.move(temp_file_path, movie_file_path)
    os.remove(sound_file_path)
</t>
<t tx="ekr.20250121054835.1891">def save_final_image(self, image: Image) -&gt; None:
    file_path = self.get_image_file_path()
    image.save(file_path)
    self.print_file_ready_message(file_path)
</t>
<t tx="ekr.20250121054835.1892">def print_file_ready_message(self, file_path: str) -&gt; None:
    if not self.quiet:
        log.info(f"File ready at {file_path}")
</t>
<t tx="ekr.20250121054835.1893">def should_open_file(self) -&gt; bool:
    return any([
        self.show_file_location_upon_completion,
        self.open_file_upon_completion,
    ])
</t>
<t tx="ekr.20250121054835.1894">def open_file(self) -&gt; None:
    if self.quiet:
        curr_stdout = sys.stdout
        sys.stdout = open(os.devnull, "w")

    current_os = platform.system()
    file_paths = []

    if self.save_last_frame:
        file_paths.append(self.get_image_file_path())
    if self.write_to_movie:
        file_paths.append(self.get_movie_file_path())

    for file_path in file_paths:
        if current_os == "Windows":
            os.startfile(file_path)
        else:
            commands = []
            if current_os == "Linux":
                commands.append("xdg-open")
            elif current_os.startswith("CYGWIN"):
                commands.append("cygstart")
            else:  # Assume macOS
                commands.append("open")

            if self.show_file_location_upon_completion:
                commands.append("-R")

            commands.append(file_path)

            FNULL = open(os.devnull, 'w')
            sp.call(commands, stdout=FNULL, stderr=sp.STDOUT)
            FNULL.close()

    if self.quiet:
        sys.stdout.close()
        sys.stdout = curr_stdout
</t>
<t tx="ekr.20250121054835.1895"></t>
<t tx="ekr.20250121054835.1896"></t>
<t tx="ekr.20250121054835.1897">@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1898">from __future__ import annotations

import numpy as np
from scipy import linalg
from fontTools.cu2qu.cu2qu import curve_to_quadratic

from manimlib.logger import log
from manimlib.utils.simple_functions import choose
from manimlib.utils.space_ops import cross2d
from manimlib.utils.space_ops import cross
from manimlib.utils.space_ops import find_intersection
from manimlib.utils.space_ops import midpoint
from manimlib.utils.space_ops import get_norm
from manimlib.utils.space_ops import z_to_vector

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, Sequence, TypeVar, Tuple
    from manimlib.typing import VectN, FloatArray, VectNArray, Vect3Array

    Scalable = TypeVar("Scalable", float, FloatArray)


CLOSED_THRESHOLD = 0.001


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1899">def bezier(
    points: Sequence[float | FloatArray] | VectNArray
) -&gt; Callable[[float], float | FloatArray]:
    if len(points) == 0:
        raise Exception("bezier cannot be calld on an empty list")

    n = len(points) - 1

    def result(t: float) -&gt; float | FloatArray:
        return sum(
            ((1 - t)**(n - k)) * (t**k) * choose(n, k) * point
            for k, point in enumerate(points)
        )

    return result
</t>
<t tx="ekr.20250121054835.19">class TexAndNumbersExample(Scene):
    @others
</t>
<t tx="ekr.20250121054835.190">def update_mobjects(self, dt: float) -&gt; None:
    for anim in self.animations:
        anim.update_mobjects(dt)
</t>
<t tx="ekr.20250121054835.1900">def partial_bezier_points(
    points: Sequence[Scalable],
    a: float,
    b: float
) -&gt; list[Scalable]:
    """
    Given an list of points which define
    a bezier curve, and two numbers 0&lt;=a&lt;b&lt;=1,
    return an list of the same size, which
    describes the portion of the original bezier
    curve on the interval [a, b].

    This algorithm is pretty nifty, and pretty dense.
    """
    if a == 1:
        return [points[-1]] * len(points)

    a_to_1 = [
        bezier(points[i:])(a)
        for i in range(len(points))
    ]
    end_prop = (b - a) / (1. - a)
    return [
        bezier(a_to_1[:i + 1])(end_prop)
        for i in range(len(points))
    ]
</t>
<t tx="ekr.20250121054835.1901"># Shortened version of partial_bezier_points just for quadratics,
# since this is called a fair amount
def partial_quadratic_bezier_points(
    points: Sequence[VectN] | VectNArray,
    a: float,
    b: float
) -&gt; list[VectN]:
    if a == 1:
        return 3 * [points[-1]]

    def curve(t):
        return points[0] * (1 - t) * (1 - t) + 2 * points[1] * t * (1 - t) + points[2] * t * t
    # bezier(points)
    h0 = curve(a) if a &gt; 0 else points[0]
    h2 = curve(b) if b &lt; 1 else points[2]
    h1_prime = (1 - a) * points[1] + a * points[2]
    end_prop = (b - a) / (1. - a)
    h1 = (1 - end_prop) * h0 + end_prop * h1_prime
    return [h0, h1, h2]
</t>
<t tx="ekr.20250121054835.1902"># Linear interpolation variants


def interpolate(start: Scalable, end: Scalable, alpha: float | VectN) -&gt; Scalable:
    try:
        return (1 - alpha) * start + alpha * end
    except TypeError:
        log.debug(f"`start` parameter with type `{type(start)}` and dtype `{start.dtype}`")
        log.debug(f"`end` parameter with type `{type(end)}` and dtype `{end.dtype}`")
        log.debug(f"`alpha` parameter with value `{alpha}`")
        import sys
        sys.exit(2)
</t>
<t tx="ekr.20250121054835.1903">def outer_interpolate(
    start: Scalable,
    end: Scalable,
    alpha: Scalable,
) -&gt; np.ndarray:
    result = np.outer(1 - alpha, start) + np.outer(alpha, end)
    return result.reshape((*np.shape(alpha), *np.shape(start)))
</t>
<t tx="ekr.20250121054835.1904">def set_array_by_interpolation(
    arr: np.ndarray,
    arr1: np.ndarray,
    arr2: np.ndarray,
    alpha: float,
    interp_func: Callable[[np.ndarray, np.ndarray, float], np.ndarray] = interpolate
) -&gt; np.ndarray:
    arr[:] = interp_func(arr1, arr2, alpha)
    return arr
</t>
<t tx="ekr.20250121054835.1905">def integer_interpolate(
    start: int,
    end: int,
    alpha: float
) -&gt; tuple[int, float]:
    """
    alpha is a float between 0 and 1.  This returns
    an integer between start and end (inclusive) representing
    appropriate interpolation between them, along with a
    "residue" representing a new proportion between the
    returned integer and the next one of the
    list.

    For example, if start=0, end=10, alpha=0.46, This
    would return (4, 0.6).
    """
    if alpha &gt;= 1:
        return (end - 1, 1.0)
    if alpha &lt;= 0:
        return (start, 0)
    value = int(interpolate(start, end, alpha))
    residue = ((end - start) * alpha) % 1
    return (value, residue)
</t>
<t tx="ekr.20250121054835.1906">def mid(start: Scalable, end: Scalable) -&gt; Scalable:
    return (start + end) / 2.0
</t>
<t tx="ekr.20250121054835.1907">def inverse_interpolate(start: Scalable, end: Scalable, value: Scalable) -&gt; np.ndarray:
    return np.true_divide(value - start, end - start)
</t>
<t tx="ekr.20250121054835.1908">def match_interpolate(
    new_start: Scalable,
    new_end: Scalable,
    old_start: Scalable,
    old_end: Scalable,
    old_value: Scalable
) -&gt; Scalable:
    return interpolate(
        new_start, new_end,
        inverse_interpolate(old_start, old_end, old_value)
    )
</t>
<t tx="ekr.20250121054835.1909">def quadratic_bezier_points_for_arc(angle: float, n_components: int = 8):
    n_points = 2 * n_components + 1
    angles = np.linspace(0, angle, n_points)
    points = np.array([np.cos(angles), np.sin(angles), np.zeros(n_points)]).T
    # Adjust handles
    theta = angle / n_components
    points[1::2] /= np.cos(theta / 2)
    return points
</t>
<t tx="ekr.20250121054835.191">def calculate_max_end_time(self) -&gt; None:
    self.max_end_time = max(
        (awt[2] for awt in self.anims_with_timings),
        default=0,
    )
    if self.run_time &lt; 0:
        self.run_time = self.max_end_time
</t>
<t tx="ekr.20250121054835.1910">def approx_smooth_quadratic_bezier_handles(
    points: FloatArray
) -&gt; FloatArray:
    """
    Figuring out which bezier curves most smoothly connect a sequence of points.

    Given three successive points, P0, P1 and P2, you can compute that by defining
    h = (1/4) P0 + P1 - (1/4)P2, the bezier curve defined by (P0, h, P1) will pass
    through the point P2.

    So for a given set of four successive points, P0, P1, P2, P3, if we want to add
    a handle point h between P1 and P2 so that the quadratic bezier (P1, h, P2) is
    part of a smooth curve passing through all four points, we calculate one solution
    for h that would produce a parbola passing through P3, call it smooth_to_right, and
    another that would produce a parabola passing through P0, call it smooth_to_left,
    and use the midpoint between the two.
    """
    if len(points) == 1:
        return points[0]
    elif len(points) == 2:
        return midpoint(*points)
    smooth_to_right, smooth_to_left = [
        0.25 * ps[0:-2] + ps[1:-1] - 0.25 * ps[2:]
        for ps in (points, points[::-1])
    ]
    if np.isclose(points[0], points[-1]).all():
        last_str = 0.25 * points[-2] + points[-1] - 0.25 * points[1]
        last_stl = 0.25 * points[1] + points[0] - 0.25 * points[-2]
    else:
        last_str = smooth_to_left[0]
        last_stl = smooth_to_right[0]
    handles = 0.5 * np.vstack([smooth_to_right, [last_str]])
    handles += 0.5 * np.vstack([last_stl, smooth_to_left[::-1]])
    return handles
</t>
<t tx="ekr.20250121054835.1911">def smooth_quadratic_path(anchors: Vect3Array) -&gt; Vect3Array:
    """
    Returns a path defining a smooth quadratic bezier spline
    through anchors.
    """
    if len(anchors) &lt; 2:
        return anchors
    elif len(anchors) == 2:
        return np.array([anchors[0], anchors.mean(0), anchors[1]])

    is_flat = (anchors[:, 2] == 0).all()
    if not is_flat:
        normal = cross(anchors[2] - anchors[1], anchors[1] - anchors[0])
        rot = z_to_vector(normal)
        anchors = np.dot(anchors, rot)
        shift = anchors[0, 2]
        anchors[:, 2] -= shift
    h1s, h2s = get_smooth_cubic_bezier_handle_points(anchors)
    quads = [anchors[0, :2]]
    for cub_bs in zip(anchors[:-1], h1s, h2s, anchors[1:]):
        # Try to use fontTools curve_to_quadratic
        new_quads = curve_to_quadratic(
            [b[:2] for b in cub_bs],
            max_err=0.1 * get_norm(cub_bs[3] - cub_bs[0])
        )
        # Otherwise fall back on home baked solution
        if new_quads is None or len(new_quads) % 2 == 0:
            new_quads = get_quadratic_approximation_of_cubic(*cub_bs)[:, :2]
        quads.extend(new_quads[1:])
    new_path = np.zeros((len(quads), 3))
    new_path[:, :2] = quads
    if not is_flat:
        new_path[:, 2] += shift
        new_path = np.dot(new_path, rot.T)
    return new_path
</t>
<t tx="ekr.20250121054835.1912">def get_smooth_cubic_bezier_handle_points(
    points: Sequence[VectN] | VectNArray
) -&gt; tuple[FloatArray, FloatArray]:
    points = np.array(points)
    num_handles = len(points) - 1
    dim = points.shape[1]
    if num_handles &lt; 1:
        return np.zeros((0, dim)), np.zeros((0, dim))
    # Must solve 2*num_handles equations to get the handles.
    # l and u are the number of lower an upper diagonal rows
    # in the matrix to solve.
    l, u = 2, 1
    # diag is a representation of the matrix in diagonal form
    # See https://www.particleincell.com/2012/bezier-splines/
    # for how to arrive at these equations
    diag = np.zeros((l + u + 1, 2 * num_handles))
    diag[0, 1::2] = -1
    diag[0, 2::2] = 1
    diag[1, 0::2] = 2
    diag[1, 1::2] = 1
    diag[2, 1:-2:2] = -2
    diag[3, 0:-3:2] = 1
    # last
    diag[2, -2] = -1
    diag[1, -1] = 2
    # This is the b as in Ax = b, where we are solving for x,
    # and A is represented using diag.  However, think of entries
    # to x and b as being points in space, not numbers
    b = np.zeros((2 * num_handles, dim))
    b[1::2] = 2 * points[1:]
    b[0] = points[0]
    b[-1] = points[-1]

    def solve_func(b):
        return linalg.solve_banded((l, u), diag, b)

    use_closed_solve_function = is_closed(points)
    if use_closed_solve_function:
        # Get equations to relate first and last points
        matrix = diag_to_matrix((l, u), diag)
        # last row handles second derivative
        matrix[-1, [0, 1, -2, -1]] = [2, -1, 1, -2]
        # first row handles first derivative
        matrix[0, :] = np.zeros(matrix.shape[1])
        matrix[0, [0, -1]] = [1, 1]
        b[0] = 2 * points[0]
        b[-1] = np.zeros(dim)

        def closed_curve_solve_func(b):
            return linalg.solve(matrix, b)

    handle_pairs = np.zeros((2 * num_handles, dim))
    for i in range(dim):
        if use_closed_solve_function:
            handle_pairs[:, i] = closed_curve_solve_func(b[:, i])
        else:
            handle_pairs[:, i] = solve_func(b[:, i])
    return handle_pairs[0::2], handle_pairs[1::2]
</t>
<t tx="ekr.20250121054835.1913">def diag_to_matrix(
    l_and_u: tuple[int, int], 
    diag: np.ndarray
) -&gt; np.ndarray:
    """
    Converts array whose rows represent diagonal
    entries of a matrix into the matrix itself.
    See scipy.linalg.solve_banded
    """
    l, u = l_and_u
    dim = diag.shape[1]
    matrix = np.zeros((dim, dim))
    for i in range(l + u + 1):
        np.fill_diagonal(
            matrix[max(0, i - u):, max(0, u - i):],
            diag[i, max(0, u - i):]
        )
    return matrix
</t>
<t tx="ekr.20250121054835.1914">def is_closed(points: FloatArray) -&gt; bool:
    return np.allclose(points[0], points[-1])
</t>
<t tx="ekr.20250121054835.1915"># Given 4 control points for a cubic bezier curve (or arrays of such)
# return control points for 2 quadratics (or 2n quadratics) approximating them.
def get_quadratic_approximation_of_cubic(
    a0: FloatArray,
    h0: FloatArray,
    h1: FloatArray,
    a1: FloatArray
) -&gt; FloatArray:
    a0 = np.array(a0, ndmin=2)
    h0 = np.array(h0, ndmin=2)
    h1 = np.array(h1, ndmin=2)
    a1 = np.array(a1, ndmin=2)
    # Tangent vectors at the start and end.
    T0 = h0 - a0
    T1 = a1 - h1

    # Search for inflection points.  If none are found, use the
    # midpoint as a cut point.
    # Based on http://www.caffeineowl.com/graphics/2d/vectorial/cubic-inflexion.html
    has_infl = np.ones(len(a0), dtype=bool)

    p = h0 - a0
    q = h1 - 2 * h0 + a0
    r = a1 - 3 * h1 + 3 * h0 - a0

    a = cross2d(q, r)
    b = cross2d(p, r)
    c = cross2d(p, q)

    disc = b * b - 4 * a * c
    has_infl &amp;= (disc &gt; 0)
    sqrt_disc = np.sqrt(np.abs(disc))
    settings = np.seterr(all='ignore')
    ti_bounds = []
    for sgn in [-1, +1]:
        ti = (-b + sgn * sqrt_disc) / (2 * a)
        ti[a == 0] = (-c / b)[a == 0]
        ti[(a == 0) &amp; (b == 0)] = 0
        ti_bounds.append(ti)
    ti_min, ti_max = ti_bounds
    np.seterr(**settings)
    ti_min_in_range = has_infl &amp; (0 &lt; ti_min) &amp; (ti_min &lt; 1)
    ti_max_in_range = has_infl &amp; (0 &lt; ti_max) &amp; (ti_max &lt; 1)

    # Choose a value of t which starts at 0.5,
    # but is updated to one of the inflection points
    # if they lie between 0 and 1

    t_mid = 0.5 * np.ones(len(a0))
    t_mid[ti_min_in_range] = ti_min[ti_min_in_range]
    t_mid[ti_max_in_range] = ti_max[ti_max_in_range]

    m, n = a0.shape
    t_mid = t_mid.repeat(n).reshape((m, n))

    # Compute bezier point and tangent at the chosen value of t
    mid = bezier([a0, h0, h1, a1])(t_mid)
    Tm = bezier([h0 - a0, h1 - h0, a1 - h1])(t_mid)

    # Intersection between tangent lines at end points
    # and tangent in the middle
    i0 = find_intersection(a0, T0, mid, Tm)
    i1 = find_intersection(a1, T1, mid, Tm)

    m, n = np.shape(a0)
    result = np.zeros((5 * m, n))
    result[0::5] = a0
    result[1::5] = i0
    result[2::5] = mid
    result[3::5] = i1
    result[4::5] = a1
    return result
</t>
<t tx="ekr.20250121054835.1916">def get_smooth_quadratic_bezier_path_through(
    points: Sequence[VectN]
) -&gt; np.ndarray:
    # TODO
    h0, h1 = get_smooth_cubic_bezier_handle_points(points)
    a0 = points[:-1]
    a1 = points[1:]
    return get_quadratic_approximation_of_cubic(a0, h0, h1, a1)
</t>
<t tx="ekr.20250121054835.1917">from __future__ import annotations

import os
from diskcache import Cache
from contextlib import contextmanager
from functools import wraps

from manimlib.utils.directories import get_cache_dir
from manimlib.utils.simple_functions import hash_string

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    T = TypeVar('T')


CACHE_SIZE = 1e9  # 1 Gig
_cache = Cache(get_cache_dir(), size_limit=CACHE_SIZE)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1918">def cache_on_disk(func: Callable[..., T]) -&gt; Callable[..., T]:
    @wraps(func)
    def wrapper(*args, **kwargs):
        key = hash_string(f"{func.__name__}{args}{kwargs}")
        value = _cache.get(key)
        if value is None:
            value = func(*args, **kwargs)
            _cache.set(key, value)
        return value
    return wrapper
</t>
<t tx="ekr.20250121054835.1919">def clear_cache():
    _cache.clear()
</t>
<t tx="ekr.20250121054835.192">def build_animations_with_timings(self, lag_ratio: float) -&gt; None:
    """
    Creates a list of triplets of the form
    (anim, start_time, end_time)
    """
    self.anims_with_timings = []
    curr_time = 0
    for anim in self.animations:
        start_time = curr_time
        end_time = start_time + anim.get_run_time()
        self.anims_with_timings.append(
            (anim, start_time, end_time)
        )
        # Start time of next animation is based on the lag_ratio
        curr_time = interpolate(
            start_time, end_time, lag_ratio
        )
</t>
<t tx="ekr.20250121054835.1920">from __future__ import annotations

from colour import Color
from colour import hex2rgb
from colour import rgb2hex
import numpy as np
import random
from matplotlib import pyplot

from manimlib.constants import COLORMAP_3B1B
from manimlib.constants import WHITE
from manimlib.utils.bezier import interpolate
from manimlib.utils.iterables import resize_with_interpolation

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable, Sequence, Callable
    from manimlib.typing import ManimColor, Vect3, Vect4, Vect3Array, Vect4Array, NDArray


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1921">def color_to_rgb(color: ManimColor) -&gt; Vect3:
    if isinstance(color, str):
        return hex_to_rgb(color)
    elif isinstance(color, Color):
        return np.array(color.get_rgb())
    else:
        raise Exception("Invalid color type")
</t>
<t tx="ekr.20250121054835.1922">def color_to_rgba(color: ManimColor, alpha: float = 1.0) -&gt; Vect4:
    return np.array([*color_to_rgb(color), alpha])
</t>
<t tx="ekr.20250121054835.1923">def rgb_to_color(rgb: Vect3 | Sequence[float]) -&gt; Color:
    try:
        return Color(rgb=tuple(rgb))
    except ValueError:
        return Color(WHITE)
</t>
<t tx="ekr.20250121054835.1924">def rgba_to_color(rgba: Vect4) -&gt; Color:
    return rgb_to_color(rgba[:3])
</t>
<t tx="ekr.20250121054835.1925">def rgb_to_hex(rgb: Vect3 | Sequence[float]) -&gt; str:
    return rgb2hex(rgb, force_long=True).upper()
</t>
<t tx="ekr.20250121054835.1926">def hex_to_rgb(hex_code: str) -&gt; Vect3:
    return np.array(hex2rgb(hex_code))
</t>
<t tx="ekr.20250121054835.1927">def invert_color(color: ManimColor) -&gt; Color:
    return rgb_to_color(1.0 - color_to_rgb(color))
</t>
<t tx="ekr.20250121054835.1928">def color_to_int_rgb(color: ManimColor) -&gt; np.ndarray[int, np.dtype[np.uint8]]:
    return (255 * color_to_rgb(color)).astype('uint8')
</t>
<t tx="ekr.20250121054835.1929">def color_to_int_rgba(color: ManimColor, opacity: float = 1.0) -&gt; np.ndarray[int, np.dtype[np.uint8]]:
    alpha = int(255 * opacity)
    return np.array([*color_to_int_rgb(color), alpha], dtype=np.uint8)
</t>
<t tx="ekr.20250121054835.193">def interpolate(self, alpha: float) -&gt; None:
    # Note, if the run_time of AnimationGroup has been
    # set to something other than its default, these
    # times might not correspond to actual times,
    # e.g. of the surrounding scene.  Instead they'd
    # be a rescaled version.  But that's okay!
    time = alpha * self.max_end_time
    for anim, start_time, end_time in self.anims_with_timings:
        anim_time = end_time - start_time
        if anim_time == 0:
            sub_alpha = 0
        else:
            sub_alpha = clip((time - start_time) / anim_time, 0, 1)
        anim.interpolate(sub_alpha)
</t>
<t tx="ekr.20250121054835.1930">def color_to_hex(color: ManimColor) -&gt; str:
    return Color(color).get_hex_l().upper()
</t>
<t tx="ekr.20250121054835.1931">def hex_to_int(rgb_hex: str) -&gt; int:
    return int(rgb_hex[1:], 16)
</t>
<t tx="ekr.20250121054835.1932">def int_to_hex(rgb_int: int) -&gt; str:
    return f"#{rgb_int:06x}".upper()
</t>
<t tx="ekr.20250121054835.1933">def color_gradient(
    reference_colors: Iterable[ManimColor],
    length_of_output: int
) -&gt; list[Color]:
    if length_of_output == 0:
        return []
    rgbs = list(map(color_to_rgb, reference_colors))
    alphas = np.linspace(0, (len(rgbs) - 1), length_of_output)
    floors = alphas.astype('int')
    alphas_mod1 = alphas % 1
    # End edge case
    alphas_mod1[-1] = 1
    floors[-1] = len(rgbs) - 2
    return [
        rgb_to_color(np.sqrt(interpolate(rgbs[i]**2, rgbs[i + 1]**2, alpha)))
        for i, alpha in zip(floors, alphas_mod1)
    ]
</t>
<t tx="ekr.20250121054835.1934">def interpolate_color(
    color1: ManimColor,
    color2: ManimColor,
    alpha: float
) -&gt; Color:
    rgb = np.sqrt(interpolate(color_to_rgb(color1)**2, color_to_rgb(color2)**2, alpha))
    return rgb_to_color(rgb)
</t>
<t tx="ekr.20250121054835.1935">def interpolate_color_by_hsl(
    color1: ManimColor,
    color2: ManimColor,
    alpha: float
) -&gt; Color:
    hsl1 = np.array(Color(color1).get_hsl())
    hsl2 = np.array(Color(color2).get_hsl())
    return Color(hsl=interpolate(hsl1, hsl2, alpha))
</t>
<t tx="ekr.20250121054835.1936">def average_color(*colors: ManimColor) -&gt; Color:
    rgbs = np.array(list(map(color_to_rgb, colors)))
    return rgb_to_color(np.sqrt((rgbs**2).mean(0)))
</t>
<t tx="ekr.20250121054835.1937">def random_color() -&gt; Color:
    return Color(rgb=tuple(np.random.random(3)))
</t>
<t tx="ekr.20250121054835.1938">def random_bright_color(
    hue_range: tuple[float, float] = (0.0, 1.0),
    saturation_range: tuple[float, float] = (0.5, 0.8),
    luminance_range: tuple[float, float] = (0.5, 1.0),
</t>
<t tx="ekr.20250121054835.1939">) -&gt; Color:
    return Color(hsl=(
        interpolate(*hue_range, random.random()),
        interpolate(*saturation_range, random.random()),
        interpolate(*luminance_range, random.random()),
    ))


def get_colormap_from_colors(colors: Iterable[ManimColor]) -&gt; Callable[[Sequence[float]], Vect4Array]:
    """
    Returns a funciton which takes in values between 0 and 1, and returns
    a corresponding list of rgba values
    """
    rgbas = np.array([color_to_rgba(color) for color in colors])

    def func(values):
        alphas = np.clip(values, 0, 1)
        scaled_alphas = alphas * (len(rgbas) - 1)
        indices = scaled_alphas.astype(int)
        next_indices = np.clip(indices + 1, 0, len(rgbas) - 1)
        inter_alphas = scaled_alphas % 1
        inter_alphas = inter_alphas.repeat(4).reshape((len(indices), 4))
        result = interpolate(rgbas[indices], rgbas[next_indices], inter_alphas)
        return result

    return func
</t>
<t tx="ekr.20250121054835.194">class Succession(AnimationGroup):
    @others
</t>
<t tx="ekr.20250121054835.1940">def get_color_map(map_name: str) -&gt; Callable[[Sequence[float]], Vect4Array]:
    if map_name == "3b1b_colormap":
        return get_colormap_from_colors(COLORMAP_3B1B)
    return pyplot.get_cmap(map_name)
</t>
<t tx="ekr.20250121054835.1941"># Delete this?
def get_colormap_list(
    map_name: str = "viridis",
    n_colors: int = 9
) -&gt; Vect3Array:
    """
    Options for map_name:
    3b1b_colormap
    magma
    inferno
    plasma
    viridis
    cividis
    twilight
    twilight_shifted
    turbo
    """
    from matplotlib.cm import cmaps_listed

    if map_name == "3b1b_colormap":
        rgbs = np.array([color_to_rgb(color) for color in COLORMAP_3B1B])
    else:
        rgbs = cmaps_listed[map_name].colors  # Make more general?
    return resize_with_interpolation(np.array(rgbs), n_colors)
</t>
<t tx="ekr.20250121054835.1942">from __future__ import annotations

from manimlib.constants import BLACK
from manimlib.logger import log
from manimlib.mobject.numbers import Integer
from manimlib.mobject.types.vectorized_mobject import VGroup

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from manimlib.mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1943">def print_family(mobject: Mobject, n_tabs: int = 0) -&gt; None:
    """For debugging purposes"""
    log.debug("\t" * n_tabs + str(mobject) + " " + str(id(mobject)))
    for submob in mobject.submobjects:
        print_family(submob, n_tabs + 1)
</t>
<t tx="ekr.20250121054835.1944">def index_labels(
    mobject: Mobject, 
    label_height: float = 0.15
) -&gt; VGroup:
    labels = VGroup()
    for n, submob in enumerate(mobject):
        label = Integer(n)
        label.set_height(label_height)
        label.move_to(submob)
        label.set_backstroke(BLACK, 5)
        labels.add(label)
    return labels
</t>
<t tx="ekr.20250121054835.1945">import itertools as it
import numpy as np


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1946">def merge_dicts_recursively(*dicts):
    """
    Creates a dict whose keyset is the union of all the
    input dictionaries.  The value for each key is based
    on the first dict in the list with that key.

    dicts later in the list have higher priority

    When values are dictionaries, it is applied recursively
    """
    result = dict()
    all_items = it.chain(*[d.items() for d in dicts])
    for key, value in all_items:
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = merge_dicts_recursively(result[key], value)
        else:
            result[key] = value
    return result
</t>
<t tx="ekr.20250121054835.1947">from __future__ import annotations

import os
import tempfile
import appdirs


from manimlib.config import manim_config
from manimlib.config import get_manim_dir
from manimlib.utils.file_ops import guarantee_existence


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1948">def get_directories() -&gt; dict[str, str]:
    return manim_config.directories
</t>
<t tx="ekr.20250121054835.1949">def get_cache_dir() -&gt; str:
    return get_directories()["cache"] or appdirs.user_cache_dir("manim")
</t>
<t tx="ekr.20250121054835.195">def __init__(
    self,
    *animations: Animation,
    lag_ratio: float = 1.0,
    **kwargs
):
    super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)
</t>
<t tx="ekr.20250121054835.1950">def get_temp_dir() -&gt; str:
    return get_directories()["temporary_storage"] or tempfile.gettempdir()
</t>
<t tx="ekr.20250121054835.1951">def get_downloads_dir() -&gt; str:
    return get_directories()["downloads"] or appdirs.user_cache_dir("manim_downloads")
</t>
<t tx="ekr.20250121054835.1952">def get_output_dir() -&gt; str:
    return guarantee_existence(get_directories()["output"])
</t>
<t tx="ekr.20250121054835.1953">def get_raster_image_dir() -&gt; str:
    return get_directories()["raster_images"]
</t>
<t tx="ekr.20250121054835.1954">def get_vector_image_dir() -&gt; str:
    return get_directories()["vector_images"]
</t>
<t tx="ekr.20250121054835.1955">def get_sound_dir() -&gt; str:
    return get_directories()["sounds"]
</t>
<t tx="ekr.20250121054835.1956">def get_shader_dir() -&gt; str:
    return os.path.join(get_manim_dir(), "manimlib", "shaders")
</t>
<t tx="ekr.20250121054835.1957">from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable, List, Set, Tuple

    from manimlib.mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1958">def extract_mobject_family_members(
    mobject_list: Iterable[Mobject],
    exclude_pointless: bool = False
) -&gt; list[Mobject]:
    return [
        sm
        for mob in mobject_list
        for sm in mob.get_family()
        if (not exclude_pointless) or sm.has_points()
    ]
</t>
<t tx="ekr.20250121054835.1959">def recursive_mobject_remove(mobjects: List[Mobject], to_remove: Set[Mobject]) -&gt; Tuple[List[Mobject], bool]:
    """
    Takes in a list of mobjects, together with a set of mobjects to remove.

    The first component of what's removed is a new list such that any mobject
    with one of the elements from `to_remove` in its family is no longer in
    the list, and in its place are its family members which aren't in `to_remove`

    The second component is a boolean value indicating whether any removals were made
    """
    result = []
    found_in_list = False
    for mob in mobjects:
        if mob in to_remove:
            found_in_list = True
            continue
        # Recursive call
        sub_list, found_in_submobjects = recursive_mobject_remove(
            mob.submobjects, to_remove
        )
        if found_in_submobjects:
            result.extend(sub_list)
            found_in_list = True
        else:
            result.append(mob)
    return result, found_in_list
</t>
<t tx="ekr.20250121054835.196">def begin(self) -&gt; None:
    assert len(self.animations) &gt; 0
    self.active_animation = self.animations[0]
    self.active_animation.begin()
</t>
<t tx="ekr.20250121054835.1960">from __future__ import annotations

import os
from pathlib import Path
import hashlib

import numpy as np
import validators
import urllib.request

import manimlib.utils.directories
from manimlib.utils.simple_functions import hash_string

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1961">def guarantee_existence(path: str | Path) -&gt; Path:
    path = Path(path)
    path.mkdir(parents=True, exist_ok=True)
    return path.absolute()
</t>
<t tx="ekr.20250121054835.1962">def find_file(
    file_name: str,
    directories: Iterable[str] | None = None,
    extensions: Iterable[str] | None = None
) -&gt; Path:
    # Check if this is a file online first, and if so, download
    # it to a temporary directory
    if validators.url(file_name):
        suffix = Path(file_name).suffix
        file_hash = hash_string(file_name)
        folder = manimlib.utils.directories.get_downloads_dir()

        path = Path(folder, file_hash).with_suffix(suffix)
        urllib.request.urlretrieve(file_name, path)
        return path

    # Check if what was passed in is already a valid path to a file
    if os.path.exists(file_name):
        return Path(file_name)

    # Otherwise look in local file system
    directories = directories or [""]
    extensions = extensions or [""]
    possible_paths = (
        Path(directory, file_name + extension)
        for directory in directories
        for extension in extensions
    )
    for path in possible_paths:
        if path.exists():
            return path
    raise IOError(f"{file_name} not Found")
</t>
<t tx="ekr.20250121054835.1963">from __future__ import annotations

import numpy as np
from PIL import Image

from manimlib.utils.directories import get_raster_image_dir
from manimlib.utils.directories import get_vector_image_dir
from manimlib.utils.file_ops import find_file

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1964">def get_full_raster_image_path(image_file_name: str) -&gt; str:
    return find_file(
        image_file_name,
        directories=[get_raster_image_dir()],
        extensions=[".jpg", ".jpeg", ".png", ".gif", ""]
    )
</t>
<t tx="ekr.20250121054835.1965">def get_full_vector_image_path(image_file_name: str) -&gt; str:
    return find_file(
        image_file_name,
        directories=[get_vector_image_dir()],
        extensions=[".svg", ".xdv", ""],
    )
</t>
<t tx="ekr.20250121054835.1966">def invert_image(image: Iterable) -&gt; Image.Image:
    arr = np.array(image)
    arr = (255 * np.ones(arr.shape)).astype(arr.dtype) - arr
    return Image.fromarray(arr)
</t>
<t tx="ekr.20250121054835.1967">from __future__ import annotations

from colour import Color

import numpy as np
import random

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, Iterable, Sequence, TypeVar

    T = TypeVar("T")
    S = TypeVar("S")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1968">def remove_list_redundancies(lst: Sequence[T]) -&gt; list[T]:
    """
    Remove duplicate elements while preserving order.
    Keeps the last occurrence of each element
    """
    return list(reversed(dict.fromkeys(reversed(lst))))
</t>
<t tx="ekr.20250121054835.1969">def list_update(l1: Iterable[T], l2: Iterable[T]) -&gt; list[T]:
    """
    Used instead of list(set(l1).update(l2)) to maintain order,
    making sure duplicates are removed from l1, not l2.
    """
    return remove_list_redundancies([*l1, *l2])
</t>
<t tx="ekr.20250121054835.197">def finish(self) -&gt; None:
    self.active_animation.finish()
</t>
<t tx="ekr.20250121054835.1970">def list_difference_update(l1: Iterable[T], l2: Iterable[T]) -&gt; list[T]:
    return [e for e in l1 if e not in l2]
</t>
<t tx="ekr.20250121054835.1971">def adjacent_n_tuples(objects: Sequence[T], n: int) -&gt; zip[tuple[T, ...]]:
    return zip(*[
        [*objects[k:], *objects[:k]]
        for k in range(n)
    ])
</t>
<t tx="ekr.20250121054835.1972">def adjacent_pairs(objects: Sequence[T]) -&gt; zip[tuple[T, T]]:
    return adjacent_n_tuples(objects, 2)
</t>
<t tx="ekr.20250121054835.1973">def batch_by_property(
    items: Iterable[T],
    property_func: Callable[[T], S]
) -&gt; list[tuple[T, S]]:
    """
    Takes in a list, and returns a list of tuples, (batch, prop)
    such that all items in a batch have the same output when
    put into property_func, and such that chaining all these
    batches together would give the original list (i.e. order is
    preserved)
    """
    batch_prop_pairs = []
    curr_batch = []
    curr_prop = None
    for item in items:
        prop = property_func(item)
        if prop != curr_prop:
            # Add current batch
            if len(curr_batch) &gt; 0:
                batch_prop_pairs.append((curr_batch, curr_prop))
            # Redefine curr
            curr_prop = prop
            curr_batch = [item]
        else:
            curr_batch.append(item)
    if len(curr_batch) &gt; 0:
        batch_prop_pairs.append((curr_batch, curr_prop))
    return batch_prop_pairs
</t>
<t tx="ekr.20250121054835.1974">def listify(obj: object) -&gt; list:
    if isinstance(obj, str):
        return [obj]
    try:
        return list(obj)
    except TypeError:
        return [obj]
</t>
<t tx="ekr.20250121054835.1975">def shuffled(iterable: Iterable) -&gt; list:
    as_list = list(iterable)
    random.shuffle(as_list)
    return as_list
</t>
<t tx="ekr.20250121054835.1976">def resize_array(nparray: np.ndarray, length: int) -&gt; np.ndarray:
    if len(nparray) == length:
        return nparray
    return np.resize(nparray, (length, *nparray.shape[1:]))
</t>
<t tx="ekr.20250121054835.1977">def resize_preserving_order(nparray: np.ndarray, length: int) -&gt; np.ndarray:
    if len(nparray) == 0:
        return np.resize(nparray, length)
    if len(nparray) == length:
        return nparray
    indices = np.arange(length) * len(nparray) // length
    return nparray[indices]
</t>
<t tx="ekr.20250121054835.1978">def resize_with_interpolation(nparray: np.ndarray, length: int) -&gt; np.ndarray:
    if len(nparray) == length:
        return nparray
    if len(nparray) == 1 or array_is_constant(nparray):
        return nparray[:1].repeat(length, axis=0)
    if length == 0:
        return np.zeros((0, *nparray.shape[1:]))
    cont_indices = np.linspace(0, len(nparray) - 1, length)
    return np.array([
        (1 - a) * nparray[lh] + a * nparray[rh]
        for ci in cont_indices
        for lh, rh, a in [(int(ci), int(np.ceil(ci)), ci % 1)]
    ])
</t>
<t tx="ekr.20250121054835.1979">def make_even(
    iterable_1: Sequence[T],
    iterable_2: Sequence[S]
) -&gt; tuple[Sequence[T], Sequence[S]]:
    len1 = len(iterable_1)
    len2 = len(iterable_2)
    if len1 == len2:
        return iterable_1, iterable_2
    new_len = max(len1, len2)
    return (
        [iterable_1[(n * len1) // new_len] for n in range(new_len)],
        [iterable_2[(n * len2) // new_len] for n in range(new_len)]
    )
</t>
<t tx="ekr.20250121054835.198">def update_mobjects(self, dt: float) -&gt; None:
    self.active_animation.update_mobjects(dt)
</t>
<t tx="ekr.20250121054835.1980">def arrays_match(arr1: np.ndarray, arr2: np.ndarray) -&gt; bool:
    return arr1.shape == arr2.shape and (arr1 == arr2).all()
</t>
<t tx="ekr.20250121054835.1981">def array_is_constant(arr: np.ndarray) -&gt; bool:
    return len(arr) &gt; 0 and (arr == arr[0]).all()
</t>
<t tx="ekr.20250121054835.1982">def cartesian_product(*arrays: np.ndarray):
    """
    Copied from https://stackoverflow.com/a/11146645
    """
    la = len(arrays)
    dtype = np.result_type(*arrays)
    arr = np.empty([len(a) for a in arrays] + [la], dtype=dtype)
    for i, a in enumerate(np.ix_(*arrays)):
        arr[..., i] = a
    return arr.reshape(-1, la)
</t>
<t tx="ekr.20250121054835.1983">def hash_obj(obj: object) -&gt; int:
    if isinstance(obj, dict):
        return hash(tuple(sorted([
            (hash_obj(k), hash_obj(v)) for k, v in obj.items()
        ])))

    if isinstance(obj, set):
        return hash(tuple(sorted(hash_obj(e) for e in obj)))

    if isinstance(obj, (tuple, list)):
        return hash(tuple(hash_obj(e) for e in obj))

    if isinstance(obj, Color):
        return hash(obj.get_rgb())

    return hash(obj)
</t>
<t tx="ekr.20250121054835.1984">from __future__ import annotations

import math

import numpy as np

from manimlib.constants import OUT
from manimlib.utils.bezier import interpolate
from manimlib.utils.space_ops import get_norm
from manimlib.utils.space_ops import rotation_matrix_transpose

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable
    from manimlib.typing import Vect3, Vect3Array


STRAIGHT_PATH_THRESHOLD = 0.01


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.1985">def straight_path(
    start_points: np.ndarray,
    end_points: np.ndarray,
    alpha: float
) -&gt; np.ndarray:
    """
    Same function as interpolate, but renamed to reflect
    intent of being used to determine how a set of points move
    to another set.  For instance, it should be a specific case
    of path_along_arc
    """
    return interpolate(start_points, end_points, alpha)
</t>
<t tx="ekr.20250121054835.1986">def path_along_arc(
    arc_angle: float, 
    axis: Vect3 = OUT
) -&gt; Callable[[Vect3Array, Vect3Array, float], Vect3Array]:
    """
    If vect is vector from start to end, [vect[:,1], -vect[:,0]] is
    perpendicular to vect in the left direction.
    """
    if abs(arc_angle) &lt; STRAIGHT_PATH_THRESHOLD:
        return straight_path
    if get_norm(axis) == 0:
        axis = OUT
    unit_axis = axis / get_norm(axis)

    def path(start_points, end_points, alpha):
        vects = end_points - start_points
        centers = start_points + 0.5 * vects
        if arc_angle != np.pi:
            centers += np.cross(unit_axis, vects / 2.0) / math.tan(arc_angle / 2)
        rot_matrix_T = rotation_matrix_transpose(alpha * arc_angle, unit_axis)
        return centers + np.dot(start_points - centers, rot_matrix_T)

    return path
</t>
<t tx="ekr.20250121054835.1987">def clockwise_path() -&gt; Callable[[Vect3Array, Vect3Array, float], Vect3Array]:
    return path_along_arc(-np.pi)
</t>
<t tx="ekr.20250121054835.1988">def counterclockwise_path() -&gt; Callable[[Vect3Array, Vect3Array, float], Vect3Array]:
    return path_along_arc(np.pi)
</t>
<t tx="ekr.20250121054835.1989">from __future__ import annotations

import numpy as np

from manimlib.utils.bezier import bezier

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.199">def interpolate(self, alpha: float) -&gt; None:
    index, subalpha = integer_interpolate(
        0, len(self.animations), alpha
    )
    animation = self.animations[index]
    if animation is not self.active_animation:
        self.active_animation.finish()
        animation.begin()
        self.active_animation = animation
    animation.interpolate(subalpha)
</t>
<t tx="ekr.20250121054835.1990">def linear(t: float) -&gt; float:
    return t
</t>
<t tx="ekr.20250121054835.1991">def smooth(t: float) -&gt; float:
    # Zero first and second derivatives at t=0 and t=1.
    # Equivalent to bezier([0, 0, 0, 1, 1, 1])
    s = 1 - t
    return (t**3) * (10 * s * s + 5 * s * t + t * t)
</t>
<t tx="ekr.20250121054835.1992">def rush_into(t: float) -&gt; float:
    return 2 * smooth(0.5 * t)
</t>
<t tx="ekr.20250121054835.1993">def rush_from(t: float) -&gt; float:
    return 2 * smooth(0.5 * (t + 1)) - 1
</t>
<t tx="ekr.20250121054835.1994">def slow_into(t: float) -&gt; float:
    return np.sqrt(1 - (1 - t) * (1 - t))
</t>
<t tx="ekr.20250121054835.1995">def double_smooth(t: float) -&gt; float:
    if t &lt; 0.5:
        return 0.5 * smooth(2 * t)
    else:
        return 0.5 * (1 + smooth(2 * t - 1))
</t>
<t tx="ekr.20250121054835.1996">def there_and_back(t: float) -&gt; float:
    new_t = 2 * t if t &lt; 0.5 else 2 * (1 - t)
    return smooth(new_t)
</t>
<t tx="ekr.20250121054835.1997">def there_and_back_with_pause(t: float, pause_ratio: float = 1. / 3) -&gt; float:
    a = 2. / (1. - pause_ratio)
    if t &lt; 0.5 - pause_ratio / 2:
        return smooth(a * t)
    elif t &lt; 0.5 + pause_ratio / 2:
        return 1
    else:
        return smooth(a - a * t)
</t>
<t tx="ekr.20250121054835.1998">def running_start(t: float, pull_factor: float = -0.5) -&gt; float:
    return bezier([0, 0, pull_factor, pull_factor, 1, 1, 1])(t)
</t>
<t tx="ekr.20250121054835.1999">def overshoot(t: float, pull_factor: float = 1.5) -&gt; float:
    return bezier([0, 0, pull_factor, pull_factor, 1, 1])(t)
</t>
<t tx="ekr.20250121054835.2">from manimlib import *
import numpy as np

# To watch one of these scenes, run the following:
# manimgl example_scenes.py OpeningManimExample
# Use -s to skip to the end and just save the final frame
# Use -w to write the animation to a file
# Use -o to write it to a file and open it once done
# Use -n &lt;number&gt; to skip ahead to the n'th animation of a scene.


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.20">def construct(self):
    axes = Axes((-3, 3), (-3, 3), unit_size=1)
    axes.to_edge(DOWN)
    axes.add_coordinate_labels(font_size=16)
    circle = Circle(radius=2)
    circle.set_stroke(YELLOW, 3)
    circle.move_to(axes.get_origin())
    self.add(axes, circle)

    # When numbers show up in tex, they can be readily
    # replaced with DecimalMobjects so that methods like
    # get_value and set_value can be called on them, and
    # animations like ChangeDecimalToValue can be called
    # on them.
    tex = Tex("x^2 + y^2 = 4.00")
    tex.next_to(axes, UP, buff=0.5)
    value = tex.make_number_changeable("4.00")


    # This will tie the right hand side of our equation to
    # the square of the radius of the circle
    value.add_updater(lambda v: v.set_value(circle.get_radius()**2))
    self.add(tex)

    text = Text("""
        You can manipulate numbers
        in Tex mobjects
    """, font_size=30)
    text.next_to(tex, RIGHT, buff=1.5)
    arrow = Arrow(text, tex)
    self.add(text, arrow)

    self.play(
        circle.animate.set_height(2.0),
        run_time=4,
        rate_func=there_and_back,
    )

    # By default, tex.make_number_changeable replaces the first occurance
    # of the number,but by passing replace_all=True it replaces all and
    # returns a group of the results
    exponents = tex.make_number_changeable("2", replace_all=True)
    self.play(
        LaggedStartMap(
            FlashAround, exponents,
            lag_ratio=0.2, buff=0.1, color=RED
        ),
        exponents.animate.set_color(RED)
    )

    def func(x, y):
        # Switch from manim coords to axes coords
        xa, ya = axes.point_to_coords(np.array([x, y, 0]))
        return xa**4 + ya**4 - 4

    new_curve = ImplicitFunction(func)
    new_curve.match_style(circle)
    circle.rotate(angle_of_vector(new_curve.get_start()))  # Align
    value.clear_updaters()

    self.play(
        *(ChangeDecimalToValue(exp, 4) for exp in exponents),
        ReplacementTransform(circle.copy(), new_curve),
        circle.animate.set_stroke(width=1, opacity=0.5),
    )
</t>
<t tx="ekr.20250121054835.200">class LaggedStart(AnimationGroup):
    @others
</t>
<t tx="ekr.20250121054835.2000">def not_quite_there(
    func: Callable[[float], float] = smooth,
    proportion: float = 0.7
) -&gt; Callable[[float], float]:
    def result(t):
        return proportion * func(t)
    return result
</t>
<t tx="ekr.20250121054835.2001">def wiggle(t: float, wiggles: float = 2) -&gt; float:
    return there_and_back(t) * np.sin(wiggles * np.pi * t)
</t>
<t tx="ekr.20250121054835.2002">def squish_rate_func(
    func: Callable[[float], float],
    a: float = 0.4,
    b: float = 0.6
) -&gt; Callable[[float], float]:
    def result(t):
        if a == b:
            return a
        elif t &lt; a:
            return func(0)
        elif t &gt; b:
            return func(1)
        else:
            return func((t - a) / (b - a))

    return result
</t>
<t tx="ekr.20250121054835.2003"># Stylistically, should this take parameters (with default values)?
# Ultimately, the functionality is entirely subsumed by squish_rate_func,
# but it may be useful to have a nice name for with nice default params for
# "lingering", different from squish_rate_func's default params


def lingering(t: float) -&gt; float:
    return squish_rate_func(lambda t: t, 0, 0.8)(t)
</t>
<t tx="ekr.20250121054835.2004">def exponential_decay(t: float, half_life: float = 0.1) -&gt; float:
    # The half-life should be rather small to minimize
    # the cut-off error at the end
    return 1 - np.exp(-t / half_life)
</t>
<t tx="ekr.20250121054835.2005">from __future__ import annotations

import os
import re
from functools import lru_cache
import moderngl
from PIL import Image
import numpy as np

from manimlib.utils.directories import get_shader_dir
from manimlib.utils.file_ops import find_file

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Sequence, Optional


# Global maps to reflect uniform status
PROGRAM_UNIFORM_MIRRORS: dict[int, dict[str, float | tuple]] = dict()


@lru_cache()
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.2006">def image_path_to_texture(path: str, ctx: moderngl.Context) -&gt; moderngl.Texture:
    im = Image.open(path).convert("RGBA")
    return ctx.texture(
        size=im.size,
        components=len(im.getbands()),
        data=im.tobytes(),
    )
</t>
<t tx="ekr.20250121054835.2007">@lru_cache()
def get_shader_program(
        ctx: moderngl.context.Context,
        vertex_shader: str,
        fragment_shader: Optional[str] = None,
        geometry_shader: Optional[str] = None,
) -&gt; moderngl.Program:
    return ctx.program(
        vertex_shader=vertex_shader,
        fragment_shader=fragment_shader,
        geometry_shader=geometry_shader,
    )
</t>
<t tx="ekr.20250121054835.2008">def set_program_uniform(
    program: moderngl.Program,
    name: str,
    value: float | tuple | np.ndarray
) -&gt; bool:
    """
    Sets a program uniform, and also keeps track of a dictionary
    of previously set uniforms for that program so that it
    doesn't needlessly reset it, requiring an exchange with gpu
    memory, if it sees the same value again.

    Returns True if changed the program, False if it left it as is.
    """

    pid = id(program)
    if pid not in PROGRAM_UNIFORM_MIRRORS:
        PROGRAM_UNIFORM_MIRRORS[pid] = dict()
    uniform_mirror = PROGRAM_UNIFORM_MIRRORS[pid]

    if type(value) is np.ndarray and value.ndim &gt; 0:
        value = tuple(value.flatten())
    if uniform_mirror.get(name, None) == value:
        return False

    try:
        program[name].value = value
    except KeyError:
        return False
    uniform_mirror[name] = value
    return True
</t>
<t tx="ekr.20250121054835.2009">@lru_cache()
def get_shader_code_from_file(filename: str) -&gt; str | None:
    if not filename:
        return None

    try:
        filepath = find_file(
            filename,
            directories=[get_shader_dir(), "/"],
            extensions=[],
        )
    except IOError:
        return None

    with open(filepath, "r") as f:
        result = f.read()

    # To share functionality between shaders, some functions are read in
    # from other files an inserted into the relevant strings before
    # passing to ctx.program for compiling
    # Replace "#INSERT " lines with relevant code
    insertions = re.findall(r"^#INSERT .*\.glsl$", result, flags=re.MULTILINE)
    for line in insertions:
        inserted_code = get_shader_code_from_file(
            os.path.join("inserts", line.replace("#INSERT ", ""))
        )
        result = result.replace(line, inserted_code)
    return result
</t>
<t tx="ekr.20250121054835.201">def __init__(
    self,
    *animations,
    lag_ratio: float = DEFAULT_LAGGED_START_LAG_RATIO,
    **kwargs
):
    super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)
</t>
<t tx="ekr.20250121054835.2010">def get_colormap_code(rgb_list: Sequence[float]) -&gt; str:
    data = ",".join(
        "vec3({}, {}, {})".format(*rgb)
        for rgb in rgb_list
    )
    return f"vec3[{len(rgb_list)}]({data})"
</t>
<t tx="ekr.20250121054835.2011">from __future__ import annotations

from functools import lru_cache
import hashlib
import inspect
import math

import numpy as np

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from typing import Callable, TypeVar, Iterable
    from manimlib.typing import FloatArray

    Scalable = TypeVar("Scalable", float, FloatArray)



@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.2012">def sigmoid(x: float | FloatArray):
    return 1.0 / (1 + np.exp(-x))
</t>
<t tx="ekr.20250121054835.2013">@lru_cache(maxsize=10)
def choose(n: int, k: int) -&gt; int:
    return math.comb(n, k)
</t>
<t tx="ekr.20250121054835.2014">def gen_choose(n: int, r: int) -&gt; int:
    return int(np.prod(range(n, n - r, -1)) / math.factorial(r))
</t>
<t tx="ekr.20250121054835.2015">def get_num_args(function: Callable) -&gt; int:
    return function.__code__.co_argcount
</t>
<t tx="ekr.20250121054835.2016">def get_parameters(function: Callable) -&gt; Iterable[str]:
    return inspect.signature(function).parameters.keys()
</t>
<t tx="ekr.20250121054835.2017">def clip(a: float, min_a: float, max_a: float) -&gt; float:
    if a &lt; min_a:
        return min_a
    elif a &gt; max_a:
        return max_a
    return a
</t>
<t tx="ekr.20250121054835.2018">def arr_clip(arr: np.ndarray, min_a: float, max_a: float) -&gt; np.ndarray:
    arr[arr &lt; min_a] = min_a
    arr[arr &gt; max_a] = max_a
    return arr
</t>
<t tx="ekr.20250121054835.2019">def fdiv(a: Scalable, b: Scalable, zero_over_zero_value: Scalable | None = None) -&gt; Scalable:
    """
    Less heavyweight name for np.true_divide, enabling
    default behavior for 0/0
    """
    if zero_over_zero_value is not None:
        out = np.full_like(a, zero_over_zero_value)
        where = np.logical_or(a != 0, b != 0)
    else:
        out = None
        where = True

    return np.true_divide(a, b, out=out, where=where)
</t>
<t tx="ekr.20250121054835.202">class LaggedStartMap(LaggedStart):
    @others
</t>
<t tx="ekr.20250121054835.2020">def binary_search(
    function: Callable[[float], float],
    target: float,
    lower_bound: float,
    upper_bound: float,
    tolerance:float = 1e-4
) -&gt; float | None:
    lh = lower_bound
    rh = upper_bound
    mh = (lh + rh) / 2
    while abs(rh - lh) &gt; tolerance:
        lx, mx, rx = [function(h) for h in (lh, mh, rh)]
        if lx == target:
            return lx
        if rx == target:
            return rx

        if lx &lt;= target and rx &gt;= target:
            if mx &gt; target:
                rh = mh
            else:
                lh = mh
        elif lx &gt; target and rx &lt; target:
            lh, rh = rh, lh
        else:
            return None
        mh = (lh + rh) / 2
    return mh
</t>
<t tx="ekr.20250121054835.2021">def hash_string(string: str, n_bytes=16) -&gt; str:
    hasher = hashlib.sha256(string.encode())
    return hasher.hexdigest()[:n_bytes]
</t>
<t tx="ekr.20250121054835.2022">from __future__ import annotations

from manimlib.utils.directories import get_sound_dir
from manimlib.utils.file_ops import find_file


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.2023">def get_full_sound_file_path(sound_file_name: str) -&gt; str:
    return find_file(
        sound_file_name,
        directories=[get_sound_dir()],
        extensions=[".wav", ".mp3", ""]
    )
</t>
<t tx="ekr.20250121054835.2024">from __future__ import annotations

from functools import reduce
import math
import operator as op
import platform

from mapbox_earcut import triangulate_float32 as earcut
import numpy as np
from scipy.spatial.transform import Rotation
from tqdm.auto import tqdm as ProgressDisplay

from manimlib.constants import DOWN, OUT, RIGHT, UP
from manimlib.constants import PI, TAU
from manimlib.utils.iterables import adjacent_pairs
from manimlib.utils.simple_functions import clip

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, Sequence, List, Tuple
    from manimlib.typing import Vect2, Vect3, Vect4, VectN, Matrix3x3, Vect3Array, Vect2Array


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.2025">def cross(
    v1: Vect3 | List[float],
    v2: Vect3 | List[float],
    out: np.ndarray | None = None
) -&gt; Vect3 | Vect3Array:
    is2d = isinstance(v1, np.ndarray) and len(v1.shape) == 2
    if is2d:
        x1, y1, z1 = v1[:, 0], v1[:, 1], v1[:, 2]
        x2, y2, z2 = v2[:, 0], v2[:, 1], v2[:, 2]
    else:
        x1, y1, z1 = v1
        x2, y2, z2 = v2
    if out is None:
        out = np.empty(np.shape(v1))
    out.T[:] = [
        y1 * z2 - z1 * y2,
        z1 * x2 - x1 * z2,
        x1 * y2 - y1 * x2,
    ]
    return out
</t>
<t tx="ekr.20250121054835.2026">def get_norm(vect: VectN | List[float]) -&gt; float:
    return sum((x**2 for x in vect))**0.5
</t>
<t tx="ekr.20250121054835.2027">def get_dist(vect1: VectN, vect2: VectN):
    return get_norm(vect2 - vect1)
</t>
<t tx="ekr.20250121054835.2028">def normalize(
    vect: VectN | List[float],
    fall_back: VectN | List[float] | None = None
) -&gt; VectN:
    norm = get_norm(vect)
    if norm &gt; 0:
        return np.array(vect) / norm
    elif fall_back is not None:
        return np.array(fall_back)
    else:
        return np.zeros(len(vect))
</t>
<t tx="ekr.20250121054835.2029">def poly_line_length(points):
    """
    Return the sum of the lengths between adjacent points
    """
    diffs = points[1:] - points[:-1]
    return np.sqrt((diffs**2).sum(1)).sum()
</t>
<t tx="ekr.20250121054835.203">def __init__(
    self,
    anim_func: Callable[[Mobject], Animation],
    group: Mobject,
    run_time: float = 2.0,
    lag_ratio: float = DEFAULT_LAGGED_START_LAG_RATIO,
    **kwargs
):
    anim_kwargs = dict(kwargs)
    anim_kwargs.pop("lag_ratio", None)
    super().__init__(
        *(anim_func(submob, **anim_kwargs) for submob in group),
        run_time=run_time,
        lag_ratio=lag_ratio,
        group=group
    )
</t>
<t tx="ekr.20250121054835.2030"># Operations related to rotation


def quaternion_mult(*quats: Vect4) -&gt; Vect4:
    """
    Inputs are treated as quaternions, where the real part is the
    last entry, so as to follow the scipy Rotation conventions.
    """
    if len(quats) == 0:
        return np.array([0, 0, 0, 1])
    result = np.array(quats[0])
    for next_quat in quats[1:]:
        x1, y1, z1, w1 = result
        x2, y2, z2, w2 = next_quat
        result[:] = [
            w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2,
            w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2,
            w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2,
            w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2,
        ]
    return result
</t>
<t tx="ekr.20250121054835.2031">def quaternion_from_angle_axis(
    angle: float,
    axis: Vect3,
) -&gt; Vect4:
    return Rotation.from_rotvec(angle * normalize(axis)).as_quat()
</t>
<t tx="ekr.20250121054835.2032">def angle_axis_from_quaternion(quat: Vect4) -&gt; Tuple[float, Vect3]:
    rot_vec = Rotation.from_quat(quat).as_rotvec()
    norm = get_norm(rot_vec)
    return norm, rot_vec / norm
</t>
<t tx="ekr.20250121054835.2033">def quaternion_conjugate(quaternion: Vect4) -&gt; Vect4:
    result = np.array(quaternion)
    result[:3] *= -1
    return result
</t>
<t tx="ekr.20250121054835.2034">def rotate_vector(
    vector: Vect3,
    angle: float,
    axis: Vect3 = OUT
) -&gt; Vect3:
    rot = Rotation.from_rotvec(angle * normalize(axis))
    return np.dot(vector, rot.as_matrix().T)
</t>
<t tx="ekr.20250121054835.2035">def rotate_vector_2d(vector: Vect2, angle: float) -&gt; Vect2:
    # Use complex numbers...because why not
    z = complex(*vector) * np.exp(complex(0, angle))
    return np.array([z.real, z.imag])
</t>
<t tx="ekr.20250121054835.2036">def rotation_matrix_transpose_from_quaternion(quat: Vect4) -&gt; Matrix3x3:
    return Rotation.from_quat(quat).as_matrix()
</t>
<t tx="ekr.20250121054835.2037">def rotation_matrix_from_quaternion(quat: Vect4) -&gt; Matrix3x3:
    return np.transpose(rotation_matrix_transpose_from_quaternion(quat))
</t>
<t tx="ekr.20250121054835.2038">def rotation_matrix(angle: float, axis: Vect3) -&gt; Matrix3x3:
    """
    Rotation in R^3 about a specified axis of rotation.
    """
    return Rotation.from_rotvec(angle * normalize(axis)).as_matrix()
</t>
<t tx="ekr.20250121054835.2039">def rotation_matrix_transpose(angle: float, axis: Vect3) -&gt; Matrix3x3:
    return rotation_matrix(angle, axis).T
</t>
<t tx="ekr.20250121054835.204">from __future__ import annotations

from abc import ABC, abstractmethod

import numpy as np

from manimlib.animation.animation import Animation
from manimlib.mobject.svg.string_mobject import StringMobject
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.bezier import integer_interpolate
from manimlib.utils.rate_functions import linear
from manimlib.utils.rate_functions import double_smooth
from manimlib.utils.rate_functions import smooth
from manimlib.utils.simple_functions import clip

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable
    from manimlib.mobject.mobject import Mobject
    from manimlib.scene.scene import Scene
    from manimlib.typing import ManimColor


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.2040">def rotation_about_z(angle: float) -&gt; Matrix3x3:
    cos_a = math.cos(angle)
    sin_a = math.sin(angle)
    return np.array([
        [cos_a, -sin_a, 0],
        [sin_a, cos_a, 0],
        [0, 0, 1]
    ])
</t>
<t tx="ekr.20250121054835.2041">def rotation_between_vectors(v1: Vect3, v2: Vect3) -&gt; Matrix3x3:
    atol = 1e-8
    if get_norm(v1 - v2) &lt; atol:
        return np.identity(3)
    axis = cross(v1, v2)
    if get_norm(axis) &lt; atol:
        # v1 and v2 align
        axis = cross(v1, RIGHT)
    if get_norm(axis) &lt; atol:
        # v1 and v2 _and_ RIGHT all align
        axis = cross(v1, UP)
    return rotation_matrix(
        angle=angle_between_vectors(v1, v2),
        axis=axis,
    )
</t>
<t tx="ekr.20250121054835.2042">def z_to_vector(vector: Vect3) -&gt; Matrix3x3:
    return rotation_between_vectors(OUT, vector)
</t>
<t tx="ekr.20250121054835.2043">def angle_of_vector(vector: Vect2 | Vect3) -&gt; float:
    """
    Returns polar coordinate theta when vector is project on xy plane
    """
    return math.atan2(vector[1], vector[0])
</t>
<t tx="ekr.20250121054835.2044">def angle_between_vectors(v1: VectN, v2: VectN) -&gt; float:
    """
    Returns the angle between two 3D vectors.
    This angle will always be btw 0 and pi
    """
    n1 = get_norm(v1)
    n2 = get_norm(v2)
    if n1 == 0 or n2 == 0:
        return 0
    cos_angle = np.dot(v1, v2) / np.float64(n1 * n2)
    return math.acos(clip(cos_angle, -1, 1))
</t>
<t tx="ekr.20250121054835.2045">def project_along_vector(point: Vect3, vector: Vect3) -&gt; Vect3:
    matrix = np.identity(3) - np.outer(vector, vector)
    return np.dot(point, matrix.T)
</t>
<t tx="ekr.20250121054835.2046">def normalize_along_axis(
    array: np.ndarray,
    axis: int,
) -&gt; np.ndarray:
    norms = np.sqrt((array * array).sum(axis))
    norms[norms == 0] = 1
    return array / norms[:, np.newaxis]
</t>
<t tx="ekr.20250121054835.2047">def get_unit_normal(
    v1: Vect3,
    v2: Vect3,
    tol: float = 1e-6
) -&gt; Vect3:
    v1 = normalize(v1)
    v2 = normalize(v2)
    cp = cross(v1, v2)
    cp_norm = get_norm(cp)
    if cp_norm &lt; tol:
        # Vectors align, so find a normal to them in the plane shared with the z-axis
        new_cp = cross(cross(v1, OUT), v1)
        new_cp_norm = get_norm(new_cp)
        if new_cp_norm &lt; tol:
            return DOWN
        return new_cp / new_cp_norm
    return cp / cp_norm
</t>
<t tx="ekr.20250121054835.2048">###


def thick_diagonal(dim: int, thickness: int = 2) -&gt; np.ndarray:
    row_indices = np.arange(dim).repeat(dim).reshape((dim, dim))
    col_indices = np.transpose(row_indices)
    return (np.abs(row_indices - col_indices) &lt; thickness).astype('uint8')
</t>
<t tx="ekr.20250121054835.2049">def compass_directions(n: int = 4, start_vect: Vect3 = RIGHT) -&gt; Vect3:
    angle = TAU / n
    return np.array([
        rotate_vector(start_vect, k * angle)
        for k in range(n)
    ])
</t>
<t tx="ekr.20250121054835.205">class ShowPartial(Animation, ABC):
    """
    Abstract class for ShowCreation and ShowPassingFlash
    """
    @others
</t>
<t tx="ekr.20250121054835.2050">def complex_to_R3(complex_num: complex) -&gt; Vect3:
    return np.array((complex_num.real, complex_num.imag, 0))
</t>
<t tx="ekr.20250121054835.2051">def R3_to_complex(point: Vect3) -&gt; complex:
    return complex(*point[:2])
</t>
<t tx="ekr.20250121054835.2052">def complex_func_to_R3_func(complex_func: Callable[[complex], complex]) -&gt; Callable[[Vect3], Vect3]:
    def result(p: Vect3):
        return complex_to_R3(complex_func(R3_to_complex(p)))
    return result
</t>
<t tx="ekr.20250121054835.2053">def center_of_mass(points: Sequence[Vect3]) -&gt; Vect3:
    return np.array(points).sum(0) / len(points)
</t>
<t tx="ekr.20250121054835.2054">def midpoint(point1: VectN, point2: VectN) -&gt; VectN:
    return center_of_mass([point1, point2])
</t>
<t tx="ekr.20250121054835.2055">def line_intersection(
    line1: Tuple[Vect3, Vect3],
    line2: Tuple[Vect3, Vect3]
) -&gt; Vect3:
    """
    return intersection point of two lines,
    each defined with a pair of vectors determining
    the end points
    """
    x_diff = (line1[0][0] - line1[1][0], line2[0][0] - line2[1][0])
    y_diff = (line1[0][1] - line1[1][1], line2[0][1] - line2[1][1])

    def det(a, b):
        return a[0] * b[1] - a[1] * b[0]

    div = det(x_diff, y_diff)
    if div == 0:
        raise Exception("Lines do not intersect")
    d = (det(*line1), det(*line2))
    x = det(d, x_diff) / div
    y = det(d, y_diff) / div
    return np.array([x, y, 0])
</t>
<t tx="ekr.20250121054835.2056">def find_intersection(
    p0: Vect3 | Vect3Array,
    v0: Vect3 | Vect3Array,
    p1: Vect3 | Vect3Array,
    v1: Vect3 | Vect3Array,
    threshold: float = 1e-5,
) -&gt; Vect3:
    """
    Return the intersection of a line passing through p0 in direction v0
    with one passing through p1 in direction v1.  (Or array of intersections
    from arrays of such points/directions).

    For 3d values, it returns the point on the ray p0 + v0 * t closest to the
    ray p1 + v1 * t
    """
    d = len(p0.shape)
    if d == 1:
        is_3d = any(arr[2] for arr in (p0, v0, p1, v1))
    else:
        is_3d = any(z for arr in (p0, v0, p1, v1) for z in arr.T[2])
    if not is_3d:
        numer = np.array(cross2d(v1, p1 - p0))
        denom = np.array(cross2d(v1, v0))
    else:
        cp1 = cross(v1, p1 - p0)
        cp2 = cross(v1, v0)
        numer = np.array((cp1 * cp1).sum(d - 1))
        denom = np.array((cp1 * cp2).sum(d - 1))
    denom[abs(denom) &lt; threshold] = np.inf
    ratio = numer / denom
    return p0 + (ratio * v0.T).T
</t>
<t tx="ekr.20250121054835.2057">def line_intersects_path(
    start: Vect2 | Vect3,
    end: Vect2 | Vect3,
    path: Vect2Array | Vect3Array,
) -&gt; bool:
    """
    Tests whether the line (start, end) intersects
    a polygonal path defined by its vertices
    """
    n = len(path) - 1
    p1 = np.empty((n, 2))
    q1 = np.empty((n, 2))
    p1[:] = start[:2]
    q1[:] = end[:2]
    p2 = path[:-1, :2]
    q2 = path[1:, :2]

    v1 = q1 - p1
    v2 = q2 - p2

    mis1 = cross2d(v1, p2 - p1) * cross2d(v1, q2 - p1) &lt; 0
    mis2 = cross2d(v2, p1 - p2) * cross2d(v2, q1 - p2) &lt; 0
    return bool((mis1 * mis2).any())
</t>
<t tx="ekr.20250121054835.2058">def get_closest_point_on_line(a: VectN, b: VectN, p: VectN) -&gt; VectN:
    """
        It returns point x such that
        x is on line ab and xp is perpendicular to ab.
        If x lies beyond ab line, then it returns nearest edge(a or b).
    """
    # x = b + t*(a-b) = t*a + (1-t)*b
    t = np.dot(p - b, a - b) / np.dot(a - b, a - b)
    if t &lt; 0:
        t = 0
    if t &gt; 1:
        t = 1
    return ((t * a) + ((1 - t) * b))
</t>
<t tx="ekr.20250121054835.2059">def get_winding_number(points: Sequence[Vect2 | Vect3]) -&gt; float:
    total_angle = 0
    for p1, p2 in adjacent_pairs(points):
        d_angle = angle_of_vector(p2) - angle_of_vector(p1)
        d_angle = ((d_angle + PI) % TAU) - PI
        total_angle += d_angle
    return total_angle / TAU
</t>
<t tx="ekr.20250121054835.206">def __init__(self, mobject: Mobject, should_match_start: bool = False, **kwargs):
    self.should_match_start = should_match_start
    super().__init__(mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.2060">##

def cross2d(a: Vect2 | Vect2Array, b: Vect2 | Vect2Array) -&gt; Vect2 | Vect2Array:
    if len(a.shape) == 2:
        return a[:, 0] * b[:, 1] - a[:, 1] * b[:, 0]
    else:
        return a[0] * b[1] - b[0] * a[1]
</t>
<t tx="ekr.20250121054835.2061">def tri_area(
    a: Vect2,
    b: Vect2,
    c: Vect2
) -&gt; float:
    return 0.5 * abs(
        a[0] * (b[1] - c[1]) +
        b[0] * (c[1] - a[1]) +
        c[0] * (a[1] - b[1])
    )
</t>
<t tx="ekr.20250121054835.2062">def is_inside_triangle(
    p: Vect2,
    a: Vect2,
    b: Vect2,
    c: Vect2
) -&gt; bool:
    """
    Test if point p is inside triangle abc
    """
    crosses = np.array([
        cross2d(p - a, b - p),
        cross2d(p - b, c - p),
        cross2d(p - c, a - p),
    ])
    return bool(np.all(crosses &gt; 0) or np.all(crosses &lt; 0))
</t>
<t tx="ekr.20250121054835.2063">def norm_squared(v: VectN | List[float]) -&gt; float:
    return sum(x * x for x in v)
</t>
<t tx="ekr.20250121054835.2064"># TODO, fails for polygons drawn over themselves
def earclip_triangulation(verts: Vect3Array | Vect2Array, ring_ends: list[int]) -&gt; list[int]:
    """
    Returns a list of indices giving a triangulation
    of a polygon, potentially with holes

    - verts is a numpy array of points

    - ring_ends is a list of indices indicating where
    the ends of new paths are
    """

    rings = [
        list(range(e0, e1))
        for e0, e1 in zip([0, *ring_ends], ring_ends)
    ]
    epsilon = 1e-6

    def is_in(point, ring_id):
        return abs(abs(get_winding_number([i - point for i in verts[rings[ring_id]]])) - 1) &lt; epsilon

    def ring_area(ring_id):
        ring = rings[ring_id]
        s = 0
        for i, j in zip(ring[1:], ring):
            s += cross2d(verts[i], verts[j])
        return abs(s) / 2

    # Points at the same position may cause problems
    for i in rings:
        if len(i) &lt; 2:
            continue
        verts[i[0]] += (verts[i[1]] - verts[i[0]]) * epsilon
        verts[i[-1]] += (verts[i[-2]] - verts[i[-1]]) * epsilon

    # First, we should know which rings are directly contained in it for each ring

    right = [max(verts[rings[i], 0]) for i in range(len(rings))]
    left = [min(verts[rings[i], 0]) for i in range(len(rings))]
    top = [max(verts[rings[i], 1]) for i in range(len(rings))]
    bottom = [min(verts[rings[i], 1]) for i in range(len(rings))]
    area = [ring_area(i) for i in range(len(rings))]

    # The larger ring must be outside
    rings_sorted = list(range(len(rings)))
    rings_sorted.sort(key=lambda x: area[x], reverse=True)

    def is_in_fast(ring_a, ring_b):
        # Whether a is in b
        return reduce(op.and_, (
            left[ring_b] &lt;= left[ring_a] &lt;= right[ring_a] &lt;= right[ring_b],
            bottom[ring_b] &lt;= bottom[ring_a] &lt;= top[ring_a] &lt;= top[ring_b],
            is_in(verts[rings[ring_a][0]], ring_b)
        ))

    chilren = [[] for i in rings]
    ringenum = ProgressDisplay(
        enumerate(rings_sorted),
        total=len(rings),
        leave=False,
        ascii=True if platform.system() == 'Windows' else None,
        dynamic_ncols=True,
        desc="SVG Triangulation",
        delay=3,
    )
    for idx, i in ringenum:
        for j in rings_sorted[:idx][::-1]:
            if is_in_fast(i, j):
                chilren[j].append(i)
                break

    res = []

    # Then, we can use earcut for each part
    used = [False] * len(rings)
    for i in rings_sorted:
        if used[i]:
            continue
        v = rings[i]
        ring_ends = [len(v)]
        for j in chilren[i]:
            used[j] = True
            v += rings[j]
            ring_ends.append(len(v))
        res += [v[i] for i in earcut(verts[v, :2], ring_ends)]

    return res
</t>
<t tx="ekr.20250121054835.2065">from __future__ import annotations

import re
from functools import lru_cache

from manimlib.utils.tex_to_symbol_count import TEX_TO_SYMBOL_COUNT


@lru_cache
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.2066">def num_tex_symbols(tex: str) -&gt; int:
    tex = remove_tex_environments(tex)
    commands_pattern = r"""
        (?P&lt;sqrt&gt;\\sqrt\[[0-9]+\])|    # Special sqrt with number
        (?P&lt;escaped_brace&gt;\\[{}])|      # Escaped braces
        (?P&lt;cmd&gt;\\[a-zA-Z!,-/:;&lt;&gt;]+)    # Regular commands
    """
    total = 0
    pos = 0
    for match in re.finditer(commands_pattern, tex, re.VERBOSE):
        # Count normal characters up to this command
        total += sum(1 for c in tex[pos:match.start()] if c not in "^{} \n\t_$\\&amp;")

        if match.group("sqrt"):
            total += len(match.group()) - 5
        elif match.group("escaped_brace"):
            total += 1  # Count escaped brace as one symbol
        else:
            total += TEX_TO_SYMBOL_COUNT.get(match.group(), 1)
        pos = match.end()

    # Count remaining characters
    total += sum(1 for c in tex[pos:] if c not in "^{} \n\t_$\\&amp;")
    return total
</t>
<t tx="ekr.20250121054835.2067">def remove_tex_environments(tex: str) -&gt; str:
    # Handle \phantom{...} with any content
    tex = re.sub(r"\\phantom\{[^}]*\}", "", tex)
    # Handle other environment commands
    tex = re.sub(r"\\(begin|end)(\{\w+\})?(\{\w+\})?(\[\w+\])?", "", tex)
    return tex
</t>
<t tx="ekr.20250121054835.2068">from __future__ import annotations

import os
import re
import yaml
import subprocess
from functools import lru_cache

from pathlib import Path
import tempfile

from manimlib.utils.cache import cache_on_disk
from manimlib.config import manim_config
from manimlib.config import get_manim_dir
from manimlib.logger import log
from manimlib.utils.simple_functions import hash_string


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.2069">def get_tex_template_config(template_name: str) -&gt; dict[str, str]:
    name = template_name.replace(" ", "_").lower()
    template_path = os.path.join(get_manim_dir(), "manimlib", "tex_templates.yml")
    with open(template_path, encoding="utf-8") as tex_templates_file:
        templates_dict = yaml.safe_load(tex_templates_file)
    if name not in templates_dict:
        log.warning(f"Cannot recognize template {name}, falling back to 'default'.")
        name = "default"
    return templates_dict[name]
</t>
<t tx="ekr.20250121054835.207">def interpolate_submobject(
    self,
    submob: VMobject,
    start_submob: VMobject,
    alpha: float
) -&gt; None:
    submob.pointwise_become_partial(
        start_submob, *self.get_bounds(alpha)
    )
</t>
<t tx="ekr.20250121054835.2070">@lru_cache
def get_tex_config(template: str = "") -&gt; tuple[str, str]:
    """
    Returns a compiler and preamble to use for rendering LaTeX
    """
    template = template or manim_config.tex.template
    config = get_tex_template_config(template)
    return config["compiler"], config["preamble"]
</t>
<t tx="ekr.20250121054835.2071">def get_full_tex(content: str, preamble: str = ""):
    return "\n\n".join((
        "\\documentclass[preview]{standalone}",
        preamble,
        "\\begin{document}",
        content,
        "\\end{document}"
    )) + "\n"
</t>
<t tx="ekr.20250121054835.2072">@lru_cache(maxsize=128)
def latex_to_svg(
    latex: str,
    template: str = "",
    additional_preamble: str = "",
    short_tex: str = "",
    show_message_during_execution: bool = True,
) -&gt; str:
    """Convert LaTeX string to SVG string.

    Args:
        latex: LaTeX source code
        template: Path to a template LaTeX file
        additional_preamble: String including any added "\\usepackage{...}" style imports

    Returns:
        str: SVG source code

    Raises:
        LatexError: If LaTeX compilation fails
        NotImplementedError: If compiler is not supported
    """
    if show_message_during_execution:
        message = f"Writing {(short_tex or latex)[:70]}..."
    else:
        message = ""

    compiler, preamble = get_tex_config(template)

    preamble = "\n".join([preamble, additional_preamble])
    full_tex = get_full_tex(latex, preamble)
    return full_tex_to_svg(full_tex, compiler, message)
</t>
<t tx="ekr.20250121054835.2073">@cache_on_disk
def full_tex_to_svg(full_tex: str, compiler: str = "latex", message: str = ""):
    if message:
        print(message, end="\r")

    if compiler == "latex":
        dvi_ext = ".dvi"
    elif compiler == "xelatex":
        dvi_ext = ".xdv"
    else:
        raise NotImplementedError(f"Compiler '{compiler}' is not implemented")

    # Write intermediate files to a temporary directory
    with tempfile.TemporaryDirectory() as temp_dir:
        tex_path = Path(temp_dir, "working").with_suffix(".tex")
        dvi_path = tex_path.with_suffix(dvi_ext)

        # Write tex file
        tex_path.write_text(full_tex)

        # Run latex compiler
        process = subprocess.run(
            [
                compiler,
                *(['-no-pdf'] if compiler == "xelatex" else []),
                "-interaction=batchmode",
                "-halt-on-error",
                f"-output-directory={temp_dir}",
                tex_path
            ],
            capture_output=True,
            text=True
        )

        if process.returncode != 0:
            # Handle error
            error_str = ""
            log_path = tex_path.with_suffix(".log")
            if log_path.exists():
                content = log_path.read_text()
                error_match = re.search(r"(?&lt;=\n! ).*\n.*\n", content)
                if error_match:
                    error_str = error_match.group()
            raise LatexError(error_str or "LaTeX compilation failed")

        # Run dvisvgm and capture output directly
        process = subprocess.run(
            [
                "dvisvgm",
                dvi_path,
                "-n",  # no fonts
                "-v", "0",  # quiet
                "--stdout",  # output to stdout instead of file
            ],
            capture_output=True
        )

        # Return SVG string
        result = process.stdout.decode('utf-8')

    if message:
        print(" " * len(message), end="\r")

    return result
</t>
<t tx="ekr.20250121054835.2074">class LatexError(Exception):
    pass
</t>
<t tx="ekr.20250121054835.2075">TEX_TO_SYMBOL_COUNT = {
    R"\!": 0,
    R"\,": 0,
    R"\-": 0,
    R"\/": 0,
    R"\:": 0,
    R"\;": 0,
    R"\&gt;": 0,
    R"\aa": 0,
    R"\AA": 0,
    R"\ae": 0,
    R"\AE": 0,
    R"\arccos": 6,
    R"\arcsin": 6,
    R"\arctan": 6,
    R"\arg": 3,
    R"\author": 0,
    R"\bf": 0,
    R"\bibliography": 0,
    R"\bibliographystyle": 0,
    R"\big": 0,
    R"\Big": 0,
    R"\bigodot": 4,
    R"\bigoplus": 5,
    R"\bigskip": 0,
    R"\bmod": 3,
    R"\boldmath": 0,
    R"\bottomfraction": 2,
    R"\bowtie": 2,
    R"\cal": 0,
    R"\cdots": 3,
    R"\centering": 0,
    R"\cite": 2,
    R"\cong": 2,
    R"\contentsline": 0,
    R"\cos": 3,
    R"\cosh": 4,
    R"\cot": 3,
    R"\coth": 4,
    R"\csc": 3,
    R"\date": 0,
    R"\dblfloatpagefraction": 2,
    R"\dbltopfraction": 2,
    R"\ddots": 3,
    R"\deg": 3,
    R"\det": 3,
    R"\dim": 3,
    R"\displaystyle": 0,
    R"\div": 2,
    R"\doteq": 2,
    R"\dotfill": 0,
    R"\dots": 3,
    R"\emph": 0,
    R"\exp": 3,
    R"\fbox": 4,
    R"\floatpagefraction": 2,
    R"\flushbottom": 0,
    R"\footnotesize": 0,
    R"\footnotetext": 0,
    R"\frame": 2,
    R"\framebox": 4,
    R"\fussy": 0,
    R"\gcd": 3,
    R"\ghost": 0,
    R"\glossary": 0,
    R"\hfill": 0,
    R"\hom": 3,
    R"\hookleftarrow": 2,
    R"\hookrightarrow": 2,
    R"\hrulefill": 0,
    R"\huge": 0,
    R"\Huge": 0,
    R"\hyphenation": 0,
    R"\iff": 2,
    R"\Im": 2,
    R"\index": 0,
    R"\inf": 3,
    R"\it": 0,
    R"\ker": 3,
    R"\l": 0,
    R"\L": 0,
    R"\label": 0,
    R"\large": 0,
    R"\Large": 0,
    R"\LARGE": 0,
    R"\ldots": 3,
    R"\lefteqn": 0,
    R"\left": 0,
    R"\lg": 2,
    R"\lim": 3,
    R"\liminf": 6,
    R"\limsup": 6,
    R"\linebreak": 0,
    R"\ln": 2,
    R"\log": 3,
    R"\longleftarrow": 2,
    R"\Longleftarrow": 2,
    R"\longleftrightarrow": 2,
    R"\Longleftrightarrow": 2,
    R"\longmapsto": 3,
    R"\longrightarrow": 2,
    R"\Longrightarrow": 2,
    R"\makebox": 0,
    R"\mapsto": 2,
    R"\markright": 0,
    R"\mathds": 0,
    R"\max": 3,
    R"\mbox": 0,
    R"\medskip": 0,
    R"\min": 3,
    R"\mit": 0,
    R"\models": 2,
    R"\ne": 2,
    R"\neq": 2,
    R"\newline": 0,
    R"\noindent": 0,
    R"\nolinebreak": 0,
    R"\nonumber": 0,
    R"\nopagebreak": 0,
    R"\normalmarginpar": 0,
    R"\normalsize": 0,
    R"\notin": 2,
    R"\o": 0,
    R"\O": 0,
    R"\obeycr": 0,
    R"\oe": 0,
    R"\OE": 0,
    R"\overbrace": 4,
    R"\pagebreak": 0,
    R"\pagenumbering": 0,
    R"\pageref": 2,
    R"\pmod": 5,
    R"\Pr": 2,
    R"\protect": 0,
    R"\qquad": 0,
    R"\quad": 0,
    R"\raggedbottom": 0,
    R"\raggedleft": 0,
    R"\raggedright": 0,
    R"\Re": 2,
    R"\ref": 2,
    R"\restorecr": 0,
    R"\reversemarginpar": 0,
    R"\right": 0,
    R"\rm": 0,
    R"\sc": 0,
    R"\scriptscriptstyle": 0,
    R"\scriptsize": 0,
    R"\scriptstyle": 0,
    R"\sec": 3,
    R"\sf": 0,
    R"\shortstack": 0,
    R"\sin": 3,
    R"\sinh": 4,
    R"\sl": 0,
    R"\sloppy": 0,
    R"\small": 0,
    R"\Small": 0,
    R"\smallskip": 0,
    R"\sqrt": 2,
    R"\ss": 0,
    R"\sup": 3,
    R"\tan": 3,
    R"\tanh": 4,
    R"\text": 0,
    R"\textbf": 0,
    R"\textfraction": 2,
    R"\textstyle": 0,
    R"\thicklines": 0,
    R"\thinlines": 0,
    R"\thinspace": 0,
    R"\tiny": 0,
    R"\title": 0,
    R"\today": 15,
    R"\topfraction": 2,
    R"\tt": 0,
    R"\typeout": 0,
    R"\unboldmath": 0,
    R"\underbrace": 6,
    R"\underline": 0,
    R"\value": 0,
    R"\vdots": 3,
    R"\vline": 0
}
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.208">@abstractmethod
def get_bounds(self, alpha: float) -&gt; tuple[float, float]:
    raise Exception("Not Implemented")
</t>
<t tx="ekr.20250121054835.209">class ShowCreation(ShowPartial):
    @others
</t>
<t tx="ekr.20250121054835.21">class SurfaceExample(ThreeDScene):
    @others
</t>
<t tx="ekr.20250121054835.210">def __init__(self, mobject: Mobject, lag_ratio: float = 1.0, **kwargs):
    super().__init__(mobject, lag_ratio=lag_ratio, **kwargs)
</t>
<t tx="ekr.20250121054835.211">def get_bounds(self, alpha: float) -&gt; tuple[float, float]:
    return (0, alpha)
</t>
<t tx="ekr.20250121054835.212">class Uncreate(ShowCreation):
    @others
    ):
        super().__init__(
            mobject,
            rate_func=rate_func,
            remover=remover,
            should_match_start=should_match_start,
            **kwargs,
        )
</t>
<t tx="ekr.20250121054835.213">def __init__(
    self,
    mobject: Mobject,
    rate_func: Callable[[float], float] = lambda t: smooth(1 - t),
    remover: bool = True,
    should_match_start: bool = True,
    **kwargs,
</t>
<t tx="ekr.20250121054835.214">class DrawBorderThenFill(Animation):
    @others
</t>
<t tx="ekr.20250121054835.215">def __init__(
    self,
    vmobject: VMobject,
    run_time: float = 2.0,
    rate_func: Callable[[float], float] = double_smooth,
    stroke_width: float = 2.0,
    stroke_color: ManimColor = None,
    draw_border_animation_config: dict = {},
    fill_animation_config: dict = {},
    **kwargs
):
    assert isinstance(vmobject, VMobject)
    self.sm_to_index = {hash(sm): 0 for sm in vmobject.get_family()}
    self.stroke_width = stroke_width
    self.stroke_color = stroke_color
    self.draw_border_animation_config = draw_border_animation_config
    self.fill_animation_config = fill_animation_config
    super().__init__(
        vmobject,
        run_time=run_time,
        rate_func=rate_func,
        **kwargs
    )
    self.mobject = vmobject
</t>
<t tx="ekr.20250121054835.216">def begin(self) -&gt; None:
    self.mobject.set_animating_status(True)
    self.outline = self.get_outline()
    super().begin()
    self.mobject.match_style(self.outline)
</t>
<t tx="ekr.20250121054835.217">def finish(self) -&gt; None:
    super().finish()
    self.mobject.refresh_joint_angles()
</t>
<t tx="ekr.20250121054835.218">def get_outline(self) -&gt; VMobject:
    outline = self.mobject.copy()
    outline.set_fill(opacity=0)
    for sm in outline.family_members_with_points():
        sm.set_stroke(
            color=self.stroke_color or sm.get_stroke_color(),
            width=self.stroke_width,
            behind=self.mobject.stroke_behind,
        )
    return outline
</t>
<t tx="ekr.20250121054835.219">def get_all_mobjects(self) -&gt; list[Mobject]:
    return [*super().get_all_mobjects(), self.outline]
</t>
<t tx="ekr.20250121054835.22">def construct(self):
    surface_text = Text("For 3d scenes, try using surfaces")
    surface_text.fix_in_frame()
    surface_text.to_edge(UP)
    self.add(surface_text)
    self.wait(0.1)

    torus1 = Torus(r1=1, r2=1)
    torus2 = Torus(r1=3, r2=1)
    sphere = Sphere(radius=3, resolution=torus1.resolution)
    # You can texture a surface with up to two images, which will
    # be interpreted as the side towards the light, and away from
    # the light.  These can be either urls, or paths to a local file
    # in whatever you've set as the image directory in
    # the custom_config.yml file

    # day_texture = "EarthTextureMap"
    # night_texture = "NightEarthTextureMap"
    day_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg"
    night_texture = "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg"

    surfaces = [
        TexturedSurface(surface, day_texture, night_texture)
        for surface in [sphere, torus1, torus2]
    ]

    for mob in surfaces:
        mob.shift(IN)
        mob.mesh = SurfaceMesh(mob)
        mob.mesh.set_stroke(BLUE, 1, opacity=0.5)

    surface = surfaces[0]

    self.play(
        FadeIn(surface),
        ShowCreation(surface.mesh, lag_ratio=0.01, run_time=3),
    )
    for mob in surfaces:
        mob.add(mob.mesh)
    surface.save_state()
    self.play(Rotate(surface, PI / 2), run_time=2)
    for mob in surfaces[1:]:
        mob.rotate(PI / 2)

    self.play(
        Transform(surface, surfaces[1]),
        run_time=3
    )

    self.play(
        Transform(surface, surfaces[2]),
        # Move camera frame during the transition
        self.frame.animate.increment_phi(-10 * DEG),
        self.frame.animate.increment_theta(-20 * DEG),
        run_time=3
    )
    # Add ambient rotation
    self.frame.add_updater(lambda m, dt: m.increment_theta(-0.1 * dt))

    # Play around with where the light is
    light_text = Text("You can move around the light source")
    light_text.move_to(surface_text)
    light_text.fix_in_frame()

    self.play(FadeTransform(surface_text, light_text))
    light = self.camera.light_source
    light_dot = GlowDot(color=WHITE, radius=0.5)
    light_dot.always.move_to(light)
    self.add(light, light_dot)
    light.save_state()
    self.play(light.animate.move_to(3 * IN), run_time=5)
    self.play(light.animate.shift(10 * OUT), run_time=5)

    drag_text = Text("Try moving the mouse while pressing d or f")
    drag_text.move_to(light_text)
    drag_text.fix_in_frame()

    self.play(FadeTransform(light_text, drag_text))
    self.wait()
</t>
<t tx="ekr.20250121054835.220">def interpolate_submobject(
    self,
    submob: VMobject,
    start: VMobject,
    outline: VMobject,
    alpha: float
) -&gt; None:
    index, subalpha = integer_interpolate(0, 2, alpha)

    if index == 1 and self.sm_to_index[hash(submob)] == 0:
        # First time crossing over
        submob.set_data(outline.data)
        self.sm_to_index[hash(submob)] = 1

    if index == 0:
        submob.pointwise_become_partial(outline, 0, subalpha)
    else:
        submob.interpolate(outline, start, subalpha)
</t>
<t tx="ekr.20250121054835.221">class Write(DrawBorderThenFill):
    @others
</t>
<t tx="ekr.20250121054835.222">def __init__(
    self,
    vmobject: VMobject,
    run_time: float = -1,  # If negative, this will be reassigned
    lag_ratio: float = -1,  # If negative, this will be reassigned
    rate_func: Callable[[float], float] = linear,
    stroke_color: ManimColor = None,
    **kwargs
):
    if stroke_color is None:
        stroke_color = vmobject.get_color()
    family_size = len(vmobject.family_members_with_points())
    super().__init__(
        vmobject,
        run_time=self.compute_run_time(family_size, run_time),
        lag_ratio=self.compute_lag_ratio(family_size, lag_ratio),
        rate_func=rate_func,
        stroke_color=stroke_color,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.223">def compute_run_time(self, family_size: int, run_time: float):
    if run_time &lt; 0:
        return 1 if family_size &lt; 15 else 2
    return run_time
</t>
<t tx="ekr.20250121054835.224">def compute_lag_ratio(self, family_size: int, lag_ratio: float):
    if lag_ratio &lt; 0:
        return min(4.0 / (family_size + 1.0), 0.2)
    return lag_ratio
</t>
<t tx="ekr.20250121054835.225">class ShowIncreasingSubsets(Animation):
    @others
</t>
<t tx="ekr.20250121054835.226">def __init__(
    self,
    group: Mobject,
    int_func: Callable[[float], float] = np.round,
    suspend_mobject_updating: bool = False,
    **kwargs
):
    self.all_submobs = list(group.submobjects)
    self.int_func = int_func
    super().__init__(
        group,
        suspend_mobject_updating=suspend_mobject_updating,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.227">def interpolate_mobject(self, alpha: float) -&gt; None:
    n_submobs = len(self.all_submobs)
    alpha = self.rate_func(alpha)
    index = int(self.int_func(alpha * n_submobs))
    self.update_submobject_list(index)
</t>
<t tx="ekr.20250121054835.228">def update_submobject_list(self, index: int) -&gt; None:
    self.mobject.set_submobjects(self.all_submobs[:index])
</t>
<t tx="ekr.20250121054835.229">class ShowSubmobjectsOneByOne(ShowIncreasingSubsets):
    @others
</t>
<t tx="ekr.20250121054835.23">class InteractiveDevelopment(Scene):
    @others
</t>
<t tx="ekr.20250121054835.230">def __init__(
    self,
    group: Mobject,
    int_func: Callable[[float], float] = np.ceil,
    **kwargs
):
    super().__init__(group, int_func=int_func, **kwargs)
</t>
<t tx="ekr.20250121054835.231">def update_submobject_list(self, index: int) -&gt; None:
    index = int(clip(index, 0, len(self.all_submobs) - 1))
    if index == 0:
        self.mobject.set_submobjects([])
    else:
        self.mobject.set_submobjects([self.all_submobs[index - 1]])
</t>
<t tx="ekr.20250121054835.232">class AddTextWordByWord(ShowIncreasingSubsets):
    @others
</t>
<t tx="ekr.20250121054835.233">def __init__(
    self,
    string_mobject: StringMobject,
    time_per_word: float = 0.2,
    run_time: float = -1.0, # If negative, it will be recomputed with time_per_word
    rate_func: Callable[[float], float] = linear,
    **kwargs
):
    assert isinstance(string_mobject, StringMobject)
    grouped_mobject = string_mobject.build_groups()
    if run_time &lt; 0:
        run_time = time_per_word * len(grouped_mobject)
    super().__init__(
        grouped_mobject,
        run_time=run_time,
        rate_func=rate_func,
        **kwargs
    )
    self.string_mobject = string_mobject
</t>
<t tx="ekr.20250121054835.234">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    scene.remove(self.mobject)
    if not self.is_remover():
        scene.add(self.string_mobject)
</t>
<t tx="ekr.20250121054835.235">from __future__ import annotations

import numpy as np

from manimlib.animation.animation import Animation
from manimlib.animation.transform import Transform
from manimlib.constants import ORIGIN
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.bezier import interpolate
from manimlib.utils.rate_functions import there_and_back

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable
    from manimlib.mobject.mobject import Mobject
    from manimlib.scene.scene import Scene
    from manimlib.typing import Vect3


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.236">class Fade(Transform):
    @others
</t>
<t tx="ekr.20250121054835.237">def __init__(
    self,
    mobject: Mobject,
    shift: np.ndarray = ORIGIN,
    scale: float = 1,
    **kwargs
):
    self.shift_vect = shift
    self.scale_factor = scale
    super().__init__(mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.238">class FadeIn(Fade):
    @others
</t>
<t tx="ekr.20250121054835.239">def create_target(self) -&gt; Mobject:
    return self.mobject.copy()
</t>
<t tx="ekr.20250121054835.24">def construct(self):
    circle = Circle()
    circle.set_fill(BLUE, opacity=0.5)
    circle.set_stroke(BLUE_E, width=4)
    square = Square()

    self.play(ShowCreation(square))
    self.wait()

    # This opens an iPython terminal where you can keep writing
    # lines as if they were part of this construct method.
    # In particular, 'square', 'circle' and 'self' will all be
    # part of the local namespace in that terminal.
    self.embed()

    # Try copying and pasting some of the lines below into
    # the interactive shell
    self.play(ReplacementTransform(square, circle))
    self.wait()
    self.play(circle.animate.stretch(4, 0))
    self.play(Rotate(circle, 90 * DEG))
    self.play(circle.animate.shift(2 * RIGHT).scale(0.25))

    text = Text("""
        In general, using the interactive shell
        is very helpful when developing new scenes
    """)
    self.play(Write(text))

    # In the interactive shell, you can just type
    # play, add, remove, clear, wait, save_state and restore,
    # instead of self.play, self.add, self.remove, etc.

    # To interact with the window, type touch().  You can then
    # scroll in the window, or zoom by holding down 'z' while scrolling,
    # and change camera perspective by holding down 'd' while moving
    # the mouse.  Press 'r' to reset to the standard camera position.
    # Press 'q' to stop interacting with the window and go back to
    # typing new commands into the shell.

    # In principle you can customize a scene to be responsive to
    # mouse and keyboard interactions
    always(circle.move_to, self.mouse_point)
</t>
<t tx="ekr.20250121054835.240">def create_starting_mobject(self) -&gt; Mobject:
    start = super().create_starting_mobject()
    start.set_opacity(0)
    start.scale(1.0 / self.scale_factor)
    start.shift(-self.shift_vect)
    return start
</t>
<t tx="ekr.20250121054835.241">class FadeOut(Fade):
    @others
</t>
<t tx="ekr.20250121054835.242">def __init__(
    self,
    mobject: Mobject,
    shift: Vect3 = ORIGIN,
    remover: bool = True,
    final_alpha_value: float = 0.0,  # Put it back in original state when done,
    **kwargs
):
    super().__init__(
        mobject, shift,
        remover=remover,
        final_alpha_value=final_alpha_value,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.243">def create_target(self) -&gt; Mobject:
    result = self.mobject.copy()
    result.set_opacity(0)
    result.shift(self.shift_vect)
    result.scale(self.scale_factor)
    return result
</t>
<t tx="ekr.20250121054835.244">class FadeInFromPoint(FadeIn):
    @others
</t>
<t tx="ekr.20250121054835.245">def __init__(self, mobject: Mobject, point: Vect3, **kwargs):
    super().__init__(
        mobject,
        shift=mobject.get_center() - point,
        scale=np.inf,
        **kwargs,
    )
</t>
<t tx="ekr.20250121054835.246">class FadeOutToPoint(FadeOut):
    @others
</t>
<t tx="ekr.20250121054835.247">def __init__(self, mobject: Mobject, point: Vect3, **kwargs):
    super().__init__(
        mobject,
        shift=point - mobject.get_center(),
        scale=0,
        **kwargs,
    )
</t>
<t tx="ekr.20250121054835.248">class FadeTransform(Transform):
    @others
</t>
<t tx="ekr.20250121054835.249">def __init__(
    self,
    mobject: Mobject,
    target_mobject: Mobject,
    stretch: bool = True,
    dim_to_match: int = 1,
    **kwargs
):
    self.to_add_on_completion = target_mobject
    self.stretch = stretch
    self.dim_to_match = dim_to_match

    mobject.save_state()
    super().__init__(mobject.get_group_class()(mobject, target_mobject.copy()), **kwargs)
</t>
<t tx="ekr.20250121054835.25">class ControlsExample(Scene):
    @others
        # self.wait(60)
        # self.embed()


# See https://github.com/3b1b/videos for many, many more
</t>
<t tx="ekr.20250121054835.250">def begin(self) -&gt; None:
    self.ending_mobject = self.mobject.copy()
    Animation.begin(self)
    # Both 'start' and 'end' consists of the source and target mobjects.
    # At the start, the traget should be faded replacing the source,
    # and at the end it should be the other way around.
    start, end = self.starting_mobject, self.ending_mobject
    for m0, m1 in ((start[1], start[0]), (end[0], end[1])):
        self.ghost_to(m0, m1)
</t>
<t tx="ekr.20250121054835.251">def ghost_to(self, source: Mobject, target: Mobject) -&gt; None:
    source.replace(target, stretch=self.stretch, dim_to_match=self.dim_to_match)
    source.set_uniform(**target.get_uniforms())
    source.set_opacity(0)
</t>
<t tx="ekr.20250121054835.252">def get_all_mobjects(self) -&gt; list[Mobject]:
    return [
        self.mobject,
        self.starting_mobject,
        self.ending_mobject,
    ]
</t>
<t tx="ekr.20250121054835.253">def get_all_families_zipped(self) -&gt; zip[tuple[Mobject]]:
    return Animation.get_all_families_zipped(self)
</t>
<t tx="ekr.20250121054835.254">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    Animation.clean_up_from_scene(self, scene)
    scene.remove(self.mobject)
    self.mobject[0].restore()
    if not self.remover:
        scene.add(self.to_add_on_completion)
</t>
<t tx="ekr.20250121054835.255">class FadeTransformPieces(FadeTransform):
    @others
</t>
<t tx="ekr.20250121054835.256">def begin(self) -&gt; None:
    self.mobject[0].align_family(self.mobject[1])
    super().begin()
</t>
<t tx="ekr.20250121054835.257">def ghost_to(self, source: Mobject, target: Mobject) -&gt; None:
    for sm0, sm1 in zip(source.get_family(), target.get_family()):
        super().ghost_to(sm0, sm1)
</t>
<t tx="ekr.20250121054835.258">class VFadeIn(Animation):
    """
    VFadeIn and VFadeOut only work for VMobjects,
    """
    @others
</t>
<t tx="ekr.20250121054835.259">def __init__(self, vmobject: VMobject, suspend_mobject_updating: bool = False, **kwargs):
    super().__init__(
        vmobject,
        suspend_mobject_updating=suspend_mobject_updating,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.26">drag_to_pan = False

def setup(self):
    self.textbox = Textbox()
    self.checkbox = Checkbox()
    self.color_picker = ColorSliders()
    self.panel = ControlPanel(
        Text("Text", font_size=24), self.textbox, Line(),
        Text("Show/Hide Text", font_size=24), self.checkbox, Line(),
        Text("Color of Text", font_size=24), self.color_picker
    )
    self.add(self.panel)
</t>
<t tx="ekr.20250121054835.260">def interpolate_submobject(
    self,
    submob: VMobject,
    start: VMobject,
    alpha: float
) -&gt; None:
    submob.set_stroke(
        opacity=interpolate(0, start.get_stroke_opacity(), alpha)
    )
    submob.set_fill(
        opacity=interpolate(0, start.get_fill_opacity(), alpha)
    )
</t>
<t tx="ekr.20250121054835.261">class VFadeOut(VFadeIn):
    @others
</t>
<t tx="ekr.20250121054835.262">def __init__(
    self,
    vmobject: VMobject,
    remover: bool = True,
    final_alpha_value: float = 0.0,
    **kwargs
):
    super().__init__(
        vmobject,
        remover=remover,
        final_alpha_value=final_alpha_value,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.263">def interpolate_submobject(
    self,
    submob: VMobject,
    start: VMobject,
    alpha: float
) -&gt; None:
    super().interpolate_submobject(submob, start, 1 - alpha)
</t>
<t tx="ekr.20250121054835.264">class VFadeInThenOut(VFadeIn):
    @others
</t>
<t tx="ekr.20250121054835.265">def __init__(
    self,
    vmobject: VMobject,
    rate_func: Callable[[float], float] = there_and_back,
    remover: bool = True,
    final_alpha_value: float = 0.5,
    **kwargs
):
    super().__init__(
        vmobject,
        rate_func=rate_func,
        remover=remover,
        final_alpha_value=final_alpha_value,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.266">from __future__ import annotations

from manimlib.animation.transform import Transform

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import numpy as np

    from manimlib.mobject.geometry import Arrow
    from manimlib.mobject.mobject import Mobject
    from manimlib.typing import ManimColor


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.267">class GrowFromPoint(Transform):
    @others
</t>
<t tx="ekr.20250121054835.268">def __init__(
    self,
    mobject: Mobject,
    point: np.ndarray,
    point_color: ManimColor = None,
    **kwargs
):
    self.point = point
    self.point_color = point_color
    super().__init__(mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.269">def create_target(self) -&gt; Mobject:
    return self.mobject.copy()
</t>
<t tx="ekr.20250121054835.27">def construct(self):
    text = Text("text", font_size=96)

    def text_updater(old_text):
        assert(isinstance(old_text, Text))
        new_text = Text(self.textbox.get_value(), font_size=old_text.font_size)
        # new_text.align_data_and_family(old_text)
        new_text.move_to(old_text)
        if self.checkbox.get_value():
            new_text.set_fill(
                color=self.color_picker.get_picked_color(),
                opacity=self.color_picker.get_picked_opacity()
            )
        else:
            new_text.set_opacity(0)
        old_text.become(new_text)

    text.add_updater(text_updater)

    self.add(MotionMobject(text))

    self.textbox.set_value("Manim")
</t>
<t tx="ekr.20250121054835.270">def create_starting_mobject(self) -&gt; Mobject:
    start = super().create_starting_mobject()
    start.scale(0)
    start.move_to(self.point)
    if self.point_color is not None:
        start.set_color(self.point_color)
    return start
</t>
<t tx="ekr.20250121054835.271">class GrowFromCenter(GrowFromPoint):
    @others
</t>
<t tx="ekr.20250121054835.272">def __init__(self, mobject: Mobject, **kwargs):
    point = mobject.get_center()
    super().__init__(mobject, point, **kwargs)
</t>
<t tx="ekr.20250121054835.273">class GrowFromEdge(GrowFromPoint):
    @others
</t>
<t tx="ekr.20250121054835.274">def __init__(self, mobject: Mobject, edge: np.ndarray, **kwargs):
    point = mobject.get_bounding_box_point(edge)
    super().__init__(mobject, point, **kwargs)
</t>
<t tx="ekr.20250121054835.275">class GrowArrow(GrowFromPoint):
    @others
</t>
<t tx="ekr.20250121054835.276">def __init__(self, arrow: Arrow, **kwargs):
    point = arrow.get_start()
    super().__init__(arrow, point, **kwargs)
</t>
<t tx="ekr.20250121054835.277">from __future__ import annotations

import numpy as np

from manimlib.animation.animation import Animation
from manimlib.animation.composition import AnimationGroup
from manimlib.animation.composition import Succession
from manimlib.animation.creation import ShowCreation
from manimlib.animation.creation import ShowPartial
from manimlib.animation.fading import FadeOut
from manimlib.animation.fading import FadeIn
from manimlib.animation.movement import Homotopy
from manimlib.animation.transform import Transform
from manimlib.constants import FRAME_X_RADIUS, FRAME_Y_RADIUS
from manimlib.constants import ORIGIN, RIGHT, UP
from manimlib.constants import SMALL_BUFF
from manimlib.constants import DEG
from manimlib.constants import TAU
from manimlib.constants import GREY, YELLOW
from manimlib.mobject.geometry import Circle
from manimlib.mobject.geometry import Dot
from manimlib.mobject.geometry import Line
from manimlib.mobject.shape_matchers import SurroundingRectangle
from manimlib.mobject.shape_matchers import Underline
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.utils.bezier import interpolate
from manimlib.utils.rate_functions import smooth
from manimlib.utils.rate_functions import squish_rate_func
from manimlib.utils.rate_functions import there_and_back
from manimlib.utils.rate_functions import wiggle

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable
    from manimlib.typing import ManimColor
    from manimlib.mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.278">class FocusOn(Transform):
    @others
</t>
<t tx="ekr.20250121054835.279">def __init__(
    self,
    focus_point: np.ndarray | Mobject,
    opacity: float = 0.2,
    color: ManimColor = GREY,
    run_time: float = 2,
    remover: bool = True,
    **kwargs
):
    self.focus_point = focus_point
    self.opacity = opacity
    self.color = color
    # Initialize with blank mobject, while create_target
    # and create_starting_mobject handle the meat
    super().__init__(VMobject(), run_time=run_time, remover=remover, **kwargs)
</t>
<t tx="ekr.20250121054835.28">import setuptools
setuptools.setup()
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.280">def create_target(self) -&gt; Dot:
    little_dot = Dot(radius=0)
    little_dot.set_fill(self.color, opacity=self.opacity)
    little_dot.add_updater(lambda d: d.move_to(self.focus_point))
    return little_dot
</t>
<t tx="ekr.20250121054835.281">def create_starting_mobject(self) -&gt; Dot:
    return Dot(
        radius=FRAME_X_RADIUS + FRAME_Y_RADIUS,
        stroke_width=0,
        fill_color=self.color,
        fill_opacity=0,
    )
</t>
<t tx="ekr.20250121054835.282">class Indicate(Transform):
    @others
</t>
<t tx="ekr.20250121054835.283">def __init__(
    self,
    mobject: Mobject,
    scale_factor: float = 1.2,
    color: ManimColor = YELLOW,
    rate_func: Callable[[float], float] = there_and_back,
    **kwargs
):
    self.scale_factor = scale_factor
    self.color = color
    super().__init__(mobject, rate_func=rate_func, **kwargs)
</t>
<t tx="ekr.20250121054835.284">def create_target(self) -&gt; Mobject:
    target = self.mobject.copy()
    target.scale(self.scale_factor)
    target.set_color(self.color)
    return target
</t>
<t tx="ekr.20250121054835.285">class Flash(AnimationGroup):
    @others
</t>
<t tx="ekr.20250121054835.286">def __init__(
    self,
    point: np.ndarray | Mobject,
    color: ManimColor = YELLOW,
    line_length: float = 0.2,
    num_lines: int = 12,
    flash_radius: float = 0.3,
    line_stroke_width: float = 3.0,
    run_time: float = 1.0,
    **kwargs
):
    self.point = point
    self.color = color
    self.line_length = line_length
    self.num_lines = num_lines
    self.flash_radius = flash_radius
    self.line_stroke_width = line_stroke_width

    self.lines = self.create_lines()
    animations = self.create_line_anims()
    super().__init__(
        *animations,
        group=self.lines,
        run_time=run_time,
        **kwargs,
    )
</t>
<t tx="ekr.20250121054835.287">def create_lines(self) -&gt; VGroup:
    lines = VGroup()
    for angle in np.arange(0, TAU, TAU / self.num_lines):
        line = Line(ORIGIN, self.line_length * RIGHT)
        line.shift((self.flash_radius - self.line_length) * RIGHT)
        line.rotate(angle, about_point=ORIGIN)
        lines.add(line)
    lines.set_stroke(
        color=self.color,
        width=self.line_stroke_width
    )
    lines.add_updater(lambda l: l.move_to(self.point))
    return lines
</t>
<t tx="ekr.20250121054835.288">def create_line_anims(self) -&gt; list[Animation]:
    return [
        ShowCreationThenDestruction(line)
        for line in self.lines
    ]
</t>
<t tx="ekr.20250121054835.289">class CircleIndicate(Transform):
    @others
</t>
<t tx="ekr.20250121054835.29"></t>
<t tx="ekr.20250121054835.290">def __init__(
    self,
    mobject: Mobject,
    scale_factor: float = 1.2,
    rate_func: Callable[[float], float] = there_and_back,
    stroke_color: ManimColor = YELLOW,
    stroke_width: float = 3.0,
    remover: bool = True,
    **kwargs
):
    circle = Circle(stroke_color=stroke_color, stroke_width=stroke_width)
    circle.surround(mobject)
    pre_circle = circle.copy().set_stroke(width=0)
    pre_circle.scale(1 / scale_factor)
    super().__init__(
        pre_circle, circle,
        rate_func=rate_func,
        remover=remover,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.291">class ShowPassingFlash(ShowPartial):
    @others
</t>
<t tx="ekr.20250121054835.292">def __init__(
    self,
    mobject: Mobject,
    time_width: float = 0.1,
    remover: bool = True,
    **kwargs
):
    self.time_width = time_width
    super().__init__(
        mobject,
        remover=remover,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.293">def get_bounds(self, alpha: float) -&gt; tuple[float, float]:
    tw = self.time_width
    upper = interpolate(0, 1 + tw, alpha)
    lower = upper - tw
    upper = min(upper, 1)
    lower = max(lower, 0)
    return (lower, upper)
</t>
<t tx="ekr.20250121054835.294">def finish(self) -&gt; None:
    super().finish()
    for submob, start in self.get_all_families_zipped():
        submob.pointwise_become_partial(start, 0, 1)
</t>
<t tx="ekr.20250121054835.295">class VShowPassingFlash(Animation):
    @others
</t>
<t tx="ekr.20250121054835.296">def __init__(
    self,
    vmobject: VMobject,
    time_width: float = 0.3,
    taper_width: float = 0.05,
    remover: bool = True,
    **kwargs
):
    self.time_width = time_width
    self.taper_width = taper_width
    super().__init__(vmobject, remover=remover, **kwargs)
    self.mobject = vmobject
</t>
<t tx="ekr.20250121054835.297">def taper_kernel(self, x):
    if x &lt; self.taper_width:
        return x
    elif x &gt; 1 - self.taper_width:
        return 1.0 - x
    return 1.0
</t>
<t tx="ekr.20250121054835.298">def begin(self) -&gt; None:
    # Compute an array of stroke widths for each submobject
    # which tapers out at either end
    self.submob_to_widths = dict()
    for sm in self.mobject.get_family():
        widths = sm.get_stroke_widths()
        self.submob_to_widths[hash(sm)] = np.array([
            width * self.taper_kernel(x)
            for width, x in zip(widths, np.linspace(0, 1, len(widths)))
        ])
    super().begin()
</t>
<t tx="ekr.20250121054835.299">def interpolate_submobject(
    self,
    submobject: VMobject,
    starting_sumobject: None,
    alpha: float
) -&gt; None:
    widths = self.submob_to_widths[hash(submobject)]

    # Create a gaussian such that 3 sigmas out on either side
    # will equals time_width
    tw = self.time_width
    sigma = tw / 6
    mu = interpolate(-tw / 2, 1 + tw / 2, alpha)
    xs = np.linspace(0, 1, len(widths))
    zs = (xs - mu) / sigma
    gaussian = np.exp(-0.5 * zs * zs)
    gaussian[abs(xs - mu) &gt; 3 * sigma] = 0

    if len(widths * gaussian) !=0:
        submobject.set_stroke(width=widths * gaussian)
</t>
<t tx="ekr.20250121054835.3">class OpeningManimExample(Scene):
    @others
</t>
<t tx="ekr.20250121054835.30">from manimlib import *

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.300">def finish(self) -&gt; None:
    super().finish()
    for submob, start in self.get_all_families_zipped():
        submob.match_style(start)
</t>
<t tx="ekr.20250121054835.301">class FlashAround(VShowPassingFlash):
    @others
</t>
<t tx="ekr.20250121054835.302">def __init__(
    self,
    mobject: Mobject,
    time_width: float = 1.0,
    taper_width: float = 0.0,
    stroke_width: float = 4.0,
    color: ManimColor = YELLOW,
    buff: float = SMALL_BUFF,
    n_inserted_curves: int = 100,
    **kwargs
):
    path = self.get_path(mobject, buff)
    if mobject.is_fixed_in_frame():
        path.fix_in_frame()
    path.insert_n_curves(n_inserted_curves)
    path.set_points(path.get_points_without_null_curves())
    path.set_stroke(color, stroke_width)
    super().__init__(path, time_width=time_width, taper_width=taper_width, **kwargs)
</t>
<t tx="ekr.20250121054835.303">def get_path(self, mobject: Mobject, buff: float) -&gt; SurroundingRectangle:
    return SurroundingRectangle(mobject, buff=buff)
</t>
<t tx="ekr.20250121054835.304">class FlashUnder(FlashAround):
    @others
</t>
<t tx="ekr.20250121054835.305">def get_path(self, mobject: Mobject, buff: float) -&gt; Underline:
    return Underline(mobject, buff=buff, stretch_factor=1.0)
</t>
<t tx="ekr.20250121054835.306">class ShowCreationThenDestruction(ShowPassingFlash):
    @others
</t>
<t tx="ekr.20250121054835.307">def __init__(self, vmobject: VMobject, time_width: float = 2.0, **kwargs):
    super().__init__(vmobject, time_width=time_width, **kwargs)
</t>
<t tx="ekr.20250121054835.308">class ShowCreationThenFadeOut(Succession):
    @others
</t>
<t tx="ekr.20250121054835.309">def __init__(self, mobject: Mobject, remover: bool = True, **kwargs):
    super().__init__(
        ShowCreation(mobject),
        FadeOut(mobject),
        remover=remover,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.31">class SquareToCircle(Scene):
    @others
</t>
<t tx="ekr.20250121054835.310">class AnimationOnSurroundingRectangle(AnimationGroup):
    @others
</t>
<t tx="ekr.20250121054835.311">RectAnimationType: type = Animation

def __init__(
    self,
    mobject: Mobject,
    stroke_width: float = 2.0,
    stroke_color: ManimColor = YELLOW,
    buff: float = SMALL_BUFF,
    **kwargs
):
    rect = SurroundingRectangle(
        mobject,
        stroke_width=stroke_width,
        stroke_color=stroke_color,
        buff=buff,
    )
    rect.add_updater(lambda r: r.move_to(mobject))
    super().__init__(self.RectAnimationType(rect, **kwargs))
</t>
<t tx="ekr.20250121054835.312">class ShowPassingFlashAround(AnimationOnSurroundingRectangle):
    RectAnimationType = ShowPassingFlash
</t>
<t tx="ekr.20250121054835.313">class ShowCreationThenDestructionAround(AnimationOnSurroundingRectangle):
    RectAnimationType = ShowCreationThenDestruction
</t>
<t tx="ekr.20250121054835.314">class ShowCreationThenFadeAround(AnimationOnSurroundingRectangle):
    RectAnimationType = ShowCreationThenFadeOut
</t>
<t tx="ekr.20250121054835.315">class ApplyWave(Homotopy):
    @others
</t>
<t tx="ekr.20250121054835.316">def __init__(
    self,
    mobject: Mobject,
    direction: np.ndarray = UP,
    amplitude: float = 0.2,
    run_time: float = 1.0,
    **kwargs
):

    left_x = mobject.get_left()[0]
    right_x = mobject.get_right()[0]
    vect = amplitude * direction

    def homotopy(x, y, z, t):
        alpha = (x - left_x) / (right_x - left_x)
        power = np.exp(2.0 * (alpha - 0.5))
        nudge = there_and_back(t**power)
        return np.array([x, y, z]) + nudge * vect

    super().__init__(homotopy, mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.317">class WiggleOutThenIn(Animation):
    @others
</t>
<t tx="ekr.20250121054835.318">def __init__(
    self,
    mobject: Mobject,
    scale_value: float = 1.1,
    rotation_angle: float = 0.01 * TAU,
    n_wiggles: int = 6,
    scale_about_point: np.ndarray | None = None,
    rotate_about_point: np.ndarray | None = None,
    run_time: float = 2,
    **kwargs
):
    self.scale_value = scale_value
    self.rotation_angle = rotation_angle
    self.n_wiggles = n_wiggles
    self.scale_about_point = scale_about_point
    self.rotate_about_point = rotate_about_point
    super().__init__(mobject, run_time=run_time, **kwargs)
</t>
<t tx="ekr.20250121054835.319">def get_scale_about_point(self) -&gt; np.ndarray:
    return self.scale_about_point or self.mobject.get_center()
</t>
<t tx="ekr.20250121054835.32">def construct(self):
    circle = Circle()
    circle.set_fill(BLUE, opacity=0.5)
    circle.set_stroke(BLUE_E, width=4)
    square = Square()

    self.play(ShowCreation(square))
    self.wait()
    self.play(ReplacementTransform(square, circle))
    self.wait()
</t>
<t tx="ekr.20250121054835.320">def get_rotate_about_point(self) -&gt; np.ndarray:
    return self.rotate_about_point or self.mobject.get_center()
</t>
<t tx="ekr.20250121054835.321">def interpolate_submobject(
    self,
    submobject: Mobject,
    starting_sumobject: Mobject,
    alpha: float
) -&gt; None:
    submobject.match_points(starting_sumobject)
    submobject.scale(
        interpolate(1, self.scale_value, there_and_back(alpha)),
        about_point=self.get_scale_about_point()
    )
    submobject.rotate(
        wiggle(alpha, self.n_wiggles) * self.rotation_angle,
        about_point=self.get_rotate_about_point()
    )
</t>
<t tx="ekr.20250121054835.322">class TurnInsideOut(Transform):
    @others
</t>
<t tx="ekr.20250121054835.323">def __init__(self, mobject: Mobject, path_arc: float = 90 * DEG, **kwargs):
    super().__init__(mobject, path_arc=path_arc, **kwargs)
</t>
<t tx="ekr.20250121054835.324">def create_target(self) -&gt; Mobject:
    result = self.mobject.copy().reverse_points()
    if isinstance(result, VMobject):
        result.refresh_triangulation()
    return result
</t>
<t tx="ekr.20250121054835.325">class FlashyFadeIn(AnimationGroup):
    @others
</t>
<t tx="ekr.20250121054835.326">def __init__(self,
    vmobject: VMobject,
    stroke_width: float = 2.0,
    fade_lag: float = 0.0,
    time_width: float = 1.0,
    **kwargs
):
    outline = vmobject.copy()
    outline.set_fill(opacity=0)
    outline.set_stroke(width=stroke_width, opacity=1)

    rate_func = kwargs.get("rate_func", smooth)
    super().__init__(
        FadeIn(vmobject, rate_func=squish_rate_func(rate_func, fade_lag, 1)),
        VShowPassingFlash(outline, time_width=time_width),
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.327">from __future__ import annotations

from manimlib.animation.animation import Animation
from manimlib.utils.rate_functions import linear

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, Sequence

    import numpy as np

    from manimlib.mobject.mobject import Mobject
    from manimlib.mobject.types.vectorized_mobject import VMobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.328">class Homotopy(Animation):
    @others
</t>
<t tx="ekr.20250121054835.329">apply_function_config: dict = dict()

def __init__(
    self,
    homotopy: Callable[[float, float, float, float], Sequence[float]],
    mobject: Mobject,
    run_time: float = 3.0,
    **kwargs
):
    """
    Homotopy is a function from
    (x, y, z, t) to (x', y', z')
    """
    self.homotopy = homotopy
    super().__init__(mobject, run_time=run_time, **kwargs)
</t>
<t tx="ekr.20250121054835.33">        # Try typing the following lines
        # self.play(circle.animate.stretch(4, dim=0))
        # self.play(Rotate(circle, TAU / 4))
        # self.play(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))
        # circle.insert_n_curves(10)
        # self.play(circle.animate.apply_complex_function(lambda z: z**2))

class SquareToCircleEmbed(Scene):
    @others
</t>
<t tx="ekr.20250121054835.330">def function_at_time_t(self, t: float) -&gt; Callable[[np.ndarray], Sequence[float]]:
    def result(p):
        return self.homotopy(*p, t)
    return result
</t>
<t tx="ekr.20250121054835.331">def interpolate_submobject(
    self,
    submob: Mobject,
    start: Mobject,
    alpha: float
) -&gt; None:
    submob.match_points(start)
    submob.apply_function(
        self.function_at_time_t(alpha),
        **self.apply_function_config
    )
</t>
<t tx="ekr.20250121054835.332">class SmoothedVectorizedHomotopy(Homotopy):
    apply_function_config: dict = dict(make_smooth=True)
</t>
<t tx="ekr.20250121054835.333">class ComplexHomotopy(Homotopy):
    @others
</t>
<t tx="ekr.20250121054835.334">def __init__(
    self,
    complex_homotopy: Callable[[complex, float], complex],
    mobject: Mobject,
    **kwargs
):
    """
    Given a function form (z, t) -&gt; w, where z and w
    are complex numbers and t is time, this animates
    the state over time
    """
    def homotopy(x, y, z, t):
        c = complex_homotopy(complex(x, y), t)
        return (c.real, c.imag, z)

    super().__init__(homotopy, mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.335">class PhaseFlow(Animation):
    @others
</t>
<t tx="ekr.20250121054835.336">def __init__(
    self,
    function: Callable[[np.ndarray], np.ndarray],
    mobject: Mobject,
    virtual_time: float | None = None,
    suspend_mobject_updating: bool = False,
    rate_func: Callable[[float], float] = linear,
    run_time: float =3.0,
    **kwargs
):
    self.function = function
    self.virtual_time = virtual_time or run_time
    super().__init__(
        mobject,
        rate_func=rate_func,
        run_time=run_time,
        suspend_mobject_updating=suspend_mobject_updating,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.337">def interpolate_mobject(self, alpha: float) -&gt; None:
    if hasattr(self, "last_alpha"):
        dt = self.virtual_time * (alpha - self.last_alpha)
        self.mobject.apply_function(
            lambda p: p + dt * self.function(p)
        )
    self.last_alpha = alpha
</t>
<t tx="ekr.20250121054835.338">class MoveAlongPath(Animation):
    @others
</t>
<t tx="ekr.20250121054835.339">def __init__(
    self,
    mobject: Mobject,
    path: VMobject,
    suspend_mobject_updating: bool = False,
    **kwargs
):
    self.path = path
    super().__init__(mobject, suspend_mobject_updating=suspend_mobject_updating, **kwargs)
</t>
<t tx="ekr.20250121054835.34">def construct(self):
    circle = Circle()
    circle.set_fill(BLUE, opacity=0.5)
    circle.set_stroke(BLUE_E, width=4)

    self.add(circle)
    self.wait()
    self.play(circle.animate.stretch(4, dim=0))
    self.wait(1.5)
    self.play(Rotate(circle, TAU / 4))
    self.wait(1.5)
    self.play(circle.animate.shift(2 * RIGHT), circle.animate.scale(0.25))
    self.wait(1.5)
    circle.insert_n_curves(10)
    self.play(circle.animate.apply_complex_function(lambda z: z**2))
    self.wait(2)
</t>
<t tx="ekr.20250121054835.340">def interpolate_mobject(self, alpha: float) -&gt; None:
    point = self.path.quick_point_from_proportion(self.rate_func(alpha))
    self.mobject.move_to(point)
</t>
<t tx="ekr.20250121054835.341">from __future__ import annotations

from manimlib.animation.animation import Animation
from manimlib.mobject.numbers import DecimalNumber
from manimlib.utils.bezier import interpolate
from manimlib.utils.simple_functions import clip

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.342">class ChangingDecimal(Animation):
    @others
</t>
<t tx="ekr.20250121054835.343">def __init__(
    self,
    decimal_mob: DecimalNumber,
    number_update_func: Callable[[float], float],
    suspend_mobject_updating: bool = False,
    **kwargs
):
    assert isinstance(decimal_mob, DecimalNumber)
    self.number_update_func = number_update_func
    super().__init__(
        decimal_mob,
        suspend_mobject_updating=suspend_mobject_updating,
        **kwargs
    )
    self.mobject = decimal_mob
</t>
<t tx="ekr.20250121054835.344">def interpolate_mobject(self, alpha: float) -&gt; None:
    self.mobject.set_value(
        self.number_update_func(alpha)
    )
</t>
<t tx="ekr.20250121054835.345">class ChangeDecimalToValue(ChangingDecimal):
    @others
</t>
<t tx="ekr.20250121054835.346">def __init__(
    self,
    decimal_mob: DecimalNumber,
    target_number: float | complex,
    **kwargs
):
    start_number = decimal_mob.number
    super().__init__(
        decimal_mob,
        lambda a: interpolate(start_number, target_number, a),
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.347">class CountInFrom(ChangingDecimal):
    @others
</t>
<t tx="ekr.20250121054835.348">def __init__(
    self,
    decimal_mob: DecimalNumber,
    source_number: float | complex = 0,
    **kwargs
):
    start_number = decimal_mob.get_value()
    super().__init__(
        decimal_mob,
        lambda a: interpolate(source_number, start_number, clip(a, 0, 1)),
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.349">from __future__ import annotations

from manimlib.animation.animation import Animation
from manimlib.constants import ORIGIN, OUT
from manimlib.constants import PI, TAU
from manimlib.utils.rate_functions import linear
from manimlib.utils.rate_functions import smooth

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import numpy as np
    from typing import Callable
    from manimlib.mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.35"></t>
<t tx="ekr.20250121054835.350">class Rotating(Animation):
    @others
</t>
<t tx="ekr.20250121054835.351">def __init__(
    self,
    mobject: Mobject,
    angle: float = TAU,
    axis: np.ndarray = OUT,
    about_point: np.ndarray | None = None,
    about_edge: np.ndarray | None = None,
    run_time: float = 5.0,
    rate_func: Callable[[float], float] = linear,
    suspend_mobject_updating: bool = False,
    **kwargs
):
    self.angle = angle
    self.axis = axis
    self.about_point = about_point
    self.about_edge = about_edge
    super().__init__(
        mobject,
        run_time=run_time,
        rate_func=rate_func,
        suspend_mobject_updating=suspend_mobject_updating,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.352">def interpolate_mobject(self, alpha: float) -&gt; None:
    pairs = zip(
        self.mobject.family_members_with_points(),
        self.starting_mobject.family_members_with_points(),
    )
    for sm1, sm2 in pairs:
        for key in sm1.pointlike_data_keys:
            sm1.data[key][:] = sm2.data[key]
    self.mobject.rotate(
        self.rate_func(self.time_spanned_alpha(alpha)) * self.angle,
        axis=self.axis,
        about_point=self.about_point,
        about_edge=self.about_edge,
    )
</t>
<t tx="ekr.20250121054835.353">class Rotate(Rotating):
    @others
</t>
<t tx="ekr.20250121054835.354">def __init__(
    self,
    mobject: Mobject,
    angle: float = PI,
    axis: np.ndarray = OUT,
    run_time: float = 1,
    rate_func: Callable[[float], float] = smooth,
    about_edge: np.ndarray = ORIGIN,
    **kwargs
):
    super().__init__(
        mobject, angle, axis,
        run_time=run_time,
        rate_func=rate_func,
        about_edge=about_edge,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.355">from __future__ import annotations

from manimlib.animation.composition import LaggedStart
from manimlib.animation.transform import Restore
from manimlib.constants import BLACK, WHITE
from manimlib.mobject.geometry import Circle
from manimlib.mobject.types.vectorized_mobject import VGroup

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import numpy as np
    from manimlib.typing import ManimColor


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.356">class Broadcast(LaggedStart):
    @others
</t>
<t tx="ekr.20250121054835.357">def __init__(
    self,
    focal_point: np.ndarray,
    small_radius: float = 0.0,
    big_radius: float = 5.0,
    n_circles: int = 5,
    start_stroke_width: float = 8.0,
    color: ManimColor = WHITE,
    run_time: float = 3.0,
    lag_ratio: float = 0.2,
    remover: bool = True,
    **kwargs
):
    self.focal_point = focal_point
    self.small_radius = small_radius
    self.big_radius = big_radius
    self.n_circles = n_circles
    self.start_stroke_width = start_stroke_width
    self.color = color

    circles = VGroup()
    for x in range(n_circles):
        circle = Circle(
            radius=big_radius,
            stroke_color=BLACK,
            stroke_width=0,
        )
        circle.add_updater(lambda c: c.move_to(focal_point))
        circle.save_state()
        circle.set_width(small_radius * 2)
        circle.set_stroke(color, start_stroke_width)
        circles.add(circle)
    super().__init__(
        *map(Restore, circles),
        run_time=run_time,
        lag_ratio=lag_ratio,
        remover=remover,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.358">from __future__ import annotations

import inspect

import numpy as np

from manimlib.animation.animation import Animation
from manimlib.constants import DEG
from manimlib.constants import OUT
from manimlib.mobject.mobject import Group
from manimlib.mobject.mobject import Mobject
from manimlib.utils.paths import path_along_arc
from manimlib.utils.paths import straight_path

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable
    import numpy.typing as npt
    from manimlib.scene.scene import Scene
    from manimlib.typing import ManimColor


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.359">class Transform(Animation):
    @others
</t>
<t tx="ekr.20250121054835.36">import os
import sys
sys.path.insert(0, os.path.abspath("."))
sys.path.insert(0, os.path.abspath('../../'))


project = 'manim'
copyright = '- This document has been placed in the public domain.'
author = 'TonyCrane'

release = ''

extensions = [
    'sphinx.ext.todo',
    'sphinx.ext.githubpages',
    'sphinx.ext.mathjax',
    'sphinx.ext.intersphinx',
    'sphinx.ext.autodoc', 
    'sphinx.ext.coverage',
    'sphinx.ext.napoleon',
    'sphinx_copybutton',
    'manim_example_ext'
]

autoclass_content = 'both'
mathjax_path = "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"

templates_path = ['_templates']
source_suffix = '.rst'
master_doc = 'index'
pygments_style = 'default'

html_static_path = ["_static"]
html_css_files = [
    "https://cdn.jsdelivr.net/gh/manim-kindergarten/CDN@master/manimgl_assets/custom.css", 
    "https://cdn.jsdelivr.net/gh/manim-kindergarten/CDN@master/manimgl_assets/colors.css"
]
html_theme = 'furo'  # pip install furo==2020.10.5b9
html_favicon = '_static/icon.png'
html_logo = '../../logo/transparent_graph.png'
html_theme_options = {
    "sidebar_hide_name": True,
}
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.360">replace_mobject_with_target_in_scene: bool = False

def __init__(
    self,
    mobject: Mobject,
    target_mobject: Mobject | None = None,
    path_arc: float = 0.0,
    path_arc_axis: np.ndarray = OUT,
    path_func: Callable | None = None,
    **kwargs
):
    self.target_mobject = target_mobject
    self.path_arc = path_arc
    self.path_arc_axis = path_arc_axis
    self.path_func = path_func
    super().__init__(mobject, **kwargs)
    self.init_path_func()
</t>
<t tx="ekr.20250121054835.361">def init_path_func(self) -&gt; None:
    if self.path_func is not None:
        return
    elif self.path_arc == 0:
        self.path_func = straight_path
    else:
        self.path_func = path_along_arc(
            self.path_arc,
            self.path_arc_axis,
        )
</t>
<t tx="ekr.20250121054835.362">def begin(self) -&gt; None:
    self.target_mobject = self.create_target()
    self.check_target_mobject_validity()

    if self.mobject.is_aligned_with(self.target_mobject):
        self.target_copy = self.target_mobject
    else:
        # Use a copy of target_mobject for the align_data_and_family
        # call so that the actual target_mobject stays
        # preserved, since calling align_data will potentially
        # change the structure of both arguments
        self.target_copy = self.target_mobject.copy()
    self.mobject.align_data_and_family(self.target_copy)
    super().begin()
    if not self.mobject.has_updaters():
        self.mobject.lock_matching_data(
            self.starting_mobject,
            self.target_copy,
        )
</t>
<t tx="ekr.20250121054835.363">def finish(self) -&gt; None:
    super().finish()
    self.mobject.unlock_data()
</t>
<t tx="ekr.20250121054835.364">def create_target(self) -&gt; Mobject:
    # Has no meaningful effect here, but may be useful
    # in subclasses
    return self.target_mobject
</t>
<t tx="ekr.20250121054835.365">def check_target_mobject_validity(self) -&gt; None:
    if self.target_mobject is None:
        raise Exception(
            f"{self.__class__.__name__}.create_target not properly implemented"
        )
</t>
<t tx="ekr.20250121054835.366">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    super().clean_up_from_scene(scene)
    if self.replace_mobject_with_target_in_scene:
        scene.remove(self.mobject)
        scene.add(self.target_mobject)
</t>
<t tx="ekr.20250121054835.367">def update_config(self, **kwargs) -&gt; None:
    Animation.update_config(self, **kwargs)
    if "path_arc" in kwargs:
        self.path_func = path_along_arc(
            kwargs["path_arc"],
            kwargs.get("path_arc_axis", OUT)
        )
</t>
<t tx="ekr.20250121054835.368">def get_all_mobjects(self) -&gt; list[Mobject]:
    return [
        self.mobject,
        self.starting_mobject,
        self.target_mobject,
        self.target_copy,
    ]
</t>
<t tx="ekr.20250121054835.369">def get_all_families_zipped(self) -&gt; zip[tuple[Mobject]]:
    return zip(*[
        mob.get_family()
        for mob in [
            self.mobject,
            self.starting_mobject,
            self.target_copy,
        ]
    ])
</t>
<t tx="ekr.20250121054835.37">from docutils import nodes
from docutils.parsers.rst import directives, Directive

import jinja2
import os


@others
TEMPLATE = r"""
{% if not hide_code %}

.. raw:: html

    &lt;div class="manim-example"&gt;

{% endif %}

{% if is_video %}
.. raw:: html

    &lt;video id="{{ scene_name_lowercase }}" class="manim-video" controls loop autoplay src="{{ media_file_name }}"&gt;&lt;/video&gt;
{% else %}
.. image:: {{ media_file_name }}
    :align: center
    :name: {{ scene_name_lowercase }}
{% endif %}

{% if not hide_code %}
.. raw:: html

    &lt;h5 class="example-header"&gt;{{ scene_name }}&lt;a class="headerlink" href="#{{ scene_name_lowercase }}"&gt;¶&lt;/a&gt;&lt;/h5&gt;

{{ source_block }}
{% endif %}

.. raw:: html

    &lt;/div&gt;
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.370">def interpolate_submobject(
    self,
    submob: Mobject,
    start: Mobject,
    target_copy: Mobject,
    alpha: float
):
    submob.interpolate(start, target_copy, alpha, self.path_func)
    return self
</t>
<t tx="ekr.20250121054835.371">class ReplacementTransform(Transform):
    replace_mobject_with_target_in_scene: bool = True
</t>
<t tx="ekr.20250121054835.372">class TransformFromCopy(Transform):
    @others
</t>
<t tx="ekr.20250121054835.373">replace_mobject_with_target_in_scene: bool = True

def __init__(self, mobject: Mobject, target_mobject: Mobject, **kwargs):
    super().__init__(mobject.copy(), target_mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.374">class MoveToTarget(Transform):
    @others
</t>
<t tx="ekr.20250121054835.375">def __init__(self, mobject: Mobject, **kwargs):
    self.check_validity_of_input(mobject)
    super().__init__(mobject, mobject.target, **kwargs)
</t>
<t tx="ekr.20250121054835.376">def check_validity_of_input(self, mobject: Mobject) -&gt; None:
    if not hasattr(mobject, "target"):
        raise Exception(
            "MoveToTarget called on mobject without attribute 'target'"
        )
</t>
<t tx="ekr.20250121054835.377">class _MethodAnimation(MoveToTarget):
    @others
</t>
<t tx="ekr.20250121054835.378">def __init__(self, mobject: Mobject, methods: list[Callable], **kwargs):
    self.methods = methods
    super().__init__(mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.379">class ApplyMethod(Transform):
    @others
</t>
<t tx="ekr.20250121054835.38">class skip_manim_node(nodes.Admonition, nodes.Element):
    pass
</t>
<t tx="ekr.20250121054835.380">def __init__(self, method: Callable, *args, **kwargs):
    """
    method is a method of Mobject, *args are arguments for
    that method.  Key word arguments should be passed in
    as the last arg, as a dict, since **kwargs is for
    configuration of the transform itself

    Relies on the fact that mobject methods return the mobject
    """
    self.check_validity_of_input(method)
    self.method = method
    self.method_args = args
    super().__init__(method.__self__, **kwargs)
</t>
<t tx="ekr.20250121054835.381">def check_validity_of_input(self, method: Callable) -&gt; None:
    if not inspect.ismethod(method):
        raise Exception(
            "Whoops, looks like you accidentally invoked "
            "the method you want to animate"
        )
    assert isinstance(method.__self__, Mobject)
</t>
<t tx="ekr.20250121054835.382">def create_target(self) -&gt; Mobject:
    method = self.method
    # Make sure it's a list so that args.pop() works
    args = list(self.method_args)

    if len(args) &gt; 0 and isinstance(args[-1], dict):
        method_kwargs = args.pop()
    else:
        method_kwargs = {}
    target = method.__self__.copy()
    method.__func__(target, *args, **method_kwargs)
    return target
</t>
<t tx="ekr.20250121054835.383">class ApplyPointwiseFunction(ApplyMethod):
    @others
</t>
<t tx="ekr.20250121054835.384">def __init__(
    self,
    function: Callable[[np.ndarray], np.ndarray],
    mobject: Mobject,
    run_time: float = 3.0,
    **kwargs
):
    super().__init__(mobject.apply_function, function, run_time=run_time, **kwargs)
</t>
<t tx="ekr.20250121054835.385">class ApplyPointwiseFunctionToCenter(Transform):
    @others
</t>
<t tx="ekr.20250121054835.386">def __init__(
    self,
    function: Callable[[np.ndarray], np.ndarray],
    mobject: Mobject,
    **kwargs
):
    self.function = function
    super().__init__(mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.387">def create_target(self) -&gt; Mobject:
    return self.mobject.copy().move_to(self.function(self.mobject.get_center()))
</t>
<t tx="ekr.20250121054835.388">class FadeToColor(ApplyMethod):
    @others
</t>
<t tx="ekr.20250121054835.389">def __init__(
    self,
    mobject: Mobject,
    color: ManimColor,
    **kwargs
):
    super().__init__(mobject.set_color, color, **kwargs)
</t>
<t tx="ekr.20250121054835.39">def visit(self, node, name=""):
    self.visit_admonition(node, name)
</t>
<t tx="ekr.20250121054835.390">class ScaleInPlace(ApplyMethod):
    @others
</t>
<t tx="ekr.20250121054835.391">def __init__(
    self,
    mobject: Mobject,
    scale_factor: npt.ArrayLike,
    **kwargs
):
    super().__init__(mobject.scale, scale_factor, **kwargs)
</t>
<t tx="ekr.20250121054835.392">class ShrinkToCenter(ScaleInPlace):
    @others
</t>
<t tx="ekr.20250121054835.393">def __init__(self, mobject: Mobject, **kwargs):
    super().__init__(mobject, 0, **kwargs)
</t>
<t tx="ekr.20250121054835.394">class Restore(Transform):
    @others
</t>
<t tx="ekr.20250121054835.395">def __init__(self, mobject: Mobject, **kwargs):
    if not hasattr(mobject, "saved_state") or mobject.saved_state is None:
        raise Exception("Trying to restore without having saved")
    super().__init__(mobject, mobject.saved_state, **kwargs)
</t>
<t tx="ekr.20250121054835.396">class ApplyFunction(Transform):
    @others
</t>
<t tx="ekr.20250121054835.397">def __init__(
    self,
    function: Callable[[Mobject], Mobject],
    mobject: Mobject,
    **kwargs
):
    self.function = function
    super().__init__(mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.398">def create_target(self) -&gt; Mobject:
    target = self.function(self.mobject.copy())
    if not isinstance(target, Mobject):
        raise Exception("Functions passed to ApplyFunction must return object of type Mobject")
    return target
</t>
<t tx="ekr.20250121054835.399">class ApplyMatrix(ApplyPointwiseFunction):
    @others
</t>
<t tx="ekr.20250121054835.4">def construct(self):
    intro_words = Text("""
        The original motivation for manim was to
        better illustrate mathematical functions
        as transformations.
    """)
    intro_words.to_edge(UP)

    self.play(Write(intro_words))
    self.wait(2)

    # Linear transform
    grid = NumberPlane((-10, 10), (-5, 5))
    matrix = [[1, 1], [0, 1]]
    linear_transform_words = VGroup(
        Text("This is what the matrix"),
        IntegerMatrix(matrix),
        Text("looks like")
    )
    linear_transform_words.arrange(RIGHT)
    linear_transform_words.to_edge(UP)
    linear_transform_words.set_backstroke(width=5)

    self.play(
        ShowCreation(grid),
        FadeTransform(intro_words, linear_transform_words)
    )
    self.wait()
    self.play(grid.animate.apply_matrix(matrix), run_time=3)
    self.wait()

    # Complex map
    c_grid = ComplexPlane()
    moving_c_grid = c_grid.copy()
    moving_c_grid.prepare_for_nonlinear_transform()
    c_grid.set_stroke(BLUE_E, 1)
    c_grid.add_coordinate_labels(font_size=24)
    complex_map_words = TexText("""
        Or thinking of the plane as $\\mathds{C}$,\\\\
        this is the map $z \\rightarrow z^2$
    """)
    complex_map_words.to_corner(UR)
    complex_map_words.set_backstroke(width=5)

    self.play(
        FadeOut(grid),
        Write(c_grid, run_time=3),
        FadeIn(moving_c_grid),
        FadeTransform(linear_transform_words, complex_map_words),
    )
    self.wait()
    self.play(
        moving_c_grid.animate.apply_complex_function(lambda z: z**2),
        run_time=6,
    )
    self.wait(2)
</t>
<t tx="ekr.20250121054835.40">def depart(self, node):
    self.depart_admonition(node)
</t>
<t tx="ekr.20250121054835.400">def __init__(
    self,
    matrix: npt.ArrayLike,
    mobject: Mobject,
    **kwargs
):
    matrix = self.initialize_matrix(matrix)

    def func(p):
        return np.dot(p, matrix.T)

    super().__init__(func, mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.401">def initialize_matrix(self, matrix: npt.ArrayLike) -&gt; np.ndarray:
    matrix = np.array(matrix)
    if matrix.shape == (2, 2):
        new_matrix = np.identity(3)
        new_matrix[:2, :2] = matrix
        matrix = new_matrix
    elif matrix.shape != (3, 3):
        raise Exception("Matrix has bad dimensions")
    return matrix
</t>
<t tx="ekr.20250121054835.402">class ApplyComplexFunction(ApplyMethod):
    @others
</t>
<t tx="ekr.20250121054835.403">def __init__(
    self,
    function: Callable[[complex], complex],
    mobject: Mobject,
    **kwargs
):
    self.function = function
    method = mobject.apply_complex_function
    super().__init__(method, function, **kwargs)
</t>
<t tx="ekr.20250121054835.404">def init_path_func(self) -&gt; None:
    func1 = self.function(complex(1))
    self.path_arc = np.log(func1).imag
    super().init_path_func()
</t>
<t tx="ekr.20250121054835.405">###


class CyclicReplace(Transform):
    @others
</t>
<t tx="ekr.20250121054835.406">def __init__(self, *mobjects: Mobject, path_arc=90 * DEG, **kwargs):
    super().__init__(Group(*mobjects), path_arc=path_arc, **kwargs)
</t>
<t tx="ekr.20250121054835.407">def create_target(self) -&gt; Mobject:
    group = self.mobject
    target = group.copy()
    cycled_targets = [target[-1], *target[:-1]]
    for m1, m2 in zip(cycled_targets, group):
        m1.move_to(m2)
    return target
</t>
<t tx="ekr.20250121054835.408">class Swap(CyclicReplace):
    """Alternate name for CyclicReplace"""
    pass
</t>
<t tx="ekr.20250121054835.409">from __future__ import annotations

import itertools as it
from difflib import SequenceMatcher

from manimlib.animation.composition import AnimationGroup
from manimlib.animation.fading import FadeInFromPoint
from manimlib.animation.fading import FadeOutToPoint
from manimlib.animation.transform import Transform
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.mobject.svg.string_mobject import StringMobject

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable
    from manimlib.scene.scene import Scene


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.41">class ManimExampleDirective(Directive):
    @others
</t>
<t tx="ekr.20250121054835.410">class TransformMatchingParts(AnimationGroup):
    @others
</t>
<t tx="ekr.20250121054835.411">def __init__(
    self,
    source: Mobject,
    target: Mobject,
    matched_pairs: Iterable[tuple[Mobject, Mobject]] = [],
    match_animation: type = Transform,
    mismatch_animation: type = Transform,
    run_time: float = 2,
    lag_ratio: float = 0,
    **kwargs,
):
    self.source = source
    self.target = target
    self.match_animation = match_animation
    self.mismatch_animation = mismatch_animation
    self.anim_config = dict(**kwargs)

    # We will progressively build up a list of transforms
    # from pieces in source to those in target. These
    # two lists keep track of which pieces are accounted
    # for so far
    self.source_pieces = source.family_members_with_points()
    self.target_pieces = target.family_members_with_points()
    self.anims = []

    for pair in matched_pairs:
        self.add_transform(*pair)

    # Match any pairs with the same shape
    for pair in self.find_pairs_with_matching_shapes(self.source_pieces, self.target_pieces):
        self.add_transform(*pair)

    # Finally, account for mismatches
    for source_piece in self.source_pieces:
        if any([source_piece in anim.mobject.get_family() for anim in self.anims]):
            continue
        self.anims.append(FadeOutToPoint(
            source_piece, target.get_center(),
            **self.anim_config
        ))
    for target_piece in self.target_pieces:
        if any([target_piece in anim.mobject.get_family() for anim in self.anims]):
            continue
        self.anims.append(FadeInFromPoint(
            target_piece, source.get_center(),
            **self.anim_config
        ))

    super().__init__(
        *self.anims,
        run_time=run_time,
        lag_ratio=lag_ratio,
    )
</t>
<t tx="ekr.20250121054835.412">def add_transform(
    self,
    source: Mobject,
    target: Mobject,
):
    new_source_pieces = source.family_members_with_points()
    new_target_pieces = target.family_members_with_points()
    if len(new_source_pieces) == 0 or len(new_target_pieces) == 0:
        # Don't animate null sorces or null targets
        return
    source_is_new = all(char in self.source_pieces for char in new_source_pieces)
    target_is_new = all(char in self.target_pieces for char in new_target_pieces)
    if not source_is_new or not target_is_new:
        return

    transform_type = self.mismatch_animation 
    if source.has_same_shape_as(target):
        transform_type = self.match_animation

    self.anims.append(transform_type(source, target, **self.anim_config))
    for char in new_source_pieces:
        self.source_pieces.remove(char)
    for char in new_target_pieces:
        self.target_pieces.remove(char)
</t>
<t tx="ekr.20250121054835.413">def find_pairs_with_matching_shapes(
    self,
    chars1: list[Mobject],
    chars2: list[Mobject]
) -&gt; list[tuple[Mobject, Mobject]]:
    result = []
    for char1, char2 in it.product(chars1, chars2):
        if char1.has_same_shape_as(char2):
            result.append((char1, char2))
    return result
</t>
<t tx="ekr.20250121054835.414">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    super().clean_up_from_scene(scene)
    scene.remove(self.mobject)
    scene.add(self.target)
</t>
<t tx="ekr.20250121054835.415">class TransformMatchingShapes(TransformMatchingParts):
    """Alias for TransformMatchingParts"""
    pass
</t>
<t tx="ekr.20250121054835.416">class TransformMatchingStrings(TransformMatchingParts):
    @others
</t>
<t tx="ekr.20250121054835.417">def __init__(
    self,
    source: StringMobject,
    target: StringMobject,
    matched_keys: Iterable[str] = [],
    key_map: dict[str, str] = dict(),
    matched_pairs: Iterable[tuple[VMobject, VMobject]] = [],
    **kwargs,
</t>
<t tx="ekr.20250121054835.418">):
    matched_pairs = [
        *matched_pairs,
        *self.matching_blocks(source, target, matched_keys, key_map),
    ]

    super().__init__(
        source, target,
        matched_pairs=matched_pairs,
        **kwargs,
    )

def matching_blocks(
    self,
    source: StringMobject,
    target: StringMobject,
    matched_keys: Iterable[str],
    key_map: dict[str, str]
) -&gt; list[tuple[VMobject, VMobject]]:
    syms1 = source.get_symbol_substrings()
    syms2 = target.get_symbol_substrings()
    counts1 = list(map(source.substr_to_path_count, syms1))
    counts2 = list(map(target.substr_to_path_count, syms2))

    # Start with user specified matches
    blocks = [(source[key], target[key]) for key in matched_keys]
    blocks += [(source[key1], target[key2]) for key1, key2 in key_map.items()]

    # Nullify any intersections with those matches in the two symbol lists
    for sub_source, sub_target in blocks:
        for i in range(len(syms1)):
            if source[i] in sub_source.family_members_with_points():
                syms1[i] = "Null1"
        for j in range(len(syms2)):
            if target[j] in sub_target.family_members_with_points():
                syms2[j] = "Null2"

    # Group together longest matching substrings
    while True:
        matcher = SequenceMatcher(None, syms1, syms2)
        match = matcher.find_longest_match(0, len(syms1), 0, len(syms2))
        if match.size == 0:
            break

        i1 = sum(counts1[:match.a])
        i2 = sum(counts2[:match.b])
        size = sum(counts1[match.a:match.a + match.size])

        blocks.append((source[i1:i1 + size], target[i2:i2 + size]))

        for i in range(match.size):
            syms1[match.a + i] = "Null1"
            syms2[match.b + i] = "Null2"

    return blocks
</t>
<t tx="ekr.20250121054835.419">class TransformMatchingTex(TransformMatchingStrings):
    """Alias for TransformMatchingStrings"""
    pass
</t>
<t tx="ekr.20250121054835.42">has_content = True
required_arguments = 1
optional_arguments = 0
option_spec = {
    "hide_code": bool,
    "media": str,
}
final_argument_whitespace = True

def run(self):
    hide_code = "hide_code" in self.options
    scene_name = self.arguments[0]
    media_file_name = self.options["media"]

    source_block = [
        ".. code-block:: python",
        "",
        *["    " + line for line in self.content],
    ]
    source_block = "\n".join(source_block)

    state_machine = self.state_machine
    document = state_machine.document

    if any(media_file_name.endswith(ext) for ext in [".png", ".jpg", ".gif"]):
        is_video = False
    else:
        is_video = True

    rendered_template = jinja2.Template(TEMPLATE).render(
        scene_name=scene_name,
        scene_name_lowercase=scene_name.lower(),
        hide_code=hide_code,
        is_video=is_video,
        media_file_name=media_file_name,
        source_block=source_block,
    )
    state_machine.insert_input(
        rendered_template.split("\n"), source=document.attributes["source"]
    )

    return []
</t>
<t tx="ekr.20250121054835.420">from __future__ import annotations

from manimlib.animation.animation import Animation

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable

    from manimlib.mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.421">class UpdateFromFunc(Animation):
    """
    update_function of the form func(mobject), presumably
    to be used when the state of one mobject is dependent
    on another simultaneously animated mobject
    """
    @others
</t>
<t tx="ekr.20250121054835.422">def __init__(
    self,
    mobject: Mobject,
    update_function: Callable[[Mobject], Mobject | None],
    suspend_mobject_updating: bool = False,
    **kwargs
):
    self.update_function = update_function
    super().__init__(
        mobject,
        suspend_mobject_updating=suspend_mobject_updating,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.423">def interpolate_mobject(self, alpha: float) -&gt; None:
    self.update_function(self.mobject)
</t>
<t tx="ekr.20250121054835.424">class UpdateFromAlphaFunc(Animation):
    @others
</t>
<t tx="ekr.20250121054835.425">def __init__(
    self,
    mobject: Mobject,
    update_function: Callable[[Mobject, float], Mobject | None],
    suspend_mobject_updating: bool = False,
    **kwargs
):
    self.update_function = update_function
    super().__init__(mobject, suspend_mobject_updating=suspend_mobject_updating, **kwargs)
</t>
<t tx="ekr.20250121054835.426">def interpolate_mobject(self, alpha: float) -&gt; None:
    self.update_function(self.mobject, alpha)
</t>
<t tx="ekr.20250121054835.427">class MaintainPositionRelativeTo(Animation):
    @others
</t>
<t tx="ekr.20250121054835.428">def __init__(
    self,
    mobject: Mobject,
    tracked_mobject: Mobject,
    **kwargs
):
    self.tracked_mobject = tracked_mobject
    self.diff = mobject.get_center() - tracked_mobject.get_center()
    super().__init__(mobject, **kwargs)
</t>
<t tx="ekr.20250121054835.429">def interpolate_mobject(self, alpha: float) -&gt; None:
    target = self.tracked_mobject.get_center()
    location = self.mobject.get_center()
    self.mobject.shift(target - location + self.diff)
</t>
<t tx="ekr.20250121054835.43">def setup(app):
    app.add_node(skip_manim_node, html=(visit, depart))

    setup.app = app
    setup.config = app.config
    setup.confdir = app.confdir

    app.add_directive("manim-example", ManimExampleDirective)

    metadata = {"parallel_read_safe": False, "parallel_write_safe": True}
    return metadata
</t>
<t tx="ekr.20250121054835.430"></t>
<t tx="ekr.20250121054835.431">@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.432">from __future__ import annotations

import moderngl
import numpy as np
import OpenGL.GL as gl
from PIL import Image

from manimlib.camera.camera_frame import CameraFrame
from manimlib.constants import BLACK
from manimlib.constants import DEFAULT_RESOLUTION
from manimlib.constants import FRAME_HEIGHT
from manimlib.constants import FRAME_WIDTH
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.mobject import Point
from manimlib.utils.color import color_to_rgba

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Optional
    from manimlib.typing import ManimColor, Vect3
    from manimlib.window import Window


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.433">class Camera(object):
    @others
</t>
<t tx="ekr.20250121054835.434">def __init__(
    self,
    window: Optional[Window] = None,
    background_image: Optional[str] = None,
    frame_config: dict = dict(),
    # Note: frame height and width will be resized to match this resolution aspect ratio
    resolution=DEFAULT_RESOLUTION,
    fps: int = 30,
    background_color: ManimColor = BLACK,
    background_opacity: float = 1.0,
    # Points in vectorized mobjects with norm greater
    # than this value will be rescaled.
    max_allowable_norm: float = FRAME_WIDTH,
    image_mode: str = "RGBA",
    n_channels: int = 4,
    pixel_array_dtype: type = np.uint8,
    light_source_position: Vect3 = np.array([-10, 10, 10]),
    # Although vector graphics handle antialiasing fine
    # without multisampling, for 3d scenes one might want
    # to set samples to be greater than 0.
    samples: int = 0,
</t>
<t tx="ekr.20250121054835.435">):
    self.window = window
    self.background_image = background_image
    self.default_pixel_shape = resolution  # Rename?
    self.fps = fps
    self.max_allowable_norm = max_allowable_norm
    self.image_mode = image_mode
    self.n_channels = n_channels
    self.pixel_array_dtype = pixel_array_dtype
    self.light_source_position = light_source_position
    self.samples = samples

    self.rgb_max_val: float = np.iinfo(self.pixel_array_dtype).max
    self.background_rgba: list[float] = list(color_to_rgba(
        background_color, background_opacity
    ))
    self.uniforms = dict()
    self.init_frame(**frame_config)
    self.init_context()
    self.init_fbo()
    self.init_light_source()

def init_frame(self, **config) -&gt; None:
    self.frame = CameraFrame(**config)
</t>
<t tx="ekr.20250121054835.436">def init_context(self) -&gt; None:
    if self.window is None:
        self.ctx: moderngl.Context = moderngl.create_standalone_context()
    else:
        self.ctx: moderngl.Context = self.window.ctx

    self.ctx.enable(moderngl.PROGRAM_POINT_SIZE)
    self.ctx.enable(moderngl.BLEND)
</t>
<t tx="ekr.20250121054835.437">def init_fbo(self) -&gt; None:
    # This is the buffer used when writing to a video/image file
    self.fbo_for_files = self.get_fbo(self.samples)

    # This is the frame buffer we'll draw into when emitting frames
    self.draw_fbo = self.get_fbo(samples=0)

    if self.window is None:
        self.window_fbo = None
        self.fbo = self.fbo_for_files
    else:
        self.window_fbo = self.ctx.detect_framebuffer()
        self.fbo = self.window_fbo

    self.fbo.use()
</t>
<t tx="ekr.20250121054835.438">def init_light_source(self) -&gt; None:
    self.light_source = Point(self.light_source_position)
</t>
<t tx="ekr.20250121054835.439">def use_window_fbo(self, use: bool = True):
    assert self.window is not None
    if use:
        self.fbo = self.window_fbo
    else:
        self.fbo = self.fbo_for_files
</t>
<t tx="ekr.20250121054835.44"></t>
<t tx="ekr.20250121054835.440"># Methods associated with the frame buffer
def get_fbo(
    self,
    samples: int = 0
) -&gt; moderngl.Framebuffer:
    return self.ctx.framebuffer(
        color_attachments=self.ctx.texture(
            self.default_pixel_shape,
            components=self.n_channels,
            samples=samples,
        ),
        depth_attachment=self.ctx.depth_renderbuffer(
            self.default_pixel_shape,
            samples=samples
        )
    )
</t>
<t tx="ekr.20250121054835.441">def clear(self) -&gt; None:
    self.fbo.clear(*self.background_rgba)
    if self.window:
        self.window.clear(*self.background_rgba)
</t>
<t tx="ekr.20250121054835.442">def blit(self, src_fbo, dst_fbo):
    """
    Copy blocks between fbo's using Blit
    """
    gl.glBindFramebuffer(gl.GL_READ_FRAMEBUFFER, src_fbo.glo)
    gl.glBindFramebuffer(gl.GL_DRAW_FRAMEBUFFER, dst_fbo.glo)
    gl.glBlitFramebuffer(
        *src_fbo.viewport,
        *dst_fbo.viewport,
        gl.GL_COLOR_BUFFER_BIT, gl.GL_LINEAR
    )
</t>
<t tx="ekr.20250121054835.443">def get_raw_fbo_data(self, dtype: str = 'f1') -&gt; bytes:
    self.blit(self.fbo, self.draw_fbo)
    return self.draw_fbo.read(
        viewport=self.draw_fbo.viewport,
        components=self.n_channels,
        dtype=dtype,
    )
</t>
<t tx="ekr.20250121054835.444">def get_image(self) -&gt; Image.Image:
    return Image.frombytes(
        'RGBA',
        self.get_pixel_shape(),
        self.get_raw_fbo_data(),
        'raw', 'RGBA', 0, -1
    )
</t>
<t tx="ekr.20250121054835.445">def get_pixel_array(self) -&gt; np.ndarray:
    raw = self.get_raw_fbo_data(dtype='f4')
    flat_arr = np.frombuffer(raw, dtype='f4')
    arr = flat_arr.reshape([*reversed(self.draw_fbo.size), self.n_channels])
    arr = arr[::-1]
    # Convert from float
    return (self.rgb_max_val * arr).astype(self.pixel_array_dtype)
</t>
<t tx="ekr.20250121054835.446"># Needed?
def get_texture(self) -&gt; moderngl.Texture:
    texture = self.ctx.texture(
        size=self.fbo.size,
        components=4,
        data=self.get_raw_fbo_data(),
        dtype='f4'
    )
    return texture
</t>
<t tx="ekr.20250121054835.447"># Getting camera attributes
def get_pixel_size(self) -&gt; float:
    return self.frame.get_width() / self.get_pixel_shape()[0]
</t>
<t tx="ekr.20250121054835.448">def get_pixel_shape(self) -&gt; tuple[int, int]:
    return self.fbo.size
</t>
<t tx="ekr.20250121054835.449">def get_pixel_width(self) -&gt; int:
    return self.get_pixel_shape()[0]
</t>
<t tx="ekr.20250121054835.45">from manimlib.imports import *

NEW_BLUE = "#68a8e1"

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.450">def get_pixel_height(self) -&gt; int:
    return self.get_pixel_shape()[1]
</t>
<t tx="ekr.20250121054835.451">def get_aspect_ratio(self):
    pw, ph = self.get_pixel_shape()
    return pw / ph
</t>
<t tx="ekr.20250121054835.452">def get_frame_height(self) -&gt; float:
    return self.frame.get_height()
</t>
<t tx="ekr.20250121054835.453">def get_frame_width(self) -&gt; float:
    return self.frame.get_width()
</t>
<t tx="ekr.20250121054835.454">def get_frame_shape(self) -&gt; tuple[float, float]:
    return (self.get_frame_width(), self.get_frame_height())
</t>
<t tx="ekr.20250121054835.455">def get_frame_center(self) -&gt; np.ndarray:
    return self.frame.get_center()
</t>
<t tx="ekr.20250121054835.456">def get_location(self) -&gt; tuple[float, float, float]:
    return self.frame.get_implied_camera_location()
</t>
<t tx="ekr.20250121054835.457">def resize_frame_shape(self, fixed_dimension: bool = False) -&gt; None:
    """
    Changes frame_shape to match the aspect ratio
    of the pixels, where fixed_dimension determines
    whether frame_height or frame_width
    remains fixed while the other changes accordingly.
    """
    frame_height = self.get_frame_height()
    frame_width = self.get_frame_width()
    aspect_ratio = self.get_aspect_ratio()
    if not fixed_dimension:
        frame_height = frame_width / aspect_ratio
    else:
        frame_width = aspect_ratio * frame_height
    self.frame.set_height(frame_height, stretch=True)
    self.frame.set_width(frame_width, stretch=True)
</t>
<t tx="ekr.20250121054835.458"># Rendering
def capture(self, *mobjects: Mobject) -&gt; None:
    self.clear()
    self.refresh_uniforms()
    self.fbo.use()
    for mobject in mobjects:
        mobject.render(self.ctx, self.uniforms)

    if self.window:
        self.window.swap_buffers()
        if self.fbo is not self.window_fbo:
            self.blit(self.fbo, self.window_fbo)
            self.window.swap_buffers()
</t>
<t tx="ekr.20250121054835.459">def refresh_uniforms(self) -&gt; None:
    frame = self.frame
    view_matrix = frame.get_view_matrix()
    light_pos = self.light_source.get_location()
    cam_pos = self.frame.get_implied_camera_location()

    self.uniforms.update(
        view=tuple(view_matrix.T.flatten()),
        frame_scale=frame.get_scale(),
        frame_rescale_factors=(
            2.0 / FRAME_WIDTH,
            2.0 / FRAME_HEIGHT,
            frame.get_scale() / frame.get_focal_distance(),
        ),
        pixel_size=self.get_pixel_size(),
        camera_position=tuple(cam_pos),
        light_position=tuple(light_pos),
    )
</t>
<t tx="ekr.20250121054835.46">class Thumbnail(GraphScene):
    @others
</t>
<t tx="ekr.20250121054835.460"># Mostly just defined so old scenes don't break
class ThreeDCamera(Camera):
    @others
</t>
<t tx="ekr.20250121054835.461">def __init__(self, samples: int = 4, **kwargs):
    super().__init__(samples=samples, **kwargs)
</t>
<t tx="ekr.20250121054835.462">from __future__ import annotations

import math
import warnings

import numpy as np
from scipy.spatial.transform import Rotation

from manimlib.constants import DEG, RADIANS
from manimlib.constants import FRAME_SHAPE
from manimlib.constants import DOWN, LEFT, ORIGIN, OUT, RIGHT, UP
from manimlib.constants import PI
from manimlib.mobject.mobject import Mobject
from manimlib.utils.space_ops import normalize
from manimlib.utils.simple_functions import clip

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from manimlib.typing import Vect3


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.463">class CameraFrame(Mobject):
    @others
</t>
<t tx="ekr.20250121054835.464">def __init__(
    self,
    frame_shape: tuple[float, float] = FRAME_SHAPE,
    center_point: Vect3 = ORIGIN,
    # Field of view in the y direction
    fovy: float = 45 * DEG,
    euler_axes: str = "zxz",
    # This keeps it ordered first in a scene
    z_index=-1,
    **kwargs,
):
    super().__init__(z_index=z_index, **kwargs)

    self.uniforms["orientation"] = Rotation.identity().as_quat()
    self.uniforms["fovy"] = fovy

    self.default_orientation = Rotation.identity()
    self.view_matrix = np.identity(4)
    self.id4x4 = np.identity(4)
    self.camera_location = OUT  # This will be updated by set_points
    self.euler_axes = euler_axes

    self.set_points(np.array([ORIGIN, LEFT, RIGHT, DOWN, UP]))
    self.set_width(frame_shape[0], stretch=True)
    self.set_height(frame_shape[1], stretch=True)
    self.move_to(center_point)
</t>
<t tx="ekr.20250121054835.465">def set_orientation(self, rotation: Rotation):
    self.uniforms["orientation"][:] = rotation.as_quat()
    return self
</t>
<t tx="ekr.20250121054835.466">def get_orientation(self):
    return Rotation.from_quat(self.uniforms["orientation"])
</t>
<t tx="ekr.20250121054835.467">def make_orientation_default(self):
    self.default_orientation = self.get_orientation()
    return self
</t>
<t tx="ekr.20250121054835.468">def to_default_state(self):
    self.set_shape(*FRAME_SHAPE)
    self.center()
    self.set_orientation(self.default_orientation)
    return self
</t>
<t tx="ekr.20250121054835.469">def get_euler_angles(self) -&gt; np.ndarray:
    orientation = self.get_orientation()
    if np.isclose(orientation.as_quat(), [0, 0, 0, 1]).all():
        return np.zeros(3)
    with warnings.catch_warnings():
        warnings.simplefilter('ignore', UserWarning)  # Ignore UserWarnings
        angles = orientation.as_euler(self.euler_axes)[::-1]
    # Handle Gimble lock case
    if self.euler_axes == "zxz":
        if np.isclose(angles[1], 0, atol=1e-2):
            angles[0] = angles[0] + angles[2]
            angles[2] = 0
        if np.isclose(angles[1], PI, atol=1e-2):
            angles[0] = angles[0] - angles[2]
            angles[2] = 0
    return angles
</t>
<t tx="ekr.20250121054835.47">CONFIG = {
    "y_max": 8,
    "y_axis_height": 5,
}

def construct(self):
    self.show_function_graph()
</t>
<t tx="ekr.20250121054835.470">def get_theta(self):
    return self.get_euler_angles()[0]
</t>
<t tx="ekr.20250121054835.471">def get_phi(self):
    return self.get_euler_angles()[1]
</t>
<t tx="ekr.20250121054835.472">def get_gamma(self):
    return self.get_euler_angles()[2]
</t>
<t tx="ekr.20250121054835.473">def get_scale(self):
    return self.get_height() / FRAME_SHAPE[1]
</t>
<t tx="ekr.20250121054835.474">def get_inverse_camera_rotation_matrix(self):
    return self.get_orientation().as_matrix().T
</t>
<t tx="ekr.20250121054835.475">def get_view_matrix(self, refresh=False):
    """
    Returns a 4x4 for the affine transformation mapping a point
    into the camera's internal coordinate system
    """
    if self._data_has_changed:
        shift = self.id4x4.copy()
        rotation = self.id4x4.copy()

        scale = self.get_scale()
        shift[:3, 3] = -self.get_center()
        rotation[:3, :3] = self.get_inverse_camera_rotation_matrix()
        np.dot(rotation, shift, out=self.view_matrix)
        if scale &gt; 0:
            self.view_matrix[:3, :4] /= scale

    return self.view_matrix
</t>
<t tx="ekr.20250121054835.476">def get_inv_view_matrix(self):
    return np.linalg.inv(self.get_view_matrix())
</t>
<t tx="ekr.20250121054835.477">@Mobject.affects_data
def interpolate(self, *args, **kwargs):
    super().interpolate(*args, **kwargs)
</t>
<t tx="ekr.20250121054835.478">@Mobject.affects_data
def rotate(self, angle: float, axis: np.ndarray = OUT, **kwargs):
    rot = Rotation.from_rotvec(angle * normalize(axis))
    self.set_orientation(rot * self.get_orientation())
    return self
</t>
<t tx="ekr.20250121054835.479">def set_euler_angles(
    self,
    theta: float | None = None,
    phi: float | None = None,
    gamma: float | None = None,
    units: float = RADIANS
):
    eulers = self.get_euler_angles()  # theta, phi, gamma
    for i, var in enumerate([theta, phi, gamma]):
        if var is not None:
            eulers[i] = var * units
    if all(eulers == 0):
        rot = Rotation.identity()
    else:
        rot = Rotation.from_euler(self.euler_axes, eulers[::-1])
    self.set_orientation(rot)
    return self
</t>
<t tx="ekr.20250121054835.48">def show_function_graph(self):
    self.setup_axes(animate=False)
    def func(x):
        return 0.1 * (x + 3-5) * (x - 3-5) * (x-5) + 5

    def rect(x):
        return 2.775*(x-1.5)+3.862
    recta = self.get_graph(rect,x_min=-1,x_max=5)
    graph = self.get_graph(func,x_min=0.2,x_max=9)
    graph.set_color(NEW_BLUE)
    input_tracker_p1 = ValueTracker(1.5)
    input_tracker_p2 = ValueTracker(3.5)

    def get_x_value(input_tracker):
        return input_tracker.get_value()

    def get_y_value(input_tracker):
        return graph.underlying_function(get_x_value(input_tracker))

    def get_x_point(input_tracker):
        return self.coords_to_point(get_x_value(input_tracker), 0)

    def get_y_point(input_tracker):
        return self.coords_to_point(0, get_y_value(input_tracker))

    def get_graph_point(input_tracker):
        return self.coords_to_point(get_x_value(input_tracker), get_y_value(input_tracker))

    def get_v_line(input_tracker):
        return DashedLine(get_x_point(input_tracker), get_graph_point(input_tracker), stroke_width=2)

    def get_h_line(input_tracker):
        return DashedLine(get_graph_point(input_tracker), get_y_point(input_tracker), stroke_width=2)
    # 
    input_triangle_p1 = RegularPolygon(n=3, start_angle=TAU / 4)
    output_triangle_p1 = RegularPolygon(n=3, start_angle=0)
    for triangle in input_triangle_p1, output_triangle_p1:
        triangle.set_fill(WHITE, 1)
        triangle.set_stroke(width=0)
        triangle.scale(0.1)
    # 
    input_triangle_p2 = RegularPolygon(n=3, start_angle=TAU / 4)
    output_triangle_p2 = RegularPolygon(n=3, start_angle=0)
    for triangle in input_triangle_p2, output_triangle_p2:
        triangle.set_fill(WHITE, 1)
        triangle.set_stroke(width=0)
        triangle.scale(0.1)
        
    # 
    x_label_p1 = Tex("a")
    output_label_p1 = Tex("f(a)")
    x_label_p2 = Tex("b")
    output_label_p2 = Tex("f(b)")
    v_line_p1 = get_v_line(input_tracker_p1)
    v_line_p2 = get_v_line(input_tracker_p2)
    h_line_p1 = get_h_line(input_tracker_p1)
    h_line_p2 = get_h_line(input_tracker_p2)
    graph_dot_p1 = Dot(color=WHITE)
    graph_dot_p2 = Dot(color=WHITE)

    # reposition mobjects
    x_label_p1.next_to(v_line_p1, DOWN)
    x_label_p2.next_to(v_line_p2, DOWN)
    output_label_p1.next_to(h_line_p1, LEFT)
    output_label_p2.next_to(h_line_p2, LEFT)
    input_triangle_p1.next_to(v_line_p1, DOWN, buff=0)
    input_triangle_p2.next_to(v_line_p2, DOWN, buff=0)
    output_triangle_p1.next_to(h_line_p1, LEFT, buff=0)
    output_triangle_p2.next_to(h_line_p2, LEFT, buff=0)
    graph_dot_p1.move_to(get_graph_point(input_tracker_p1))
    graph_dot_p2.move_to(get_graph_point(input_tracker_p2))


    #
    self.play(
        ShowCreation(graph),
    )
    # Animacion del punto a
    self.add_foreground_mobject(graph_dot_p1)
    self.add_foreground_mobject(graph_dot_p2)
    self.play(
        DrawBorderThenFill(input_triangle_p1),
        Write(x_label_p1),
        ShowCreation(v_line_p1),
        GrowFromCenter(graph_dot_p1),
        ShowCreation(h_line_p1),
        Write(output_label_p1),
        DrawBorderThenFill(output_triangle_p1),
        DrawBorderThenFill(input_triangle_p2),
        Write(x_label_p2),
        ShowCreation(v_line_p2),
        GrowFromCenter(graph_dot_p2),
        ShowCreation(h_line_p2),
        Write(output_label_p2),
        DrawBorderThenFill(output_triangle_p2),
        run_time=0.5
    )
    self.add(
        input_triangle_p2,
        x_label_p2,
        graph_dot_p2,
        v_line_p2,
        h_line_p2,
        output_triangle_p2,
        output_label_p2,
    )
    ###################
    pendiente_recta = self.get_secant_slope_group(
        1.9, recta, dx = 1.4,
        df_label = None,
        dx_label = None,
        dx_line_color = PURPLE,
        df_line_color= ORANGE,
        )
    grupo_secante = self.get_secant_slope_group(
        1.5, graph, dx = 2,
        df_label = None,
        dx_label = None,
        dx_line_color = "#942357",
        df_line_color= "#3f7d5c",
        secant_line_color = RED,
    )


    self.add(
        input_triangle_p2,
        graph_dot_p2,
        v_line_p2,
        h_line_p2,
        output_triangle_p2,
    )
    self.play(FadeIn(grupo_secante))

    kwargs = {
        "x_min" : 4,
        "x_max" : 9,
        "fill_opacity" : 0.75,
        "stroke_width" : 0.25,
    }
    self.graph=graph
    iteraciones=6


    self.rect_list = self.get_riemann_rectangles_list(
        graph, iteraciones,start_color=PURPLE,end_color=ORANGE, **kwargs
    )
    flat_rects = self.get_riemann_rectangles(
        self.get_graph(lambda x : 0), dx = 0.5,start_color=invert_color(PURPLE),end_color=invert_color(ORANGE),**kwargs
    )
    rects = self.rect_list[0]
    self.transform_between_riemann_rects(
        flat_rects, rects, 
        replace_mobject_with_target_in_scene = True,
        run_time=0.9
    )

    # adding manim
    picture = Group(*self.mobjects)
    picture.scale(0.6).to_edge(LEFT, buff=SMALL_BUFF)
    manim = TexText("Manim").set_height(1.5) \
                                .next_to(picture, RIGHT) \
                                .shift(DOWN * 0.7)
    self.add(manim)
</t>
<t tx="ekr.20250121054835.480">def increment_euler_angles(
    self,
    dtheta: float = 0,
    dphi: float = 0,
    dgamma: float = 0,
    units: float = RADIANS
):
    angles = self.get_euler_angles()
    new_angles = angles + np.array([dtheta, dphi, dgamma]) * units

    # Limit range for phi
    if self.euler_axes == "zxz":
        new_angles[1] = clip(new_angles[1], 0, PI)
    elif self.euler_axes == "zxy":
        new_angles[1] = clip(new_angles[1], -PI / 2, PI / 2)

    new_rot = Rotation.from_euler(self.euler_axes, new_angles[::-1])
    self.set_orientation(new_rot)
    return self
</t>
<t tx="ekr.20250121054835.481">def set_euler_axes(self, seq: str):
    self.euler_axes = seq
</t>
<t tx="ekr.20250121054835.482">def reorient(
    self,
    theta_degrees: float | None = None,
    phi_degrees: float | None = None,
    gamma_degrees: float | None = None,
    center: Vect3 | tuple[float, float, float] | None = None,
    height: float | None = None
):
    """
    Shortcut for set_euler_angles, defaulting to taking
    in angles in degrees
    """
    self.set_euler_angles(theta_degrees, phi_degrees, gamma_degrees, units=DEG)
    if center is not None:
        self.move_to(np.array(center))
    if height is not None:
        self.set_height(height)
    return self
</t>
<t tx="ekr.20250121054835.483">def set_theta(self, theta: float):
    return self.set_euler_angles(theta=theta)
</t>
<t tx="ekr.20250121054835.484">def set_phi(self, phi: float):
    return self.set_euler_angles(phi=phi)
</t>
<t tx="ekr.20250121054835.485">def set_gamma(self, gamma: float):
    return self.set_euler_angles(gamma=gamma)
</t>
<t tx="ekr.20250121054835.486">def increment_theta(self, dtheta: float, units=RADIANS):
    self.increment_euler_angles(dtheta=dtheta, units=units)
    return self
</t>
<t tx="ekr.20250121054835.487">def increment_phi(self, dphi: float, units=RADIANS):
    self.increment_euler_angles(dphi=dphi, units=units)
    return self
</t>
<t tx="ekr.20250121054835.488">def increment_gamma(self, dgamma: float, units=RADIANS):
    self.increment_euler_angles(dgamma=dgamma, units=units)
    return self
</t>
<t tx="ekr.20250121054835.489">def add_ambient_rotation(self, angular_speed=1 * DEG):
    self.add_updater(lambda m, dt: m.increment_theta(angular_speed * dt))
    return self
</t>
<t tx="ekr.20250121054835.49"></t>
<t tx="ekr.20250121054835.490">@Mobject.affects_data
def set_focal_distance(self, focal_distance: float):
    self.uniforms["fovy"] = 2 * math.atan(0.5 * self.get_height() / focal_distance)
    return self
</t>
<t tx="ekr.20250121054835.491">@Mobject.affects_data
def set_field_of_view(self, field_of_view: float):
    self.uniforms["fovy"] = field_of_view
    return self
</t>
<t tx="ekr.20250121054835.492">def get_shape(self):
    return (self.get_width(), self.get_height())
</t>
<t tx="ekr.20250121054835.493">def get_aspect_ratio(self):
    width, height = self.get_shape()
    return width / height
</t>
<t tx="ekr.20250121054835.494">def get_center(self) -&gt; np.ndarray:
    # Assumes first point is at the center
    return self.get_points()[0]
</t>
<t tx="ekr.20250121054835.495">def get_width(self) -&gt; float:
    points = self.get_points()
    return points[2, 0] - points[1, 0]
</t>
<t tx="ekr.20250121054835.496">def get_height(self) -&gt; float:
    points = self.get_points()
    return points[4, 1] - points[3, 1]
</t>
<t tx="ekr.20250121054835.497">def get_focal_distance(self) -&gt; float:
    return 0.5 * self.get_height() / math.tan(0.5 * self.uniforms["fovy"])
</t>
<t tx="ekr.20250121054835.498">def get_field_of_view(self) -&gt; float:
    return self.uniforms["fovy"]
</t>
<t tx="ekr.20250121054835.499">def get_implied_camera_location(self) -&gt; np.ndarray:
    if self._data_has_changed:
        to_camera = self.get_inverse_camera_rotation_matrix()[2]
        dist = self.get_focal_distance()
        self.camera_location = self.get_center() + dist * to_camera
    return self.camera_location
</t>
<t tx="ekr.20250121054835.5">class AnimatingMethods(Scene):
    @others
</t>
<t tx="ekr.20250121054835.50">import pkg_resources

__version__ = pkg_resources.get_distribution("manimgl").version

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from manimlib.typing import *

from manimlib.constants import *

from manimlib.window import *

from manimlib.animation.animation import *
from manimlib.animation.composition import *
from manimlib.animation.creation import *
from manimlib.animation.fading import *
from manimlib.animation.growing import *
from manimlib.animation.indication import *
from manimlib.animation.movement import *
from manimlib.animation.numbers import *
from manimlib.animation.rotation import *
from manimlib.animation.specialized import *
from manimlib.animation.transform import *
from manimlib.animation.transform_matching_parts import *
from manimlib.animation.update import *

from manimlib.camera.camera import *

from manimlib.mobject.boolean_ops import *
from manimlib.mobject.changing import *
from manimlib.mobject.coordinate_systems import *
from manimlib.mobject.frame import *
from manimlib.mobject.functions import *
from manimlib.mobject.geometry import *
from manimlib.mobject.interactive import *
from manimlib.mobject.matrix import *
from manimlib.mobject.mobject import *
from manimlib.mobject.mobject_update_utils import *
from manimlib.mobject.number_line import *
from manimlib.mobject.numbers import *
from manimlib.mobject.probability import *
from manimlib.mobject.shape_matchers import *
from manimlib.mobject.svg.brace import *
from manimlib.mobject.svg.drawings import *
from manimlib.mobject.svg.string_mobject import *
from manimlib.mobject.svg.svg_mobject import *
from manimlib.mobject.svg.special_tex import *
from manimlib.mobject.svg.tex_mobject import *
from manimlib.mobject.svg.text_mobject import *
from manimlib.mobject.three_dimensions import *
from manimlib.mobject.types.dot_cloud import *
from manimlib.mobject.types.image_mobject import *
from manimlib.mobject.types.point_cloud_mobject import *
from manimlib.mobject.types.surface import *
from manimlib.mobject.types.vectorized_mobject import *
from manimlib.mobject.value_tracker import *
from manimlib.mobject.vector_field import *

from manimlib.scene.interactive_scene import *
from manimlib.scene.scene import *

from manimlib.utils.bezier import *
from manimlib.utils.cache import *
from manimlib.utils.color import *
from manimlib.utils.dict_ops import *
from manimlib.utils.debug import *
from manimlib.utils.directories import *
from manimlib.utils.file_ops import *
from manimlib.utils.images import *
from manimlib.utils.iterables import *
from manimlib.utils.paths import *
from manimlib.utils.rate_functions import *
from manimlib.utils.simple_functions import *
from manimlib.utils.shaders import *
from manimlib.utils.sounds import *
from manimlib.utils.space_ops import *
from manimlib.utils.tex import *
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.500">def to_fixed_frame_point(self, point: Vect3, relative: bool = False):
    view = self.get_view_matrix()
    point4d = [*point, 0 if relative else 1]
    return np.dot(point4d, view.T)[:3]
</t>
<t tx="ekr.20250121054835.501">def from_fixed_frame_point(self, point: Vect3, relative: bool = False):
    inv_view = self.get_inv_view_matrix()
    point4d = [*point, 0 if relative else 1]
    return np.dot(point4d, inv_view.T)[:3]
</t>
<t tx="ekr.20250121054835.502"></t>
<t tx="ekr.20250121054835.503">from manimlib.event_handler.event_dispatcher import EventDispatcher


# This is supposed to be a Singleton
# i.e., during runtime there should be only one object of Event Dispatcher
EVENT_DISPATCHER = EventDispatcher()
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.504">from __future__ import annotations

import numpy as np

from manimlib.event_handler.event_listner import EventListener
from manimlib.event_handler.event_type import EventType


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.505">class EventDispatcher(object):
    @others
    __iadd__ = add_listner
    __isub__ = remove_listner
    __call__ = dispatch
    __len__ = get_listners_count
</t>
<t tx="ekr.20250121054835.506">def __init__(self):
    self.event_listners: dict[
        EventType, list[EventListener]
    ] = {
        event_type: []
        for event_type in EventType
    }
    self.mouse_point = np.array((0., 0., 0.))
    self.mouse_drag_point = np.array((0., 0., 0.))
    self.pressed_keys: set[int] = set()
    self.draggable_object_listners: list[EventListener] = []
</t>
<t tx="ekr.20250121054835.507">def add_listner(self, event_listner: EventListener):
    assert isinstance(event_listner, EventListener)
    self.event_listners[event_listner.event_type].append(event_listner)
    return self
</t>
<t tx="ekr.20250121054835.508">def remove_listner(self, event_listner: EventListener):
    assert isinstance(event_listner, EventListener)
    try:
        while event_listner in self.event_listners[event_listner.event_type]:
            self.event_listners[event_listner.event_type].remove(event_listner)
    except:
        # raise ValueError("Handler is not handling this event, so cannot remove it.")
        pass
    return self
</t>
<t tx="ekr.20250121054835.509">def dispatch(self, event_type: EventType, **event_data):
    if event_type == EventType.MouseMotionEvent:
        self.mouse_point = event_data["point"]
    elif event_type == EventType.MouseDragEvent:
        self.mouse_drag_point = event_data["point"]
    elif event_type == EventType.KeyPressEvent:
        self.pressed_keys.add(event_data["symbol"])  # Modifiers?
    elif event_type == EventType.KeyReleaseEvent:
        self.pressed_keys.difference_update({event_data["symbol"]})  # Modifiers?
    elif event_type == EventType.MousePressEvent:
        self.draggable_object_listners = [
            listner
            for listner in self.event_listners[EventType.MouseDragEvent]
            if listner.mobject.is_point_touching(self.mouse_point)
        ]
    elif event_type == EventType.MouseReleaseEvent:
        self.draggable_object_listners = []

    propagate_event = None

    if event_type == EventType.MouseDragEvent:
        for listner in self.draggable_object_listners:
            assert isinstance(listner, EventListener)
            propagate_event = listner.callback(listner.mobject, event_data)
            if propagate_event is not None and propagate_event is False:
                return propagate_event

    elif event_type.value.startswith('mouse'):
        for listner in self.event_listners[event_type]:
            if listner.mobject.is_point_touching(self.mouse_point):
                propagate_event = listner.callback(
                    listner.mobject, event_data)
                if propagate_event is not None and propagate_event is False:
                    return propagate_event

    elif event_type.value.startswith('key'):
        for listner in self.event_listners[event_type]:
            propagate_event = listner.callback(listner.mobject, event_data)
            if propagate_event is not None and propagate_event is False:
                return propagate_event

    return propagate_event
</t>
<t tx="ekr.20250121054835.51">#!/usr/bin/env python
from addict import Dict

from manimlib import __version__
from manimlib.config import manim_config
from manimlib.config import parse_cli
import manimlib.extract_scene
from manimlib.utils.cache import clear_cache
from manimlib.window import Window


from IPython.terminal.embed import KillEmbedded


from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from argparse import Namespace


@others
if __name__ == "__main__":
    main()
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.510">def get_listners_count(self) -&gt; int:
    return sum([len(value) for key, value in self.event_listners.items()])
</t>
<t tx="ekr.20250121054835.511">def get_mouse_point(self) -&gt; np.ndarray:
    return self.mouse_point
</t>
<t tx="ekr.20250121054835.512">def get_mouse_drag_point(self) -&gt; np.ndarray:
    return self.mouse_drag_point
</t>
<t tx="ekr.20250121054835.513">def is_key_pressed(self, symbol: int) -&gt; bool:
    return (symbol in self.pressed_keys)
</t>
<t tx="ekr.20250121054835.514">from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable

    from manimlib.event_handler.event_type import EventType
    from manimlib.mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.515">class EventListener(object):
    @others
</t>
<t tx="ekr.20250121054835.516">def __init__(
    self,
    mobject: Mobject,
    event_type: EventType,
    event_callback: Callable[[Mobject, dict[str]]]
):
    self.mobject = mobject
    self.event_type = event_type
    self.callback = event_callback
</t>
<t tx="ekr.20250121054835.517">def __eq__(self, o: object) -&gt; bool:
    return_val = False
    try:
        return_val = self.callback == o.callback \
            and self.mobject == o.mobject \
            and self.event_type == o.event_type
    except:
        pass
    return return_val
</t>
<t tx="ekr.20250121054835.518">from enum import Enum


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.519">class EventType(Enum):
    MouseMotionEvent = 'mouse_motion_event'
    MousePressEvent = 'mouse_press_event'
    MouseReleaseEvent = 'mouse_release_event'
    MouseDragEvent = 'mouse_drag_event'
    MouseScrollEvent = 'mouse_scroll_event'
    KeyPressEvent = 'key_press_event'
    KeyReleaseEvent = 'key_release_event'
</t>
<t tx="ekr.20250121054835.52">def run_scenes():
    """
    Runs the scenes in a loop and detects when a scene reload is requested.
    """
    # Create a new dict to be able to upate without
    # altering global configuration
    scene_config = Dict(manim_config.scene)
    run_config = manim_config.run

    if run_config.show_in_window:
        # Create a reusable window
        window = Window(**manim_config.window)
        scene_config.update(window=window)

    while True:
        try:
            # Blocking call since a scene may init an IPython shell()
            scenes = manimlib.extract_scene.main(scene_config, run_config)
            for scene in scenes:
                scene.run()
            return
        except KillEmbedded:
            # Requested via the `exit_raise` IPython runline magic
            # by means of the reload_scene() command
            pass
        except KeyboardInterrupt:
            break
</t>
<t tx="ekr.20250121054835.520"></t>
<t tx="ekr.20250121054835.521">@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.522">from __future__ import annotations

import numpy as np
import pathops

from manimlib.mobject.types.vectorized_mobject import VMobject


# Boolean operations between 2D mobjects
# Borrowed from https://github.com/ManimCommunity/manim/

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.523">def _convert_vmobject_to_skia_path(vmobject: VMobject) -&gt; pathops.Path:
    path = pathops.Path()
    for submob in vmobject.family_members_with_points():
        for subpath in submob.get_subpaths():
            quads = vmobject.get_bezier_tuples_from_points(subpath)
            start = subpath[0]
            path.moveTo(*start[:2])
            for p0, p1, p2 in quads:
                path.quadTo(*p1[:2], *p2[:2])
            if vmobject.consider_points_equal(subpath[0], subpath[-1]):
                path.close()
    return path
</t>
<t tx="ekr.20250121054835.524">def _convert_skia_path_to_vmobject(
    path: pathops.Path,
    vmobject: VMobject
) -&gt; VMobject:
    PathVerb = pathops.PathVerb
    current_path_start = np.array([0.0, 0.0, 0.0])
    for path_verb, points in path:
        if path_verb == PathVerb.CLOSE:
            vmobject.add_line_to(current_path_start)
        else:
            points = np.hstack((np.array(points), np.zeros((len(points), 1))))
            if path_verb == PathVerb.MOVE:
                for point in points:
                    current_path_start = point
                    vmobject.start_new_path(point)
            elif path_verb == PathVerb.CUBIC:
                vmobject.add_cubic_bezier_curve_to(*points)
            elif path_verb == PathVerb.LINE:
                vmobject.add_line_to(points[0])
            elif path_verb == PathVerb.QUAD:
                vmobject.add_quadratic_bezier_curve_to(*points)
            else:
                raise Exception(f"Unsupported: {path_verb}")
    return vmobject.reverse_points()
</t>
<t tx="ekr.20250121054835.525">class Union(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.526">def __init__(self, *vmobjects: VMobject, **kwargs):
    if len(vmobjects) &lt; 2:
        raise ValueError("At least 2 mobjects needed for Union.")
    super().__init__(**kwargs)
    outpen = pathops.Path()
    paths = [
        _convert_vmobject_to_skia_path(vmobject)
        for vmobject in vmobjects
    ]
    pathops.union(paths, outpen.getPen())
    _convert_skia_path_to_vmobject(outpen, self)
</t>
<t tx="ekr.20250121054835.527">class Difference(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.528">def __init__(self, subject: VMobject, clip: VMobject, **kwargs):
    super().__init__(**kwargs)
    outpen = pathops.Path()
    pathops.difference(
        [_convert_vmobject_to_skia_path(subject)],
        [_convert_vmobject_to_skia_path(clip)],
        outpen.getPen(),
    )
    _convert_skia_path_to_vmobject(outpen, self)
</t>
<t tx="ekr.20250121054835.529">class Intersection(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.53">def main():
    """
    Main entry point for ManimGL.
    """
    print(f"ManimGL \033[32mv{__version__}\033[0m")

    args = parse_cli()
    if args.version and args.file is None:
        return
    if args.clear_cache:
        clear_cache()

    run_scenes()
</t>
<t tx="ekr.20250121054835.530">def __init__(self, *vmobjects: VMobject, **kwargs):
    if len(vmobjects) &lt; 2:
        raise ValueError("At least 2 mobjects needed for Intersection.")
    super().__init__(**kwargs)
    outpen = pathops.Path()
    pathops.intersection(
        [_convert_vmobject_to_skia_path(vmobjects[0])],
        [_convert_vmobject_to_skia_path(vmobjects[1])],
        outpen.getPen(),
    )
    new_outpen = outpen
    for _i in range(2, len(vmobjects)):
        new_outpen = pathops.Path()
        pathops.intersection(
            [outpen],
            [_convert_vmobject_to_skia_path(vmobjects[_i])],
            new_outpen.getPen(),
        )
        outpen = new_outpen
    _convert_skia_path_to_vmobject(outpen, self)
</t>
<t tx="ekr.20250121054835.531">class Exclusion(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.532">def __init__(self, *vmobjects: VMobject, **kwargs):
    if len(vmobjects) &lt; 2:
        raise ValueError("At least 2 mobjects needed for Exclusion.")
    super().__init__(**kwargs)
    outpen = pathops.Path()
    pathops.xor(
        [_convert_vmobject_to_skia_path(vmobjects[0])],
        [_convert_vmobject_to_skia_path(vmobjects[1])],
        outpen.getPen(),
    )
    new_outpen = outpen
    for _i in range(2, len(vmobjects)):
        new_outpen = pathops.Path()
        pathops.xor(
            [outpen],
            [_convert_vmobject_to_skia_path(vmobjects[_i])],
            new_outpen.getPen(),
        )
        outpen = new_outpen
    _convert_skia_path_to_vmobject(outpen, self)
</t>
<t tx="ekr.20250121054835.533">from __future__ import annotations

import numpy as np

from manimlib.constants import BLUE_B, BLUE_D, BLUE_E, GREY_BROWN, WHITE
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.rate_functions import smooth

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, List, Iterable
    from manimlib.typing import ManimColor, Vect3, Self


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.534">class AnimatedBoundary(VGroup):
    @others
</t>
<t tx="ekr.20250121054835.535">def __init__(
    self,
    vmobject: VMobject,
    colors: List[ManimColor] = [BLUE_D, BLUE_B, BLUE_E, GREY_BROWN],
    max_stroke_width: float = 3.0,
    cycle_rate: float = 0.5,
    back_and_forth: bool = True,
    draw_rate_func: Callable[[float], float] = smooth,
    fade_rate_func: Callable[[float], float] = smooth,
    **kwargs
):
    super().__init__(**kwargs)
    self.vmobject: VMobject = vmobject
    self.colors = colors
    self.max_stroke_width = max_stroke_width
    self.cycle_rate = cycle_rate
    self.back_and_forth = back_and_forth
    self.draw_rate_func = draw_rate_func
    self.fade_rate_func = fade_rate_func

    self.boundary_copies: list[VMobject] = [
        vmobject.copy().set_style(
            stroke_width=0,
            fill_opacity=0
        )
        for x in range(2)
    ]
    self.add(*self.boundary_copies)
    self.total_time: float = 0
    self.add_updater(
        lambda m, dt: self.update_boundary_copies(dt)
    )
</t>
<t tx="ekr.20250121054835.536">def update_boundary_copies(self, dt: float) -&gt; Self:
    # Not actual time, but something which passes at
    # an altered rate to make the implementation below
    # cleaner
    time = self.total_time * self.cycle_rate
    growing, fading = self.boundary_copies
    colors = self.colors
    msw = self.max_stroke_width
    vmobject = self.vmobject

    index = int(time % len(colors))
    alpha = time % 1
    draw_alpha = self.draw_rate_func(alpha)
    fade_alpha = self.fade_rate_func(alpha)

    if self.back_and_forth and int(time) % 2 == 1:
        bounds = (1 - draw_alpha, 1)
    else:
        bounds = (0, draw_alpha)
    self.full_family_become_partial(growing, vmobject, *bounds)
    growing.set_stroke(colors[index], width=msw)

    if time &gt;= 1:
        self.full_family_become_partial(fading, vmobject, 0, 1)
        fading.set_stroke(
            color=colors[index - 1],
            width=(1 - fade_alpha) * msw
        )

    self.total_time += dt
    return self
</t>
<t tx="ekr.20250121054835.537">def full_family_become_partial(
    self,
    mob1: VMobject,
    mob2: VMobject,
    a: float,
    b: float
) -&gt; Self:
    family1 = mob1.family_members_with_points()
    family2 = mob2.family_members_with_points()
    for sm1, sm2 in zip(family1, family2):
        sm1.pointwise_become_partial(sm2, a, b)
    return self
</t>
<t tx="ekr.20250121054835.538">class TracedPath(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.539">def __init__(
    self,
    traced_point_func: Callable[[], Vect3],
    time_traced: float = np.inf,
    time_per_anchor: float = 1.0 / 15,
    stroke_width: float | Iterable[float] = 2.0,
    stroke_color: ManimColor = WHITE,
    **kwargs
):
    super().__init__(**kwargs)
    self.traced_point_func = traced_point_func
    self.time_traced = time_traced
    self.time_per_anchor = time_per_anchor
    self.time: float = 0
    self.traced_points: list[np.ndarray] = []
    self.add_updater(lambda m, dt: m.update_path(dt))
    self.always.set_stroke(stroke_color, stroke_width)
</t>
<t tx="ekr.20250121054835.54">from __future__ import annotations

import argparse
import colour
import importlib
import inspect
import os
import sys
import yaml
from pathlib import Path
from ast import literal_eval
from addict import Dict

from manimlib.logger import log
from manimlib.utils.dict_ops import merge_dicts_recursively

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from argparse import Namespace
    from typing import Optional


@others
# Create global configuration
manim_config: Dict = initialize_manim_config()
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.540">def update_path(self, dt: float) -&gt; Self:
    if dt == 0:
        return self
    point = self.traced_point_func().copy()
    self.traced_points.append(point)

    if self.time_traced &lt; np.inf:
        n_relevant_points = int(self.time_traced / dt + 0.5)
        n_tps = len(self.traced_points)
        if n_tps &lt; n_relevant_points:
            points = self.traced_points + [point] * (n_relevant_points - n_tps)
        else:
            points = self.traced_points[n_tps - n_relevant_points:]
        # Every now and then refresh the list
        if n_tps &gt; 10 * n_relevant_points:
            self.traced_points = self.traced_points[-n_relevant_points:]
    else:
        points = self.traced_points

    if points:
        self.set_points_smoothly(points)

    self.time += dt
    return self
</t>
<t tx="ekr.20250121054835.541">class TracingTail(TracedPath):
    @others
    ):
        if isinstance(mobject_or_func, Mobject):
            func = mobject_or_func.get_center
        else:
            func = mobject_or_func
        super().__init__(
            func,
            time_traced=time_traced,
            stroke_width=stroke_width,
            stroke_opacity=stroke_opacity,
            stroke_color=stroke_color,
            **kwargs
        )
        self.add_updater(lambda m: m.set_stroke(width=stroke_width, opacity=stroke_opacity))
</t>
<t tx="ekr.20250121054835.542">def __init__(
    self,
    mobject_or_func: Mobject | Callable[[], np.ndarray],
    time_traced: float = 1.0,
    stroke_width: float | Iterable[float] = (0, 3),
    stroke_opacity: float | Iterable[float] = (0, 1),
    stroke_color: ManimColor = WHITE,
    **kwargs
</t>
<t tx="ekr.20250121054835.543">from __future__ import annotations

from abc import ABC, abstractmethod
import numbers

import numpy as np
import itertools as it

from manimlib.constants import BLACK, BLUE, BLUE_D, BLUE_E, GREEN, GREY_A, WHITE, RED
from manimlib.constants import DEG, PI
from manimlib.constants import DL, UL, DOWN, DR, LEFT, ORIGIN, OUT, RIGHT, UP
from manimlib.constants import FRAME_X_RADIUS, FRAME_Y_RADIUS
from manimlib.constants import MED_SMALL_BUFF, SMALL_BUFF
from manimlib.mobject.functions import ParametricCurve
from manimlib.mobject.geometry import Arrow
from manimlib.mobject.geometry import DashedLine
from manimlib.mobject.geometry import Line
from manimlib.mobject.geometry import Rectangle
from manimlib.mobject.number_line import NumberLine
from manimlib.mobject.svg.tex_mobject import Tex
from manimlib.mobject.types.dot_cloud import DotCloud
from manimlib.mobject.types.surface import ParametricSurface
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.bezier import inverse_interpolate
from manimlib.utils.dict_ops import merge_dicts_recursively
from manimlib.utils.simple_functions import binary_search
from manimlib.utils.space_ops import angle_of_vector
from manimlib.utils.space_ops import get_norm
from manimlib.utils.space_ops import rotate_vector
from manimlib.utils.space_ops import normalize

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, Iterable, Sequence, Type, TypeVar, Optional
    from manimlib.mobject.mobject import Mobject
    from manimlib.typing import ManimColor, Vect3, Vect3Array, VectN, RangeSpecifier, Self

    T = TypeVar("T", bound=Mobject)


EPSILON = 1e-8
DEFAULT_X_RANGE = (-8.0, 8.0, 1.0)
DEFAULT_Y_RANGE = (-4.0, 4.0, 1.0)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.544">def full_range_specifier(range_args):
    if len(range_args) == 2:
        return (*range_args, 1)
    return range_args
</t>
<t tx="ekr.20250121054835.545">class CoordinateSystem(ABC):
    """
    Abstract class for Axes and NumberPlane
    """
    @others
</t>
<t tx="ekr.20250121054835.546">dimension: int = 2

def __init__(
    self,
    x_range: RangeSpecifier = DEFAULT_X_RANGE,
    y_range: RangeSpecifier = DEFAULT_Y_RANGE,
    num_sampled_graph_points_per_tick: int = 5,
):
    self.x_range = full_range_specifier(x_range)
    self.y_range = full_range_specifier(y_range)
    self.num_sampled_graph_points_per_tick = num_sampled_graph_points_per_tick
</t>
<t tx="ekr.20250121054835.547">@abstractmethod
def coords_to_point(self, *coords: float | VectN) -&gt; Vect3 | Vect3Array:
    raise Exception("Not implemented")
</t>
<t tx="ekr.20250121054835.548">@abstractmethod
def point_to_coords(self, point: Vect3 | Vect3Array) -&gt; tuple[float | VectN, ...]:
    raise Exception("Not implemented")
</t>
<t tx="ekr.20250121054835.549">def c2p(self, *coords: float) -&gt; Vect3 | Vect3Array:
    """Abbreviation for coords_to_point"""
    return self.coords_to_point(*coords)
</t>
<t tx="ekr.20250121054835.55">def initialize_manim_config() -&gt; Dict:
    """
    Return default configuration for various classes in manim, such as
    Scene, Window, Camera, and SceneFileWriter, as well as configuration
    determining how the scene is run (e.g. written to file or previewed in window).

    The result is initially on the contents of default_config.yml in the manimlib directory,
    which can be further updated by a custom configuration file custom_config.yml.
    It is further updated based on command line argument.
    """
    args = parse_cli()
    global_defaults_file = os.path.join(get_manim_dir(), "manimlib", "default_config.yml")
    config = Dict(merge_dicts_recursively(
        load_yaml(global_defaults_file),
        load_yaml("custom_config.yml"),  # From current working directory
        load_yaml(args.config_file) if args.config_file else dict(),
    ))

    log.setLevel(args.log_level or config["log_level"])

    update_directory_config(config)
    update_window_config(config, args)
    update_camera_config(config, args)
    update_file_writer_config(config, args)
    update_scene_config(config, args)
    update_run_config(config, args)
    update_embed_config(config, args)

    return config
</t>
<t tx="ekr.20250121054835.550">def p2c(self, point: Vect3) -&gt; tuple[float | VectN, ...]:
    """Abbreviation for point_to_coords"""
    return self.point_to_coords(point)
</t>
<t tx="ekr.20250121054835.551">def get_origin(self) -&gt; Vect3:
    return self.c2p(*[0] * self.dimension)
</t>
<t tx="ekr.20250121054835.552">@abstractmethod
def get_axes(self) -&gt; VGroup:
    raise Exception("Not implemented")
</t>
<t tx="ekr.20250121054835.553">@abstractmethod
def get_all_ranges(self) -&gt; list[np.ndarray]:
    raise Exception("Not implemented")
</t>
<t tx="ekr.20250121054835.554">def get_axis(self, index: int) -&gt; NumberLine:
    return self.get_axes()[index]
</t>
<t tx="ekr.20250121054835.555">def get_x_axis(self) -&gt; NumberLine:
    return self.get_axis(0)
</t>
<t tx="ekr.20250121054835.556">def get_y_axis(self) -&gt; NumberLine:
    return self.get_axis(1)
</t>
<t tx="ekr.20250121054835.557">def get_z_axis(self) -&gt; NumberLine:
    return self.get_axis(2)
</t>
<t tx="ekr.20250121054835.558">def get_x_axis_label(
    self,
    label_tex: str,
    edge: Vect3 = RIGHT,
    direction: Vect3 = DL,
    **kwargs
) -&gt; Tex:
    return self.get_axis_label(
        label_tex, self.get_x_axis(),
        edge, direction, **kwargs
    )
</t>
<t tx="ekr.20250121054835.559">def get_y_axis_label(
    self,
    label_tex: str,
    edge: Vect3 = UP,
    direction: Vect3 = DR,
    **kwargs
) -&gt; Tex:
    return self.get_axis_label(
        label_tex, self.get_y_axis(),
        edge, direction, **kwargs
    )
</t>
<t tx="ekr.20250121054835.56">def parse_cli():
    try:
        parser = argparse.ArgumentParser()
        module_location = parser.add_mutually_exclusive_group()
        module_location.add_argument(
            "file",
            nargs="?",
            help="Path to file holding the python code for the scene",
        )
        parser.add_argument(
            "scene_names",
            nargs="*",
            help="Name of the Scene class you want to see",
        )
        parser.add_argument(
            "-w", "--write_file",
            action="store_true",
            help="Render the scene as a movie file",
        )
        parser.add_argument(
            "-s", "--skip_animations",
            action="store_true",
            help="Save the last frame",
        )
        parser.add_argument(
            "-l", "--low_quality",
            action="store_true",
            help="Render at 480p",
        )
        parser.add_argument(
            "-m", "--medium_quality",
            action="store_true",
            help="Render at 720p",
        )
        parser.add_argument(
            "--hd",
            action="store_true",
            help="Render at a 1080p",
        )
        parser.add_argument(
            "--uhd",
            action="store_true",
            help="Render at a 4k",
        )
        parser.add_argument(
            "-f", "--full_screen",
            action="store_true",
            help="Show window in full screen",
        )
        parser.add_argument(
            "-p", "--presenter_mode",
            action="store_true",
            help="Scene will stay paused during wait calls until " + \
                 "space bar or right arrow is hit, like a slide show"
        )
        parser.add_argument(
            "-i", "--gif",
            action="store_true",
            help="Save the video as gif",
        )
        parser.add_argument(
            "-t", "--transparent",
            action="store_true",
            help="Render to a movie file with an alpha channel",
        )
        parser.add_argument(
            "--vcodec",
            help="Video codec to use with ffmpeg",
        )
        parser.add_argument(
            "--pix_fmt",
            help="Pixel format to use for the output of ffmpeg, defaults to `yuv420p`",
        )
        parser.add_argument(
            "-q", "--quiet",
            action="store_true",
            help="",
        )
        parser.add_argument(
            "-a", "--write_all",
            action="store_true",
            help="Write all the scenes from a file",
        )
        parser.add_argument(
            "-o", "--open",
            action="store_true",
            help="Automatically open the saved file once its done",
        )
        parser.add_argument(
            "--finder",
            action="store_true",
            help="Show the output file in finder",
        )
        parser.add_argument(
            "--subdivide",
            action="store_true",
            help="Divide the output animation into individual movie files " +
                 "for each animation",
        )
        parser.add_argument(
            "--file_name",
            help="Name for the movie or image file",
        )
        parser.add_argument(
            "-n", "--start_at_animation_number",
            help="Start rendering not from the first animation, but " + \
                 "from another, specified by its index.  If you pass " + \
                 "in two comma separated values, e.g. \"3,6\", it will end " + \
                 "the rendering at the second value",
        )
        parser.add_argument(
            "-e", "--embed",
            metavar="LINE_NUMBER",
            help="Adds a breakpoint at the inputted file dropping into an " + \
                 "interactive iPython session at that point of the code."
        )
        parser.add_argument(
            "-r", "--resolution",
            help="Resolution, passed as \"WxH\", e.g. \"1920x1080\"",
        )
        parser.add_argument(
            "--fps",
            help="Frame rate, as an integer",
        )
        parser.add_argument(
            "-c", "--color",
            help="Background color",
        )
        parser.add_argument(
            "--leave_progress_bars",
            action="store_true",
            help="Leave progress bars displayed in terminal",
        )
        parser.add_argument(
            "--show_animation_progress",
            action="store_true",
            help="Show progress bar for each animation",
        )
        parser.add_argument(
            "--prerun",
            action="store_true",
            help="Calculate total framecount, to display in a progress bar, by doing " + \
                 "an initial run of the scene which skips animations."
        )
        parser.add_argument(
            "--video_dir",
            help="Directory to write video",
        )
        parser.add_argument(
            "--config_file",
            help="Path to the custom configuration file",
        )
        parser.add_argument(
            "-v", "--version",
            action="store_true",
            help="Display the version of manimgl"
        )
        parser.add_argument(
            "--log-level",
            help="Level of messages to Display, can be DEBUG / INFO / WARNING / ERROR / CRITICAL"
        )
        parser.add_argument(
            "--clear-cache",
            action="store_true",
            help="Erase the cache used for Tex and Text Mobjects"
        )
        parser.add_argument(
            "--autoreload",
            action="store_true",
            help="Automatically reload Python modules to pick up code changes " +
                 "across different files",
        )
        args = parser.parse_args()
        args.write_file = any([args.write_file, args.open, args.finder])
        return args
    except argparse.ArgumentError as err:
        log.error(str(err))
        sys.exit(2)
</t>
<t tx="ekr.20250121054835.560">def get_axis_label(
    self,
    label_tex: str,
    axis: Vect3,
    edge: Vect3,
    direction: Vect3,
    buff: float = MED_SMALL_BUFF,
    ensure_on_screen: bool = False
) -&gt; Tex:
    label = Tex(label_tex)
    label.next_to(
        axis.get_edge_center(edge), direction,
        buff=buff
    )
    if ensure_on_screen:
        label.shift_onto_screen(buff=MED_SMALL_BUFF)
    return label
</t>
<t tx="ekr.20250121054835.561">def get_axis_labels(
    self,
    x_label_tex: str = "x",
    y_label_tex: str = "y"
) -&gt; VGroup:
    self.axis_labels = VGroup(
        self.get_x_axis_label(x_label_tex),
        self.get_y_axis_label(y_label_tex),
    )
    return self.axis_labels
</t>
<t tx="ekr.20250121054835.562">def get_line_from_axis_to_point(
    self, 
    index: int,
    point: Vect3,
    line_func: Type[T] = DashedLine,
    color: ManimColor = GREY_A,
    stroke_width: float = 2
) -&gt; T:
    axis = self.get_axis(index)
    line = line_func(axis.get_projection(point), point)
    line.set_stroke(color, stroke_width)
    return line
</t>
<t tx="ekr.20250121054835.563">def get_v_line(self, point: Vect3, **kwargs):
    return self.get_line_from_axis_to_point(0, point, **kwargs)
</t>
<t tx="ekr.20250121054835.564">def get_h_line(self, point: Vect3, **kwargs):
    return self.get_line_from_axis_to_point(1, point, **kwargs)
</t>
<t tx="ekr.20250121054835.565"># Useful for graphing
def get_graph(
    self,
    function: Callable[[float], float],
    x_range: Sequence[float] | None = None,
    bind: bool = False,
    **kwargs
) -&gt; ParametricCurve:
    x_range = x_range or self.x_range
    t_range = np.ones(3)
    t_range[:len(x_range)] = x_range
    # For axes, the third coordinate of x_range indicates
    # tick frequency.  But for functions, it indicates a
    # sample frequency
    t_range[2] /= self.num_sampled_graph_points_per_tick

    def parametric_function(t: float) -&gt; Vect3:
        return self.c2p(t, function(t))

    graph = ParametricCurve(
        parametric_function,
        t_range=tuple(t_range),
        **kwargs
    )
    graph.underlying_function = function
    graph.x_range = x_range

    if bind:
        self.bind_graph_to_func(graph, function)

    return graph
</t>
<t tx="ekr.20250121054835.566">def get_parametric_curve(
    self,
    function: Callable[[float], Vect3],
    **kwargs
) -&gt; ParametricCurve:
    dim = self.dimension
    graph = ParametricCurve(
        lambda t: self.coords_to_point(*function(t)[:dim]),
        **kwargs
    )
    graph.underlying_function = function
    return graph
</t>
<t tx="ekr.20250121054835.567">def input_to_graph_point(
    self,
    x: float,
    graph: ParametricCurve
) -&gt; Vect3 | None:
    if hasattr(graph, "underlying_function"):
        return self.coords_to_point(x, graph.underlying_function(x))
    else:
        alpha = binary_search(
            function=lambda a: self.point_to_coords(
                graph.quick_point_from_proportion(a)
            )[0],
            target=x,
            lower_bound=self.x_range[0],
            upper_bound=self.x_range[1],
        )
        if alpha is not None:
            return graph.quick_point_from_proportion(alpha)
        else:
            return None
</t>
<t tx="ekr.20250121054835.568">def i2gp(self, x: float, graph: ParametricCurve) -&gt; Vect3 | None:
    """
    Alias for input_to_graph_point
    """
    return self.input_to_graph_point(x, graph)
</t>
<t tx="ekr.20250121054835.569">def bind_graph_to_func(
    self,
    graph: VMobject,
    func: Callable[[VectN], VectN],
    jagged: bool = False,
    get_discontinuities: Optional[Callable[[], Vect3]] = None
) -&gt; VMobject:
    """
    Use for graphing functions which might change over time, or change with
    conditions
    """
    x_values = np.array([self.x_axis.p2n(p) for p in graph.get_points()])

    def get_graph_points():
        xs = x_values
        if get_discontinuities:
            ds = get_discontinuities()
            ep = 1e-6
            added_xs = it.chain(*((d - ep, d + ep) for d in ds))
            xs[:] = sorted([*x_values, *added_xs])[:len(x_values)]
        return self.c2p(xs, func(xs))

    graph.add_updater(
        lambda g: g.set_points_as_corners(get_graph_points())
    )
    if not jagged:
        graph.add_updater(lambda g: g.make_smooth(approx=True))
    return graph
</t>
<t tx="ekr.20250121054835.57">def update_directory_config(config: Dict):
    dir_config = config.directories
    base = dir_config.base
    for key, subdir in dir_config.subdirs.items():
        dir_config[key] = os.path.join(base, subdir)
</t>
<t tx="ekr.20250121054835.570">def get_graph_label(
    self,
    graph: ParametricCurve,
    label: str | Mobject = "f(x)",
    x: float | None = None,
    direction: Vect3 = RIGHT,
    buff: float = MED_SMALL_BUFF,
    color: ManimColor | None = None
) -&gt; Tex | Mobject:
    if isinstance(label, str):
        label = Tex(label)
    if color is None:
        label.match_color(graph)
    if x is None:
        # Searching from the right, find a point
        # whose y value is in bounds
        max_y = FRAME_Y_RADIUS - label.get_height()
        max_x = FRAME_X_RADIUS - label.get_width()
        for x0 in np.arange(*self.x_range)[::-1]:
            pt = self.i2gp(x0, graph)
            if abs(pt[0]) &lt; max_x and abs(pt[1]) &lt; max_y:
                x = x0
                break
        if x is None:
            x = self.x_range[1]

    point = self.input_to_graph_point(x, graph)
    angle = self.angle_of_tangent(x, graph)
    normal = rotate_vector(RIGHT, angle + 90 * DEG)
    if normal[1] &lt; 0:
        normal *= -1
    label.next_to(point, normal, buff=buff)
    label.shift_onto_screen()
    return label
</t>
<t tx="ekr.20250121054835.571">def get_v_line_to_graph(self, x: float, graph: ParametricCurve, **kwargs):
    return self.get_v_line(self.i2gp(x, graph), **kwargs)
</t>
<t tx="ekr.20250121054835.572">def get_h_line_to_graph(self, x: float, graph: ParametricCurve, **kwargs):
    return self.get_h_line(self.i2gp(x, graph), **kwargs)
</t>
<t tx="ekr.20250121054835.573">def get_scatterplot(self,
                    x_values: Vect3Array,
                    y_values: Vect3Array,
                    **dot_config):
    return DotCloud(self.c2p(x_values, y_values), **dot_config)
</t>
<t tx="ekr.20250121054835.574"># For calculus
def angle_of_tangent(
    self,
    x: float,
    graph: ParametricCurve,
    dx: float = EPSILON
) -&gt; float:
    p0 = self.input_to_graph_point(x, graph)
    p1 = self.input_to_graph_point(x + dx, graph)
    return angle_of_vector(p1 - p0)
</t>
<t tx="ekr.20250121054835.575">def slope_of_tangent(
    self,
    x: float,
    graph: ParametricCurve,
    **kwargs
) -&gt; float:
    return np.tan(self.angle_of_tangent(x, graph, **kwargs))
</t>
<t tx="ekr.20250121054835.576">def get_tangent_line(
    self,
    x: float,
    graph: ParametricCurve,
    length: float = 5,
    line_func: Type[T] = Line
) -&gt; T:
    line = line_func(LEFT, RIGHT)
    line.set_width(length)
    line.rotate(self.angle_of_tangent(x, graph))
    line.move_to(self.input_to_graph_point(x, graph))
    return line
</t>
<t tx="ekr.20250121054835.577">def get_riemann_rectangles(
    self,
    graph: ParametricCurve,
    x_range: Sequence[float] = None,
    dx: float | None = None,
    input_sample_type: str = "left",
    stroke_width: float = 1,
    stroke_color: ManimColor = BLACK,
    fill_opacity: float = 1,
    colors: Iterable[ManimColor] = (BLUE, GREEN),
    negative_color: ManimColor = RED,
    stroke_background: bool = True,
    show_signed_area: bool = True
</t>
<t tx="ekr.20250121054835.578">) -&gt; VGroup:
    if x_range is None:
        x_range = self.x_range[:2]
    if dx is None:
        dx = self.x_range[2]
    if len(x_range) &lt; 3:
        x_range = [*x_range, dx]

    rects = []
    x_range[1] = x_range[1] + dx
    xs = np.arange(*x_range)
    for x0, x1 in zip(xs, xs[1:]):
        if input_sample_type == "left":
            sample = x0
        elif input_sample_type == "right":
            sample = x1
        elif input_sample_type == "center":
            sample = 0.5 * x0 + 0.5 * x1
        else:
            raise Exception("Invalid input sample type")
        height_vect = self.i2gp(sample, graph) - self.c2p(sample, 0)
        rect = Rectangle(
            width=self.x_axis.n2p(x1)[0] - self.x_axis.n2p(x0)[0],
            height=get_norm(height_vect),
        )
        rect.positive = height_vect[1] &gt; 0
        rect.move_to(self.c2p(x0, 0), DL if rect.positive else UL)
        rects.append(rect)
    result = VGroup(*rects)
    result.set_submobject_colors_by_gradient(*colors)
    result.set_style(
        stroke_width=stroke_width,
        stroke_color=stroke_color,
        fill_opacity=fill_opacity,
        stroke_behind=stroke_background
    )
    for rect in result:
        if not rect.positive:
            rect.set_fill(negative_color)
    return result

def get_area_under_graph(self, graph, x_range, fill_color=BLUE, fill_opacity=0.5):
    if not hasattr(graph, "x_range"):
        raise Exception("Argument `graph` must have attribute `x_range`")

    alpha_bounds = [
        inverse_interpolate(*graph.x_range, x)
        for x in x_range
    ]
    sub_graph = graph.copy()
    sub_graph.pointwise_become_partial(graph, *alpha_bounds)
    sub_graph.add_line_to(self.c2p(x_range[1], 0))
    sub_graph.add_line_to(self.c2p(x_range[0], 0))
    sub_graph.add_line_to(sub_graph.get_start())

    sub_graph.set_stroke(width=0)
    sub_graph.set_fill(fill_color, fill_opacity)

    return sub_graph
</t>
<t tx="ekr.20250121054835.579">class Axes(VGroup, CoordinateSystem):
    @others
</t>
<t tx="ekr.20250121054835.58">def update_window_config(config: Dict, args: Namespace):
    window_config = config.window
    for key in "position", "size":
        if window_config.get(key):
            window_config[key] = literal_eval(window_config[key])
    if args.full_screen:
        window_config.full_screen = True
</t>
<t tx="ekr.20250121054835.580">default_axis_config: dict = dict()
default_x_axis_config: dict = dict()
default_y_axis_config: dict = dict(line_to_number_direction=LEFT)

def __init__(
    self,
    x_range: RangeSpecifier = DEFAULT_X_RANGE,
    y_range: RangeSpecifier = DEFAULT_Y_RANGE,
    axis_config: dict = dict(),
    x_axis_config: dict = dict(),
    y_axis_config: dict = dict(),
    height: float | None = None,
    width: float | None = None,
    unit_size: float = 1.0,
    **kwargs
</t>
<t tx="ekr.20250121054835.581">):
    CoordinateSystem.__init__(self, x_range, y_range, **kwargs)
    kwargs.pop("num_sampled_graph_points_per_tick", None)
    VGroup.__init__(self, **kwargs)

    axis_config = dict(**axis_config, unit_size=unit_size)
    self.x_axis = self.create_axis(
        self.x_range,
        axis_config=merge_dicts_recursively(
            self.default_axis_config,
            self.default_x_axis_config,
            axis_config,
            x_axis_config
        ),
        length=width,
    )
    self.y_axis = self.create_axis(
        self.y_range,
        axis_config=merge_dicts_recursively(
            self.default_axis_config,
            self.default_y_axis_config,
            axis_config,
            y_axis_config
        ),
        length=height,
    )
    self.y_axis.rotate(90 * DEG, about_point=ORIGIN)
    # Add as a separate group in case various other
    # mobjects are added to self, as for example in
    # NumberPlane below
    self.axes = VGroup(self.x_axis, self.y_axis)
    self.add(*self.axes)
    self.center()

def create_axis(
    self,
    range_terms: RangeSpecifier,
    axis_config: dict,
    length: float | None
) -&gt; NumberLine:
    axis = NumberLine(range_terms, width=length, **axis_config)
    axis.shift(-axis.n2p(0))
    return axis
</t>
<t tx="ekr.20250121054835.582">def coords_to_point(self, *coords: float | VectN) -&gt; Vect3 | Vect3Array:
    origin = self.x_axis.number_to_point(0)
    return origin + sum(
        axis.number_to_point(coord) - origin
        for axis, coord in zip(self.get_axes(), coords)
    )
</t>
<t tx="ekr.20250121054835.583">def point_to_coords(self, point: Vect3 | Vect3Array) -&gt; tuple[float | VectN, ...]:
    return tuple([
        axis.point_to_number(point)
        for axis in self.get_axes()
    ])
</t>
<t tx="ekr.20250121054835.584">def get_axes(self) -&gt; VGroup:
    return self.axes
</t>
<t tx="ekr.20250121054835.585">def get_all_ranges(self) -&gt; list[Sequence[float]]:
    return [self.x_range, self.y_range]
</t>
<t tx="ekr.20250121054835.586">def add_coordinate_labels(
    self,
    x_values: Iterable[float] | None = None,
    y_values: Iterable[float] | None = None,
    excluding: Iterable[float] = [0],
    **kwargs
) -&gt; VGroup:
    axes = self.get_axes()
    self.coordinate_labels = VGroup()
    for axis, values in zip(axes, [x_values, y_values]):
        labels = axis.add_numbers(values, excluding=excluding, **kwargs)
        self.coordinate_labels.add(labels)
    return self.coordinate_labels
</t>
<t tx="ekr.20250121054835.587">class ThreeDAxes(Axes):
    @others
</t>
<t tx="ekr.20250121054835.588">dimension: int = 3
default_z_axis_config: dict = dict()

def __init__(
    self,
    x_range: RangeSpecifier = (-6.0, 6.0, 1.0),
    y_range: RangeSpecifier = (-5.0, 5.0, 1.0),
    z_range: RangeSpecifier = (-4.0, 4.0, 1.0),
    z_axis_config: dict = dict(),
    z_normal: Vect3 = DOWN,
    depth: float | None = None,
    **kwargs
</t>
<t tx="ekr.20250121054835.589">):
    Axes.__init__(self, x_range, y_range, **kwargs)

    self.z_range = full_range_specifier(z_range)
    self.z_axis = self.create_axis(
        self.z_range,
        axis_config=merge_dicts_recursively(
            self.default_axis_config,
            self.default_z_axis_config,
            kwargs.get("axis_config", {}),
            z_axis_config
        ),
        length=depth,
    )
    self.z_axis.rotate(-PI / 2, UP, about_point=ORIGIN)
    self.z_axis.rotate(
        angle_of_vector(z_normal), OUT,
        about_point=ORIGIN
    )
    self.z_axis.shift(self.x_axis.n2p(0))
    self.axes.add(self.z_axis)
    self.add(self.z_axis)

def get_all_ranges(self) -&gt; list[Sequence[float]]:
    return [self.x_range, self.y_range, self.z_range]
</t>
<t tx="ekr.20250121054835.59">def update_camera_config(config: Dict, args: Namespace):
    camera_config = config.camera
    arg_resolution = get_resolution_from_args(args, config.resolution_options)
    camera_config.resolution = arg_resolution or literal_eval(camera_config.resolution)
    if args.fps:
        camera_config.fps = args.fps
    if args.color:
        try:
            camera_config.background_color = colour.Color(args.color)
        except Exception:
            log.error("Please use a valid color")
            log.error(err)
            sys.exit(2)
    if args.transparent:
        camera_config.background_opacity = 0.0
</t>
<t tx="ekr.20250121054835.590">def add_axis_labels(self, x_tex="x", y_tex="y", z_tex="z", font_size=24, buff=0.2):
    x_label, y_label, z_label = labels = VGroup(*(
        Tex(tex, font_size=font_size)
        for tex in [x_tex, y_tex, z_tex]
    ))
    z_label.rotate(PI / 2, RIGHT)
    for label, axis in zip(labels, self):
        label.next_to(axis, normalize(np.round(axis.get_vector()), 2), buff=buff)
        axis.add(label)
    self.axis_labels = labels
</t>
<t tx="ekr.20250121054835.591">def get_graph(
    self,
    func,
    color=BLUE_E,
    opacity=0.9,
    u_range=None,
    v_range=None,
    **kwargs
) -&gt; ParametricSurface:
    xu = self.x_axis.get_unit_size()
    yu = self.y_axis.get_unit_size()
    zu = self.z_axis.get_unit_size()
    x0, y0, z0 = self.get_origin()
    u_range = u_range or self.x_range[:2]
    v_range = v_range or self.y_range[:2]
    return ParametricSurface(
        lambda u, v: [xu * u + x0, yu * v + y0, zu * func(u, v) + z0],
        u_range=u_range,
        v_range=v_range,
        color=color,
        opacity=opacity,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.592">def get_parametric_surface(
    self,
    func,
    color=BLUE_E,
    opacity=0.9,
    **kwargs
) -&gt; ParametricSurface:
    surface = ParametricSurface(func, color=color, opacity=opacity, **kwargs)
    axes = [self.x_axis, self.y_axis, self.z_axis]
    for dim, axis in zip(range(3), axes):
        surface.stretch(axis.get_unit_size(), dim, about_point=ORIGIN)
    surface.shift(self.get_origin())
    return surface
</t>
<t tx="ekr.20250121054835.593">class NumberPlane(Axes):
    @others
</t>
<t tx="ekr.20250121054835.594">default_axis_config: dict = dict(
    stroke_color=WHITE,
    stroke_width=2,
    include_ticks=False,
    include_tip=False,
    line_to_number_buff=SMALL_BUFF,
    line_to_number_direction=DL,
)
default_y_axis_config: dict = dict(
    line_to_number_direction=DL,
)

def __init__(
    self,
    x_range: RangeSpecifier = (-8.0, 8.0, 1.0),
    y_range: RangeSpecifier = (-4.0, 4.0, 1.0),
    background_line_style: dict = dict(
        stroke_color=BLUE_D,
        stroke_width=2,
        stroke_opacity=1,
    ),
    # Defaults to a faded version of line_config
    faded_line_style: dict = dict(),
    faded_line_ratio: int = 4,
    make_smooth_after_applying_functions: bool = True,
    **kwargs
</t>
<t tx="ekr.20250121054835.595">):
    super().__init__(x_range, y_range, **kwargs)
    self.background_line_style = dict(background_line_style)
    self.faded_line_style = dict(faded_line_style)
    self.faded_line_ratio = faded_line_ratio
    self.make_smooth_after_applying_functions = make_smooth_after_applying_functions
    self.init_background_lines()

def init_background_lines(self) -&gt; None:
    if not self.faded_line_style:
        style = dict(self.background_line_style)
        # For anything numerical, like stroke_width
        # and stroke_opacity, chop it in half
        for key in style:
            if isinstance(style[key], numbers.Number):
                style[key] *= 0.5
        self.faded_line_style = style

    self.background_lines, self.faded_lines = self.get_lines()
    self.background_lines.set_style(**self.background_line_style)
    self.faded_lines.set_style(**self.faded_line_style)
    self.add_to_back(
        self.faded_lines,
        self.background_lines,
    )
</t>
<t tx="ekr.20250121054835.596">def get_lines(self) -&gt; tuple[VGroup, VGroup]:
    x_axis = self.get_x_axis()
    y_axis = self.get_y_axis()

    x_lines1, x_lines2 = self.get_lines_parallel_to_axis(x_axis, y_axis)
    y_lines1, y_lines2 = self.get_lines_parallel_to_axis(y_axis, x_axis)
    lines1 = VGroup(*x_lines1, *y_lines1)
    lines2 = VGroup(*x_lines2, *y_lines2)
    return lines1, lines2
</t>
<t tx="ekr.20250121054835.597">def get_lines_parallel_to_axis(
    self,
    axis1: NumberLine,
    axis2: NumberLine
) -&gt; tuple[VGroup, VGroup]:
    freq = axis2.x_step
    ratio = self.faded_line_ratio
    line = Line(axis1.get_start(), axis1.get_end())
    dense_freq = (1 + ratio)
    step = (1 / dense_freq) * freq

    lines1 = VGroup()
    lines2 = VGroup()
    inputs = np.arange(axis2.x_min, axis2.x_max + step, step)
    for i, x in enumerate(inputs):
        if abs(x) &lt; 1e-8:
            continue
        new_line = line.copy()
        new_line.shift(axis2.n2p(x) - axis2.n2p(0))
        if i % (1 + ratio) == 0:
            lines1.add(new_line)
        else:
            lines2.add(new_line)
    return lines1, lines2
</t>
<t tx="ekr.20250121054835.598">def get_x_unit_size(self) -&gt; float:
    return self.get_x_axis().get_unit_size()
</t>
<t tx="ekr.20250121054835.599">def get_y_unit_size(self) -&gt; list:
    return self.get_x_axis().get_unit_size()
</t>
<t tx="ekr.20250121054835.6">def construct(self):
    grid = Tex(R"\pi").get_grid(10, 10, height=4)
    self.add(grid)

    # You can animate the application of mobject methods with the
    # ".animate" syntax:
    self.play(grid.animate.shift(LEFT))

    # Both of those will interpolate between the mobject's initial
    # state and whatever happens when you apply that method.
    # For this example, calling grid.shift(LEFT) would shift the
    # grid one unit to the left, but both of the previous calls to
    # "self.play" animate that motion.

    # The same applies for any method, including those setting colors.
    self.play(grid.animate.set_color(YELLOW))
    self.wait()
    self.play(grid.animate.set_submobject_colors_by_gradient(BLUE, GREEN))
    self.wait()
    self.play(grid.animate.set_height(TAU - MED_SMALL_BUFF))
    self.wait()

    # The method Mobject.apply_complex_function lets you apply arbitrary
    # complex functions, treating the points defining the mobject as
    # complex numbers.
    self.play(grid.animate.apply_complex_function(np.exp), run_time=5)
    self.wait()

    # Even more generally, you could apply Mobject.apply_function,
    # which takes in functions form R^3 to R^3
    self.play(
        grid.animate.apply_function(
            lambda p: [
                p[0] + 0.5 * math.sin(p[1]),
                p[1] + 0.5 * math.sin(p[0]),
                p[2]
            ]
        ),
        run_time=5,
    )
    self.wait()
</t>
<t tx="ekr.20250121054835.60">def update_file_writer_config(config: Dict, args: Namespace):
    file_writer_config = config.file_writer
    file_writer_config.update(
        write_to_movie=(not args.skip_animations and args.write_file),
        subdivide_output=args.subdivide,
        save_last_frame=(args.skip_animations and args.write_file),
        png_mode=("RGBA" if args.transparent else "RGB"),
        movie_file_extension=(get_file_ext(args)),
        output_directory=get_output_directory(args, config),
        file_name=args.file_name,
        open_file_upon_completion=args.open,
        show_file_location_upon_completion=args.finder,
        quiet=args.quiet,
    )

    if args.vcodec:
        file_writer_config.video_codec = args.vcodec
    elif args.transparent:
        file_writer_config.video_codec = 'prores_ks'
        file_writer_config.pixel_format = ''
    elif args.gif:
        file_writer_config.video_codec = ''

    if args.pix_fmt:
        file_writer_config.pixel_format = args.pix_fmt
</t>
<t tx="ekr.20250121054835.600">def get_axes(self) -&gt; VGroup:
    return self.axes
</t>
<t tx="ekr.20250121054835.601">def get_vector(self, coords: Iterable[float], **kwargs) -&gt; Arrow:
    kwargs["buff"] = 0
    return Arrow(self.c2p(0, 0), self.c2p(*coords), **kwargs)
</t>
<t tx="ekr.20250121054835.602">def prepare_for_nonlinear_transform(self, num_inserted_curves: int = 50) -&gt; Self:
    for mob in self.family_members_with_points():
        num_curves = mob.get_num_curves()
        if num_inserted_curves &gt; num_curves:
            mob.insert_n_curves(num_inserted_curves - num_curves)
        mob.make_smooth_after_applying_functions = True
    return self
</t>
<t tx="ekr.20250121054835.603">class ComplexPlane(NumberPlane):
    @others
</t>
<t tx="ekr.20250121054835.604">def number_to_point(self, number: complex | float) -&gt; Vect3:
    number = complex(number)
    return self.coords_to_point(number.real, number.imag)
</t>
<t tx="ekr.20250121054835.605">def n2p(self, number: complex | float) -&gt; Vect3:
    return self.number_to_point(number)
</t>
<t tx="ekr.20250121054835.606">def point_to_number(self, point: Vect3) -&gt; complex:
    x, y = self.point_to_coords(point)
    return complex(x, y)
</t>
<t tx="ekr.20250121054835.607">def p2n(self, point: Vect3) -&gt; complex:
    return self.point_to_number(point)
</t>
<t tx="ekr.20250121054835.608">def get_default_coordinate_values(
    self,
    skip_first: bool = True
) -&gt; list[complex]:
    x_numbers = self.get_x_axis().get_tick_range()[1:]
    y_numbers = self.get_y_axis().get_tick_range()[1:]
    y_numbers = [complex(0, y) for y in y_numbers if y != 0]
    return [*x_numbers, *y_numbers]
</t>
<t tx="ekr.20250121054835.609">def add_coordinate_labels(
    self,
    numbers: list[complex] | None = None,
    skip_first: bool = True,
    font_size: int = 36,
    **kwargs
) -&gt; Self:
    if numbers is None:
        numbers = self.get_default_coordinate_values(skip_first)

    self.coordinate_labels = VGroup()
    for number in numbers:
        z = complex(number)
        if abs(z.imag) &gt; abs(z.real):
            axis = self.get_y_axis()
            value = z.imag
            kwargs["unit_tex"] = "i"
        else:
            axis = self.get_x_axis()
            value = z.real
        number_mob = axis.get_number_mobject(value, font_size=font_size, **kwargs)
        # For -i, remove the "1"
        if z.imag == -1:
            number_mob.remove(number_mob[1])
            number_mob[0].next_to(
                number_mob[1], LEFT,
                buff=number_mob[0].get_width() / 4
            )
        self.coordinate_labels.add(number_mob)
    self.add(self.coordinate_labels)
    return self
</t>
<t tx="ekr.20250121054835.61">def update_scene_config(config: Dict, args: Namespace):
    scene_config = config.scene
    start, end = get_animations_numbers(args)
    scene_config.update(
        # Note, Scene.__init__ makes use of both manimlib.camera and
        # manimlib.file_writer below, so the arguments here are just for
        # any future specifications beyond what the global configuration holds
        camera_config=dict(),
        file_writer_config=dict(),
        skip_animations=args.skip_animations,
        start_at_animation_number=start,
        end_at_animation_number=end,
        presenter_mode=args.presenter_mode,
    )
    if args.leave_progress_bars:
        scene_config.leave_progress_bars = True
    if args.show_animation_progress:
        scene_config.show_animation_progress = True
</t>
<t tx="ekr.20250121054835.610">from __future__ import annotations

from manimlib.constants import BLACK, GREY_E
from manimlib.constants import FRAME_HEIGHT
from manimlib.mobject.geometry import Rectangle

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from manimlib.typing import ManimColor


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.611">class ScreenRectangle(Rectangle):
    @others
</t>
<t tx="ekr.20250121054835.612">def __init__(
    self,
    aspect_ratio: float = 16.0 / 9.0,
    height: float = 4,
    **kwargs
):
    super().__init__(
        width=aspect_ratio * height,
        height=height,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.613">class FullScreenRectangle(ScreenRectangle):
    @others
</t>
<t tx="ekr.20250121054835.614">def __init__(
    self,
    height: float = FRAME_HEIGHT,
    fill_color: ManimColor = GREY_E,
    fill_opacity: float = 1,
    stroke_width: float = 0,
    **kwargs,
):
    super().__init__(
        height=height,
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.615">class FullScreenFadeRectangle(FullScreenRectangle):
    @others
</t>
<t tx="ekr.20250121054835.616">def __init__(
    self,
    stroke_width: float = 0.0,
    fill_color: ManimColor = BLACK,
    fill_opacity: float = 0.7,
    **kwargs,
):
    super().__init__(
        stroke_width=stroke_width,
        fill_color=fill_color,
        fill_opacity=fill_opacity,
    )
</t>
<t tx="ekr.20250121054835.617">from __future__ import annotations

from isosurfaces import plot_isoline
import numpy as np

from manimlib.constants import FRAME_X_RADIUS, FRAME_Y_RADIUS
from manimlib.constants import YELLOW
from manimlib.mobject.types.vectorized_mobject import VMobject

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable, Sequence, Tuple
    from manimlib.typing import ManimColor, Vect3


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.618">class ParametricCurve(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.619">def __init__(
    self,
    t_func: Callable[[float], Sequence[float] | Vect3],
    t_range: Tuple[float, float, float] = (0, 1, 0.1),
    epsilon: float = 1e-8,
    # TODO, automatically figure out discontinuities
    discontinuities: Sequence[float] = [],
    use_smoothing: bool = True,
    **kwargs
</t>
<t tx="ekr.20250121054835.62">def update_run_config(config: Dict, args: Namespace):
    config.run = Dict(
        file_name=args.file,
        embed_line=(int(args.embed) if args.embed is not None else None),
        is_reload=False,
        prerun=args.prerun,
        scene_names=args.scene_names,
        quiet=args.quiet or args.write_all,
        write_all=args.write_all,
        show_in_window=not args.write_file
    )
</t>
<t tx="ekr.20250121054835.620">):
    self.t_func = t_func
    self.t_range = t_range
    self.epsilon = epsilon
    self.discontinuities = discontinuities
    self.use_smoothing = use_smoothing
    super().__init__(**kwargs)

def get_point_from_function(self, t: float) -&gt; Vect3:
    return np.array(self.t_func(t))
</t>
<t tx="ekr.20250121054835.621">def init_points(self):
    t_min, t_max, step = self.t_range

    jumps = np.array(self.discontinuities)
    jumps = jumps[(jumps &gt; t_min) &amp; (jumps &lt; t_max)]
    boundary_times = [t_min, t_max, *(jumps - self.epsilon), *(jumps + self.epsilon)]
    boundary_times.sort()
    for t1, t2 in zip(boundary_times[0::2], boundary_times[1::2]):
        t_range = [*np.arange(t1, t2, step), t2]
        points = np.array([self.t_func(t) for t in t_range])
        self.start_new_path(points[0])
        self.add_points_as_corners(points[1:])
    if self.use_smoothing:
        self.make_smooth(approx=True)
    if not self.has_points():
        self.set_points(np.array([self.t_func(t_min)]))
    return self
</t>
<t tx="ekr.20250121054835.622">def get_t_func(self):
    return self.t_func
</t>
<t tx="ekr.20250121054835.623">def get_function(self):
    if hasattr(self, "underlying_function"):
        return self.underlying_function
    if hasattr(self, "function"):
        return self.function
</t>
<t tx="ekr.20250121054835.624">def get_x_range(self):
    if hasattr(self, "x_range"):
        return self.x_range
</t>
<t tx="ekr.20250121054835.625">class FunctionGraph(ParametricCurve):
    @others
        super().__init__(parametric_function, self.x_range, **kwargs)
</t>
<t tx="ekr.20250121054835.626">def __init__(
    self,
    function: Callable[[float], float],
    x_range: Tuple[float, float, float] = (-8, 8, 0.25),
    color: ManimColor = YELLOW,
    **kwargs
</t>
<t tx="ekr.20250121054835.627">):
    self.function = function
    self.x_range = x_range

    def parametric_function(t):
        return [t, function(t), 0]
</t>
<t tx="ekr.20250121054835.628">class ImplicitFunction(VMobject):
    @others
    ):
        super().__init__(joint_type=joint_type, **kwargs)

        p_min, p_max = (
            np.array([x_range[0], y_range[0]]),
            np.array([x_range[1], y_range[1]]),
        )
        curves = plot_isoline(
            fn=lambda u: func(u[0], u[1]),
            pmin=p_min,
            pmax=p_max,
            min_depth=min_depth,
            max_quads=max_quads,
        )  # returns a list of lists of 2D points
        curves = [
            np.pad(curve, [(0, 0), (0, 1)])
            for curve in curves
            if curve != []
        ]  # add z coord as 0
        for curve in curves:
            self.start_new_path(curve[0])
            self.add_points_as_corners(curve[1:])
        if use_smoothing:
            self.make_smooth()
</t>
<t tx="ekr.20250121054835.629">def __init__(
    self,
    func: Callable[[float, float], float],
    x_range: Tuple[float, float] = (-FRAME_X_RADIUS, FRAME_X_RADIUS),
    y_range: Tuple[float, float] = (-FRAME_Y_RADIUS, FRAME_Y_RADIUS),
    min_depth: int = 5,
    max_quads: int = 1500,
    use_smoothing: bool = False,
    joint_type: str = 'no_joint',
    **kwargs
</t>
<t tx="ekr.20250121054835.63">def update_embed_config(config: Dict, args: Namespace):
    if args.autoreload:
        config.embed.autoreload = True
</t>
<t tx="ekr.20250121054835.630">from __future__ import annotations

import math

import numpy as np

from manimlib.constants import DL, DOWN, DR, LEFT, ORIGIN, OUT, RIGHT, UL, UP, UR
from manimlib.constants import GREY_A, RED, WHITE, BLACK
from manimlib.constants import MED_SMALL_BUFF, SMALL_BUFF
from manimlib.constants import DEG, PI, TAU
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.types.vectorized_mobject import DashedVMobject
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject
from manimlib.utils.bezier import quadratic_bezier_points_for_arc
from manimlib.utils.iterables import adjacent_n_tuples
from manimlib.utils.iterables import adjacent_pairs
from manimlib.utils.simple_functions import clip
from manimlib.utils.simple_functions import fdiv
from manimlib.utils.space_ops import angle_between_vectors
from manimlib.utils.space_ops import angle_of_vector
from manimlib.utils.space_ops import cross2d
from manimlib.utils.space_ops import compass_directions
from manimlib.utils.space_ops import find_intersection
from manimlib.utils.space_ops import get_norm
from manimlib.utils.space_ops import normalize
from manimlib.utils.space_ops import rotate_vector
from manimlib.utils.space_ops import rotation_matrix_transpose
from manimlib.utils.space_ops import rotation_between_vectors

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Iterable, Optional
    from manimlib.typing import ManimColor, Vect3, Vect3Array, Self


DEFAULT_DOT_RADIUS = 0.08
DEFAULT_SMALL_DOT_RADIUS = 0.04
DEFAULT_DASH_LENGTH = 0.05
DEFAULT_ARROW_TIP_LENGTH = 0.35
DEFAULT_ARROW_TIP_WIDTH = 0.35


# Deprecate?
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.631">class TipableVMobject(VMobject):
    """
    Meant for shared functionality between Arc and Line.
    Functionality can be classified broadly into these groups:
    
        * Adding, Creating, Modifying tips
            - add_tip calls create_tip, before pushing the new tip
                into the TipableVMobject's list of submobjects
            - stylistic and positional configuration
    
        * Checking for tips
            - Boolean checks for whether the TipableVMobject has a tip
                and a starting tip
    
        * Getters
            - Straightforward accessors, returning information pertaining
                to the TipableVMobject instance's tip(s), its length etc
    """
    @others
</t>
<t tx="ekr.20250121054835.632">tip_config: dict = dict(
    fill_opacity=1.0,
    stroke_width=0.0,
    tip_style=0.0,  # triangle=0, inner_smooth=1, dot=2
)

# Adding, Creating, Modifying tips
def add_tip(self, at_start: bool = False, **kwargs) -&gt; Self:
    """
    Adds a tip to the TipableVMobject instance, recognising
    that the endpoints might need to be switched if it's
    a 'starting tip' or not.
    """
    tip = self.create_tip(at_start, **kwargs)
    self.reset_endpoints_based_on_tip(tip, at_start)
    self.asign_tip_attr(tip, at_start)
    tip.set_color(self.get_stroke_color())
    self.add(tip)
    return self
</t>
<t tx="ekr.20250121054835.633">def create_tip(self, at_start: bool = False, **kwargs) -&gt; ArrowTip:
    """
    Stylises the tip, positions it spacially, and returns
    the newly instantiated tip to the caller.
    """
    tip = self.get_unpositioned_tip(**kwargs)
    self.position_tip(tip, at_start)
    return tip
</t>
<t tx="ekr.20250121054835.634">def get_unpositioned_tip(self, **kwargs) -&gt; ArrowTip:
    """
    Returns a tip that has been stylistically configured,
    but has not yet been given a position in space.
    """
    config = dict()
    config.update(self.tip_config)
    config.update(kwargs)
    return ArrowTip(**config)
</t>
<t tx="ekr.20250121054835.635">def position_tip(self, tip: ArrowTip, at_start: bool = False) -&gt; ArrowTip:
    # Last two control points, defining both
    # the end, and the tangency direction
    if at_start:
        anchor = self.get_start()
        handle = self.get_first_handle()
    else:
        handle = self.get_last_handle()
        anchor = self.get_end()
    tip.rotate(angle_of_vector(handle - anchor) - PI - tip.get_angle())
    tip.shift(anchor - tip.get_tip_point())
    return tip
</t>
<t tx="ekr.20250121054835.636">def reset_endpoints_based_on_tip(self, tip: ArrowTip, at_start: bool) -&gt; Self:
    if self.get_length() == 0:
        # Zero length, put_start_and_end_on wouldn't
        # work
        return self

    if at_start:
        start = tip.get_base()
        end = self.get_end()
    else:
        start = self.get_start()
        end = tip.get_base()
    self.put_start_and_end_on(start, end)
    return self
</t>
<t tx="ekr.20250121054835.637">def asign_tip_attr(self, tip: ArrowTip, at_start: bool) -&gt; Self:
    if at_start:
        self.start_tip = tip
    else:
        self.tip = tip
    return self
</t>
<t tx="ekr.20250121054835.638"># Checking for tips
def has_tip(self) -&gt; bool:
    return hasattr(self, "tip") and self.tip in self
</t>
<t tx="ekr.20250121054835.639">def has_start_tip(self) -&gt; bool:
    return hasattr(self, "start_tip") and self.start_tip in self
</t>
<t tx="ekr.20250121054835.64"># Helpers for the functions above


def load_yaml(file_path: str):
    try:
        with open(file_path, "r") as file:
            return yaml.safe_load(file) or {}
    except FileNotFoundError:
        return {}
</t>
<t tx="ekr.20250121054835.640"># Getters
def pop_tips(self) -&gt; VGroup:
    start, end = self.get_start_and_end()
    result = VGroup()
    if self.has_tip():
        result.add(self.tip)
        self.remove(self.tip)
    if self.has_start_tip():
        result.add(self.start_tip)
        self.remove(self.start_tip)
    self.put_start_and_end_on(start, end)
    return result
</t>
<t tx="ekr.20250121054835.641">def get_tips(self) -&gt; VGroup:
    """
    Returns a VGroup (collection of VMobjects) containing
    the TipableVMObject instance's tips.
    """
    result = VGroup()
    if hasattr(self, "tip"):
        result.add(self.tip)
    if hasattr(self, "start_tip"):
        result.add(self.start_tip)
    return result
</t>
<t tx="ekr.20250121054835.642">def get_tip(self) -&gt; ArrowTip:
    """Returns the TipableVMobject instance's (first) tip,
    otherwise throws an exception."""
    tips = self.get_tips()
    if len(tips) == 0:
        raise Exception("tip not found")
    else:
        return tips[0]
</t>
<t tx="ekr.20250121054835.643">def get_default_tip_length(self) -&gt; float:
    return self.tip_length
</t>
<t tx="ekr.20250121054835.644">def get_first_handle(self) -&gt; Vect3:
    return self.get_points()[1]
</t>
<t tx="ekr.20250121054835.645">def get_last_handle(self) -&gt; Vect3:
    return self.get_points()[-2]
</t>
<t tx="ekr.20250121054835.646">def get_end(self) -&gt; Vect3:
    if self.has_tip():
        return self.tip.get_start()
    else:
        return VMobject.get_end(self)
</t>
<t tx="ekr.20250121054835.647">def get_start(self) -&gt; Vect3:
    if self.has_start_tip():
        return self.start_tip.get_start()
    else:
        return VMobject.get_start(self)
</t>
<t tx="ekr.20250121054835.648">def get_length(self) -&gt; float:
    start, end = self.get_start_and_end()
    return get_norm(start - end)
</t>
<t tx="ekr.20250121054835.649">class Arc(TipableVMobject):
    @others
</t>
<t tx="ekr.20250121054835.65">def get_manim_dir():
    manimlib_module = importlib.import_module("manimlib")
    manimlib_dir = os.path.dirname(inspect.getabsfile(manimlib_module))
    return os.path.abspath(os.path.join(manimlib_dir, ".."))
</t>
<t tx="ekr.20250121054835.650">def __init__(
    self,
    start_angle: float = 0,
    angle: float = TAU / 4,
    radius: float = 1.0,
    n_components: int = 8,
    arc_center: Vect3 = ORIGIN,
    **kwargs
):
    super().__init__(**kwargs)

    self.set_points(quadratic_bezier_points_for_arc(angle, n_components))
    self.rotate(start_angle, about_point=ORIGIN)
    self.scale(radius, about_point=ORIGIN)
    self.shift(arc_center)
</t>
<t tx="ekr.20250121054835.651">def get_arc_center(self) -&gt; Vect3:
    """
    Looks at the normals to the first two
    anchors, and finds their intersection points
    """
    # First two anchors and handles
    a1, h, a2 = self.get_points()[:3]
    # Tangent vectors
    t1 = h - a1
    t2 = h - a2
    # Normals
    n1 = rotate_vector(t1, TAU / 4)
    n2 = rotate_vector(t2, TAU / 4)
    return find_intersection(a1, n1, a2, n2)
</t>
<t tx="ekr.20250121054835.652">def get_start_angle(self) -&gt; float:
    angle = angle_of_vector(self.get_start() - self.get_arc_center())
    return angle % TAU
</t>
<t tx="ekr.20250121054835.653">def get_stop_angle(self) -&gt; float:
    angle = angle_of_vector(self.get_end() - self.get_arc_center())
    return angle % TAU
</t>
<t tx="ekr.20250121054835.654">def move_arc_center_to(self, point: Vect3) -&gt; Self:
    self.shift(point - self.get_arc_center())
    return self
</t>
<t tx="ekr.20250121054835.655">class ArcBetweenPoints(Arc):
    @others
</t>
<t tx="ekr.20250121054835.656">def __init__(
    self,
    start: Vect3,
    end: Vect3,
    angle: float = TAU / 4,
    **kwargs
):
    super().__init__(angle=angle, **kwargs)
    if angle == 0:
        self.set_points_as_corners([LEFT, RIGHT])
    self.put_start_and_end_on(start, end)
</t>
<t tx="ekr.20250121054835.657">class CurvedArrow(ArcBetweenPoints):
    @others
</t>
<t tx="ekr.20250121054835.658">def __init__(
    self,
    start_point: Vect3,
    end_point: Vect3,
    **kwargs
):
    super().__init__(start_point, end_point, **kwargs)
    self.add_tip()
</t>
<t tx="ekr.20250121054835.659">class CurvedDoubleArrow(CurvedArrow):
    @others
</t>
<t tx="ekr.20250121054835.66">def get_resolution_from_args(args: Optional[Namespace], resolution_options: dict) -&gt; Optional[tuple[int, int]]:
    if args.resolution:
        return tuple(map(int, args.resolution.split("x")))
    if args.low_quality:
        return literal_eval(resolution_options["low"])
    if args.medium_quality:
        return literal_eval(resolution_options["med"])
    if args.hd:
        return literal_eval(resolution_options["high"])
    if args.uhd:
        return literal_eval(resolution_options["4k"])
    return None
</t>
<t tx="ekr.20250121054835.660">def __init__(
    self,
    start_point: Vect3,
    end_point: Vect3,
    **kwargs
):
    super().__init__(start_point, end_point, **kwargs)
    self.add_tip(at_start=True)
</t>
<t tx="ekr.20250121054835.661">class Circle(Arc):
    @others
</t>
<t tx="ekr.20250121054835.662">def __init__(
    self,
    start_angle: float = 0,
    stroke_color: ManimColor = RED,
    **kwargs
):
    super().__init__(
        start_angle, TAU,
        stroke_color=stroke_color,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.663">def surround(
    self,
    mobject: Mobject,
    dim_to_match: int = 0,
    stretch: bool = False,
    buff: float = MED_SMALL_BUFF
) -&gt; Self:
    self.replace(mobject, dim_to_match, stretch)
    self.stretch((self.get_width() + 2 * buff) / self.get_width(), 0)
    self.stretch((self.get_height() + 2 * buff) / self.get_height(), 1)
    return self
</t>
<t tx="ekr.20250121054835.664">def point_at_angle(self, angle: float) -&gt; Vect3:
    start_angle = self.get_start_angle()
    return self.point_from_proportion(
        ((angle - start_angle) % TAU) / TAU
    )
</t>
<t tx="ekr.20250121054835.665">def get_radius(self) -&gt; float:
    return get_norm(self.get_start() - self.get_center())
</t>
<t tx="ekr.20250121054835.666">class Dot(Circle):
    @others
</t>
<t tx="ekr.20250121054835.667">def __init__(
    self,
    point: Vect3 = ORIGIN,
    radius: float = DEFAULT_DOT_RADIUS,
    stroke_color: ManimColor = BLACK,
    stroke_width: float = 0.0,
    fill_opacity: float = 1.0,
    fill_color: ManimColor = WHITE,
    **kwargs
):
    super().__init__(
        arc_center=point,
        radius=radius,
        stroke_color=stroke_color,
        stroke_width=stroke_width,
        fill_opacity=fill_opacity,
        fill_color=fill_color,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.668">class SmallDot(Dot):
    @others
</t>
<t tx="ekr.20250121054835.669">def __init__(
    self,
    point: Vect3 = ORIGIN,
    radius: float = DEFAULT_SMALL_DOT_RADIUS,
    **kwargs
):
    super().__init__(point, radius=radius, **kwargs)
</t>
<t tx="ekr.20250121054835.67">def get_file_ext(args: Namespace) -&gt; str:
    if args.transparent:
        file_ext = ".mov"
    elif args.gif:
        file_ext = ".gif"
    else:
        file_ext = ".mp4"
    return file_ext
</t>
<t tx="ekr.20250121054835.670">class Ellipse(Circle):
    @others
</t>
<t tx="ekr.20250121054835.671">def __init__(
    self,
    width: float = 2.0,
    height: float = 1.0,
    **kwargs
):
    super().__init__(**kwargs)
    self.set_width(width, stretch=True)
    self.set_height(height, stretch=True)
</t>
<t tx="ekr.20250121054835.672">class AnnularSector(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.673">def __init__(
    self,
    angle: float = TAU / 4,
    start_angle: float = 0.0,
    inner_radius: float = 1.0,
    outer_radius: float = 2.0,
    arc_center: Vect3 = ORIGIN,
    fill_color: ManimColor = GREY_A,
    fill_opacity: float = 1.0,
    stroke_width: float = 0.0,
    **kwargs,
):
    super().__init__(
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        **kwargs,
    )

    # Initialize points
    inner_arc, outer_arc = [
        Arc(
            start_angle=start_angle,
            angle=angle,
            radius=radius,
            arc_center=arc_center,
        )
        for radius in (inner_radius, outer_radius)
    ]
    self.set_points(inner_arc.get_points()[::-1])  # Reverse
    self.add_line_to(outer_arc.get_points()[0])
    self.add_subpath(outer_arc.get_points())
    self.add_line_to(inner_arc.get_points()[-1])
</t>
<t tx="ekr.20250121054835.674">class Sector(AnnularSector):
    @others
</t>
<t tx="ekr.20250121054835.675">def __init__(
    self,
    angle: float = TAU / 4,
    radius: float = 1.0,
    **kwargs
):
    super().__init__(
        angle,
        inner_radius=0,
        outer_radius=radius,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.676">class Annulus(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.677">def __init__(
    self,
    inner_radius: float = 1.0,
    outer_radius: float = 2.0,
    fill_opacity: float = 1.0,
    stroke_width: float = 0.0,
    fill_color: ManimColor = GREY_A,
    center: Vect3 = ORIGIN,
    **kwargs,
):
    super().__init__(
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        **kwargs,
    )

    self.radius = outer_radius
    outer_path = outer_radius * quadratic_bezier_points_for_arc(TAU)
    inner_path = inner_radius * quadratic_bezier_points_for_arc(-TAU)
    self.add_subpath(outer_path)
    self.add_subpath(inner_path)
    self.shift(center)
</t>
<t tx="ekr.20250121054835.678">class Line(TipableVMobject):
    @others
</t>
<t tx="ekr.20250121054835.679">def __init__(
    self,
    start: Vect3 | Mobject = LEFT,
    end: Vect3 | Mobject = RIGHT,
    buff: float = 0.0,
    path_arc: float = 0.0,
    **kwargs
):
    super().__init__(**kwargs)
    self.path_arc = path_arc
    self.buff = buff
    self.set_start_and_end_attrs(start, end)
    self.set_points_by_ends(self.start, self.end, buff, path_arc)
</t>
<t tx="ekr.20250121054835.68">def get_animations_numbers(args: Namespace) -&gt; tuple[int | None, int | None]:
    stan = args.start_at_animation_number
    if stan is None:
        return (None, None)
    elif "," in stan:
        return tuple(map(int, stan.split(",")))
    else:
        return int(stan), None
</t>
<t tx="ekr.20250121054835.680">def set_points_by_ends(
    self,
    start: Vect3,
    end: Vect3,
    buff: float = 0,
    path_arc: float = 0
) -&gt; Self:
    self.clear_points()
    self.start_new_path(start)
    self.add_arc_to(end, path_arc)

    # Apply buffer
    if buff &gt; 0:
        length = self.get_arc_length()
        alpha = min(buff / length, 0.5)
        self.pointwise_become_partial(self, alpha, 1 - alpha)
    return self
</t>
<t tx="ekr.20250121054835.681">def set_path_arc(self, new_value: float) -&gt; Self:
    self.path_arc = new_value
    self.init_points()
    return self
</t>
<t tx="ekr.20250121054835.682">def set_start_and_end_attrs(self, start: Vect3 | Mobject, end: Vect3 | Mobject):
    # If either start or end are Mobjects, this
    # gives their centers
    rough_start = self.pointify(start)
    rough_end = self.pointify(end)
    vect = normalize(rough_end - rough_start)
    # Now that we know the direction between them,
    # we can find the appropriate boundary point from
    # start and end, if they're mobjects
    self.start = self.pointify(start, vect)
    self.end = self.pointify(end, -vect)
</t>
<t tx="ekr.20250121054835.683">def pointify(
    self,
    mob_or_point: Mobject | Vect3,
    direction: Vect3 | None = None
) -&gt; Vect3:
    """
    Take an argument passed into Line (or subclass) and turn
    it into a 3d point.
    """
    if isinstance(mob_or_point, Mobject):
        mob = mob_or_point
        if direction is None:
            return mob.get_center()
        else:
            return mob.get_continuous_bounding_box_point(direction)
    else:
        point = mob_or_point
        result = np.zeros(self.dim)
        result[:len(point)] = point
        return result
</t>
<t tx="ekr.20250121054835.684">def put_start_and_end_on(self, start: Vect3, end: Vect3) -&gt; Self:
    curr_start, curr_end = self.get_start_and_end()
    if np.isclose(curr_start, curr_end).all():
        # Handle null lines more gracefully
        self.set_points_by_ends(start, end, buff=0, path_arc=self.path_arc)
        return self
    return super().put_start_and_end_on(start, end)
</t>
<t tx="ekr.20250121054835.685">def get_vector(self) -&gt; Vect3:
    return self.get_end() - self.get_start()
</t>
<t tx="ekr.20250121054835.686">def get_unit_vector(self) -&gt; Vect3:
    return normalize(self.get_vector())
</t>
<t tx="ekr.20250121054835.687">def get_angle(self) -&gt; float:
    return angle_of_vector(self.get_vector())
</t>
<t tx="ekr.20250121054835.688">def get_projection(self, point: Vect3) -&gt; Vect3:
    """
    Return projection of a point onto the line
    """
    unit_vect = self.get_unit_vector()
    start = self.get_start()
    return start + np.dot(point - start, unit_vect) * unit_vect
</t>
<t tx="ekr.20250121054835.689">def get_slope(self) -&gt; float:
    return np.tan(self.get_angle())
</t>
<t tx="ekr.20250121054835.69">def get_output_directory(args: Namespace, config: Dict) -&gt; str:
    dir_config = config.directories
    out_dir = args.video_dir or dir_config.output
    if dir_config.mirror_module_path and args.file:
        file_path = Path(args.file).absolute()
        rel_path = file_path.relative_to(dir_config.removed_mirror_prefix)
        rel_path = Path(str(rel_path).lstrip("_"))
        out_dir = Path(out_dir, rel_path).with_suffix("")
    return out_dir
</t>
<t tx="ekr.20250121054835.690">def set_angle(self, angle: float, about_point: Optional[Vect3] = None) -&gt; Self:
    if about_point is None:
        about_point = self.get_start()
    self.rotate(
        angle - self.get_angle(),
        about_point=about_point,
    )
    return self
</t>
<t tx="ekr.20250121054835.691">def set_length(self, length: float, **kwargs):
    self.scale(length / self.get_length(), **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.692">def get_arc_length(self) -&gt; float:
    arc_len = get_norm(self.get_vector())
    if self.path_arc &gt; 0:
        arc_len *= self.path_arc / (2 * math.sin(self.path_arc / 2))
    return arc_len
</t>
<t tx="ekr.20250121054835.693">class DashedLine(Line):
    @others
</t>
<t tx="ekr.20250121054835.694">def __init__(
    self,
    start: Vect3 = LEFT,
    end: Vect3 = RIGHT,
    dash_length: float = DEFAULT_DASH_LENGTH,
    positive_space_ratio: float = 0.5,
    **kwargs
):
    super().__init__(start, end, **kwargs)

    num_dashes = self.calculate_num_dashes(dash_length, positive_space_ratio)
    dashes = DashedVMobject(
        self,
        num_dashes=num_dashes,
        positive_space_ratio=positive_space_ratio
    )
    self.clear_points()
    self.add(*dashes)
</t>
<t tx="ekr.20250121054835.695">def calculate_num_dashes(self, dash_length: float, positive_space_ratio: float) -&gt; int:
    try:
        full_length = dash_length / positive_space_ratio
        return int(np.ceil(self.get_length() / full_length))
    except ZeroDivisionError:
        return 1
</t>
<t tx="ekr.20250121054835.696">def get_start(self) -&gt; Vect3:
    if len(self.submobjects) &gt; 0:
        return self.submobjects[0].get_start()
    else:
        return Line.get_start(self)
</t>
<t tx="ekr.20250121054835.697">def get_end(self) -&gt; Vect3:
    if len(self.submobjects) &gt; 0:
        return self.submobjects[-1].get_end()
    else:
        return Line.get_end(self)
</t>
<t tx="ekr.20250121054835.698">def get_first_handle(self) -&gt; Vect3:
    return self.submobjects[0].get_points()[1]
</t>
<t tx="ekr.20250121054835.699">def get_last_handle(self) -&gt; Vect3:
    return self.submobjects[-1].get_points()[-2]
</t>
<t tx="ekr.20250121054835.7">class TextExample(Scene):
    @others
</t>
<t tx="ekr.20250121054835.70">from __future__ import annotations
import numpy as np

from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from typing import List
    from manimlib.typing import ManimColor, Vect3

# See manimlib/default_config.yml
from manimlib.config import manim_config


DEFAULT_RESOLUTION: tuple[int, int] = manim_config.camera.resolution
DEFAULT_PIXEL_WIDTH: int = DEFAULT_RESOLUTION[0]
DEFAULT_PIXEL_HEIGHT: int = DEFAULT_RESOLUTION[1]

# Sizes relevant to default camera frame
ASPECT_RATIO: float = DEFAULT_PIXEL_WIDTH / DEFAULT_PIXEL_HEIGHT
FRAME_HEIGHT: float = manim_config.sizes.frame_height
FRAME_WIDTH: float = FRAME_HEIGHT * ASPECT_RATIO
FRAME_SHAPE: tuple[float, float] = (FRAME_WIDTH, FRAME_HEIGHT)
FRAME_Y_RADIUS: float = FRAME_HEIGHT / 2
FRAME_X_RADIUS: float = FRAME_WIDTH / 2


# Helpful values for positioning mobjects
SMALL_BUFF: float = manim_config.sizes.small_buff
MED_SMALL_BUFF: float = manim_config.sizes.med_small_buff
MED_LARGE_BUFF: float = manim_config.sizes.med_large_buff
LARGE_BUFF: float = manim_config.sizes.large_buff

DEFAULT_MOBJECT_TO_EDGE_BUFF: float = manim_config.sizes.default_mobject_to_edge_buff
DEFAULT_MOBJECT_TO_MOBJECT_BUFF: float = manim_config.sizes.default_mobject_to_mobject_buff


# Standard vectors
ORIGIN: Vect3 = np.array([0., 0., 0.])
UP: Vect3 = np.array([0., 1., 0.])
DOWN: Vect3 = np.array([0., -1., 0.])
RIGHT: Vect3 = np.array([1., 0., 0.])
LEFT: Vect3 = np.array([-1., 0., 0.])
IN: Vect3 = np.array([0., 0., -1.])
OUT: Vect3 = np.array([0., 0., 1.])
X_AXIS: Vect3 = np.array([1., 0., 0.])
Y_AXIS: Vect3 = np.array([0., 1., 0.])
Z_AXIS: Vect3 = np.array([0., 0., 1.])

NULL_POINTS = np.array([[0., 0., 0.]])

# Useful abbreviations for diagonals
UL: Vect3 = UP + LEFT
UR: Vect3 = UP + RIGHT
DL: Vect3 = DOWN + LEFT
DR: Vect3 = DOWN + RIGHT

TOP: Vect3 = FRAME_Y_RADIUS * UP
BOTTOM: Vect3 = FRAME_Y_RADIUS * DOWN
LEFT_SIDE: Vect3 = FRAME_X_RADIUS * LEFT
RIGHT_SIDE: Vect3 = FRAME_X_RADIUS * RIGHT

# Angles
PI: float = np.pi
TAU: float = 2 * PI
DEG: float = TAU / 360
DEGREES = DEG  # Many older animations use the full name
# Nice to have a constant for readability
# when juxtaposed with expressions like 30 * DEG
RADIANS: float = 1

# Related to Text
NORMAL: str = "NORMAL"
ITALIC: str = "ITALIC"
OBLIQUE: str = "OBLIQUE"
BOLD: str = "BOLD"

DEFAULT_STROKE_WIDTH: float = manim_config.vmobject.default_stroke_width

# Colors
BLUE_E: ManimColor = manim_config.colors.blue_e
BLUE_D: ManimColor = manim_config.colors.blue_d
BLUE_C: ManimColor = manim_config.colors.blue_c
BLUE_B: ManimColor = manim_config.colors.blue_b
BLUE_A: ManimColor = manim_config.colors.blue_a
TEAL_E: ManimColor = manim_config.colors.teal_e
TEAL_D: ManimColor = manim_config.colors.teal_d
TEAL_C: ManimColor = manim_config.colors.teal_c
TEAL_B: ManimColor = manim_config.colors.teal_b
TEAL_A: ManimColor = manim_config.colors.teal_a
GREEN_E: ManimColor = manim_config.colors.green_e
GREEN_D: ManimColor = manim_config.colors.green_d
GREEN_C: ManimColor = manim_config.colors.green_c
GREEN_B: ManimColor = manim_config.colors.green_b
GREEN_A: ManimColor = manim_config.colors.green_a
YELLOW_E: ManimColor = manim_config.colors.yellow_e
YELLOW_D: ManimColor = manim_config.colors.yellow_d
YELLOW_C: ManimColor = manim_config.colors.yellow_c
YELLOW_B: ManimColor = manim_config.colors.yellow_b
YELLOW_A: ManimColor = manim_config.colors.yellow_a
GOLD_E: ManimColor = manim_config.colors.gold_e
GOLD_D: ManimColor = manim_config.colors.gold_d
GOLD_C: ManimColor = manim_config.colors.gold_c
GOLD_B: ManimColor = manim_config.colors.gold_b
GOLD_A: ManimColor = manim_config.colors.gold_a
RED_E: ManimColor = manim_config.colors.red_e
RED_D: ManimColor = manim_config.colors.red_d
RED_C: ManimColor = manim_config.colors.red_c
RED_B: ManimColor = manim_config.colors.red_b
RED_A: ManimColor = manim_config.colors.red_a
MAROON_E: ManimColor = manim_config.colors.maroon_e
MAROON_D: ManimColor = manim_config.colors.maroon_d
MAROON_C: ManimColor = manim_config.colors.maroon_c
MAROON_B: ManimColor = manim_config.colors.maroon_b
MAROON_A: ManimColor = manim_config.colors.maroon_a
PURPLE_E: ManimColor = manim_config.colors.purple_e
PURPLE_D: ManimColor = manim_config.colors.purple_d
PURPLE_C: ManimColor = manim_config.colors.purple_c
PURPLE_B: ManimColor = manim_config.colors.purple_b
PURPLE_A: ManimColor = manim_config.colors.purple_a
GREY_E: ManimColor = manim_config.colors.grey_e
GREY_D: ManimColor = manim_config.colors.grey_d
GREY_C: ManimColor = manim_config.colors.grey_c
GREY_B: ManimColor = manim_config.colors.grey_b
GREY_A: ManimColor = manim_config.colors.grey_a
WHITE: ManimColor = manim_config.colors.white
BLACK: ManimColor = manim_config.colors.black
GREY_BROWN: ManimColor = manim_config.colors.grey_brown
DARK_BROWN: ManimColor = manim_config.colors.dark_brown
LIGHT_BROWN: ManimColor = manim_config.colors.light_brown
PINK: ManimColor = manim_config.colors.pink
LIGHT_PINK: ManimColor = manim_config.colors.light_pink
GREEN_SCREEN: ManimColor = manim_config.colors.green_screen
ORANGE: ManimColor = manim_config.colors.orange

MANIM_COLORS: List[ManimColor] = list(manim_config.colors.values())

# Abbreviated names for the "median" colors
BLUE: ManimColor = BLUE_C
TEAL: ManimColor = TEAL_C
GREEN: ManimColor = GREEN_C
YELLOW: ManimColor = YELLOW_C
GOLD: ManimColor = GOLD_C
RED: ManimColor = RED_C
MAROON: ManimColor = MAROON_C
PURPLE: ManimColor = PURPLE_C
GREY: ManimColor = GREY_C

COLORMAP_3B1B: List[ManimColor] = [BLUE_E, GREEN, YELLOW, RED]
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.700">class TangentLine(Line):
    @others
</t>
<t tx="ekr.20250121054835.701">def __init__(
    self,
    vmob: VMobject,
    alpha: float,
    length: float = 2,
    d_alpha: float = 1e-6,
    **kwargs
):
    a1 = clip(alpha - d_alpha, 0, 1)
    a2 = clip(alpha + d_alpha, 0, 1)
    super().__init__(vmob.pfp(a1), vmob.pfp(a2), **kwargs)
    self.scale(length / self.get_length())
</t>
<t tx="ekr.20250121054835.702">class Elbow(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.703">def __init__(
    self,
    width: float = 0.2,
    angle: float = 0,
    **kwargs
):
    super().__init__(**kwargs)
    self.set_points_as_corners([UP, UR, RIGHT])
    self.set_width(width, about_point=ORIGIN)
    self.rotate(angle, about_point=ORIGIN)
</t>
<t tx="ekr.20250121054835.704">class StrokeArrow(Line):
    @others
</t>
<t tx="ekr.20250121054835.705">def __init__(
    self,
    start: Vect3 | Mobject,
    end: Vect3 | Mobject,
    stroke_color: ManimColor = GREY_A,
    stroke_width: float = 5,
    buff: float = 0.25,
    tip_width_ratio: float = 5,
    tip_len_to_width: float = 0.0075,
    max_tip_length_to_length_ratio: float = 0.3,
    max_width_to_length_ratio: float = 8.0,
    **kwargs,
):
    self.tip_width_ratio = tip_width_ratio
    self.tip_len_to_width = tip_len_to_width
    self.max_tip_length_to_length_ratio = max_tip_length_to_length_ratio
    self.max_width_to_length_ratio = max_width_to_length_ratio
    self.n_tip_points = 3
    self.original_stroke_width = stroke_width
    super().__init__(
        start, end,
        stroke_color=stroke_color,
        stroke_width=stroke_width,
        buff=buff,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.706">def set_points_by_ends(
    self,
    start: Vect3,
    end: Vect3,
    buff: float = 0,
    path_arc: float = 0
) -&gt; Self:
    super().set_points_by_ends(start, end, buff, path_arc)
    self.insert_tip_anchor()
    self.create_tip_with_stroke_width()
    return self
</t>
<t tx="ekr.20250121054835.707">def insert_tip_anchor(self) -&gt; Self:
    prev_end = self.get_end()
    arc_len = self.get_arc_length()
    tip_len = self.get_stroke_width() * self.tip_width_ratio * self.tip_len_to_width
    if tip_len &gt;= self.max_tip_length_to_length_ratio * arc_len or arc_len == 0:
        alpha = self.max_tip_length_to_length_ratio
    else:
        alpha = tip_len / arc_len

    if self.path_arc &gt; 0 and self.buff &gt; 0:
        self.insert_n_curves(10)  # Is this needed?
    self.pointwise_become_partial(self, 0.0, 1.0 - alpha)
    self.add_line_to(self.get_end())
    self.add_line_to(prev_end)
    self.n_tip_points = 3
    return self
</t>
<t tx="ekr.20250121054835.708">@Mobject.affects_data
def create_tip_with_stroke_width(self) -&gt; Self:
    if self.get_num_points() &lt; 3:
        return self
    stroke_width = min(
        self.original_stroke_width,
        self.max_width_to_length_ratio * self.get_length(),
    )
    tip_width = self.tip_width_ratio * stroke_width
    ntp = self.n_tip_points
    self.data['stroke_width'][:-ntp] = self.data['stroke_width'][0]
    self.data['stroke_width'][-ntp:, 0] = tip_width * np.linspace(1, 0, ntp)
    return self
</t>
<t tx="ekr.20250121054835.709">def reset_tip(self) -&gt; Self:
    self.set_points_by_ends(
        self.get_start(), self.get_end(),
        path_arc=self.path_arc
    )
    return self
</t>
<t tx="ekr.20250121054835.71">from __future__ import annotations

import copy
import inspect
import sys

from manimlib.module_loader import ModuleLoader

from manimlib.config import manim_config
from manimlib.logger import log
from manimlib.scene.interactive_scene import InteractiveScene
from manimlib.scene.scene import Scene

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    Module = importlib.util.types.ModuleType
    from typing import Optional
    from addict import Dict


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.710">def set_stroke(
    self,
    color: ManimColor | Iterable[ManimColor] | None = None,
    width: float | Iterable[float] | None = None,
    *args, **kwargs
) -&gt; Self:
    super().set_stroke(color=color, width=width, *args, **kwargs)
    self.original_stroke_width = self.get_stroke_width()
    if self.has_points():
        self.reset_tip()
    return self
</t>
<t tx="ekr.20250121054835.711">def _handle_scale_side_effects(self, scale_factor: float) -&gt; Self:
    if scale_factor != 1.0:
        self.reset_tip()
    return self
</t>
<t tx="ekr.20250121054835.712">class Arrow(Line):
    @others
</t>
<t tx="ekr.20250121054835.713">tickness_multiplier = 0.015

def __init__(
    self,
    start: Vect3 | Mobject = LEFT,
    end: Vect3 | Mobject = LEFT,
    buff: float = MED_SMALL_BUFF,
    path_arc: float = 0,
    fill_color: ManimColor = GREY_A,
    fill_opacity: float = 1.0,
    stroke_width: float = 0.0,
    thickness: float = 3.0,
    tip_width_ratio: float = 5,
    tip_angle: float = PI / 3,
    max_tip_length_to_length_ratio: float = 0.5,
    max_width_to_length_ratio: float = 0.1,
    **kwargs,
):
    self.thickness = thickness
    self.tip_width_ratio = tip_width_ratio
    self.tip_angle = tip_angle
    self.max_tip_length_to_length_ratio = max_tip_length_to_length_ratio
    self.max_width_to_length_ratio = max_width_to_length_ratio
    super().__init__(
        start, end,
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        buff=buff,
        path_arc=path_arc,
        **kwargs
    )
</t>
<t tx="ekr.20250121054835.714">def get_key_dimensions(self, length):
    width = self.thickness * self.tickness_multiplier
    w_ratio = fdiv(self.max_width_to_length_ratio, fdiv(width, length))
    if w_ratio &lt; 1:
        width *= w_ratio

    tip_width = self.tip_width_ratio * width
    tip_length = tip_width / (2 * np.tan(self.tip_angle / 2))
    t_ratio = fdiv(self.max_tip_length_to_length_ratio, fdiv(tip_length, length))
    if t_ratio &lt; 1:
        tip_length *= t_ratio
        tip_width *= t_ratio

    return width, tip_width, tip_length
</t>
<t tx="ekr.20250121054835.715">def set_points_by_ends(
    self,
    start: Vect3,
    end: Vect3,
    buff: float = 0,
    path_arc: float = 0
) -&gt; Self:
    vect = end - start
    length = max(get_norm(vect), 1e-8)  # More systematic min?
    unit_vect = normalize(vect)

    # Find the right tip length and thickness
    width, tip_width, tip_length = self.get_key_dimensions(length - buff)

    # Adjust start and end based on buff
    if path_arc == 0:
        start = start + buff * unit_vect
        end = end - buff * unit_vect
    else:
        R = length / 2 / math.sin(path_arc / 2)
        midpoint = 0.5 * (start + end)
        center = midpoint + rotate_vector(0.5 * vect, PI / 2) / math.tan(path_arc / 2)
        sign = 1
        start = center + rotate_vector(start - center, buff / R)
        end = center + rotate_vector(end - center, -buff / R)
        path_arc -= (2 * buff + tip_length) / R
    vect = end - start
    length = get_norm(vect)

    # Find points for the stem, imagining an arrow pointed to the left
    if path_arc == 0:
        points1 = (length - tip_length) * np.array([RIGHT, 0.5 * RIGHT, ORIGIN])
        points1 += width * UP / 2
        points2 = points1[::-1] + width * DOWN
    else:
        # Find arc points
        points1 = quadratic_bezier_points_for_arc(path_arc)
        points2 = np.array(points1[::-1])
        points1 *= (R + width / 2)
        points2 *= (R - width / 2)
        rot_T = rotation_matrix_transpose(PI / 2 - path_arc, OUT)
        for points in points1, points2:
            points[:] = np.dot(points, rot_T)
            points += R * DOWN

    self.set_points(points1)
    # Tip
    self.add_line_to(tip_width * UP / 2)
    self.add_line_to(tip_length * LEFT)
    self.tip_index = len(self.get_points()) - 1
    self.add_line_to(tip_width * DOWN / 2)
    self.add_line_to(points2[0])
    # Close it out
    self.add_subpath(points2)
    self.add_line_to(points1[0])

    # Reposition to match proper start and end
    self.rotate(angle_of_vector(vect) - self.get_angle())
    self.rotate(
        PI / 2 - np.arccos(normalize(vect)[2]),
        axis=rotate_vector(self.get_unit_vector(), -PI / 2),
    )
    self.shift(start - self.get_start())
    return self
</t>
<t tx="ekr.20250121054835.716">def reset_points_around_ends(self) -&gt; Self:
    self.set_points_by_ends(
        self.get_start().copy(),
        self.get_end().copy(),
        path_arc=self.path_arc
    )
    return self
</t>
<t tx="ekr.20250121054835.717">def get_start(self) -&gt; Vect3:
    points = self.get_points()
    return 0.5 * (points[0] + points[-3])
</t>
<t tx="ekr.20250121054835.718">def get_end(self) -&gt; Vect3:
    return self.get_points()[self.tip_index]
</t>
<t tx="ekr.20250121054835.719">def get_start_and_end(self):
    return (self.get_start(), self.get_end())
</t>
<t tx="ekr.20250121054835.72">class BlankScene(InteractiveScene):
    @others
</t>
<t tx="ekr.20250121054835.720">def put_start_and_end_on(self, start: Vect3, end: Vect3) -&gt; Self:
    self.set_points_by_ends(start, end, buff=0, path_arc=self.path_arc)
    return self
</t>
<t tx="ekr.20250121054835.721">def scale(self, *args, **kwargs) -&gt; Self:
    super().scale(*args, **kwargs)
    self.reset_points_around_ends()
    return self
</t>
<t tx="ekr.20250121054835.722">def set_thickness(self, thickness: float) -&gt; Self:
    self.thickness = thickness
    self.reset_points_around_ends()
    return self
</t>
<t tx="ekr.20250121054835.723">def set_path_arc(self, path_arc: float) -&gt; Self:
    self.path_arc = path_arc
    self.reset_points_around_ends()
    return self
</t>
<t tx="ekr.20250121054835.724">def set_perpendicular_to_camera(self, camera_frame):
    to_cam = camera_frame.get_implied_camera_location() - self.get_center()
    normal = self.get_unit_normal()
    axis = normalize(self.get_vector())
    # Project to be perpendicular to axis
    trg_normal = to_cam - np.dot(to_cam, axis) * axis
    mat = rotation_between_vectors(normal, trg_normal)
    self.apply_matrix(mat, about_point=self.get_start())
    return self
</t>
<t tx="ekr.20250121054835.725">class Vector(Arrow):
    @others
</t>
<t tx="ekr.20250121054835.726">def __init__(
    self,
    direction: Vect3 = RIGHT,
    buff: float = 0.0,
    **kwargs
):
    if len(direction) == 2:
        direction = np.hstack([direction, 0])
    super().__init__(ORIGIN, direction, buff=buff, **kwargs)
</t>
<t tx="ekr.20250121054835.727">class CubicBezier(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.728">def __init__(
    self,
    a0: Vect3,
    h0: Vect3,
    h1: Vect3,
    a1: Vect3,
    **kwargs
):
    super().__init__(**kwargs)
    self.add_cubic_bezier_curve(a0, h0, h1, a1)
</t>
<t tx="ekr.20250121054835.729">class Polygon(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.73">def construct(self):
    exec(manim_config.universal_import_line)
    self.embed()
</t>
<t tx="ekr.20250121054835.730">def __init__(
    self,
    *vertices: Vect3,
    **kwargs
):
    super().__init__(**kwargs)
    self.set_points_as_corners([*vertices, vertices[0]])
</t>
<t tx="ekr.20250121054835.731">def get_vertices(self) -&gt; Vect3Array:
    return self.get_start_anchors()
</t>
<t tx="ekr.20250121054835.732">def round_corners(self, radius: Optional[float] = None) -&gt; Self:
    if radius is None:
        verts = self.get_vertices()
        min_edge_length = min(
            get_norm(v1 - v2)
            for v1, v2 in zip(verts, verts[1:])
            if not np.isclose(v1, v2).all()
        )
        radius = 0.25 * min_edge_length
    vertices = self.get_vertices()
    arcs = []
    for v1, v2, v3 in adjacent_n_tuples(vertices, 3):
        vect1 = normalize(v2 - v1)
        vect2 = normalize(v3 - v2)
        angle = angle_between_vectors(vect1, vect2)
        # Distance between vertex and start of the arc
        cut_off_length = radius * np.tan(angle / 2)
        # Negative radius gives concave curves
        sign = float(np.sign(radius * cross2d(vect1, vect2)))
        arc = ArcBetweenPoints(
            v2 - vect1 * cut_off_length,
            v2 + vect2 * cut_off_length,
            angle=sign * angle,
            n_components=2,
        )
        arcs.append(arc)

    self.clear_points()
    # To ensure that we loop through starting with last
    arcs = [arcs[-1], *arcs[:-1]]
    for arc1, arc2 in adjacent_pairs(arcs):
        self.add_subpath(arc1.get_points())
        self.add_line_to(arc2.get_start())
    return self
</t>
<t tx="ekr.20250121054835.733">class Polyline(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.734">def __init__(
    self,
    *vertices: Vect3,
    **kwargs
):
    super().__init__(**kwargs)
    self.set_points_as_corners(vertices)
</t>
<t tx="ekr.20250121054835.735">class RegularPolygon(Polygon):
    @others
</t>
<t tx="ekr.20250121054835.736">def __init__(
    self,
    n: int = 6,
    radius: float = 1.0,
    start_angle: float | None = None,
    **kwargs
):
    # Defaults to 0 for odd, 90 for even
    if start_angle is None:
        start_angle = (n % 2) * 90 * DEG
    start_vect = rotate_vector(radius * RIGHT, start_angle)
    vertices = compass_directions(n, start_vect)
    super().__init__(*vertices, **kwargs)
</t>
<t tx="ekr.20250121054835.737">class Triangle(RegularPolygon):
    @others
</t>
<t tx="ekr.20250121054835.738">def __init__(self, **kwargs):
    super().__init__(n=3, **kwargs)
</t>
<t tx="ekr.20250121054835.739">class ArrowTip(Triangle):
    @others
</t>
<t tx="ekr.20250121054835.74">def is_child_scene(obj, module):
    if not inspect.isclass(obj):
        return False
    if not issubclass(obj, Scene):
        return False
    if obj == Scene:
        return False
    if not obj.__module__.startswith(module.__name__):
        return False
    return True
</t>
<t tx="ekr.20250121054835.740">def __init__(
    self,
    angle: float = 0,
    width: float = DEFAULT_ARROW_TIP_WIDTH,
    length: float = DEFAULT_ARROW_TIP_LENGTH,
    fill_opacity: float = 1.0,
    fill_color: ManimColor = WHITE,
    stroke_width: float = 0.0,
    tip_style: int = 0,  # triangle=0, inner_smooth=1, dot=2
    **kwargs
):
    super().__init__(
        start_angle=0,
        fill_opacity=fill_opacity,
        fill_color=fill_color,
        stroke_width=stroke_width,
        **kwargs
    )
    self.set_height(width)
    self.set_width(length, stretch=True)
    if tip_style == 1:
        self.set_height(length * 0.9, stretch=True)
        self.data["point"][4] += np.array([0.6 * length, 0, 0])
    elif tip_style == 2:
        h = length / 2
        self.set_points(Dot().set_width(h).get_points())
    self.rotate(angle)
</t>
<t tx="ekr.20250121054835.741">def get_base(self) -&gt; Vect3:
    return self.point_from_proportion(0.5)
</t>
<t tx="ekr.20250121054835.742">def get_tip_point(self) -&gt; Vect3:
    return self.get_points()[0]
</t>
<t tx="ekr.20250121054835.743">def get_vector(self) -&gt; Vect3:
    return self.get_tip_point() - self.get_base()
</t>
<t tx="ekr.20250121054835.744">def get_angle(self) -&gt; float:
    return angle_of_vector(self.get_vector())
</t>
<t tx="ekr.20250121054835.745">def get_length(self) -&gt; float:
    return get_norm(self.get_vector())
</t>
<t tx="ekr.20250121054835.746">class Rectangle(Polygon):
    @others
</t>
<t tx="ekr.20250121054835.747">def __init__(
    self,
    width: float = 4.0,
    height: float = 2.0,
    **kwargs
):
    super().__init__(UR, UL, DL, DR, **kwargs)
    self.set_width(width, stretch=True)
    self.set_height(height, stretch=True)
</t>
<t tx="ekr.20250121054835.748">def surround(self, mobject, buff=SMALL_BUFF) -&gt; Self:
    target_shape = np.array(mobject.get_shape()) + 2 * buff
    self.set_shape(*target_shape)
    self.move_to(mobject)
    return self
</t>
<t tx="ekr.20250121054835.749">class Square(Rectangle):
    @others
</t>
<t tx="ekr.20250121054835.75">def prompt_user_for_choice(scene_classes):
    name_to_class = {}
    max_digits = len(str(len(scene_classes)))
    for idx, scene_class in enumerate(scene_classes, start=1):
        name = scene_class.__name__
        print(f"{str(idx).zfill(max_digits)}: {name}")
        name_to_class[name] = scene_class
    try:
        user_input = input("\nSelect which scene to render (by name or number): ")
        return [
            name_to_class[split_str] if not split_str.isnumeric() else scene_classes[int(split_str) - 1]
            for split_str in user_input.replace(" ", "").split(",")
        ]
    except IndexError:
        log.error("Invalid scene number")
        sys.exit(2)
    except KeyError:
        log.error("Invalid scene name")
        sys.exit(2)
    except EOFError:
        sys.exit(1)
</t>
<t tx="ekr.20250121054835.750">def __init__(self, side_length: float = 2.0, **kwargs):
    super().__init__(side_length, side_length, **kwargs)
</t>
<t tx="ekr.20250121054835.751">class RoundedRectangle(Rectangle):
    @others
</t>
<t tx="ekr.20250121054835.752">def __init__(
    self,
    width: float = 4.0,
    height: float = 2.0,
    corner_radius: float = 0.5,
    **kwargs
):
    super().__init__(width, height, **kwargs)
    self.round_corners(corner_radius)
</t>
<t tx="ekr.20250121054835.753">from __future__ import annotations

import numpy as np
from pyglet.window import key as PygletWindowKeys

from manimlib.constants import FRAME_HEIGHT, FRAME_WIDTH
from manimlib.constants import DOWN, LEFT, ORIGIN, RIGHT, UP
from manimlib.constants import MED_LARGE_BUFF, MED_SMALL_BUFF, SMALL_BUFF
from manimlib.constants import BLACK, BLUE, GREEN, GREY_A, GREY_C, RED, WHITE
from manimlib.mobject.mobject import Group
from manimlib.mobject.mobject import Mobject
from manimlib.mobject.geometry import Circle
from manimlib.mobject.geometry import Dot
from manimlib.mobject.geometry import Line
from manimlib.mobject.geometry import Rectangle
from manimlib.mobject.geometry import RoundedRectangle
from manimlib.mobject.geometry import Square
from manimlib.mobject.svg.text_mobject import Text
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.value_tracker import ValueTracker
from manimlib.utils.color import rgb_to_hex
from manimlib.utils.space_ops import get_closest_point_on_line
from manimlib.utils.space_ops import get_norm

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Callable
    from manimlib.typing import ManimColor


# Interactive Mobjects

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.754">class MotionMobject(Mobject):
    """
        You could hold and drag this object to any position
    """
    @others
</t>
<t tx="ekr.20250121054835.755">def __init__(self, mobject: Mobject, **kwargs):
    super().__init__(**kwargs)
    assert isinstance(mobject, Mobject)
    self.mobject = mobject
    self.mobject.add_mouse_drag_listner(self.mob_on_mouse_drag)
    # To avoid locking it as static mobject
    self.mobject.add_updater(lambda mob: None)
    self.add(mobject)
</t>
<t tx="ekr.20250121054835.756">def mob_on_mouse_drag(self, mob: Mobject, event_data: dict[str, np.ndarray]) -&gt; bool:
    mob.move_to(event_data["point"])
    return False
</t>
<t tx="ekr.20250121054835.757">class Button(Mobject):
    """
        Pass any mobject and register an on_click method
    
        The on_click method takes mobject as argument like updater
    """
    @others
</t>
<t tx="ekr.20250121054835.758">def __init__(self, mobject: Mobject, on_click: Callable[[Mobject]], **kwargs):
    super().__init__(**kwargs)
    assert isinstance(mobject, Mobject)
    self.on_click = on_click
    self.mobject = mobject
    self.mobject.add_mouse_press_listner(self.mob_on_mouse_press)
    self.add(self.mobject)
</t>
<t tx="ekr.20250121054835.759">def mob_on_mouse_press(self, mob: Mobject, event_data) -&gt; bool:
    self.on_click(mob)
    return False
</t>
<t tx="ekr.20250121054835.76">def compute_total_frames(scene_class, scene_config):
    """
    When a scene is being written to file, a copy of the scene is run with
    skip_animations set to true so as to count how many frames it will require.
    This allows for a total progress bar on rendering, and also allows runtime
    errors to be exposed preemptively for long running scenes.
    """
    pre_config = copy.deepcopy(scene_config)
    pre_config["file_writer_config"]["write_to_movie"] = False
    pre_config["file_writer_config"]["save_last_frame"] = False
    pre_config["file_writer_config"]["quiet"] = True
    pre_config["skip_animations"] = True
    pre_scene = scene_class(**pre_config)
    pre_scene.run()
    total_time = pre_scene.time - pre_scene.skip_time
    return int(total_time * manim_config.camera.fps)
</t>
<t tx="ekr.20250121054835.760"># Controls

class ControlMobject(ValueTracker):
    @others
</t>
<t tx="ekr.20250121054835.761">def __init__(self, value: float, *mobjects: Mobject, **kwargs):
    super().__init__(value=value, **kwargs)
    self.add(*mobjects)

    # To avoid lock_static_mobject_data while waiting in scene
    self.add_updater(lambda mob: None)
    self.fix_in_frame()
</t>
<t tx="ekr.20250121054835.762">def set_value(self, value: float):
    self.assert_value(value)
    self.set_value_anim(value)
    return ValueTracker.set_value(self, value)
</t>
<t tx="ekr.20250121054835.763">def assert_value(self, value):
    # To be implemented in subclasses
    pass
</t>
<t tx="ekr.20250121054835.764">def set_value_anim(self, value):
    # To be implemented in subclasses
    pass
</t>
<t tx="ekr.20250121054835.765">class EnableDisableButton(ControlMobject):
    @others
</t>
<t tx="ekr.20250121054835.766">def __init__(
    self,
    value: bool = True,
    value_type: np.dtype = np.dtype(bool),
    rect_kwargs: dict = {
        "width": 0.5,
        "height": 0.5,
        "fill_opacity": 1.0
    },
    enable_color: ManimColor = GREEN,
    disable_color: ManimColor = RED,
    **kwargs
</t>
<t tx="ekr.20250121054835.767">):
    self.value = value
    self.value_type = value_type
    self.rect_kwargs = rect_kwargs
    self.enable_color = enable_color
    self.disable_color = disable_color

    self.box = Rectangle(**self.rect_kwargs)
    super().__init__(value, self.box, **kwargs)
    self.add_mouse_press_listner(self.on_mouse_press)

def assert_value(self, value: bool) -&gt; None:
    assert isinstance(value, bool)
</t>
<t tx="ekr.20250121054835.768">def set_value_anim(self, value: bool) -&gt; None:
    if value:
        self.box.set_fill(self.enable_color)
    else:
        self.box.set_fill(self.disable_color)
</t>
<t tx="ekr.20250121054835.769">def toggle_value(self) -&gt; None:
    super().set_value(not self.get_value())
</t>
<t tx="ekr.20250121054835.77">def scene_from_class(scene_class, scene_config: Dict, run_config: Dict):
    fw_config = manim_config.file_writer
    if fw_config.write_to_movie and run_config.prerun:
        scene_config.file_writer_config.total_frames = compute_total_frames(scene_class, scene_config)
    return scene_class(**scene_config)
</t>
<t tx="ekr.20250121054835.770">def on_mouse_press(self, mob: Mobject, event_data) -&gt; bool:
    mob.toggle_value()
    return False
</t>
<t tx="ekr.20250121054835.771">class Checkbox(ControlMobject):
    @others
</t>
<t tx="ekr.20250121054835.772">def __init__(
    self,
    value: bool = True,
    value_type: np.dtype = np.dtype(bool),
    rect_kwargs: dict = {
        "width": 0.5,
        "height": 0.5,
        "fill_opacity": 0.0
    },
    checkmark_kwargs: dict = {
        "stroke_color": GREEN,
        "stroke_width": 6,
    },
    cross_kwargs: dict = {
        "stroke_color": RED,
        "stroke_width": 6,
    },
    box_content_buff: float = SMALL_BUFF,
    **kwargs
</t>
<t tx="ekr.20250121054835.773">):
    self.value_type = value_type
    self.rect_kwargs = rect_kwargs
    self.checkmark_kwargs = checkmark_kwargs
    self.cross_kwargs = cross_kwargs
    self.box_content_buff = box_content_buff

    self.box = Rectangle(**self.rect_kwargs)
    self.box_content = self.get_checkmark() if value else self.get_cross()
    super().__init__(value, self.box, self.box_content, **kwargs)
    self.add_mouse_press_listner(self.on_mouse_press)

def assert_value(self, value: bool) -&gt; None:
    assert isinstance(value, bool)
</t>
<t tx="ekr.20250121054835.774">def toggle_value(self) -&gt; None:
    super().set_value(not self.get_value())
</t>
<t tx="ekr.20250121054835.775">def set_value_anim(self, value: bool) -&gt; None:
    if value:
        self.box_content.become(self.get_checkmark())
    else:
        self.box_content.become(self.get_cross())
</t>
<t tx="ekr.20250121054835.776">def on_mouse_press(self, mob: Mobject, event_data) -&gt; None:
    mob.toggle_value()
    return False
</t>
<t tx="ekr.20250121054835.777"># Helper methods

def get_checkmark(self) -&gt; VGroup:
    checkmark = VGroup(
        Line(UP / 2 + 2 * LEFT, DOWN + LEFT, **self.checkmark_kwargs),
        Line(DOWN + LEFT, UP + RIGHT, **self.checkmark_kwargs)
    )

    checkmark.stretch_to_fit_width(self.box.get_width())
    checkmark.stretch_to_fit_height(self.box.get_height())
    checkmark.scale(0.5)
    checkmark.move_to(self.box)
    return checkmark
</t>
<t tx="ekr.20250121054835.778">def get_cross(self) -&gt; VGroup:
    cross = VGroup(
        Line(UP + LEFT, DOWN + RIGHT, **self.cross_kwargs),
        Line(UP + RIGHT, DOWN + LEFT, **self.cross_kwargs)
    )

    cross.stretch_to_fit_width(self.box.get_width())
    cross.stretch_to_fit_height(self.box.get_height())
    cross.scale(0.5)
    cross.move_to(self.box)
    return cross
</t>
<t tx="ekr.20250121054835.779">class LinearNumberSlider(ControlMobject):
    @others
</t>
<t tx="ekr.20250121054835.78">def note_missing_scenes(arg_names, module_names):
    for name in arg_names:
        if name not in module_names:
            log.error(f"No scene named {name} found")
</t>
<t tx="ekr.20250121054835.780">def __init__(
    self,
    value: float = 0,
    value_type: type = np.float64,
    min_value: float = -10.0,
    max_value: float = 10.0,
    step: float = 1.0,
    rounded_rect_kwargs: dict = {
        "height": 0.075,
        "width": 2,
        "corner_radius": 0.0375
    },
    circle_kwargs: dict = {
        "radius": 0.1,
        "stroke_color": GREY_A,
        "fill_color": GREY_A,
        "fill_opacity": 1.0
    },
    **kwargs
):
    self.value_type = value_type
    self.min_value = min_value
    self.max_value = max_value
    self.step = step
    self.rounded_rect_kwargs = rounded_rect_kwargs
    self.circle_kwargs = circle_kwargs

    self.bar = RoundedRectangle(**self.rounded_rect_kwargs)
    self.slider = Circle(**self.circle_kwargs)
    self.slider_axis = Line(
        start=self.bar.get_bounding_box_point(LEFT),
        end=self.bar.get_bounding_box_point(RIGHT)
    )
    self.slider_axis.set_opacity(0.0)
    self.slider.move_to(self.slider_axis)

    self.slider.add_mouse_drag_listner(self.slider_on_mouse_drag)

    super().__init__(value, self.bar, self.slider, self.slider_axis, **kwargs)
</t>
<t tx="ekr.20250121054835.781">def assert_value(self, value: float) -&gt; None:
    assert self.min_value &lt;= value &lt;= self.max_value
</t>
<t tx="ekr.20250121054835.782">def set_value_anim(self, value: float) -&gt; None:
    prop = (value - self.min_value) / (self.max_value - self.min_value)
    self.slider.move_to(self.slider_axis.point_from_proportion(prop))
</t>
<t tx="ekr.20250121054835.783">def slider_on_mouse_drag(self, mob, event_data: dict[str, np.ndarray]) -&gt; bool:
    self.set_value(self.get_value_from_point(event_data["point"]))
    return False
</t>
<t tx="ekr.20250121054835.784"># Helper Methods

def get_value_from_point(self, point: np.ndarray) -&gt; float:
    start, end = self.slider_axis.get_start_and_end()
    point_on_line = get_closest_point_on_line(start, end, point)
    prop = get_norm(point_on_line - start) / get_norm(end - start)
    value = self.min_value + prop * (self.max_value - self.min_value)
    no_of_steps = int((value - self.min_value) / self.step)
    value_nearest_to_step = self.min_value + no_of_steps * self.step
    return value_nearest_to_step
</t>
<t tx="ekr.20250121054835.785">class ColorSliders(Group):
    @others
</t>
<t tx="ekr.20250121054835.786">def __init__(
    self,
    sliders_kwargs: dict = {},
    rect_kwargs: dict = {
        "width": 2.0,
        "height": 0.5,
        "stroke_opacity": 1.0
    },
    background_grid_kwargs: dict = {
        "colors": [GREY_A, GREY_C],
        "single_square_len": 0.1
    },
    sliders_buff: float = MED_LARGE_BUFF,
    default_rgb_value: int = 255,
    default_a_value: int = 1,
    **kwargs
):
    self.sliders_kwargs = sliders_kwargs
    self.rect_kwargs = rect_kwargs
    self.background_grid_kwargs = background_grid_kwargs
    self.sliders_buff = sliders_buff
    self.default_rgb_value = default_rgb_value
    self.default_a_value = default_a_value

    rgb_kwargs = {"value": self.default_rgb_value, "min_value": 0, "max_value": 255, "step": 1}
    a_kwargs = {"value": self.default_a_value, "min_value": 0, "max_value": 1, "step": 0.04}

    self.r_slider = LinearNumberSlider(**self.sliders_kwargs, **rgb_kwargs)
    self.g_slider = LinearNumberSlider(**self.sliders_kwargs, **rgb_kwargs)
    self.b_slider = LinearNumberSlider(**self.sliders_kwargs, **rgb_kwargs)
    self.a_slider = LinearNumberSlider(**self.sliders_kwargs, **a_kwargs)
    self.sliders = Group(
        self.r_slider,
        self.g_slider,
        self.b_slider,
        self.a_slider
    )
    self.sliders.arrange(DOWN, buff=self.sliders_buff)

    self.r_slider.slider.set_color(RED)
    self.g_slider.slider.set_color(GREEN)
    self.b_slider.slider.set_color(BLUE)
    self.a_slider.slider.set_color_by_gradient(BLACK, WHITE)

    self.selected_color_box = Rectangle(**self.rect_kwargs)
    self.selected_color_box.add_updater(
        lambda mob: mob.set_fill(
            self.get_picked_color(), self.get_picked_opacity()
        )
    )
    self.background = self.get_background()

    super().__init__(
        Group(self.background, self.selected_color_box).fix_in_frame(),
        self.sliders,
        **kwargs
    )

    self.arrange(DOWN)
</t>
<t tx="ekr.20250121054835.787">def get_background(self) -&gt; VGroup:
    single_square_len = self.background_grid_kwargs["single_square_len"]
    colors = self.background_grid_kwargs["colors"]
    width = self.rect_kwargs["width"]
    height = self.rect_kwargs["height"]
    rows = int(height / single_square_len)
    cols = int(width / single_square_len)
    cols = (cols + 1) if (cols % 2 == 0) else cols

    single_square = Square(single_square_len)
    grid = single_square.get_grid(n_rows=rows, n_cols=cols, buff=0.0)
    grid.stretch_to_fit_width(width)
    grid.stretch_to_fit_height(height)
    grid.move_to(self.selected_color_box)

    for idx, square in enumerate(grid):
        assert isinstance(square, Square)
        square.set_stroke(width=0.0, opacity=0.0)
        square.set_fill(colors[idx % len(colors)], 1.0)

    return grid
</t>
<t tx="ekr.20250121054835.788">def set_value(self, r: float, g: float, b: float, a: float):
    self.r_slider.set_value(r)
    self.g_slider.set_value(g)
    self.b_slider.set_value(b)
    self.a_slider.set_value(a)
</t>
<t tx="ekr.20250121054835.789">def get_value(self) -&gt; np.ndarary:
    r = self.r_slider.get_value() / 255
    g = self.g_slider.get_value() / 255
    b = self.b_slider.get_value() / 255
    alpha = self.a_slider.get_value()
    return np.array((r, g, b, alpha))
</t>
<t tx="ekr.20250121054835.79">def get_scenes_to_render(all_scene_classes: list, scene_config: Dict, run_config: Dict):
    if run_config["write_all"] or len(all_scene_classes) == 1:
        classes_to_run = all_scene_classes
    else:
        name_to_class = {sc.__name__: sc for sc in all_scene_classes}
        classes_to_run = [name_to_class.get(name) for name in run_config.scene_names]
        classes_to_run = list(filter(lambda x: x, classes_to_run))  # Remove Nones
        note_missing_scenes(run_config.scene_names, name_to_class.keys())

    if len(classes_to_run) == 0:
        classes_to_run = prompt_user_for_choice(all_scene_classes)

    return [
        scene_from_class(scene_class, scene_config, run_config)
        for scene_class in classes_to_run
    ]
</t>
<t tx="ekr.20250121054835.790">def get_picked_color(self) -&gt; str:
    rgba = self.get_value()
    return rgb_to_hex(rgba[:3])
</t>
<t tx="ekr.20250121054835.791">def get_picked_opacity(self) -&gt; float:
    rgba = self.get_value()
    return rgba[3]
</t>
<t tx="ekr.20250121054835.792">class Textbox(ControlMobject):
    @others
</t>
<t tx="ekr.20250121054835.793">def __init__(
    self,
    value: str = "",
    value_type: np.dtype = np.dtype(object),
    box_kwargs: dict = {
        "width": 2.0,
        "height": 1.0,
        "fill_color": WHITE,
        "fill_opacity": 1.0,
    },
    text_kwargs: dict = {
        "color": BLUE
    },
    text_buff: float = MED_SMALL_BUFF,
    isInitiallyActive: bool = False,
    active_color: ManimColor = BLUE,
    deactive_color: ManimColor = RED,
    **kwargs
</t>
<t tx="ekr.20250121054835.794">):
    self.value_type = value_type
    self.box_kwargs = box_kwargs
    self.text_kwargs = text_kwargs
    self.text_buff = text_buff
    self.isInitiallyActive = isInitiallyActive
    self.active_color = active_color
    self.deactive_color = deactive_color

    self.isActive = self.isInitiallyActive
    self.box = Rectangle(**self.box_kwargs)
    self.box.add_mouse_press_listner(self.box_on_mouse_press)
    self.text = Text(value, **self.text_kwargs)
    super().__init__(value, self.box, self.text, **kwargs)
    self.update_text(value)
    self.active_anim(self.isActive)
    self.add_key_press_listner(self.on_key_press)

def set_value_anim(self, value: str) -&gt; None:
    self.update_text(value)
</t>
<t tx="ekr.20250121054835.795">def update_text(self, value: str) -&gt; None:
    text = self.text
    self.remove(text)
    text.__init__(value, **self.text_kwargs)
    height = text.get_height()
    text.set_width(self.box.get_width() - 2 * self.text_buff)
    if text.get_height() &gt; height:
        text.set_height(height)
    text.add_updater(lambda mob: mob.move_to(self.box))
    text.fix_in_frame()
    self.add(text)
</t>
<t tx="ekr.20250121054835.796">def active_anim(self, isActive: bool) -&gt; None:
    if isActive:
        self.box.set_stroke(self.active_color)
    else:
        self.box.set_stroke(self.deactive_color)
</t>
<t tx="ekr.20250121054835.797">def box_on_mouse_press(self, mob, event_data) -&gt; bool:
    self.isActive = not self.isActive
    self.active_anim(self.isActive)
    return False
</t>
<t tx="ekr.20250121054835.798">def on_key_press(self, mob: Mobject, event_data: dict[str, int]) -&gt; bool | None:
    symbol = event_data["symbol"]
    modifiers = event_data["modifiers"]
    char = chr(symbol)
    if mob.isActive:
        old_value = mob.get_value()
        new_value = old_value
        if char.isalnum():
            if (modifiers &amp; PygletWindowKeys.MOD_SHIFT) or (modifiers &amp; PygletWindowKeys.MOD_CAPSLOCK):
                new_value = old_value + char.upper()
            else:
                new_value = old_value + char.lower()
        elif symbol in [PygletWindowKeys.SPACE]:
            new_value = old_value + char
        elif symbol == PygletWindowKeys.TAB:
            new_value = old_value + '\t'
        elif symbol == PygletWindowKeys.BACKSPACE:
            new_value = old_value[:-1] or ''
        mob.set_value(new_value)
        return False
</t>
<t tx="ekr.20250121054835.799">class ControlPanel(Group):
    @others
</t>
<t tx="ekr.20250121054835.8">def construct(self):
    # To run this scene properly, you should have "Consolas" font in your computer
    # for full usage, you can see https://github.com/3b1b/manim/pull/680
    text = Text("Here is a text", font="Consolas", font_size=90)
    difference = Text(
        """
        The most important difference between Text and TexText is that\n
        you can change the font more easily, but can't use the LaTeX grammar
        """,
        font="Arial", font_size=24,
        # t2c is a dict that you can choose color for different text
        t2c={"Text": BLUE, "TexText": BLUE, "LaTeX": ORANGE}
    )
    VGroup(text, difference).arrange(DOWN, buff=1)
    self.play(Write(text))
    self.play(FadeIn(difference, UP))
    self.wait(3)

    fonts = Text(
        "And you can also set the font according to different words",
        font="Arial",
        t2f={"font": "Consolas", "words": "Consolas"},
        t2c={"font": BLUE, "words": GREEN}
    )
    fonts.set_width(FRAME_WIDTH - 1)
    slant = Text(
        "And the same as slant and weight",
        font="Consolas",
        t2s={"slant": ITALIC},
        t2w={"weight": BOLD},
        t2c={"slant": ORANGE, "weight": RED}
    )
    VGroup(fonts, slant).arrange(DOWN, buff=0.8)
    self.play(FadeOut(text), FadeOut(difference, shift=DOWN))
    self.play(Write(fonts))
    self.wait()
    self.play(Write(slant))
    self.wait()
</t>
<t tx="ekr.20250121054835.80">def get_scene_classes(module: Optional[Module]):
    if module is None:
        # If no module was passed in, just play the blank scene
        return [BlankScene]
    if hasattr(module, "SCENES_IN_ORDER"):
        return module.SCENES_IN_ORDER
    else:
        return [
            member[1]
            for member in inspect.getmembers(
                module,
                lambda x: is_child_scene(x, module)
            )
        ]
</t>
<t tx="ekr.20250121054835.800">def __init__(
    self,
    *controls: ControlMobject,
    panel_kwargs: dict = {
        "width": FRAME_WIDTH / 4,
        "height": MED_SMALL_BUFF + FRAME_HEIGHT,
        "fill_color": GREY_C,
        "fill_opacity": 1.0,
        "stroke_width": 0.0
    },
    opener_kwargs: dict = {
        "width": FRAME_WIDTH / 8,
        "height": 0.5,
        "fill_color": GREY_C,
        "fill_opacity": 1.0
    },
    opener_text_kwargs: dict = {
        "text": "Control Panel",
        "font_size": 20
    },
    **kwargs
):
    self.panel_kwargs = panel_kwargs
    self.opener_kwargs = opener_kwargs
    self.opener_text_kwargs = opener_text_kwargs

    self.panel = Rectangle(**self.panel_kwargs)
    self.panel.to_corner(UP + LEFT, buff=0)
    self.panel.shift(self.panel.get_height() * UP)
    self.panel.add_mouse_scroll_listner(self.panel_on_mouse_scroll)

    self.panel_opener_rect = Rectangle(**self.opener_kwargs)
    self.panel_info_text = Text(**self.opener_text_kwargs)
    self.panel_info_text.move_to(self.panel_opener_rect)

    self.panel_opener = Group(self.panel_opener_rect, self.panel_info_text)
    self.panel_opener.next_to(self.panel, DOWN, aligned_edge=DOWN)
    self.panel_opener.add_mouse_drag_listner(self.panel_opener_on_mouse_drag)

    self.controls = Group(*controls)
    self.controls.arrange(DOWN, center=False, aligned_edge=ORIGIN)
    self.controls.move_to(self.panel)

    super().__init__(
        self.panel, self.panel_opener,
        self.controls,
        **kwargs
    )

    self.move_panel_and_controls_to_panel_opener()
    self.fix_in_frame()
</t>
<t tx="ekr.20250121054835.801">def move_panel_and_controls_to_panel_opener(self) -&gt; None:
    self.panel.next_to(
        self.panel_opener_rect,
        direction=UP,
        buff=0
    )

    controls_old_x = self.controls.get_x()
    self.controls.next_to(
        self.panel_opener_rect,
        direction=UP,
        buff=MED_SMALL_BUFF
    )

    self.controls.set_x(controls_old_x)
</t>
<t tx="ekr.20250121054835.802">def add_controls(self, *new_controls: ControlMobject) -&gt; None:
    self.controls.add(*new_controls)
    self.move_panel_and_controls_to_panel_opener()
</t>
<t tx="ekr.20250121054835.803">def remove_controls(self, *controls_to_remove: ControlMobject) -&gt; None:
    self.controls.remove(*controls_to_remove)
    self.move_panel_and_controls_to_panel_opener()
</t>
<t tx="ekr.20250121054835.804">def open_panel(self):
    panel_opener_x = self.panel_opener.get_x()
    self.panel_opener.to_corner(DOWN + LEFT, buff=0.0)
    self.panel_opener.set_x(panel_opener_x)
    self.move_panel_and_controls_to_panel_opener()
    return self
</t>
<t tx="ekr.20250121054835.805">def close_panel(self):
    panel_opener_x = self.panel_opener.get_x()
    self.panel_opener.to_corner(UP + LEFT, buff=0.0)
    self.panel_opener.set_x(panel_opener_x)
    self.move_panel_and_controls_to_panel_opener()
    return self
</t>
<t tx="ekr.20250121054835.806">def panel_opener_on_mouse_drag(self, mob, event_data: dict[str, np.ndarray]) -&gt; bool:
    point = event_data["point"]
    self.panel_opener.match_y(Dot(point))
    self.move_panel_and_controls_to_panel_opener()
    return False
</t>
<t tx="ekr.20250121054835.807">def panel_on_mouse_scroll(self, mob, event_data: dict[str, np.ndarray]) -&gt; bool:
    offset = event_data["offset"]
    factor = 10 * offset[1]
    self.controls.set_y(self.controls.get_y() + factor)
    return False
</t>
<t tx="ekr.20250121054835.808">from __future__ import annotations

import numpy as np

from manimlib.constants import DOWN, LEFT, RIGHT, ORIGIN
from manimlib.constants import DEG
from manimlib.mobject.numbers import DecimalNumber
from manimlib.mobject.svg.tex_mobject import Tex
from manimlib.mobject.types.vectorized_mobject import VGroup
from manimlib.mobject.types.vectorized_mobject import VMobject

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Sequence, Union, Optional
    from manimlib.typing import ManimColor, Vect3, VectNArray, Self

    StringMatrixType = Union[Sequence[Sequence[str]], np.ndarray[int, np.dtype[np.str_]]]
    FloatMatrixType = Union[Sequence[Sequence[float]], VectNArray]
    VMobjectMatrixType = Sequence[Sequence[VMobject]]
    GenericMatrixType = Union[FloatMatrixType, StringMatrixType, VMobjectMatrixType]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.809">class Matrix(VMobject):
    @others
</t>
<t tx="ekr.20250121054835.81">def get_indent(code_lines: list[str], line_number: int) -&gt; str:
    """
    Find the indent associated with a given line of python code,
    as a string of spaces
    """
    # Find most recent non-empty line
    try:
        line = next(filter(lambda line: line.strip(), code_lines[line_number - 1::-1]))
    except StopIteration:
        return ""

    # Either return its leading spaces, or add for if it ends with colon
    n_spaces = len(line) - len(line.lstrip())
    if line.endswith(":"):
        n_spaces += 4
    return n_spaces * " "
</t>
<t tx="ekr.20250121054835.810">def __init__(
    self,
    matrix: GenericMatrixType,
    v_buff: float = 0.5,
    h_buff: float = 0.5,
    bracket_h_buff: float = 0.2,
    bracket_v_buff: float = 0.25,
    height: float | None = None,
    element_config: dict = dict(),
    element_alignment_corner: Vect3 = DOWN,
    ellipses_row: Optional[int] = None,
    ellipses_col: Optional[int] = None,
</t>
<t tx="ekr.20250121054835.811">):
    """
    Matrix can either include numbers, tex_strings,
    or mobjects
    """
    super().__init__()

    self.mob_matrix = self.create_mobject_matrix(
        matrix, v_buff, h_buff, element_alignment_corner,
        **element_config
    )

    # Create helpful groups for the elements
    n_cols = len(self.mob_matrix[0])
    self.elements = [elem for row in self.mob_matrix for elem in row]
    self.columns = VGroup(*(
        VGroup(*(row[i] for row in self.mob_matrix))
        for i in range(n_cols)
    ))
    self.rows = VGroup(*(VGroup(*row) for row in self.mob_matrix))
    if height is not None:
        self.rows.set_height(height - 2 * bracket_v_buff)
    self.brackets = self.create_brackets(self.rows, bracket_v_buff, bracket_h_buff)
    self.ellipses = []

    # Add elements and brackets
    self.add(*self.elements)
    self.add(*self.brackets)
    self.center()

    # Potentially add ellipses
    self.swap_entries_for_ellipses(
        ellipses_row,
        ellipses_col,
    )

def copy(self, deep: bool = False):
    result = super().copy(deep)
    self_family = self.get_family()
    copy_family = result.get_family()
    for attr in ["elements", "ellipses"]:
        setattr(result, attr, [
            copy_family[self_family.index(mob)]
            for mob in getattr(self, attr)
        ])
    return result
</t>
<t tx="ekr.20250121054835.812">def create_mobject_matrix(
    self,
    matrix: GenericMatrixType,
    v_buff: float,
    h_buff: float,
    aligned_corner: Vect3,
    **element_config
) -&gt; VMobjectMatrixType:
    """
    Creates and organizes the matrix of mobjects
    """
    mob_matrix = [
        [
            self.element_to_mobject(element, **element_config)
            for element in row
        ]
        for row in matrix
    ]
    max_width = max(elem.get_width() for row in mob_matrix for elem in row)
    max_height = max(elem.get_height() for row in mob_matrix for elem in row)
    x_step = (max_width + h_buff) * RIGHT
    y_step = (max_height + v_buff) * DOWN
    for i, row in enumerate(mob_matrix):
        for j, elem in enumerate(row):
            elem.move_to(i * y_step + j * x_step, aligned_corner)
    return mob_matrix
</t>
<t tx="ekr.20250121054835.813">def element_to_mobject(self, element, **config) -&gt; VMobject:
    if isinstance(element, VMobject):
        return element
    elif isinstance(element, float | complex):
        return DecimalNumber(element, **config)
    else:
        return Tex(str(element), **config)
</t>
<t tx="ekr.20250121054835.814">def create_brackets(self, rows, v_buff: float, h_buff: float) -&gt; VGroup:
    brackets = Tex("".join((
        R"\left[\begin{array}{c}",
        *len(rows) * [R"\quad \\"],
        R"\end{array}\right]",
    )))
    brackets.set_height(rows.get_height() + v_buff)
    l_bracket = brackets[:len(brackets) // 2]
    r_bracket = brackets[len(brackets) // 2:]
    l_bracket.next_to(rows, LEFT, h_buff)
    r_bracket.next_to(rows, RIGHT, h_buff)
    return VGroup(l_bracket, r_bracket)
</t>
<t tx="ekr.20250121054835.815">def get_column(self, index: int):
    if not 0 &lt;= index &lt; len(self.columns):
        raise IndexError(f"Index {index} out of bound for matrix with {len(self.columns)} columns")
    return self.columns[index]
</t>
<t tx="ekr.20250121054835.816">def get_row(self, index: int):
    if not 0 &lt;= index &lt; len(self.rows):
        raise IndexError(f"Index {index} out of bound for matrix with {len(self.rows)} rows")
    return self.rows[index]
</t>
<t tx="ekr.20250121054835.817">def get_columns(self) -&gt; VGroup:
    return self.columns
</t>
<t tx="ekr.20250121054835.818">def get_rows(self) -&gt; VGroup:
    return self.rows
</t>
<t tx="ekr.20250121054835.819">def set_column_colors(self, *colors: ManimColor) -&gt; Self:
    columns = self.get_columns()
    for color, column in zip(colors, columns):
        column.set_color(color)
    return self
</t>
<t tx="ekr.20250121054835.82">def insert_embed_line_to_module(module: Module, run_config: Dict) -&gt; None:
    """
    This is hacky, but convenient. When user includes the argument "-e", it will try
    to recreate a file that inserts the line `self.embed()` into the end of the scene's
    construct method. If there is an argument passed in, it will insert the line after
    the last line in the sourcefile which includes that string.
    """
    lines = inspect.getsource(module).splitlines()
    line_number = run_config.embed_line

    # Add the relevant embed line to the code
    indent = get_indent(lines, line_number)
    lines.insert(line_number, indent + "self.embed()")
    new_code = "\n".join(lines)

    # When the user executes the `-e &lt;line_number&gt;` command
    # without specifying scene_names, the nearest class name above
    # `&lt;line_number&gt;` will be automatically used as 'scene_names'.

    if not run_config.scene_names:
        classes = list(filter(lambda line: line.startswith("class"), lines[:line_number]))
        if classes:
            from re import search

            scene_name = search(r"(\w+)\(", classes[-1])
            run_config.update(scene_names=[scene_name.group(1)])
        else:
            log.error(f"No 'class' found above {line_number}!")

    # Execute the code, which presumably redefines the user's
    # scene to include this embed line, within the relevant module.
    code_object = compile(new_code, module.__name__, 'exec')
    exec(code_object, module.__dict__)
</t>
<t tx="ekr.20250121054835.820">def add_background_to_entries(self) -&gt; Self:
    for mob in self.get_entries():
        mob.add_background_rectangle()
    return self
</t>
<t tx="ekr.20250121054835.821">def swap_entry_for_dots(self, entry, dots):
    dots.move_to(entry)
    entry.become(dots)
    if entry in self.elements:
        self.elements.remove(entry)
    if entry not in self.ellipses:
        self.ellipses.append(entry)
</t>
<t tx="ekr.20250121054835.822">def swap_entries_for_ellipses(
    self,
    row_index: Optional[int] = None,
    col_index: Optional[int] = None,
    height_ratio: float = 0.65,
    width_ratio: float = 0.4
):
    rows = self.get_rows()
    cols = self.get_columns()

    avg_row_height = rows.get_height() / len(rows)
    vdots_height = height_ratio * avg_row_height

    avg_col_width = cols.get_width() / len(cols)
    hdots_width = width_ratio * avg_col_width

    use_vdots = row_index is not None and -len(rows) &lt;= row_index &lt; len(rows)
    use_hdots = col_index is not None and -len(cols) &lt;= col_index &lt; len(cols)

    if use_vdots:
        for column in cols:
            # Add vdots
            dots = Tex(R"\vdots")
            dots.set_height(vdots_height)
            self.swap_entry_for_dots(column[row_index], dots)
    if use_hdots:
        for row in rows:
            # Add hdots
            dots = Tex(R"\hdots")
            dots.set_width(hdots_width)
            self.swap_entry_for_dots(row[col_index], dots)
    if use_vdots and use_hdots:
        rows[row_index][col_index].rotate(-45 * DEG)
    return self
</t>
<t tx="ekr.20250121054835.823">def get_mob_matrix(self) -&gt; VMobjectMatrixType:
    return self.mob_matrix
</t>
<t tx="ekr.20250121054835.824">def get_entries(self) -&gt; VGroup:
    return VGroup(*self.elements)
</t>
<t tx="ekr.20250121054835.825">def get_brackets(self) -&gt; VGroup:
    return VGroup(*self.brackets)
</t>
<t tx="ekr.20250121054835.826">def get_ellipses(self) -&gt; VGroup:
    return VGroup(*self.ellipses)
</t>
<t tx="ekr.20250121054835.827">class DecimalMatrix(Matrix):
    @others
</t>
<t tx="ekr.20250121054835.828">def __init__(
    self,
    matrix: FloatMatrixType,
    num_decimal_places: int = 2,
    decimal_config: dict = dict(),
    **config
</t>
<t tx="ekr.20250121054835.829">):
    self.float_matrix = matrix
    super().__init__(
        matrix,
        element_config=dict(
            num_decimal_places=num_decimal_places,
            **decimal_config
        ),
        **config
    )

def element_to_mobject(self, element, **decimal_config) -&gt; DecimalNumber:
    return DecimalNumber(element, **decimal_config)
</t>
<t tx="ekr.20250121054835.83">def get_module(run_config: Dict) -&gt; Module:
    module = ModuleLoader.get_module(run_config.file_name, run_config.is_reload)
    if run_config.embed_line:
        insert_embed_line_to_module(module, run_config)
    return module
</t>
<t tx="ekr.20250121054835.830">class IntegerMatrix(DecimalMatrix):
    @others
    ):
        super().__init__(matrix, num_decimal_places, decimal_config, **config)
</t>
<t tx="ekr.20250121054835.831">def __init__(
    self,
    matrix: FloatMatrixType,
    num_decimal_places: int = 0,
    decimal_config: dict = dict(),
    **config
</t>
<t tx="ekr.20250121054835.832">class TexMatrix(Matrix):
    @others
    ):
        super().__init__(
            matrix,
            element_config=tex_config,
            **config
        )
</t>
<t tx="ekr.20250121054835.833">def __init__(
    self,
    matrix: StringMatrixType,
    tex_config: dict = dict(),
    **config,
</t>
<t tx="ekr.20250121054835.834">class MobjectMatrix(Matrix):
    @others
</t>
<t tx="ekr.20250121054835.835">def __init__(
    self,
    group: VGroup,
    n_rows: int | None = None,
    n_cols: int | None = None,
    height: float = 4.0,
    element_alignment_corner=ORIGIN,
    **config,
):
    # Have fallback defaults of n_rows and n_cols
    n_mobs = len(group)
    if n_rows is None:
        n_rows = int(np.sqrt(n_mobs)) if n_cols is None else n_mobs // n_cols
    if n_cols is None:
        n_cols = n_mobs // n_rows

    if len(group) &lt; n_rows * n_cols:
        raise Exception("Input to MobjectMatrix must have at least n_rows * n_cols entries")

    mob_matrix = [
        [group[n * n_cols + k] for k in range(n_cols)]
        for n in range(n_rows)
    ]
    config.update(
        height=height,
        element_alignment_corner=element_alignment_corner,
    )
    super().__init__(mob_matrix,  **config)
</t>
<t tx="ekr.20250121054835.836">def element_to_mobject(self, element: VMobject, **config) -&gt; VMobject:
    return element
</t>
<t tx="ekr.20250121054835.837">from __future__ import annotations

import copy
from functools import wraps
import itertools as it
import os
import pickle
import random
import sys

import moderngl
import numbers
import numpy as np

from manimlib.constants import DEFAULT_MOBJECT_TO_EDGE_BUFF
from manimlib.constants import DEFAULT_MOBJECT_TO_MOBJECT_BUFF
from manimlib.constants import DOWN, IN, LEFT, ORIGIN, OUT, RIGHT, UP
from manimlib.constants import FRAME_X_RADIUS, FRAME_Y_RADIUS
from manimlib.constants import MED_SMALL_BUFF
from manimlib.constants import TAU
from manimlib.constants import WHITE
from manimlib.event_handler import EVENT_DISPATCHER
from manimlib.event_handler.event_listner import EventListener
from manimlib.event_handler.event_type import EventType
from manimlib.logger import log
from manimlib.shader_wrapper import ShaderWrapper
from manimlib.utils.color import color_gradient
from manimlib.utils.color import color_to_rgb
from manimlib.utils.color import get_colormap_list
from manimlib.utils.color import rgb_to_hex
from manimlib.utils.iterables import arrays_match
from manimlib.utils.iterables import array_is_constant
from manimlib.utils.iterables import batch_by_property
from manimlib.utils.iterables import list_update
from manimlib.utils.iterables import listify
from manimlib.utils.iterables import resize_array
from manimlib.utils.iterables import resize_preserving_order
from manimlib.utils.iterables import resize_with_interpolation
from manimlib.utils.bezier import integer_interpolate
from manimlib.utils.bezier import interpolate
from manimlib.utils.paths import straight_path
from manimlib.utils.shaders import get_colormap_code
from manimlib.utils.space_ops import angle_of_vector
from manimlib.utils.space_ops import get_norm
from manimlib.utils.space_ops import rotation_matrix_transpose

from typing import TYPE_CHECKING
from typing import TypeVar, Generic, Iterable
SubmobjectType = TypeVar('SubmobjectType', bound='Mobject')


if TYPE_CHECKING:
    from typing import Callable, Iterator, Union, Tuple, Optional, Any
    import numpy.typing as npt
    from manimlib.typing import ManimColor, Vect3, Vect4, Vect3Array, UniformDict, Self
    from moderngl.context import Context

    T = TypeVar('T')
    TimeBasedUpdater = Callable[["Mobject", float], "Mobject" | None]
    NonTimeUpdater = Callable[["Mobject"], "Mobject" | None]
    Updater = Union[TimeBasedUpdater, NonTimeUpdater]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.838">class Mobject(object):
    """
    Mathematical Object
    """
    @others
</t>
<t tx="ekr.20250121054835.839">dim: int = 3
shader_folder: str = ""
render_primitive: int = moderngl.TRIANGLE_STRIP
# Must match in attributes of vert shader
data_dtype: np.dtype = np.dtype([
    ('point', np.float32, (3,)),
    ('rgba', np.float32, (4,)),
])
aligned_data_keys = ['point']
pointlike_data_keys = ['point']

def __init__(
    self,
    color: ManimColor = WHITE,
    opacity: float = 1.0,
    shading: Tuple[float, float, float] = (0.0, 0.0, 0.0),
    # For shaders
    texture_paths: dict[str, str] | None = None,
    # If true, the mobject will not get rotated according to camera position
    is_fixed_in_frame: bool = False,
    depth_test: bool = False,
    z_index: int = 0,
</t>
<t tx="ekr.20250121054835.84">def main(scene_config: Dict, run_config: Dict):
    module = get_module(run_config)
    all_scene_classes = get_scene_classes(module)
    scenes = get_scenes_to_render(all_scene_classes, scene_config, run_config)
    if len(scenes) == 0:
        print("No scenes found to run")
    return scenes
</t>
<t tx="ekr.20250121054835.840">):
    self.color = color
    self.opacity = opacity
    self.shading = shading
    self.texture_paths = texture_paths
    self.depth_test = depth_test
    self.z_index = z_index

    # Internal state
    self.submobjects: list[Mobject] = []
    self.parents: list[Mobject] = []
    self.family: list[Mobject] | None = [self]
    self.locked_data_keys: set[str] = set()
    self.const_data_keys: set[str] = set()
    self.locked_uniform_keys: set[str] = set()
    self.saved_state = None
    self.target = None
    self.bounding_box: Vect3Array = np.zeros((3, 3))
    self.shader_wrapper: Optional[ShaderWrapper] = None
    self._is_animating: bool = False
    self._needs_new_bounding_box: bool = True
    self._data_has_changed: bool = True
    self.shader_code_replacements: dict[str, str] = dict()

    self.init_data()
    self.init_uniforms()
    self.init_updaters()
    self.init_event_listners()
    self.init_points()
    self.init_colors()

    if self.depth_test:
        self.apply_depth_test()
    if is_fixed_in_frame:
        self.fix_in_frame()

def __str__(self):
    return self.__class__.__name__
</t>
<t tx="ekr.20250121054835.841">def __add__(self, other: Mobject) -&gt; Mobject:
    assert isinstance(other, Mobject)
    return self.get_group_class()(self, other)
</t>
<t tx="ekr.20250121054835.842">def __mul__(self, other: int) -&gt; Mobject:
    assert isinstance(other, int)
    return self.replicate(other)
</t>
<t tx="ekr.20250121054835.843">def init_data(self, length: int = 0):
    self.data = np.zeros(length, dtype=self.data_dtype)
    self._data_defaults = np.ones(1, dtype=self.data.dtype)
</t>
<t tx="ekr.20250121054835.844">def init_uniforms(self):
    self.uniforms: UniformDict = {
        "is_fixed_in_frame": 0.0,
        "shading": np.array(self.shading, dtype=float),
        "clip_plane": np.zeros(4),
    }
</t>
<t tx="ekr.20250121054835.845">def init_colors(self):
    self.set_color(self.color, self.opacity)
</t>
<t tx="ekr.20250121054835.846">def init_points(self):
    # Typically implemented in subclass, unlpess purposefully left blank
    pass
</t>
<t tx="ekr.20250121054835.847">def set_uniforms(self, uniforms: dict) -&gt; Self:
    for key, value in uniforms.items():
        if isinstance(value, np.ndarray):
            value = value.copy()
        self.uniforms[key] = value
    return self
</t>
<t tx="ekr.20250121054835.848">@property
def animate(self) -&gt; _AnimationBuilder:
    """
    Methods called with Mobject.animate.method() can be passed
    into a Scene.play call, as if you were calling 
    ApplyMethod(mobject.method)

    Borrowed from https://github.com/ManimCommunity/manim/
    """
    return _AnimationBuilder(self)
</t>
<t tx="ekr.20250121054835.849">@property
def always(self) -&gt; _UpdaterBuilder:
    """
    Methods called with mobject.always.method(*args, **kwargs)
    will result in the call mobject.method(*args, **kwargs)
    on every frame
    """
    return _UpdaterBuilder(self)
</t>
<t tx="ekr.20250121054835.85">import logging

from rich.logging import RichHandler

__all__ = ["log"]


FORMAT = "%(message)s"
logging.basicConfig(
    level=logging.WARNING, format=FORMAT, datefmt="[%X]", handlers=[RichHandler()]
)

log = logging.getLogger("manimgl")
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.850">@property
def f_always(self) -&gt; _FunctionalUpdaterBuilder:
    """
    Similar to Mobject.always, but with the intent that arguments
    are functions returning the corresponding type fit for the method
    Methods called with
    mobject.f_always.method(
        func1, func2, ...,
        kwarg1=kw_func1,
        kwarg2=kw_func2,
        ...
    )
    will result in the call
    mobject.method(
        func1(), func2(), ...,
        kwarg1=kw_func1(),
        kwarg2=kw_func2(),
        ...
    )
    on every frame
    """
    return _FunctionalUpdaterBuilder(self)
</t>
<t tx="ekr.20250121054835.851">def note_changed_data(self, recurse_up: bool = True) -&gt; Self:
    self._data_has_changed = True
    if recurse_up:
        for mob in self.parents:
            mob.note_changed_data()
    return self
</t>
<t tx="ekr.20250121054835.852">@staticmethod
def affects_data(func: Callable[..., T]) -&gt; Callable[..., T]:
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        result = func(self, *args, **kwargs)
        self.note_changed_data()
        return result
    return wrapper
</t>
<t tx="ekr.20250121054835.853">@staticmethod
def affects_family_data(func: Callable[..., T]) -&gt; Callable[..., T]:
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        result = func(self, *args, **kwargs)
        for mob in self.family_members_with_points():
            mob.note_changed_data()
        return result
    return wrapper
</t>
<t tx="ekr.20250121054835.854"># Only these methods should directly affect points
@affects_data
def set_data(self, data: np.ndarray) -&gt; Self:
    assert data.dtype == self.data.dtype
    self.resize_points(len(data))
    self.data[:] = data
    return self
</t>
<t tx="ekr.20250121054835.855">@affects_data
def resize_points(
    self,
    new_length: int,
    resize_func: Callable[[np.ndarray, int], np.ndarray] = resize_array
) -&gt; Self:
    if new_length == 0:
        if len(self.data) &gt; 0:
            self._data_defaults[:1] = self.data[:1]
    elif self.get_num_points() == 0:
        self.data = self._data_defaults.copy()

    self.data = resize_func(self.data, new_length)
    self.refresh_bounding_box()
    return self
</t>
<t tx="ekr.20250121054835.856">@affects_data
def set_points(self, points: Vect3Array | list[Vect3]) -&gt; Self:
    self.resize_points(len(points), resize_func=resize_preserving_order)
    self.data["point"][:] = points
    return self
</t>
<t tx="ekr.20250121054835.857">@affects_data
def append_points(self, new_points: Vect3Array) -&gt; Self:
    n = self.get_num_points()
    self.resize_points(n + len(new_points))
    # Have most data default to the last value
    self.data[n:] = self.data[n - 1]
    # Then read in new points
    self.data["point"][n:] = new_points
    self.refresh_bounding_box()
    return self
</t>
<t tx="ekr.20250121054835.858">@affects_family_data
def reverse_points(self) -&gt; Self:
    for mob in self.get_family():
        mob.data[:] = mob.data[::-1]
    return self
</t>
<t tx="ekr.20250121054835.859">@affects_family_data
def apply_points_function(
    self,
    func: Callable[[np.ndarray], np.ndarray],
    about_point: Vect3 | None = None,
    about_edge: Vect3 = ORIGIN,
    works_on_bounding_box: bool = False
) -&gt; Self:
    if about_point is None and about_edge is not None:
        about_point = self.get_bounding_box_point(about_edge)

    for mob in self.get_family():
        arrs = []
        if mob.has_points():
            for key in mob.pointlike_data_keys:
                arrs.append(mob.data[key])
        if works_on_bounding_box:
            arrs.append(mob.get_bounding_box())

        for arr in arrs:
            if about_point is None:
                arr[:] = func(arr)
            else:
                arr[:] = func(arr - about_point) + about_point

    if not works_on_bounding_box:
        self.refresh_bounding_box(recurse_down=True)
    else:
        for parent in self.parents:
            parent.refresh_bounding_box()
    return self
</t>
<t tx="ekr.20250121054835.86">from __future__ import annotations

import builtins
import importlib
import os
import sys
import sysconfig

from manimlib.config import manim_config
from manimlib.logger import log

Module = importlib.util.types.ModuleType


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.860">@affects_data
def match_points(self, mobject: Mobject) -&gt; Self:
    self.resize_points(len(mobject.data), resize_func=resize_preserving_order)
    for key in self.pointlike_data_keys:
        self.data[key][:] = mobject.data[key]
    return self
</t>
<t tx="ekr.20250121054835.861"># Others related to points

def get_points(self) -&gt; Vect3Array:
    return self.data["point"]
</t>
<t tx="ekr.20250121054835.862">def clear_points(self) -&gt; Self:
    self.resize_points(0)
    return self
</t>
<t tx="ekr.20250121054835.863">def get_num_points(self) -&gt; int:
    return len(self.get_points())
</t>
<t tx="ekr.20250121054835.864">def get_all_points(self) -&gt; Vect3Array:
    if self.submobjects:
        return np.vstack([sm.get_points() for sm in self.get_family()])
    else:
        return self.get_points()
</t>
<t tx="ekr.20250121054835.865">def has_points(self) -&gt; bool:
    return len(self.get_points()) &gt; 0
</t>
<t tx="ekr.20250121054835.866">def get_bounding_box(self) -&gt; Vect3Array:
    if self._needs_new_bounding_box:
        self.bounding_box[:] = self.compute_bounding_box()
        self._needs_new_bounding_box = False
    return self.bounding_box
</t>
<t tx="ekr.20250121054835.867">def compute_bounding_box(self) -&gt; Vect3Array:
    all_points = np.vstack([
        self.get_points(),
        *(
            mob.get_bounding_box()
            for mob in self.get_family()[1:]
            if mob.has_points()
        )
    ])
    if len(all_points) == 0:
        return np.zeros((3, self.dim))
    else:
        # Lower left and upper right corners
        mins = all_points.min(0)
        maxs = all_points.max(0)
        mids = (mins + maxs) / 2
        return np.array([mins, mids, maxs])
</t>
<t tx="ekr.20250121054835.868">def refresh_bounding_box(
    self,
    recurse_down: bool = False,
    recurse_up: bool = True
) -&gt; Self:
    for mob in self.get_family(recurse_down):
        mob._needs_new_bounding_box = True
    if recurse_up:
        for parent in self.parents:
            parent.refresh_bounding_box()
    return self
</t>
<t tx="ekr.20250121054835.869">def are_points_touching(
    self,
    points: Vect3Array,
    buff: float = 0
) -&gt; np.ndarray:
    bb = self.get_bounding_box()
    mins = (bb[0] - buff)
    maxs = (bb[2] + buff)
    return ((points &gt;= mins) * (points &lt;= maxs)).all(1)
</t>
<t tx="ekr.20250121054835.87">class ModuleLoader:
    """
    Utility class to load a module from a file and handle its imports.
    
    Most parts of this class are only needed for the reload functionality,
    while the `get_module` method is the main entry point to import a module.
    """
    @others
</t>
<t tx="ekr.20250121054835.870">def is_point_touching(
    self,
    point: Vect3,
    buff: float = 0
) -&gt; bool:
    return self.are_points_touching(np.array(point, ndmin=2), buff)[0]
</t>
<t tx="ekr.20250121054835.871">def is_touching(self, mobject: Mobject, buff: float = 1e-2) -&gt; bool:
    bb1 = self.get_bounding_box()
    bb2 = mobject.get_bounding_box()
    return not any((
        (bb2[2] &lt; bb1[0] - buff).any(),  # E.g. Right of mobject is left of self's left
        (bb2[0] &gt; bb1[2] + buff).any(),  # E.g. Left of mobject is right of self's right
    ))
</t>
<t tx="ekr.20250121054835.872"># Family matters

def __getitem__(self, value: int | slice) -&gt; Mobject:
    if isinstance(value, slice):
        GroupClass = self.get_group_class()
        return GroupClass(*self.split().__getitem__(value))
    return self.split().__getitem__(value)
</t>
<t tx="ekr.20250121054835.873">def __iter__(self) -&gt; Iterator[Self]:
    return iter(self.split())
</t>
<t tx="ekr.20250121054835.874">def __len__(self) -&gt; int:
    return len(self.split())
</t>
<t tx="ekr.20250121054835.875">def split(self) -&gt; list[Self]:
    return self.submobjects
</t>
<t tx="ekr.20250121054835.876">@affects_data
def note_changed_family(self, only_changed_order=False) -&gt; Self:
    self.family = None
    if not only_changed_order:
        self.refresh_has_updater_status()
        self.refresh_bounding_box()
    for parent in self.parents:
        parent.note_changed_family()
    return self
</t>
<t tx="ekr.20250121054835.877">def get_family(self, recurse: bool = True) -&gt; list[Mobject]:
    if not recurse:
        return [self]
    if self.family is None:
        # Reconstruct and save
        sub_families = (sm.get_family() for sm in self.submobjects)
        self.family = [self, *it.chain(*sub_families)]
    return self.family
</t>
<t tx="ekr.20250121054835.878">def family_members_with_points(self) -&gt; list[Mobject]:
    return [m for m in self.get_family() if len(m.data) &gt; 0]
</t>
<t tx="ekr.20250121054835.879">def get_ancestors(self, extended: bool = False) -&gt; list[Mobject]:
    """
    Returns parents, grandparents, etc.
    Order of result should be from higher members of the hierarchy down.

    If extended is set to true, it includes the ancestors of all family members,
    e.g. any other parents of a submobject
    """
    ancestors = []
    to_process = list(self.get_family(recurse=extended))
    excluded = set(to_process)
    while to_process:
        for p in to_process.pop().parents:
            if p not in excluded:
                ancestors.append(p)
                to_process.append(p)
    # Ensure mobjects highest in the hierarchy show up first
    ancestors.reverse()
    # Remove list redundancies while preserving order
    return list(dict.fromkeys(ancestors))
</t>
<t tx="ekr.20250121054835.88">@staticmethod
def get_module(file_name: str | None, is_during_reload=False) -&gt; Module | None:
    """
    Imports a module from a file and returns it.

    During reload (when the user calls `reload()` in the IPython shell), we
    also track the imported modules and reload them as well (they would be
    cached otherwise). See the reload_manager where the reload parameter is set.

    Note that `exec_module()` is called twice when reloading a module:
    1. In exec_module_and_track_imports to track the imports
    2. Here to actually execute the module again with the respective
       imported modules reloaded.
    """
    if file_name is None:
        return None

    module_name = file_name.replace(os.sep, ".").replace(".py", "")
    spec = importlib.util.spec_from_file_location(module_name, file_name)
    module = importlib.util.module_from_spec(spec)

    if is_during_reload:
        imported_modules = ModuleLoader._exec_module_and_track_imports(spec, module)
        reloaded_modules_tracker = set()
        ModuleLoader._reload_modules(imported_modules, reloaded_modules_tracker)

    spec.loader.exec_module(module)
    return module
</t>
<t tx="ekr.20250121054835.880">def add(self, *mobjects: Mobject) -&gt; Self:
    if self in mobjects:
        raise Exception("Mobject cannot contain self")
    for mobject in mobjects:
        if mobject not in self.submobjects:
            self.submobjects.append(mobject)
        if self not in mobject.parents:
            mobject.parents.append(self)
    self.note_changed_family()
    return self
</t>
<t tx="ekr.20250121054835.881">def remove(
    self,
    *to_remove: Mobject,
    reassemble: bool = True,
    recurse: bool = True
) -&gt; Self:
    for parent in self.get_family(recurse):
        for child in to_remove:
            if child in parent.submobjects:
                parent.submobjects.remove(child)
            if parent in child.parents:
                child.parents.remove(parent)
        if reassemble:
            parent.note_changed_family()
    return self
</t>
<t tx="ekr.20250121054835.882">def clear(self) -&gt; Self:
    self.remove(*self.submobjects, recurse=False)
    return self
</t>
<t tx="ekr.20250121054835.883">def add_to_back(self, *mobjects: Mobject) -&gt; Self:
    self.set_submobjects(list_update(mobjects, self.submobjects))
    return self
</t>
<t tx="ekr.20250121054835.884">def replace_submobject(self, index: int, new_submob: Mobject) -&gt; Self:
    old_submob = self.submobjects[index]
    if self in old_submob.parents:
        old_submob.parents.remove(self)
    self.submobjects[index] = new_submob
    new_submob.parents.append(self)
    self.note_changed_family()
    return self
</t>
<t tx="ekr.20250121054835.885">def insert_submobject(self, index: int, new_submob: Mobject) -&gt; Self:
    self.submobjects.insert(index, new_submob)
    self.note_changed_family()
    return self
</t>
<t tx="ekr.20250121054835.886">def set_submobjects(self, submobject_list: list[Mobject]) -&gt; Self:
    if self.submobjects == submobject_list:
        return self
    self.clear()
    self.add(*submobject_list)
    return self
</t>
<t tx="ekr.20250121054835.887">def digest_mobject_attrs(self) -&gt; Self:
    """
    Ensures all attributes which are mobjects are included
    in the submobjects list.
    """
    mobject_attrs = [x for x in list(self.__dict__.values()) if isinstance(x, Mobject)]
    self.set_submobjects(list_update(self.submobjects, mobject_attrs))
    return self
</t>
<t tx="ekr.20250121054835.888"># Submobject organization

def arrange(
    self,
    direction: Vect3 = RIGHT,
    center: bool = True,
    **kwargs
) -&gt; Self:
    for m1, m2 in zip(self.submobjects, self.submobjects[1:]):
        m2.next_to(m1, direction, **kwargs)
    if center:
        self.center()
    return self
</t>
<t tx="ekr.20250121054835.889">def arrange_in_grid(
    self,
    n_rows: int | None = None,
    n_cols: int | None = None,
    buff: float | None = None,
    h_buff: float | None = None,
    v_buff: float | None = None,
    buff_ratio: float | None = None,
    h_buff_ratio: float = 0.5,
    v_buff_ratio: float = 0.5,
    aligned_edge: Vect3 = ORIGIN,
    fill_rows_first: bool = True
) -&gt; Self:
    submobs = self.submobjects
    n_submobs = len(submobs)
    if n_rows is None:
        n_rows = int(np.sqrt(n_submobs)) if n_cols is None else n_submobs // n_cols
    if n_cols is None:
        n_cols = n_submobs // n_rows

    if buff is not None:
        h_buff = buff
        v_buff = buff
    else:
        if buff_ratio is not None:
            v_buff_ratio = buff_ratio
            h_buff_ratio = buff_ratio
        if h_buff is None:
            h_buff = h_buff_ratio * self[0].get_width()
        if v_buff is None:
            v_buff = v_buff_ratio * self[0].get_height()

    x_unit = h_buff + max([sm.get_width() for sm in submobs])
    y_unit = v_buff + max([sm.get_height() for sm in submobs])

    for index, sm in enumerate(submobs):
        if fill_rows_first:
            x, y = index % n_cols, index // n_cols
        else:
            x, y = index // n_rows, index % n_rows
        sm.move_to(ORIGIN, aligned_edge)
        sm.shift(x * x_unit * RIGHT + y * y_unit * DOWN)
    self.center()
    return self
</t>
<t tx="ekr.20250121054835.89">@staticmethod
def _exec_module_and_track_imports(spec, module: Module) -&gt; set[str]:
    """
    Executes the given module (imports it) and returns all the modules that
    are imported during its execution.

    This is achieved by replacing the __import__ function with a custom one
    that tracks the imported modules. At the end, the original __import__
    built-in function is restored.
    """
    imported_modules: set[str] = set()
    original_import = builtins.__import__

    def tracked_import(name, globals=None, locals=None, fromlist=(), level=0):
        """
        Custom __import__ function that does exactly the same as the original
        one, but also tracks the imported modules by means of adding their
        names to a set.
        """
        result = original_import(name, globals, locals, fromlist, level)
        imported_modules.add(name)
        return result

    builtins.__import__ = tracked_import

    try:
        module_name = module.__name__
        log.debug('Reloading module "%s"', module_name)

        spec.loader.exec_module(module)
    finally:
        builtins.__import__ = original_import

    return imported_modules
</t>
<t tx="ekr.20250121054835.890">def arrange_to_fit_dim(self, length: float, dim: int, about_edge=ORIGIN) -&gt; Self:
    ref_point = self.get_bounding_box_point(about_edge)
    n_submobs = len(self.submobjects)
    if n_submobs &lt;= 1:
        return
    total_length = sum(sm.length_over_dim(dim) for sm in self.submobjects)
    buff = (length - total_length) / (n_submobs - 1)
    vect = np.zeros(self.dim)
    vect[dim] = 1
    x = 0
    for submob in self.submobjects:
        submob.set_coord(x, dim, -vect)
        x += submob.length_over_dim(dim) + buff
    self.move_to(ref_point, about_edge)
    return self
</t>
<t tx="ekr.20250121054835.891">def arrange_to_fit_width(self, width: float, about_edge=ORIGIN) -&gt; Self:
    return self.arrange_to_fit_dim(width, 0, about_edge)
</t>
<t tx="ekr.20250121054835.892">def arrange_to_fit_height(self, height: float, about_edge=ORIGIN) -&gt; Self:
    return self.arrange_to_fit_dim(height, 1, about_edge)
</t>
<t tx="ekr.20250121054835.893">def arrange_to_fit_depth(self, depth: float, about_edge=ORIGIN) -&gt; Self:
    return self.arrange_to_fit_dim(depth, 2, about_edge)
</t>
<t tx="ekr.20250121054835.894">def sort(
    self,
    point_to_num_func: Callable[[np.ndarray], float] = lambda p: p[0],
    submob_func: Callable[[Mobject]] | None = None
) -&gt; Self:
    if submob_func is not None:
        self.submobjects.sort(key=submob_func)
    else:
        self.submobjects.sort(key=lambda m: point_to_num_func(m.get_center()))
    self.note_changed_family(only_changed_order=True)
    return self
</t>
<t tx="ekr.20250121054835.895">def shuffle(self, recurse: bool = False) -&gt; Self:
    if recurse:
        for submob in self.submobjects:
            submob.shuffle(recurse=True)
    random.shuffle(self.submobjects)
    self.note_changed_family(only_changed_order=True)
    return self
</t>
<t tx="ekr.20250121054835.896">def reverse_submobjects(self) -&gt; Self:
    self.submobjects.reverse()
    self.note_changed_family(only_changed_order=True)
    return self
</t>
<t tx="ekr.20250121054835.897"># Copying and serialization

@staticmethod
def stash_mobject_pointers(func: Callable[..., T]) -&gt; Callable[..., T]:
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        uncopied_attrs = ["parents", "target", "saved_state"]
        stash = dict()
        for attr in uncopied_attrs:
            if hasattr(self, attr):
                value = getattr(self, attr)
                stash[attr] = value
                null_value = [] if isinstance(value, list) else None
                setattr(self, attr, null_value)
        result = func(self, *args, **kwargs)
        self.__dict__.update(stash)
        return result
    return wrapper
</t>
<t tx="ekr.20250121054835.898">@stash_mobject_pointers
def serialize(self) -&gt; bytes:
    return pickle.dumps(self)
</t>
<t tx="ekr.20250121054835.899">def deserialize(self, data: bytes) -&gt; Self:
    self.become(pickle.loads(data))
    return self
</t>
<t tx="ekr.20250121054835.9">class TexTransformExample(Scene):
    @others
</t>
<t tx="ekr.20250121054835.90">@staticmethod
def _reload_modules(modules: set[str], reloaded_modules_tracker: set[str]):
    """
    Out of the given modules, reloads the ones that were not already imported.

    We skip modules that are not user-defined (see `is_user_defined_module()`).
    """
    for mod in modules:
        if mod in reloaded_modules_tracker:
            continue

        if not ModuleLoader._is_user_defined_module(mod):
            continue

        module = sys.modules[mod]
        ModuleLoader._deep_reload(module, reloaded_modules_tracker)

        reloaded_modules_tracker.add(mod)
</t>
<t tx="ekr.20250121054835.900">@stash_mobject_pointers
def deepcopy(self) -&gt; Self:
    return copy.deepcopy(self)
</t>
<t tx="ekr.20250121054835.901">def copy(self, deep: bool = False) -&gt; Self:
    if deep:
        return self.deepcopy()

    result = copy.copy(self)

    result.parents = []
    result.target = None
    result.saved_state = None

    # copy.copy is only a shallow copy, so the internal
    # data which are numpy arrays or other mobjects still
    # need to be further copied.
    result.uniforms = {
        key: value.copy() if isinstance(value, np.ndarray) else value
        for key, value in self.uniforms.items()
    }

    # Instead of adding using result.add, which does some checks for updating
    # updater statues and bounding box, just directly modify the family-related
    # lists
    result.submobjects = [sm.copy() for sm in self.submobjects]
    for sm in result.submobjects:
        sm.parents = [result]
    result.family = [result, *it.chain(*(sm.get_family() for sm in result.submobjects))]

    # Similarly, instead of calling match_updaters, since we know the status
    # won't have changed, just directly match.
    result.updaters = list(self.updaters)
    result._data_has_changed = True
    result.shader_wrapper = None

    family = self.get_family()
    for attr, value in self.__dict__.items():
        if isinstance(value, Mobject) and value is not self:
            if value in family:
                setattr(result, attr, result.family[family.index(value)])
        elif isinstance(value, np.ndarray):
            setattr(result, attr, value.copy())
    return result
</t>
<t tx="ekr.20250121054835.902">def generate_target(self, use_deepcopy: bool = False) -&gt; Self:
    self.target = self.copy(deep=use_deepcopy)
    self.target.saved_state = self.saved_state
    return self.target
</t>
<t tx="ekr.20250121054835.903">def save_state(self, use_deepcopy: bool = False) -&gt; Self:
    self.saved_state = self.copy(deep=use_deepcopy)
    self.saved_state.target = self.target
    return self
</t>
<t tx="ekr.20250121054835.904">def restore(self) -&gt; Self:
    if not hasattr(self, "saved_state") or self.saved_state is None:
        raise Exception("Trying to restore without having saved")
    self.become(self.saved_state)
    return self
</t>
<t tx="ekr.20250121054835.905">def become(self, mobject: Mobject, match_updaters=False) -&gt; Self:
    """
    Edit all data and submobjects to be idential
    to another mobject
    """
    self.align_family(mobject)
    family1 = self.get_family()
    family2 = mobject.get_family()
    for sm1, sm2 in zip(family1, family2):
        sm1.set_data(sm2.data)
        sm1.set_uniforms(sm2.uniforms)
        sm1.bounding_box[:] = sm2.bounding_box
        sm1.shader_folder = sm2.shader_folder
        sm1.texture_paths = sm2.texture_paths
        sm1.depth_test = sm2.depth_test
        sm1.render_primitive = sm2.render_primitive
        sm1._needs_new_bounding_box = sm2._needs_new_bounding_box
    # Make sure named family members carry over
    for attr, value in list(mobject.__dict__.items()):
        if isinstance(value, Mobject) and value in family2:
            setattr(self, attr, family1[family2.index(value)])
    if match_updaters:
        self.match_updaters(mobject)
    return self
</t>
<t tx="ekr.20250121054835.906">def looks_identical(self, mobject: Mobject) -&gt; bool:
    fam1 = self.family_members_with_points()
    fam2 = mobject.family_members_with_points()
    if len(fam1) != len(fam2):
        return False
    for m1, m2 in zip(fam1, fam2):
        if m1.get_num_points() != m2.get_num_points():
            return False
        if not m1.data.dtype == m2.data.dtype:
            return False
        for key in m1.data.dtype.names:
            if not np.isclose(m1.data[key], m2.data[key]).all():
                return False
        if set(m1.uniforms).difference(m2.uniforms):
            return False
        for key in m1.uniforms:
            value1 = m1.uniforms[key]
            value2 = m2.uniforms[key]
            if isinstance(value1, np.ndarray) and isinstance(value2, np.ndarray) and not value1.size == value2.size:
                return False
            if not np.isclose(value1, value2).all():
                return False
    return True
</t>
<t tx="ekr.20250121054835.907">def has_same_shape_as(self, mobject: Mobject) -&gt; bool:
    # Normalize both point sets by centering and making height 1
    points1, points2 = (
        (m.get_all_points() - m.get_center()) / m.get_height()
        for m in (self, mobject)
    )
    if len(points1) != len(points2):
        return False
    return bool(np.isclose(points1, points2, atol=self.get_width() * 1e-2).all())
</t>
<t tx="ekr.20250121054835.908"># Creating new Mobjects from this one

def replicate(self, n: int) -&gt; Self:
    group_class = self.get_group_class()
    return group_class(*(self.copy() for _ in range(n)))
</t>
<t tx="ekr.20250121054835.909">def get_grid(
    self,
    n_rows: int,
    n_cols: int,
    height: float | None = None,
    width: float | None = None,
    group_by_rows: bool = False,
    group_by_cols: bool = False,
    **kwargs
) -&gt; Self:
    """
    Returns a new mobject containing multiple copies of this one
    arranged in a grid
    """
    total = n_rows * n_cols
    grid = self.replicate(total)
    if group_by_cols:
        kwargs["fill_rows_first"] = False
    grid.arrange_in_grid(n_rows, n_cols, **kwargs)
    if height is not None:
        grid.set_height(height)
    if width is not None:
        grid.set_height(width)

    group_class = self.get_group_class()
    if group_by_rows:
        return group_class(*(grid[n:n + n_cols] for n in range(0, total, n_cols)))
    elif group_by_cols:
        return group_class(*(grid[n:n + n_rows] for n in range(0, total, n_rows)))
    else:
        return grid
</t>
<t tx="ekr.20250121054835.91">@staticmethod
def _is_user_defined_module(mod: str) -&gt; bool:
    """
    Returns whether the given module is user-defined or not.

    A module is considered user-defined if
    - it is not part of the standard library
    - AND it is not an external library (site-packages or dist-packages)
    """
    if mod not in sys.modules:
        return False

    if mod in sys.builtin_module_names:
        return False

    module = sys.modules[mod]
    module_path = getattr(module, "__file__", None)
    if module_path is None:
        return False
    module_path = os.path.abspath(module_path)

    # External libraries (site-packages or dist-packages), e.g. numpy
    if "site-packages" in module_path or "dist-packages" in module_path:
        return False

    # Standard lib
    standard_lib_path = sysconfig.get_path("stdlib")
    if module_path.startswith(standard_lib_path):
        return False

    return True
</t>
<t tx="ekr.20250121054835.910"># Updating

def init_updaters(self):
    self.updaters: list[Updater] = list()
    self._has_updaters_in_family: Optional[bool] = False
    self.updating_suspended: bool = False
</t>
<t tx="ekr.20250121054835.911">def update(self, dt: float = 0, recurse: bool = True) -&gt; Self:
    if not self.has_updaters() or self.updating_suspended:
        return self
    if recurse:
        for submob in self.submobjects:
            submob.update(dt, recurse)
    for updater in self.updaters:
        # This is hacky, but if an updater takes dt as an arg,
        # it will be passed the change in time from here
        if "dt" in updater.__code__.co_varnames:
            updater(self, dt=dt)
        else:
            updater(self)
    return self
</t>
<t tx="ekr.20250121054835.912">def get_updaters(self) -&gt; list[Updater]:
    return self.updaters
</t>
<t tx="ekr.20250121054835.913">def add_updater(self, update_func: Updater, call: bool = True) -&gt; Self:
    self.updaters.append(update_func)
    if call:
        self.update(dt=0)
    self.refresh_has_updater_status()
    self.update()
    return self
</t>
<t tx="ekr.20250121054835.914">def insert_updater(self, update_func: Updater, index=0):
    self.updaters.insert(index, update_func)
    self.refresh_has_updater_status()
    return self
</t>
<t tx="ekr.20250121054835.915">def remove_updater(self, update_func: Updater) -&gt; Self:
    while update_func in self.updaters:
        self.updaters.remove(update_func)
    self.refresh_has_updater_status()
    return self
</t>
<t tx="ekr.20250121054835.916">def clear_updaters(self, recurse: bool = True) -&gt; Self:
    for mob in self.get_family(recurse):
        mob.updaters = []
        mob._has_updaters_in_family = False
    for parent in self.get_ancestors():
        parent._has_updaters_in_family = False
    return self
</t>
<t tx="ekr.20250121054835.917">def match_updaters(self, mobject: Mobject) -&gt; Self:
    self.updaters = list(mobject.updaters)
    self.refresh_has_updater_status()
    return self
</t>
<t tx="ekr.20250121054835.918">def suspend_updating(self, recurse: bool = True) -&gt; Self:
    self.updating_suspended = True
    if recurse:
        for submob in self.submobjects:
            submob.suspend_updating(recurse)
    return self
</t>
<t tx="ekr.20250121054835.919">def resume_updating(self, recurse: bool = True, call_updater: bool = True) -&gt; Self:
    self.updating_suspended = False
    if recurse:
        for submob in self.submobjects:
            submob.resume_updating(recurse)
    for parent in self.parents:
        parent.resume_updating(recurse=False, call_updater=False)
    if call_updater:
        self.update(dt=0, recurse=recurse)
    return self
</t>
<t tx="ekr.20250121054835.92">@staticmethod
def _deep_reload(module: Module, reloaded_modules_tracker: set[str]):
    """
    Recursively reloads modules imported by the given module.

    Only user-defined modules are reloaded, see `is_user_defined_module()`.
    """
    ignore_manimlib_modules = manim_config.ignore_manimlib_modules_on_reload
    if ignore_manimlib_modules and module.__name__.startswith("manimlib"):
        return
    if module.__name__.startswith("manimlib.config"):
        # We don't want to reload global manim_config
        return

    if not hasattr(module, "__dict__"):
        return

    # Prevent reloading the same module multiple times
    if module.__name__ in reloaded_modules_tracker:
        return
    reloaded_modules_tracker.add(module.__name__)

    # Recurse for all imported modules
    for _attr_name, attr_value in module.__dict__.items():
        if isinstance(attr_value, Module):
            if ModuleLoader._is_user_defined_module(attr_value.__name__):
                ModuleLoader._deep_reload(attr_value, reloaded_modules_tracker)

        # Also reload modules that are part of a class or function
        # e.g. when importing `from custom_module import CustomClass`
        elif hasattr(attr_value, "__module__"):
            attr_module_name = attr_value.__module__
            if ModuleLoader._is_user_defined_module(attr_module_name):
                attr_module = sys.modules[attr_module_name]
                ModuleLoader._deep_reload(attr_module, reloaded_modules_tracker)

    # Reload
    log.debug('Reloading module "%s"', module.__name__)
    importlib.reload(module)
</t>
<t tx="ekr.20250121054835.920">def has_updaters(self) -&gt; bool:
    if self._has_updaters_in_family is None:
        # Recompute and save
        self._has_updaters_in_family = bool(self.updaters) or any(
            sm.has_updaters() for sm in self.submobjects
        )
    return self._has_updaters_in_family
</t>
<t tx="ekr.20250121054835.921">def refresh_has_updater_status(self) -&gt; Self:
    self._has_updaters_in_family = None
    for parent in self.parents:
        parent.refresh_has_updater_status()
    return self
</t>
<t tx="ekr.20250121054835.922"># Check if mark as static or not for camera

def is_changing(self) -&gt; bool:
    return self._is_animating or self.has_updaters()
</t>
<t tx="ekr.20250121054835.923">def set_animating_status(self, is_animating: bool, recurse: bool = True) -&gt; Self:
    for mob in (*self.get_family(recurse), *self.get_ancestors()):
        mob._is_animating = is_animating
    return self
</t>
<t tx="ekr.20250121054835.924"># Transforming operations

def shift(self, vector: Vect3) -&gt; Self:
    self.apply_points_function(
        lambda points: points + vector,
        about_edge=None,
        works_on_bounding_box=True,
    )
    return self
</t>
<t tx="ekr.20250121054835.925">def scale(
    self,
    scale_factor: float | npt.ArrayLike,
    min_scale_factor: float = 1e-8,
    about_point: Vect3 | None = None,
    about_edge: Vect3 = ORIGIN
) -&gt; Self:
    """
    Default behavior is to scale about the center of the mobject.
    The argument about_edge can be a vector, indicating which side of
    the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)
    scales about mob.get_right().

    Otherwise, if about_point is given a value, scaling is done with
    respect to that point.
    """
    if isinstance(scale_factor, numbers.Number):
        scale_factor = max(scale_factor, min_scale_factor)
    else:
        scale_factor = np.array(scale_factor).clip(min=min_scale_factor)
    self.apply_points_function(
        lambda points: scale_factor * points,
        about_point=about_point,
        about_edge=about_edge,
        works_on_bounding_box=True,
    )
    for mob in self.get_family():
        mob._handle_scale_side_effects(scale_factor)
    return self
</t>
<t tx="ekr.20250121054835.926">def _handle_scale_side_effects(self, scale_factor):
    # In case subclasses, such as DecimalNumber, need to make
    # any other changes when the size gets altered
    pass
</t>
<t tx="ekr.20250121054835.927">def stretch(self, factor: float, dim: int, **kwargs) -&gt; Self:
    def func(points):
        points[:, dim] *= factor
        return points
    self.apply_points_function(func, works_on_bounding_box=True, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.928">def rotate_about_origin(self, angle: float, axis: Vect3 = OUT) -&gt; Self:
    return self.rotate(angle, axis, about_point=ORIGIN)
</t>
<t tx="ekr.20250121054835.929">def rotate(
    self,
    angle: float,
    axis: Vect3 = OUT,
    about_point: Vect3 | None = None,
    **kwargs
) -&gt; Self:
    rot_matrix_T = rotation_matrix_transpose(angle, axis)
    self.apply_points_function(
        lambda points: np.dot(points, rot_matrix_T),
        about_point,
        **kwargs
    )
    return self
</t>
<t tx="ekr.20250121054835.93">from __future__ import annotations

import copy
import os
import re

import OpenGL.GL as gl
import moderngl
import numpy as np
from functools import lru_cache

from manimlib.config import parse_cli
from manimlib.config import manim_config
from manimlib.utils.shaders import get_shader_code_from_file
from manimlib.utils.shaders import get_shader_program
from manimlib.utils.shaders import image_path_to_texture
from manimlib.utils.shaders import set_program_uniform

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from typing import Optional, Tuple, Iterable
    from manimlib.typing import UniformDict
    from moderngl.vertex_array import VertexArray
    from moderngl.framebuffer import Framebuffer

# Mobjects that should be rendered with
# the same shader will be organized and
# clumped together based on keeping track
# of a dict holding all the relevant information
# to that shader


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121054835.930">def flip(self, axis: Vect3 = UP, **kwargs) -&gt; Self:
    return self.rotate(TAU / 2, axis, **kwargs)
</t>
<t tx="ekr.20250121054835.931">def apply_function(self, function: Callable[[np.ndarray], np.ndarray], **kwargs) -&gt; Self:
    # Default to applying matrix about the origin, not mobjects center
    if len(kwargs) == 0:
        kwargs["about_point"] = ORIGIN
    self.apply_points_function(
        lambda points: np.array([function(p) for p in points]),
        **kwargs
    )
    return self
</t>
<t tx="ekr.20250121054835.932">def apply_function_to_position(self, function: Callable[[np.ndarray], np.ndarray]) -&gt; Self:
    self.move_to(function(self.get_center()))
    return self
</t>
<t tx="ekr.20250121054835.933">def apply_function_to_submobject_positions(
    self,
    function: Callable[[np.ndarray], np.ndarray]
) -&gt; Self:
    for submob in self.submobjects:
        submob.apply_function_to_position(function)
    return self
</t>
<t tx="ekr.20250121054835.934">def apply_matrix(self, matrix: npt.ArrayLike, **kwargs) -&gt; Self:
    # Default to applying matrix about the origin, not mobjects center
    if ("about_point" not in kwargs) and ("about_edge" not in kwargs):
        kwargs["about_point"] = ORIGIN
    full_matrix = np.identity(self.dim)
    matrix = np.array(matrix)
    full_matrix[:matrix.shape[0], :matrix.shape[1]] = matrix
    self.apply_points_function(
        lambda points: np.dot(points, full_matrix.T),
        **kwargs
    )
    return self
</t>
<t tx="ekr.20250121054835.935">def apply_complex_function(self, function: Callable[[complex], complex], **kwargs) -&gt; Self:
    def R3_func(point):
        x, y, z = point
        xy_complex = function(complex(x, y))
        return [
            xy_complex.real,
            xy_complex.imag,
            z
        ]
    return self.apply_function(R3_func, **kwargs)
</t>
<t tx="ekr.20250121054835.936">def wag(
    self,
    direction: Vect3 = RIGHT,
    axis: Vect3 = DOWN,
    wag_factor: float = 1.0
) -&gt; Self:
    for mob in self.family_members_with_points():
        alphas = np.dot(mob.get_points(), np.transpose(axis))
        alphas -= min(alphas)
        alphas /= max(alphas)
        alphas = alphas**wag_factor
        mob.set_points(mob.get_points() + np.dot(
            alphas.reshape((len(alphas), 1)),
            np.array(direction).reshape((1, mob.dim))
        ))
    return self
</t>
<t tx="ekr.20250121054835.937"># Positioning methods

def center(self) -&gt; Self:
    self.shift(-self.get_center())
    return self
</t>
<t tx="ekr.20250121054835.938">def align_on_border(
    self,
    direction: Vect3,
    buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFF
) -&gt; Self:
    """
    Direction just needs to be a vector pointing towards side or
    corner in the 2d plane.
    """
    target_point = np.sign(direction) * (FRAME_X_RADIUS, FRAME_Y_RADIUS, 0)
    point_to_align = self.get_bounding_box_point(direction)
    shift_val = target_point - point_to_align - buff * np.array(direction)
    shift_val = shift_val * abs(np.sign(direction))
    self.shift(shift_val)
    return self
</t>
<t tx="ekr.20250121054835.939">def to_corner(
    self,
    corner: Vect3 = LEFT + DOWN,
    buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFF
) -&gt; Self:
    return self.align_on_border(corner, buff)
</t>
<t tx="ekr.20250121054835.94">class ShaderWrapper(object):
    @others
</t>
<t tx="ekr.20250121054835.940">def to_edge(
    self,
    edge: Vect3 = LEFT,
    buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFF
) -&gt; Self:
    return self.align_on_border(edge, buff)
</t>
<t tx="ekr.20250121054835.941">def next_to(
    self,
    mobject_or_point: Mobject | Vect3,
    direction: Vect3 = RIGHT,
    buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFF,
    aligned_edge: Vect3 = ORIGIN,
    submobject_to_align: Mobject | None = None,
    index_of_submobject_to_align: int | slice | None = None,
    coor_mask: Vect3 = np.array([1, 1, 1]),
</t>
<t tx="ekr.20250121054835.942">) -&gt; Self:
    if isinstance(mobject_or_point, Mobject):
        mob = mobject_or_point
        if index_of_submobject_to_align is not None:
            target_aligner = mob[index_of_submobject_to_align]
        else:
            target_aligner = mob
        target_point = target_aligner.get_bounding_box_point(
            aligned_edge + direction
        )
    else:
        target_point = mobject_or_point
    if submobject_to_align is not None:
        aligner = submobject_to_align
    elif index_of_submobject_to_align is not None:
        aligner = self[index_of_submobject_to_align]
    else:
        aligner = self
    point_to_align = aligner.get_bounding_box_point(aligned_edge - direction)
    self.shift((target_point - point_to_align + buff * direction) * coor_mask)
    return self

def shift_onto_screen(self, **kwargs) -&gt; Self:
    space_lengths = [FRAME_X_RADIUS, FRAME_Y_RADIUS]
    for vect in UP, DOWN, LEFT, RIGHT:
        dim = np.argmax(np.abs(vect))
        buff = kwargs.get("buff", DEFAULT_MOBJECT_TO_EDGE_BUFF)
        max_val = space_lengths[dim] - buff
        edge_center = self.get_edge_center(vect)
        if np.dot(edge_center, vect) &gt; max_val:
            self.to_edge(vect, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.943">def is_off_screen(self) -&gt; bool:
    if self.get_left()[0] &gt; FRAME_X_RADIUS:
        return True
    if self.get_right()[0] &lt; -FRAME_X_RADIUS:
        return True
    if self.get_bottom()[1] &gt; FRAME_Y_RADIUS:
        return True
    if self.get_top()[1] &lt; -FRAME_Y_RADIUS:
        return True
    return False
</t>
<t tx="ekr.20250121054835.944">def stretch_about_point(self, factor: float, dim: int, point: Vect3) -&gt; Self:
    return self.stretch(factor, dim, about_point=point)
</t>
<t tx="ekr.20250121054835.945">def stretch_in_place(self, factor: float, dim: int) -&gt; Self:
    # Now redundant with stretch
    return self.stretch(factor, dim)
</t>
<t tx="ekr.20250121054835.946">def rescale_to_fit(self, length: float, dim: int, stretch: bool = False, **kwargs) -&gt; Self:
    old_length = self.length_over_dim(dim)
    if old_length == 0:
        return self
    if stretch:
        self.stretch(length / old_length, dim, **kwargs)
    else:
        self.scale(length / old_length, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.947">def stretch_to_fit_width(self, width: float, **kwargs) -&gt; Self:
    return self.rescale_to_fit(width, 0, stretch=True, **kwargs)
</t>
<t tx="ekr.20250121054835.948">def stretch_to_fit_height(self, height: float, **kwargs) -&gt; Self:
    return self.rescale_to_fit(height, 1, stretch=True, **kwargs)
</t>
<t tx="ekr.20250121054835.949">def stretch_to_fit_depth(self, depth: float, **kwargs) -&gt; Self:
    return self.rescale_to_fit(depth, 2, stretch=True, **kwargs)
</t>
<t tx="ekr.20250121054835.95">def __init__(
    self,
    ctx: moderngl.context.Context,
    vert_data: np.ndarray,
    shader_folder: Optional[str] = None,
    mobject_uniforms: Optional[UniformDict] = None,  # A dictionary mapping names of uniform variables
    texture_paths: Optional[dict[str, str]] = None,  # A dictionary mapping names to filepaths for textures.
    depth_test: bool = False,
    render_primitive: int = moderngl.TRIANGLE_STRIP,
    code_replacements: dict[str, str] = dict(),
</t>
<t tx="ekr.20250121054835.950">def set_width(self, width: float, stretch: bool = False, **kwargs) -&gt; Self:
    return self.rescale_to_fit(width, 0, stretch=stretch, **kwargs)
</t>
<t tx="ekr.20250121054835.951">def set_height(self, height: float, stretch: bool = False, **kwargs) -&gt; Self:
    return self.rescale_to_fit(height, 1, stretch=stretch, **kwargs)
</t>
<t tx="ekr.20250121054835.952">def set_depth(self, depth: float, stretch: bool = False, **kwargs) -&gt; Self:
    return self.rescale_to_fit(depth, 2, stretch=stretch, **kwargs)
</t>
<t tx="ekr.20250121054835.953">def set_max_width(self, max_width: float, **kwargs) -&gt; Self:
    if self.get_width() &gt; max_width:
        self.set_width(max_width, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.954">def set_max_height(self, max_height: float, **kwargs) -&gt; Self:
    if self.get_height() &gt; max_height:
        self.set_height(max_height, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.955">def set_max_depth(self, max_depth: float, **kwargs) -&gt; Self:
    if self.get_depth() &gt; max_depth:
        self.set_depth(max_depth, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.956">def set_min_width(self, min_width: float, **kwargs) -&gt; Self:
    if self.get_width() &lt; min_width:
        self.set_width(min_width, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.957">def set_min_height(self, min_height: float, **kwargs) -&gt; Self:
    if self.get_height() &lt; min_height:
        self.set_height(min_height, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.958">def set_min_depth(self, min_depth: float, **kwargs) -&gt; Self:
    if self.get_depth() &lt; min_depth:
        self.set_depth(min_depth, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.959">def set_shape(
    self,
    width: Optional[float] = None,
    height: Optional[float] = None,
    depth: Optional[float] = None,
    **kwargs
) -&gt; Self:
    if width is not None:
        self.set_width(width, stretch=True, **kwargs)
    if height is not None:
        self.set_height(height, stretch=True, **kwargs)
    if depth is not None:
        self.set_depth(depth, stretch=True, **kwargs)
    return self
</t>
<t tx="ekr.20250121054835.96">):
    self.ctx = ctx
    self.vert_data = vert_data
    self.vert_attributes = vert_data.dtype.names
    self.shader_folder = shader_folder
    self.depth_test = depth_test
    self.render_primitive = render_primitive
    self.texture_paths = texture_paths or dict()

    self.program_uniform_mirror: UniformDict = dict()
    self.bind_to_mobject_uniforms(mobject_uniforms or dict())

    self.init_program_code()
    for old, new in code_replacements.items():
        self.replace_code(old, new)
    self.init_program()
    self.init_textures()
    self.init_vertex_objects()
    self.refresh_id()

def __deepcopy__(self, memo):
    # Don't allow deepcopies, e.g. if the mobject with this ShaderWrapper as an
    # attribute gets copies. Returning None means the parent object with this ShaderWrapper
    # as an attribute should smoothly handle this case.
    return None
</t>
<t tx="ekr.20250121054835.960">def set_coord(self, value: float, dim: int, direction: Vect3 = ORIGIN) -&gt; Self:
    curr = self.get_coord(dim, direction)
    shift_vect = np.zeros(self.dim)
    shift_vect[dim] = value - curr
    self.shift(shift_vect)
    return self
</t>
<t tx="ekr.20250121054835.961">def set_x(self, x: float, direction: Vect3 = ORIGIN) -&gt; Self:
    return self.set_coord(x, 0, direction)
</t>
<t tx="ekr.20250121054835.962">def set_y(self, y: float, direction: Vect3 = ORIGIN) -&gt; Self:
    return self.set_coord(y, 1, direction)
</t>
<t tx="ekr.20250121054835.963">def set_z(self, z: float, direction: Vect3 = ORIGIN) -&gt; Self:
    return self.set_coord(z, 2, direction)
</t>
<t tx="ekr.20250121054835.964">def set_z_index(self, z_index: int) -&gt; Self:
    self.z_index = z_index
    return self
</t>
<t tx="ekr.20250121054835.965">def space_out_submobjects(self, factor: float = 1.5, **kwargs) -&gt; Self:
    self.scale(factor, **kwargs)
    for submob in self.submobjects:
        submob.scale(1. / factor)
    return self
</t>
<t tx="ekr.20250121054835.966">def move_to(
    self,
    point_or_mobject: Mobject | Vect3,
    aligned_edge: Vect3 = ORIGIN,
    coor_mask: Vect3 = np.array([1, 1, 1])
</t>
<t tx="ekr.20250121054835.967">) -&gt; Self:
    if isinstance(point_or_mobject, Mobject):
        target = point_or_mobject.get_bounding_box_point(aligned_edge)
    else:
        target = point_or_mobject
    point_to_align = self.get_bounding_box_point(aligned_edge)
    self.shift((target - point_to_align) * coor_mask)
    return self

def replace(self, mobject: Mobject, dim_to_match: int = 0, stretch: bool = False) -&gt; Self:
    if not mobject.get_num_points() and not mobject.submobjects:
        self.scale(0)
        return self
    if stretch:
        for i in range(self.dim):
            self.rescale_to_fit(mobject.length_over_dim(i), i, stretch=True)
    else:
        self.rescale_to_fit(
            mobject.length_over_dim(dim_to_match),
            dim_to_match,
            stretch=False
        )
    self.shift(mobject.get_center() - self.get_center())
    return self
</t>
<t tx="ekr.20250121054835.968">def surround(
    self,
    mobject: Mobject,
    dim_to_match: int = 0,
    stretch: bool = False,
    buff: float = MED_SMALL_BUFF
) -&gt; Self:
    self.replace(mobject, dim_to_match, stretch)
    length = mobject.length_over_dim(dim_to_match)
    self.scale((length + buff) / length)
    return self
</t>
<t tx="ekr.20250121054835.969">def put_start_and_end_on(self, start: Vect3, end: Vect3) -&gt; Self:
    curr_start, curr_end = self.get_start_and_end()
    curr_vect = curr_end - curr_start
    if np.all(curr_vect == 0):
        raise Exception("Cannot position endpoints of closed loop")
    target_vect = end - start
    self.scale(
        get_norm(target_vect) / get_norm(curr_vect),
        about_point=curr_start,
    )
    self.rotate(
        angle_of_vector(target_vect) - angle_of_vector(curr_vect),
    )
    self.rotate(
        np.arctan2(curr_vect[2], get_norm(curr_vect[:2])) - np.arctan2(target_vect[2], get_norm(target_vect[:2])),
        axis=np.array([-target_vect[1], target_vect[0], 0]),
    )
    self.shift(start - self.get_start())
    return self
</t>
<t tx="ekr.20250121054835.97">def init_program_code(self) -&gt; None:
    def get_code(name: str) -&gt; str | None:
        return get_shader_code_from_file(
            os.path.join(self.shader_folder, f"{name}.glsl")
        )

    self.program_code: dict[str, str | None] = {
        "vertex_shader": get_code("vert"),
        "geometry_shader": get_code("geom"),
        "fragment_shader": get_code("frag"),
    }
</t>
<t tx="ekr.20250121054835.970"># Color functions

@affects_family_data
def set_rgba_array(
    self,
    rgba_array: npt.ArrayLike,
    name: str = "rgba",
    recurse: bool = False
) -&gt; Self:
    for mob in self.get_family(recurse):
        data = mob.data if mob.get_num_points() &gt; 0 else mob._data_defaults
        data[name][:] = rgba_array
    return self
</t>
<t tx="ekr.20250121054835.971">def set_color_by_rgba_func(
    self,
    func: Callable[[Vect3], Vect4],
    recurse: bool = True
) -&gt; Self:
    """
    Func should take in a point in R3 and output an rgba value
    """
    for mob in self.get_family(recurse):
        rgba_array = [func(point) for point in mob.get_points()]
        mob.set_rgba_array(rgba_array)
    return self
</t>
<t tx="ekr.20250121054835.972">def set_color_by_rgb_func(
    self,
    func: Callable[[Vect3], Vect3],
    opacity: float = 1,
    recurse: bool = True
) -&gt; Self:
    """
    Func should take in a point in R3 and output an rgb value
    """
    for mob in self.get_family(recurse):
        rgba_array = [[*func(point), opacity] for point in mob.get_points()]
        mob.set_rgba_array(rgba_array)
    return self
</t>
<t tx="ekr.20250121054835.973">@affects_family_data
def set_rgba_array_by_color(
    self,
    color: ManimColor | Iterable[ManimColor] | None = None,
    opacity: float | Iterable[float] | None = None,
    name: str = "rgba",
    recurse: bool = True
) -&gt; Self:
    for mob in self.get_family(recurse):
        data = mob.data if mob.has_points() &gt; 0 else mob._data_defaults
        if color is not None:
            rgbs = np.array(list(map(color_to_rgb, listify(color))))
            if 1 &lt; len(rgbs):
                rgbs = resize_with_interpolation(rgbs, len(data))
            data[name][:, :3] = rgbs
        if opacity is not None:
            if not isinstance(opacity, (float, int)):
                opacity = resize_with_interpolation(np.array(opacity), len(data))
            data[name][:, 3] = opacity
    return self
</t>
<t tx="ekr.20250121054835.974">def set_color(
    self,
    color: ManimColor | Iterable[ManimColor] | None,
    opacity: float | Iterable[float] | None = None,
    recurse: bool = True
) -&gt; Self:
    self.set_rgba_array_by_color(color, opacity, recurse=False)
    # Recurse to submobjects differently from how set_rgba_array_by_color
    # in case they implement set_color differently
    if recurse:
        for submob in self.submobjects:
            submob.set_color(color, recurse=True)
    return self
</t>
<t tx="ekr.20250121054835.975">def set_opacity(
    self,
    opacity: float | Iterable[float] | None,
    recurse: bool = True
) -&gt; Self:
    self.set_rgba_array_by_color(color=None, opacity=opacity, recurse=False)
    if recurse:
        for submob in self.submobjects:
            submob.set_opacity(opacity, recurse=True)
    return self
</t>
<t tx="ekr.20250121054835.976">def get_color(self) -&gt; str:
    return rgb_to_hex(self.data["rgba"][0, :3])
</t>
<t tx="ekr.20250121054835.977">def get_opacity(self) -&gt; float:
    return float(self.data["rgba"][0, 3])
</t>
<t tx="ekr.20250121054835.978">def get_opacities(self) -&gt; float:
    return self.data["rgba"][:, 3]
</t>
<t tx="ekr.20250121054835.979">def set_color_by_gradient(self, *colors: ManimColor) -&gt; Self:
    if self.has_points():
        self.set_color(colors)
    else:
        self.set_submobject_colors_by_gradient(*colors)
    return self
</t>
<t tx="ekr.20250121054835.98">def init_program(self):
    if not self.shader_folder:
        self.program = None
        self.vert_format = None
        self.programs = []
        return
    self.program = get_shader_program(self.ctx, **self.program_code)
    self.vert_format = moderngl.detect_format(self.program, self.vert_attributes)
    self.programs = [self.program]
</t>
<t tx="ekr.20250121054835.980">def set_submobject_colors_by_gradient(self, *colors: ManimColor) -&gt; Self:
    if len(colors) == 0:
        raise Exception("Need at least one color")
    elif len(colors) == 1:
        return self.set_color(*colors)

    # mobs = self.family_members_with_points()
    mobs = self.submobjects
    new_colors = color_gradient(colors, len(mobs))

    for mob, color in zip(mobs, new_colors):
        mob.set_color(color)
    return self
</t>
<t tx="ekr.20250121054835.981">def fade(self, darkness: float = 0.5, recurse: bool = True) -&gt; Self:
    self.set_opacity(1.0 - darkness, recurse=recurse)
</t>
<t tx="ekr.20250121054835.982">def get_shading(self) -&gt; np.ndarray:
    return self.uniforms["shading"]
</t>
<t tx="ekr.20250121054835.983">def set_shading(
    self,
    reflectiveness: float | None = None,
    gloss: float | None = None,
    shadow: float | None = None,
    recurse: bool = True
) -&gt; Self:
    """
    Larger reflectiveness makes things brighter when facing the light
    Larger shadow makes faces opposite the light darker
    Makes parts bright where light gets reflected toward the camera
    """
    for mob in self.get_family(recurse):
        shading = mob.uniforms["shading"]
        for i, value in enumerate([reflectiveness, gloss, shadow]):
            if value is not None:
                shading[i] = value
        mob.set_uniform(shading=shading, recurse=False)
    return self
</t>
<t tx="ekr.20250121054835.984">def get_reflectiveness(self) -&gt; float:
    return self.get_shading()[0]
</t>
<t tx="ekr.20250121054835.985">def get_gloss(self) -&gt; float:
    return self.get_shading()[1]
</t>
<t tx="ekr.20250121054835.986">def get_shadow(self) -&gt; float:
    return self.get_shading()[2]
</t>
<t tx="ekr.20250121054835.987">def set_reflectiveness(self, reflectiveness: float, recurse: bool = True) -&gt; Self:
    self.set_shading(reflectiveness=reflectiveness, recurse=recurse)
    return self
</t>
<t tx="ekr.20250121054835.988">def set_gloss(self, gloss: float, recurse: bool = True) -&gt; Self:
    self.set_shading(gloss=gloss, recurse=recurse)
    return self
</t>
<t tx="ekr.20250121054835.989">def set_shadow(self, shadow: float, recurse: bool = True) -&gt; Self:
    self.set_shading(shadow=shadow, recurse=recurse)
    return self
</t>
<t tx="ekr.20250121054835.99">def init_textures(self):
    self.texture_names_to_ids = dict()
    self.textures = []
    for name, path in self.texture_paths.items():
        self.add_texture(name, image_path_to_texture(path, self.ctx))
</t>
<t tx="ekr.20250121054835.990"># Background rectangle

def add_background_rectangle(
    self,
    color: ManimColor | None = None,
    opacity: float = 1.0,
    **kwargs
) -&gt; Self:
    from manimlib.mobject.shape_matchers import BackgroundRectangle
    self.background_rectangle = BackgroundRectangle(
        self, color=color,
        fill_opacity=opacity,
        **kwargs
    )
    self.add_to_back(self.background_rectangle)
    return self
</t>
<t tx="ekr.20250121054835.991">def add_background_rectangle_to_submobjects(self, **kwargs) -&gt; Self:
    for submobject in self.submobjects:
        submobject.add_background_rectangle(**kwargs)
    return self
</t>
<t tx="ekr.20250121054835.992">def add_background_rectangle_to_family_members_with_points(self, **kwargs) -&gt; Self:
    for mob in self.family_members_with_points():
        mob.add_background_rectangle(**kwargs)
    return self
</t>
<t tx="ekr.20250121054835.993"># Getters

def get_bounding_box_point(self, direction: Vect3) -&gt; Vect3:
    bb = self.get_bounding_box()
    indices = (np.sign(direction) + 1).astype(int)
    return np.array([
        bb[indices[i]][i]
        for i in range(3)
    ])
</t>
<t tx="ekr.20250121054835.994">def get_edge_center(self, direction: Vect3) -&gt; Vect3:
    return self.get_bounding_box_point(direction)
</t>
<t tx="ekr.20250121054835.995">def get_corner(self, direction: Vect3) -&gt; Vect3:
    return self.get_bounding_box_point(direction)
</t>
<t tx="ekr.20250121054835.996">def get_all_corners(self):
    bb = self.get_bounding_box()
    return np.array([
        [bb[indices[-i + 1]][i] for i in range(3)]
        for indices in it.product([0, 2], repeat=3)
    ])
</t>
<t tx="ekr.20250121054835.997">def get_center(self) -&gt; Vect3:
    return self.get_bounding_box()[1]
</t>
<t tx="ekr.20250121054835.998">def get_center_of_mass(self) -&gt; Vect3:
    return self.get_all_points().mean(0)
</t>
<t tx="ekr.20250121054835.999">def get_boundary_point(self, direction: Vect3) -&gt; Vect3:
    all_points = self.get_all_points()
    boundary_directions = all_points - self.get_center()
    norms = np.linalg.norm(boundary_directions, axis=1)
    boundary_directions /= np.repeat(norms, 3).reshape((len(norms), 3))
    index = np.argmax(np.dot(boundary_directions, np.array(direction).T))
    return all_points[index]
</t>
<t tx="ekr.20250121054839.1"></t>
<t tx="ekr.20250121054955.1">"""Recursively import all python files in a directory and clean the result."""
@language python
@tabwidth -4 # For a better match.
g.cls()
# dir_ = r'C:\Python\Python3.12\Lib\site-packages\micrograd'
dir_ = r'C:\Repos\manim'
c.recursiveImport(
    dir_=dir_,
    kind = '@clean', # '@auto', '@clean', '@nosent','@file',
    recursive = True,
    safe_at_file = True,
    theTypes = ['.py',],
    verbose = True,
)
if 1:
    last = c.lastTopLevel()
    last.expand()
    if last.hasChildren():
        last.firstChild().expand()
    c.redraw(last)
print('Done')</t>
<t tx="ekr.20250121055138.1"></t>
<t tx="ekr.20250121055138.10"></t>
<t tx="ekr.20250121055138.11">def __neg__(self): # -self

    return self * -1
</t>
<t tx="ekr.20250121055138.12">def __radd__(self, other): # other + self
    
    return self + other
</t>
<t tx="ekr.20250121055138.13">def __sub__(self, other): # self - other

    return self + (-other)
</t>
<t tx="ekr.20250121055138.14">def __rsub__(self, other): # other - self
    
    return other + (-self)
</t>
<t tx="ekr.20250121055138.15">def __rmul__(self, other): # other * self

    return self * other
</t>
<t tx="ekr.20250121055138.16">def __truediv__(self, other): # self / other

    return self * other**-1
</t>
<t tx="ekr.20250121055138.17">def __rtruediv__(self, other): # other / self
    
    return other * self**-1
</t>
<t tx="ekr.20250121055138.18"></t>
<t tx="ekr.20250121055138.19">import random
from micrograd.engine import Value

@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250121055138.2">class Value:
    """ stores a single scalar value and its gradient """
    @others

@language python
@tabwidth -4
</t>
<t tx="ekr.20250121055138.20">class Module:
    @others
</t>
<t tx="ekr.20250121055138.21">def zero_grad(self):
    for p in self.parameters():
        p.grad = 0
</t>
<t tx="ekr.20250121055138.22">def parameters(self):
    return []
</t>
<t tx="ekr.20250121055138.23">class Neuron(Module):
    @others
</t>
<t tx="ekr.20250121055138.24">def __init__(self, nin, nonlin=True):

    self.w = [Value(random.uniform(-1,1)) for _ in range(nin)]
    self.b = Value(0)
    self.nonlin = nonlin

def __repr__(self):
    return f"{'ReLU' if self.nonlin else 'Linear'}Neuron({len(self.w)})"
</t>
<t tx="ekr.20250121055138.25">def __call__(self, x):

    act = sum(
        (wi*xi for wi,xi in zip(self.w, x)),
        self.b
    )
    return act.relu() if self.nonlin else act
</t>
<t tx="ekr.20250121055138.26">def parameters(self):
    return self.w + [self.b]
</t>
<t tx="ekr.20250121055138.27">class Layer(Module):
    @others
</t>
<t tx="ekr.20250121055138.28">def __init__(self, nin, nout, **kwargs):
    self.neurons = [Neuron(nin, **kwargs) for _ in range(nout)]

def __repr__(self):
    return f"Layer of [{', '.join(str(n) for n in self.neurons)}]"
</t>
<t tx="ekr.20250121055138.29">def __call__(self, x):
    out = [
        n(x) #  Call the Neuron's call method.
        for n in self.neurons
    ]
    return out[0] if len(out) == 1 else out
</t>
<t tx="ekr.20250121055138.3">def __init__(self, data, _children=(), _op=''):

    self.data = data
    self.grad = 0

    # Internal variables used for autograd graph construction...

    self._backward = lambda: None  # EKR: the backward function.
    self._prev = set(_children)
    self._op = _op # the op that produced this node, for graphviz / debugging / etc

def __repr__(self):
    return f"Value(data={self.data}, grad={self.grad})"
</t>
<t tx="ekr.20250121055138.30">def parameters(self):
    return [p for n in self.neurons for p in n.parameters()]
</t>
<t tx="ekr.20250121055138.31">class MLP(Module):
    @others
</t>
<t tx="ekr.20250121055138.32">def __init__(self, nin, nouts):

    sz = [nin] + nouts
    self.layers = [
        Layer(sz[i], sz[i+1], nonlin=i!=len(nouts)-1)
        for i in range(len(nouts))
    ]

def __repr__(self):
    return f"MLP of [{', '.join(str(layer) for layer in self.layers)}]"
</t>
<t tx="ekr.20250121055138.33">def __call__(self, x):

    for layer in self.layers:
        x = layer(x)  #  Call the Layer's call method.
    return x
</t>
<t tx="ekr.20250121055138.34">def parameters(self):
    return [p for layer in self.layers for p in layer.parameters()]
</t>
<t tx="ekr.20250121055138.4">def backward(self):

    # Topological order all of the children in the graph.
    topo = []
    visited = set()

    def build_topo(v):
        if v not in visited:
            visited.add(v)
            for child in v._prev:
                build_topo(child)
            topo.append(v)

    build_topo(self)

    # For each variable, apply the chain rule to get its gradient.
    self.grad = 1
    for v in reversed(topo):
        v._backward()
</t>
<t tx="ekr.20250121055138.5">def relu(self):
    
    

    # out = Value(0 if self.data &lt; 0 else self.data, (self,), 'ReLU')
    data = 0 if self.data &lt; 0 else self.data
    out = Value(data=data, childre=tuple(self), op='ReLU')

    def _backward():
        self.grad += (out.data &gt; 0) * out.grad

    out._backward = _backward
    return out
</t>
<t tx="ekr.20250121055138.6"></t>
<t tx="ekr.20250121055138.7">def __add__(self, other):

    other = other if isinstance(other, Value) else Value(other)
    out = Value(data=self.data + other.data, children=(self, other), op='+')

    def _backward():
        self.grad += out.grad
        other.grad += out.grad

    out._backward = _backward
    return out
</t>
<t tx="ekr.20250121055138.8">def __mul__(self, other):

    other = other if isinstance(other, Value) else Value(other)
    out = Value(data=self.data * other.data, children=(self, other), op='*')

    def _backward():
        self.grad += other.data * out.grad
        other.grad += self.data * out.grad

    out._backward = _backward
    return out
</t>
<t tx="ekr.20250121055138.9">def __pow__(self, other):

    assert isinstance(other, (int, float)), "only supporting int/float powers for now"
    out = Value(data=self.data**other, children=tuple(self), op=f"**{other}")

    def _backward():
        self.grad += (other * self.data**(other-1)) * out.grad

    out._backward = _backward
    return out
</t>
<t tx="ekr.20250121055147.1"></t>
<t tx="ekr.20250121055447.153">@language python
</t>
<t tx="ekr.20250121055447.154">"""
Back up this .leo file.

os.environ['LEO_BACKUP'] must be the path to an existing (writable) directory.
"""
c.backup_helper(sub_dir='ekr-study')
</t>
<t tx="ekr.20250121055447.161" __bookmarks="7d7100580700000069735f6475706571014930300a732e"></t>
<t tx="ekr.20250121055447.163">manim

</t>
<t tx="ekr.20250121055447.164" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032312d30332d33307103752e">@language python

# Recommended plugins, from leoSettings.leo:

plugins_menu.py
# contextmenu.py      # Required by the vim.py and xemacs.py plugins.
mod_scripting.py
nav_qt.py
# Both VR plugins may be enabled.
viewrendered.py
# viewrendered3.py
</t>
<t tx="ekr.20250121055447.2" __bookmarks="7d7100580700000069735f6475706571014930300a732e">@language rest
@wrap

The @settings tree contains all active settings. 

Settings outside this tree have no effect.</t>
<t tx="ekr.20250121055447.4"></t>
</tnodes>
</leo_file>
