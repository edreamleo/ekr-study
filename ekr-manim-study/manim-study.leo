<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: https://leo-editor.github.io/leo-editor/leo_toc.html -->
<leo_file xmlns:leo="https://leo-editor.github.io/leo-editor/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2"/>
<globals/>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20250121054642.1" descendentVnodeUnknownAttributes="7d7100285803000000302e3071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735805000000302e302e3571067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c7573752e"><vh>Startup</vh>
<v t="ekr.20250121055447.2" descendentVnodeUnknownAttributes="7d71002858010000003071017d7102580b0000005f5f626f6f6b6d61726b7371037d7104580700000069735f6475706571054930300a73735803000000302e3571067d71075808000000616e6e6f7461746571087d71092858080000007072696f72697479710a4d0f27580a00000070726973657464617465710b580a000000323032312d30332d3330710c7573752e"><vh>@settings</vh>
<v t="ekr.20250122151915.1"><vh>@bool beautify-python-code-on-write = False</vh></v>
<v t="ekr.20250122043559.1"><vh>@string target-language = python</vh></v>
<v t="ekr.20250121055447.163"><vh>@data history-list</vh></v>
<v t="ekr.20250121055447.154"><vh>@button backup</vh></v>
<v t="ekr.20250121054646.1"><vh>@button manim</vh></v>
<v t="ekr.20250121055447.164" descendentVnodeUnknownAttributes="7d710058010000003071017d71025808000000616e6e6f7461746571037d71042858080000007072696f7269747971054d0f27580a000000707269736574646174657106580a000000323032312d30332d333071077573732e"><vh>@enabled-plugins</vh></v>
</v>
<v t="ekr.20250121054955.1"><vh>Recursive import script</vh></v>
</v>
<v t="ekr.20250121054839.1"><vh>--- files</vh>
<v t="ekr.20250121052813.1"><vh>@file main.py </vh></v>
<v t="ekr.20250121053749.1"><vh>@edit manim.cfg</vh></v>
</v>
<v t="ekr.20250121054646.1"></v>
<v t="ekr.20250121052813.1"></v>
<v t="ekr.20250122151620.2"><vh>Lib/site-packages/manim</vh>
<v t="ekr.20250122152209.1"><vh>manim: top-level</vh>
<v t="ekr.20250122151620.3"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/__init__.py</vh></v>
<v t="ekr.20250122151620.4"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/__main__.py</vh>
<v t="ekr.20250122151620.5"><vh>function: show_splash</vh></v>
<v t="ekr.20250122151620.6"><vh>function: print_version_and_exit</vh></v>
<v t="ekr.20250122151620.7"><vh>function: main</vh></v>
</v>
<v t="ekr.20250122151620.8"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/constants.py</vh>
<v t="ekr.20250122151620.9"><vh>class QualityDict</vh></v>
<v t="ekr.20250122151620.10"><vh>class RendererType</vh></v>
<v t="ekr.20250122151620.11"><vh>class LineJointType</vh></v>
<v t="ekr.20250122151620.12"><vh>class CapStyleType</vh></v>
</v>
<v t="ekr.20250122151620.13"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/typing.py</vh></v>
</v>
<v t="ekr.20250122151620.14"><vh>manim/_config</vh>
<v t="ekr.20250122151620.15"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/_config/__init__.py</vh>
<v t="ekr.20250122151620.16"><vh>function: tempconfig</vh></v>
</v>
<v t="ekr.20250122151620.17"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/_config/cli_colors.py</vh>
<v t="ekr.20250122151620.18"><vh>function: parse_cli_ctx</vh></v>
</v>
<v t="ekr.20250122151620.19"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/_config/logger_utils.py</vh>
<v t="ekr.20250122151620.20"><vh>function: make_logger</vh></v>
<v t="ekr.20250122151620.21"><vh>function: parse_theme</vh></v>
<v t="ekr.20250122151620.22"><vh>function: set_file_logger</vh></v>
<v t="ekr.20250122151620.23"><vh>class JSONFormatter</vh>
<v t="ekr.20250122151620.24"><vh>JSONFormatter.format</vh></v>
</v>
</v>
<v t="ekr.20250122151620.25"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/_config/utils.py</vh>
<v t="ekr.20250122151620.26"><vh>function: config_file_paths</vh></v>
<v t="ekr.20250122151620.27"><vh>function: make_config_parser</vh></v>
<v t="ekr.20250122151620.28"><vh>function: _determine_quality</vh></v>
<v t="ekr.20250122151620.29"><vh>class ManimConfig</vh>
<v t="ekr.20250122151620.31"><vh>ManimConfig.__init__</vh></v>
<v t="ekr.20250122151620.32"><vh>ManimConfig.__iter__</vh></v>
<v t="ekr.20250122151620.33"><vh>ManimConfig.__len__</vh></v>
<v t="ekr.20250122151620.34"><vh>ManimConfig.__contains__</vh></v>
<v t="ekr.20250122151620.35"><vh>ManimConfig.__getitem__</vh></v>
<v t="ekr.20250122151620.36"><vh>ManimConfig.__setitem__</vh></v>
<v t="ekr.20250122151620.37"><vh>ManimConfig.update</vh></v>
<v t="ekr.20250122151620.38"><vh>ManimConfig.__delitem__</vh></v>
<v t="ekr.20250122151620.39"><vh>ManimConfig.__delattr__</vh></v>
<v t="ekr.20250122151620.40"><vh>ManimConfig.copy</vh></v>
<v t="ekr.20250122151620.41"><vh>ManimConfig.__copy__</vh></v>
<v t="ekr.20250122151620.42"><vh>ManimConfig.__deepcopy__</vh></v>
<v t="ekr.20250122151620.43"><vh>ManimConfig._set_from_list</vh></v>
<v t="ekr.20250122151620.44"><vh>ManimConfig._set_from_enum</vh></v>
<v t="ekr.20250122151620.45"><vh>ManimConfig._set_boolean</vh></v>
<v t="ekr.20250122151620.46"><vh>ManimConfig._set_tuple</vh></v>
<v t="ekr.20250122151620.47"><vh>ManimConfig._set_str</vh></v>
<v t="ekr.20250122151620.48"><vh>ManimConfig._set_between</vh></v>
<v t="ekr.20250122151620.49"><vh>ManimConfig._set_int_between</vh></v>
<v t="ekr.20250122151620.50"><vh>ManimConfig._set_pos_number</vh></v>
<v t="ekr.20250122151620.51"><vh>ManimConfig.__repr__</vh></v>
<v t="ekr.20250122151620.52"><vh>ManimConfig.digest_parser</vh></v>
<v t="ekr.20250122151620.53"><vh>ManimConfig.digest_args</vh></v>
<v t="ekr.20250122151620.54"><vh>ManimConfig.digest_file</vh></v>
<v t="ekr.20250122151620.55"><vh>ManimConfig.preview</vh></v>
<v t="ekr.20250122151620.56"><vh>ManimConfig.preview</vh></v>
<v t="ekr.20250122151620.57"><vh>ManimConfig.show_in_file_browser</vh></v>
<v t="ekr.20250122151620.58"><vh>ManimConfig.show_in_file_browser</vh></v>
<v t="ekr.20250122151620.59"><vh>ManimConfig.progress_bar</vh></v>
<v t="ekr.20250122151620.60"><vh>ManimConfig.progress_bar</vh></v>
<v t="ekr.20250122151620.61"><vh>ManimConfig.log_to_file</vh></v>
<v t="ekr.20250122151620.62"><vh>ManimConfig.log_to_file</vh></v>
<v t="ekr.20250122151620.63"><vh>ManimConfig.notify_outdated_version</vh></v>
<v t="ekr.20250122151620.64"><vh>ManimConfig.notify_outdated_version</vh></v>
<v t="ekr.20250122151620.65"><vh>ManimConfig.write_to_movie</vh></v>
<v t="ekr.20250122151620.66"><vh>ManimConfig.write_to_movie</vh></v>
<v t="ekr.20250122151620.67"><vh>ManimConfig.save_last_frame</vh></v>
<v t="ekr.20250122151620.68"><vh>ManimConfig.save_last_frame</vh></v>
<v t="ekr.20250122151620.69"><vh>ManimConfig.write_all</vh></v>
<v t="ekr.20250122151620.70"><vh>ManimConfig.write_all</vh></v>
<v t="ekr.20250122151620.71"><vh>ManimConfig.save_pngs</vh></v>
<v t="ekr.20250122151620.72"><vh>ManimConfig.save_pngs</vh></v>
<v t="ekr.20250122151620.73"><vh>ManimConfig.save_as_gif</vh></v>
<v t="ekr.20250122151620.74"><vh>ManimConfig.save_as_gif</vh></v>
<v t="ekr.20250122151620.75"><vh>ManimConfig.save_sections</vh></v>
<v t="ekr.20250122151620.76"><vh>ManimConfig.save_sections</vh></v>
<v t="ekr.20250122151620.77"><vh>ManimConfig.enable_wireframe</vh></v>
<v t="ekr.20250122151620.78"><vh>ManimConfig.enable_wireframe</vh></v>
<v t="ekr.20250122151620.79"><vh>ManimConfig.force_window</vh></v>
<v t="ekr.20250122151620.80"><vh>ManimConfig.force_window</vh></v>
<v t="ekr.20250122151620.81"><vh>ManimConfig.no_latex_cleanup</vh></v>
<v t="ekr.20250122151620.82"><vh>ManimConfig.no_latex_cleanup</vh></v>
<v t="ekr.20250122151620.83"><vh>ManimConfig.preview_command</vh></v>
<v t="ekr.20250122151620.84"><vh>ManimConfig.preview_command</vh></v>
<v t="ekr.20250122151620.85"><vh>ManimConfig.verbosity</vh></v>
<v t="ekr.20250122151620.86"><vh>ManimConfig.verbosity</vh></v>
<v t="ekr.20250122151620.87"><vh>ManimConfig.format</vh></v>
<v t="ekr.20250122151620.88"><vh>ManimConfig.format</vh></v>
<v t="ekr.20250122151620.89"><vh>ManimConfig.ffmpeg_loglevel</vh></v>
<v t="ekr.20250122151620.90"><vh>ManimConfig.ffmpeg_loglevel</vh></v>
<v t="ekr.20250122151620.91"><vh>ManimConfig.media_embed</vh></v>
<v t="ekr.20250122151620.92"><vh>ManimConfig.media_embed</vh></v>
<v t="ekr.20250122151620.93"><vh>ManimConfig.media_width</vh></v>
<v t="ekr.20250122151620.94"><vh>ManimConfig.media_width</vh></v>
<v t="ekr.20250122151620.95"><vh>ManimConfig.pixel_width</vh></v>
<v t="ekr.20250122151620.96"><vh>ManimConfig.pixel_width</vh></v>
<v t="ekr.20250122151620.97"><vh>ManimConfig.pixel_height</vh></v>
<v t="ekr.20250122151620.98"><vh>ManimConfig.pixel_height</vh></v>
<v t="ekr.20250122151620.99"><vh>ManimConfig.aspect_ratio</vh></v>
<v t="ekr.20250122151620.100"><vh>ManimConfig.frame_height</vh></v>
<v t="ekr.20250122151620.101"><vh>ManimConfig.frame_height</vh></v>
<v t="ekr.20250122151620.102"><vh>ManimConfig.frame_width</vh></v>
<v t="ekr.20250122151620.103"><vh>ManimConfig.frame_width</vh></v>
<v t="ekr.20250122151620.104"><vh>ManimConfig.frame_y_radius</vh></v>
<v t="ekr.20250122151620.105"><vh>ManimConfig.frame_y_radius</vh></v>
<v t="ekr.20250122151620.106"><vh>ManimConfig.frame_x_radius</vh></v>
<v t="ekr.20250122151620.107"><vh>ManimConfig.frame_x_radius</vh></v>
<v t="ekr.20250122151620.108"><vh>ManimConfig.top</vh></v>
<v t="ekr.20250122151620.109"><vh>ManimConfig.bottom</vh></v>
<v t="ekr.20250122151620.110"><vh>ManimConfig.left_side</vh></v>
<v t="ekr.20250122151620.111"><vh>ManimConfig.right_side</vh></v>
<v t="ekr.20250122151620.112"><vh>ManimConfig.frame_rate</vh></v>
<v t="ekr.20250122151620.113"><vh>ManimConfig.frame_rate</vh></v>
<v t="ekr.20250122151620.114"><vh>ManimConfig.background_color</vh></v>
<v t="ekr.20250122151620.115"><vh>ManimConfig.background_color</vh></v>
<v t="ekr.20250122151620.116"><vh>ManimConfig.from_animation_number</vh></v>
<v t="ekr.20250122151620.117"><vh>ManimConfig.from_animation_number</vh></v>
<v t="ekr.20250122151620.118"><vh>ManimConfig.upto_animation_number</vh></v>
<v t="ekr.20250122151620.119"><vh>ManimConfig.upto_animation_number</vh></v>
<v t="ekr.20250122151620.120"><vh>ManimConfig.max_files_cached</vh></v>
<v t="ekr.20250122151620.121"><vh>ManimConfig.max_files_cached</vh></v>
<v t="ekr.20250122151620.122"><vh>ManimConfig.window_monitor</vh></v>
<v t="ekr.20250122151620.123"><vh>ManimConfig.window_monitor</vh></v>
<v t="ekr.20250122151620.124"><vh>ManimConfig.flush_cache</vh></v>
<v t="ekr.20250122151620.125"><vh>ManimConfig.flush_cache</vh></v>
<v t="ekr.20250122151620.126"><vh>ManimConfig.disable_caching</vh></v>
<v t="ekr.20250122151620.127"><vh>ManimConfig.disable_caching</vh></v>
<v t="ekr.20250122151620.128"><vh>ManimConfig.disable_caching_warning</vh></v>
<v t="ekr.20250122151620.129"><vh>ManimConfig.disable_caching_warning</vh></v>
<v t="ekr.20250122151620.130"><vh>ManimConfig.movie_file_extension</vh></v>
<v t="ekr.20250122151620.131"><vh>ManimConfig.movie_file_extension</vh></v>
<v t="ekr.20250122151620.132"><vh>ManimConfig.background_opacity</vh></v>
<v t="ekr.20250122151620.133"><vh>ManimConfig.background_opacity</vh></v>
<v t="ekr.20250122151620.134"><vh>ManimConfig.frame_size</vh></v>
<v t="ekr.20250122151620.135"><vh>ManimConfig.frame_size</vh></v>
<v t="ekr.20250122151620.136"><vh>ManimConfig.quality</vh></v>
<v t="ekr.20250122151620.137"><vh>ManimConfig.quality</vh></v>
<v t="ekr.20250122151620.138"><vh>ManimConfig.transparent</vh></v>
<v t="ekr.20250122151620.139"><vh>ManimConfig.transparent</vh></v>
<v t="ekr.20250122151620.140"><vh>ManimConfig.dry_run</vh></v>
<v t="ekr.20250122151620.141"><vh>ManimConfig.dry_run</vh></v>
<v t="ekr.20250122151620.142"><vh>ManimConfig.renderer</vh></v>
<v t="ekr.20250122151620.143"><vh>ManimConfig.renderer</vh></v>
<v t="ekr.20250122151620.144"><vh>ManimConfig.media_dir</vh></v>
<v t="ekr.20250122151620.145"><vh>ManimConfig.media_dir</vh></v>
<v t="ekr.20250122151620.146"><vh>ManimConfig.window_position</vh></v>
<v t="ekr.20250122151620.147"><vh>ManimConfig.window_position</vh></v>
<v t="ekr.20250122151620.148"><vh>ManimConfig.window_size</vh></v>
<v t="ekr.20250122151620.149"><vh>ManimConfig.window_size</vh></v>
<v t="ekr.20250122151620.150"><vh>ManimConfig.resolve_movie_file_extension</vh></v>
<v t="ekr.20250122151620.151"><vh>ManimConfig.enable_gui</vh></v>
<v t="ekr.20250122151620.152"><vh>ManimConfig.enable_gui</vh></v>
<v t="ekr.20250122151620.153"><vh>ManimConfig.gui_location</vh></v>
<v t="ekr.20250122151620.154"><vh>ManimConfig.gui_location</vh></v>
<v t="ekr.20250122151620.155"><vh>ManimConfig.fullscreen</vh></v>
<v t="ekr.20250122151620.156"><vh>ManimConfig.fullscreen</vh></v>
<v t="ekr.20250122151620.157"><vh>ManimConfig.use_projection_fill_shaders</vh></v>
<v t="ekr.20250122151620.158"><vh>ManimConfig.use_projection_fill_shaders</vh></v>
<v t="ekr.20250122151620.159"><vh>ManimConfig.use_projection_stroke_shaders</vh></v>
<v t="ekr.20250122151620.160"><vh>ManimConfig.use_projection_stroke_shaders</vh></v>
<v t="ekr.20250122151620.161"><vh>ManimConfig.zero_pad</vh></v>
<v t="ekr.20250122151620.162"><vh>ManimConfig.zero_pad</vh></v>
<v t="ekr.20250122151620.163"><vh>ManimConfig.get_dir</vh></v>
<v t="ekr.20250122151620.164"><vh>ManimConfig._set_dir</vh></v>
<v t="ekr.20250122151620.165"><vh>ManimConfig.assets_dir</vh></v>
<v t="ekr.20250122151620.166"><vh>ManimConfig.assets_dir</vh></v>
<v t="ekr.20250122151620.167"><vh>ManimConfig.log_dir</vh></v>
<v t="ekr.20250122151620.168"><vh>ManimConfig.log_dir</vh></v>
<v t="ekr.20250122151620.169"><vh>ManimConfig.video_dir</vh></v>
<v t="ekr.20250122151620.170"><vh>ManimConfig.video_dir</vh></v>
<v t="ekr.20250122151620.171"><vh>ManimConfig.sections_dir</vh></v>
<v t="ekr.20250122151620.172"><vh>ManimConfig.sections_dir</vh></v>
<v t="ekr.20250122151620.173"><vh>ManimConfig.images_dir</vh></v>
<v t="ekr.20250122151620.174"><vh>ManimConfig.images_dir</vh></v>
<v t="ekr.20250122151620.175"><vh>ManimConfig.text_dir</vh></v>
<v t="ekr.20250122151620.176"><vh>ManimConfig.text_dir</vh></v>
<v t="ekr.20250122151620.177"><vh>ManimConfig.tex_dir</vh></v>
<v t="ekr.20250122151620.178"><vh>ManimConfig.tex_dir</vh></v>
<v t="ekr.20250122151620.179"><vh>ManimConfig.partial_movie_dir</vh></v>
<v t="ekr.20250122151620.180"><vh>ManimConfig.partial_movie_dir</vh></v>
<v t="ekr.20250122151620.181"><vh>ManimConfig.custom_folders</vh></v>
<v t="ekr.20250122151620.182"><vh>ManimConfig.custom_folders</vh></v>
<v t="ekr.20250122151620.183"><vh>ManimConfig.input_file</vh></v>
<v t="ekr.20250122151620.184"><vh>ManimConfig.input_file</vh></v>
<v t="ekr.20250122151620.185"><vh>ManimConfig.output_file</vh></v>
<v t="ekr.20250122151620.186"><vh>ManimConfig.output_file</vh></v>
<v t="ekr.20250122151620.187"><vh>ManimConfig.scene_names</vh></v>
<v t="ekr.20250122151620.188"><vh>ManimConfig.scene_names</vh></v>
<v t="ekr.20250122151620.189"><vh>ManimConfig.tex_template</vh></v>
<v t="ekr.20250122151620.190"><vh>ManimConfig.tex_template</vh></v>
<v t="ekr.20250122151620.191"><vh>ManimConfig.tex_template_file</vh></v>
<v t="ekr.20250122151620.192"><vh>ManimConfig.tex_template_file</vh></v>
<v t="ekr.20250122151620.193"><vh>ManimConfig.plugins</vh></v>
<v t="ekr.20250122151620.194"><vh>ManimConfig.plugins</vh></v>
</v>
<v t="ekr.20250122151620.30"><vh>class ManimFrame</vh>
<v t="ekr.20250122151620.195"><vh>ManimFrame.__init__</vh></v>
<v t="ekr.20250122151620.196"><vh>ManimFrame.__getitem__</vh></v>
<v t="ekr.20250122151620.197"><vh>ManimFrame.__iter__</vh></v>
<v t="ekr.20250122151620.198"><vh>ManimFrame.__len__</vh></v>
<v t="ekr.20250122151620.199"><vh>ManimFrame.__setattr__</vh></v>
<v t="ekr.20250122151620.200"><vh>ManimFrame.__setitem__</vh></v>
<v t="ekr.20250122151620.201"><vh>ManimFrame.__delitem__</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151620.202"><vh>manim/animation</vh>
<v t="ekr.20250122151620.203"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/__init__.py</vh></v>
<v t="ekr.20250122151620.204"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/animation.py</vh>
<v t="ekr.20250122151620.205"><vh>class Animation</vh>
<v t="ekr.20250122151620.210"><vh>Animation.__new__</vh></v>
<v t="ekr.20250122151620.211"><vh>Animation.__init__</vh></v>
<v t="ekr.20250122151620.212"><vh>Animation.run_time</vh></v>
<v t="ekr.20250122151620.213"><vh>Animation.run_time</vh></v>
<v t="ekr.20250122151620.214"><vh>Animation._typecheck_input</vh></v>
<v t="ekr.20250122151620.215"><vh>Animation.__str__</vh></v>
<v t="ekr.20250122151620.216"><vh>Animation.__repr__</vh></v>
<v t="ekr.20250122151620.217"><vh>Animation.begin</vh></v>
<v t="ekr.20250122151620.218"><vh>Animation.finish</vh></v>
<v t="ekr.20250122151620.219"><vh>Animation.clean_up_from_scene</vh></v>
<v t="ekr.20250122151620.220"><vh>Animation._setup_scene</vh></v>
<v t="ekr.20250122151620.221"><vh>Animation.create_starting_mobject</vh></v>
<v t="ekr.20250122151620.222"><vh>Animation.get_all_mobjects</vh></v>
<v t="ekr.20250122151620.223"><vh>Animation.get_all_families_zipped</vh></v>
<v t="ekr.20250122151620.224"><vh>Animation.update_mobjects</vh></v>
<v t="ekr.20250122151620.225"><vh>Animation.get_all_mobjects_to_update</vh></v>
<v t="ekr.20250122151620.226"><vh>Animation.copy</vh></v>
<v t="ekr.20250122151620.227"><vh>Animation.interpolate</vh></v>
<v t="ekr.20250122151620.228"><vh>Animation.interpolate_mobject</vh></v>
<v t="ekr.20250122151620.229"><vh>Animation.interpolate_submobject</vh></v>
<v t="ekr.20250122151620.230"><vh>Animation.get_sub_alpha</vh></v>
<v t="ekr.20250122151620.231"><vh>Animation.set_run_time</vh></v>
<v t="ekr.20250122151620.232"><vh>Animation.get_run_time</vh></v>
<v t="ekr.20250122151620.233"><vh>Animation.set_rate_func</vh></v>
<v t="ekr.20250122151620.234"><vh>Animation.get_rate_func</vh></v>
<v t="ekr.20250122151620.235"><vh>Animation.set_name</vh></v>
<v t="ekr.20250122151620.236"><vh>Animation.is_remover</vh></v>
<v t="ekr.20250122151620.237"><vh>Animation.is_introducer</vh></v>
<v t="ekr.20250122151620.238"><vh>Animation.__init_subclass__</vh></v>
<v t="ekr.20250122151620.239"><vh>Animation.set_default</vh></v>
</v>
<v t="ekr.20250122151620.206"><vh>function: prepare_animation</vh></v>
<v t="ekr.20250122151620.207"><vh>class Wait</vh>
<v t="ekr.20250122151620.240"><vh>Wait.__init__</vh></v>
<v t="ekr.20250122151620.241"><vh>Wait.begin</vh></v>
<v t="ekr.20250122151620.242"><vh>Wait.finish</vh></v>
<v t="ekr.20250122151620.243"><vh>Wait.clean_up_from_scene</vh></v>
<v t="ekr.20250122151620.244"><vh>Wait.update_mobjects</vh></v>
<v t="ekr.20250122151620.245"><vh>Wait.interpolate</vh></v>
</v>
<v t="ekr.20250122151620.208"><vh>class Add</vh>
<v t="ekr.20250122151620.246"><vh>Add.__init__</vh></v>
<v t="ekr.20250122151620.247"><vh>Add.begin</vh></v>
<v t="ekr.20250122151620.248"><vh>Add.finish</vh></v>
<v t="ekr.20250122151620.249"><vh>Add.clean_up_from_scene</vh></v>
<v t="ekr.20250122151620.250"><vh>Add.update_mobjects</vh></v>
<v t="ekr.20250122151620.251"><vh>Add.interpolate</vh></v>
</v>
<v t="ekr.20250122151620.209"><vh>function: override_animation</vh></v>
</v>
<v t="ekr.20250122151620.252"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/changing.py</vh>
<v t="ekr.20250122151620.253"><vh>class AnimatedBoundary</vh>
<v t="ekr.20250122151620.255"><vh>AnimatedBoundary.__init__</vh></v>
<v t="ekr.20250122151620.256"><vh>AnimatedBoundary.update_boundary_copies</vh></v>
<v t="ekr.20250122151620.257"><vh>AnimatedBoundary.full_family_become_partial</vh></v>
</v>
<v t="ekr.20250122151620.254"><vh>class TracedPath</vh>
<v t="ekr.20250122151620.258"><vh>TracedPath.__init__</vh></v>
<v t="ekr.20250122151620.259"><vh>TracedPath.update_path</vh></v>
</v>
</v>
<v t="ekr.20250122151620.260"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/composition.py</vh>
<v t="ekr.20250122151620.261"><vh>class AnimationGroup</vh>
<v t="ekr.20250122151620.265"><vh>AnimationGroup.__init__</vh></v>
<v t="ekr.20250122151620.266"><vh>AnimationGroup.get_all_mobjects</vh></v>
<v t="ekr.20250122151620.267"><vh>AnimationGroup.begin</vh></v>
<v t="ekr.20250122151620.268"><vh>AnimationGroup._setup_scene</vh></v>
<v t="ekr.20250122151620.269"><vh>AnimationGroup.finish</vh></v>
<v t="ekr.20250122151620.270"><vh>AnimationGroup.clean_up_from_scene</vh></v>
<v t="ekr.20250122151620.271"><vh>AnimationGroup.update_mobjects</vh></v>
<v t="ekr.20250122151620.272"><vh>AnimationGroup.init_run_time</vh></v>
<v t="ekr.20250122151620.273"><vh>AnimationGroup.build_animations_with_timings</vh></v>
<v t="ekr.20250122151620.274"><vh>AnimationGroup.interpolate</vh></v>
</v>
<v t="ekr.20250122151620.262"><vh>class Succession</vh>
<v t="ekr.20250122151620.275"><vh>Succession.__init__</vh></v>
<v t="ekr.20250122151620.276"><vh>Succession.begin</vh></v>
<v t="ekr.20250122151620.277"><vh>Succession.finish</vh></v>
<v t="ekr.20250122151620.278"><vh>Succession.update_mobjects</vh></v>
<v t="ekr.20250122151620.279"><vh>Succession._setup_scene</vh></v>
<v t="ekr.20250122151620.280"><vh>Succession.update_active_animation</vh></v>
<v t="ekr.20250122151620.281"><vh>Succession.next_animation</vh></v>
<v t="ekr.20250122151620.282"><vh>Succession.interpolate</vh></v>
</v>
<v t="ekr.20250122151620.263"><vh>class LaggedStart</vh>
<v t="ekr.20250122151620.283"><vh>LaggedStart.__init__</vh></v>
</v>
<v t="ekr.20250122151620.264"><vh>class LaggedStartMap</vh>
<v t="ekr.20250122151620.284"><vh>LaggedStartMap.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.285"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/creation.py</vh>
<v t="ekr.20250122151620.286"><vh>class ShowPartial</vh>
<v t="ekr.20250122151620.300"><vh>ShowPartial.__init__</vh></v>
<v t="ekr.20250122151620.301"><vh>ShowPartial.interpolate_submobject</vh></v>
<v t="ekr.20250122151620.302"><vh>ShowPartial._get_bounds</vh></v>
</v>
<v t="ekr.20250122151620.287"><vh>class Create</vh>
<v t="ekr.20250122151620.303"><vh>Create.__init__</vh></v>
<v t="ekr.20250122151620.304"><vh>Create._get_bounds</vh></v>
</v>
<v t="ekr.20250122151620.288"><vh>class Uncreate</vh>
<v t="ekr.20250122151620.305"><vh>Uncreate.__init__</vh></v>
</v>
<v t="ekr.20250122151620.289"><vh>class DrawBorderThenFill</vh>
<v t="ekr.20250122151620.306"><vh>DrawBorderThenFill.__init__</vh></v>
<v t="ekr.20250122151620.307"><vh>DrawBorderThenFill._typecheck_input</vh></v>
<v t="ekr.20250122151620.308"><vh>DrawBorderThenFill.begin</vh></v>
<v t="ekr.20250122151620.309"><vh>DrawBorderThenFill.get_outline</vh></v>
<v t="ekr.20250122151620.310"><vh>DrawBorderThenFill.get_stroke_color</vh></v>
<v t="ekr.20250122151620.311"><vh>DrawBorderThenFill.get_all_mobjects</vh></v>
<v t="ekr.20250122151620.312"><vh>DrawBorderThenFill.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250122151620.290"><vh>class Write</vh>
<v t="ekr.20250122151620.313"><vh>Write.__init__</vh></v>
<v t="ekr.20250122151620.314"><vh>Write._set_default_config_from_length</vh></v>
<v t="ekr.20250122151620.315"><vh>Write.reverse_submobjects</vh></v>
<v t="ekr.20250122151620.316"><vh>Write.begin</vh></v>
<v t="ekr.20250122151620.317"><vh>Write.finish</vh></v>
</v>
<v t="ekr.20250122151620.291"><vh>class Unwrite</vh>
<v t="ekr.20250122151620.318"><vh>Unwrite.__init__</vh></v>
</v>
<v t="ekr.20250122151620.292"><vh>class SpiralIn</vh>
<v t="ekr.20250122151620.319"><vh>SpiralIn.__init__</vh></v>
<v t="ekr.20250122151620.320"><vh>SpiralIn.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250122151620.293"><vh>class ShowIncreasingSubsets</vh>
<v t="ekr.20250122151620.321"><vh>ShowIncreasingSubsets.__init__</vh></v>
<v t="ekr.20250122151620.322"><vh>ShowIncreasingSubsets.interpolate_mobject</vh></v>
<v t="ekr.20250122151620.323"><vh>ShowIncreasingSubsets.update_submobject_list</vh></v>
</v>
<v t="ekr.20250122151620.294"><vh>class AddTextLetterByLetter</vh>
<v t="ekr.20250122151620.324"><vh>AddTextLetterByLetter.__init__</vh></v>
</v>
<v t="ekr.20250122151620.295"><vh>class RemoveTextLetterByLetter</vh>
<v t="ekr.20250122151620.325"><vh>RemoveTextLetterByLetter.__init__</vh></v>
</v>
<v t="ekr.20250122151620.296"><vh>class ShowSubmobjectsOneByOne</vh>
<v t="ekr.20250122151620.326"><vh>ShowSubmobjectsOneByOne.__init__</vh></v>
<v t="ekr.20250122151620.327"><vh>ShowSubmobjectsOneByOne.update_submobject_list</vh></v>
</v>
<v t="ekr.20250122151620.297"><vh>class AddTextWordByWord</vh>
<v t="ekr.20250122151620.328"><vh>AddTextWordByWord.__init__</vh></v>
</v>
<v t="ekr.20250122151620.298"><vh>class TypeWithCursor</vh>
<v t="ekr.20250122151620.329"><vh>TypeWithCursor.__init__</vh></v>
<v t="ekr.20250122151620.330"><vh>TypeWithCursor.begin</vh></v>
<v t="ekr.20250122151620.331"><vh>TypeWithCursor.finish</vh></v>
<v t="ekr.20250122151620.332"><vh>TypeWithCursor.clean_up_from_scene</vh></v>
<v t="ekr.20250122151620.333"><vh>TypeWithCursor.update_submobject_list</vh></v>
</v>
<v t="ekr.20250122151620.299"><vh>class UntypeWithCursor</vh>
<v t="ekr.20250122151620.334"><vh>UntypeWithCursor.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.335"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/fading.py</vh>
<v t="ekr.20250122151620.336"><vh>class _Fade</vh>
<v t="ekr.20250122151620.339"><vh>_Fade.__init__</vh></v>
<v t="ekr.20250122151620.340"><vh>_Fade._create_faded_mobject</vh></v>
</v>
<v t="ekr.20250122151620.337"><vh>class FadeIn</vh>
<v t="ekr.20250122151620.341"><vh>FadeIn.__init__</vh></v>
<v t="ekr.20250122151620.342"><vh>FadeIn.create_target</vh></v>
<v t="ekr.20250122151620.343"><vh>FadeIn.create_starting_mobject</vh></v>
</v>
<v t="ekr.20250122151620.338"><vh>class FadeOut</vh>
<v t="ekr.20250122151620.344"><vh>FadeOut.__init__</vh></v>
<v t="ekr.20250122151620.345"><vh>FadeOut.create_target</vh></v>
<v t="ekr.20250122151620.346"><vh>FadeOut.clean_up_from_scene</vh></v>
</v>
</v>
<v t="ekr.20250122151620.347"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/growing.py</vh>
<v t="ekr.20250122151620.348"><vh>class GrowFromPoint</vh>
<v t="ekr.20250122151620.353"><vh>GrowFromPoint.__init__</vh></v>
<v t="ekr.20250122151620.354"><vh>GrowFromPoint.create_target</vh></v>
<v t="ekr.20250122151620.355"><vh>GrowFromPoint.create_starting_mobject</vh></v>
</v>
<v t="ekr.20250122151620.349"><vh>class GrowFromCenter</vh>
<v t="ekr.20250122151620.356"><vh>GrowFromCenter.__init__</vh></v>
</v>
<v t="ekr.20250122151620.350"><vh>class GrowFromEdge</vh>
<v t="ekr.20250122151620.357"><vh>GrowFromEdge.__init__</vh></v>
</v>
<v t="ekr.20250122151620.351"><vh>class GrowArrow</vh>
<v t="ekr.20250122151620.358"><vh>GrowArrow.__init__</vh></v>
<v t="ekr.20250122151620.359"><vh>GrowArrow.create_starting_mobject</vh></v>
</v>
<v t="ekr.20250122151620.352"><vh>class SpinInFromNothing</vh>
<v t="ekr.20250122151620.360"><vh>SpinInFromNothing.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.361"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/indication.py</vh>
<v t="ekr.20250122151620.362"><vh>class FocusOn</vh>
<v t="ekr.20250122151620.371"><vh>FocusOn.__init__</vh></v>
<v t="ekr.20250122151620.372"><vh>FocusOn.create_target</vh></v>
</v>
<v t="ekr.20250122151620.363"><vh>class Indicate</vh>
<v t="ekr.20250122151620.373"><vh>Indicate.__init__</vh></v>
<v t="ekr.20250122151620.374"><vh>Indicate.create_target</vh></v>
</v>
<v t="ekr.20250122151620.364"><vh>class Flash</vh>
<v t="ekr.20250122151620.375"><vh>Flash.__init__</vh></v>
<v t="ekr.20250122151620.376"><vh>Flash.create_lines</vh></v>
<v t="ekr.20250122151620.377"><vh>Flash.create_line_anims</vh></v>
</v>
<v t="ekr.20250122151620.365"><vh>class ShowPassingFlash</vh>
<v t="ekr.20250122151620.378"><vh>ShowPassingFlash.__init__</vh></v>
<v t="ekr.20250122151620.379"><vh>ShowPassingFlash._get_bounds</vh></v>
<v t="ekr.20250122151620.380"><vh>ShowPassingFlash.clean_up_from_scene</vh></v>
</v>
<v t="ekr.20250122151620.366"><vh>class ShowPassingFlashWithThinningStrokeWidth</vh>
<v t="ekr.20250122151620.381"><vh>ShowPassingFlashWithThinningStrokeWidth.__init__</vh></v>
</v>
<v t="ekr.20250122151620.367"><vh>class ApplyWave</vh>
<v t="ekr.20250122151620.382"><vh>ApplyWave.__init__</vh></v>
</v>
<v t="ekr.20250122151620.368"><vh>class Wiggle</vh>
<v t="ekr.20250122151620.383"><vh>Wiggle.__init__</vh></v>
<v t="ekr.20250122151620.384"><vh>Wiggle.get_scale_about_point</vh></v>
<v t="ekr.20250122151620.385"><vh>Wiggle.get_rotate_about_point</vh></v>
<v t="ekr.20250122151620.386"><vh>Wiggle.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250122151620.369"><vh>class Circumscribe</vh>
<v t="ekr.20250122151620.387"><vh>Circumscribe.__init__</vh></v>
</v>
<v t="ekr.20250122151620.370"><vh>class Blink</vh>
<v t="ekr.20250122151620.388"><vh>Blink.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.389"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/movement.py</vh>
<v t="ekr.20250122151620.390"><vh>class Homotopy</vh>
<v t="ekr.20250122151620.395"><vh>Homotopy.__init__</vh></v>
<v t="ekr.20250122151620.396"><vh>Homotopy.function_at_time_t</vh></v>
<v t="ekr.20250122151620.397"><vh>Homotopy.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250122151620.391"><vh>class SmoothedVectorizedHomotopy</vh>
<v t="ekr.20250122151620.398"><vh>SmoothedVectorizedHomotopy.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250122151620.392"><vh>class ComplexHomotopy</vh>
<v t="ekr.20250122151620.399"><vh>ComplexHomotopy.__init__</vh></v>
</v>
<v t="ekr.20250122151620.393"><vh>class PhaseFlow</vh>
<v t="ekr.20250122151620.400"><vh>PhaseFlow.__init__</vh></v>
<v t="ekr.20250122151620.401"><vh>PhaseFlow.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250122151620.394"><vh>class MoveAlongPath</vh>
<v t="ekr.20250122151620.402"><vh>MoveAlongPath.__init__</vh></v>
<v t="ekr.20250122151620.403"><vh>MoveAlongPath.interpolate_mobject</vh></v>
</v>
</v>
<v t="ekr.20250122151620.404"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/numbers.py</vh>
<v t="ekr.20250122151620.405"><vh>class ChangingDecimal</vh>
<v t="ekr.20250122151620.407"><vh>ChangingDecimal.__init__</vh></v>
<v t="ekr.20250122151620.408"><vh>ChangingDecimal.check_validity_of_input</vh></v>
<v t="ekr.20250122151620.409"><vh>ChangingDecimal.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250122151620.406"><vh>class ChangeDecimalToValue</vh>
<v t="ekr.20250122151620.410"><vh>ChangeDecimalToValue.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.411"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/rotation.py</vh>
<v t="ekr.20250122151620.412"><vh>class Rotating</vh>
<v t="ekr.20250122151620.414"><vh>Rotating.__init__</vh></v>
<v t="ekr.20250122151620.415"><vh>Rotating.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250122151620.413"><vh>class Rotate</vh>
<v t="ekr.20250122151620.416"><vh>Rotate.__init__</vh></v>
<v t="ekr.20250122151620.417"><vh>Rotate.create_target</vh></v>
</v>
</v>
<v t="ekr.20250122151620.418"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/specialized.py</vh>
<v t="ekr.20250122151620.419"><vh>class Broadcast</vh>
<v t="ekr.20250122151620.420"><vh>Broadcast.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.421"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/speedmodifier.py</vh>
<v t="ekr.20250122151620.422"><vh>class ChangeSpeed</vh>
<v t="ekr.20250122151620.423"><vh>ChangeSpeed.__init__</vh></v>
<v t="ekr.20250122151620.424"><vh>ChangeSpeed.setup</vh></v>
<v t="ekr.20250122151620.425"><vh>ChangeSpeed.get_scaled_total_time</vh></v>
<v t="ekr.20250122151620.426"><vh>ChangeSpeed.add_updater</vh></v>
<v t="ekr.20250122151620.427"><vh>ChangeSpeed.interpolate</vh></v>
<v t="ekr.20250122151620.428"><vh>ChangeSpeed.update_mobjects</vh></v>
<v t="ekr.20250122151620.429"><vh>ChangeSpeed.finish</vh></v>
<v t="ekr.20250122151620.430"><vh>ChangeSpeed.begin</vh></v>
<v t="ekr.20250122151620.431"><vh>ChangeSpeed.clean_up_from_scene</vh></v>
<v t="ekr.20250122151620.432"><vh>ChangeSpeed._setup_scene</vh></v>
</v>
</v>
<v t="ekr.20250122151620.433"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/transform.py</vh>
<v t="ekr.20250122151620.434"><vh>class Transform</vh>
<v t="ekr.20250122151620.456"><vh>Transform.__init__</vh></v>
<v t="ekr.20250122151620.457"><vh>Transform.path_arc</vh></v>
<v t="ekr.20250122151620.458"><vh>Transform.path_arc</vh></v>
<v t="ekr.20250122151620.459"><vh>Transform.path_func</vh></v>
<v t="ekr.20250122151620.460"><vh>Transform.path_func</vh></v>
<v t="ekr.20250122151620.461"><vh>Transform.begin</vh></v>
<v t="ekr.20250122151620.462"><vh>Transform.create_target</vh></v>
<v t="ekr.20250122151620.463"><vh>Transform.clean_up_from_scene</vh></v>
<v t="ekr.20250122151620.464"><vh>Transform.get_all_mobjects</vh></v>
<v t="ekr.20250122151620.465"><vh>Transform.get_all_families_zipped</vh></v>
<v t="ekr.20250122151620.466"><vh>Transform.interpolate_submobject</vh></v>
</v>
<v t="ekr.20250122151620.435"><vh>class ReplacementTransform</vh>
<v t="ekr.20250122151620.467"><vh>ReplacementTransform.__init__</vh></v>
</v>
<v t="ekr.20250122151620.436"><vh>class TransformFromCopy</vh>
<v t="ekr.20250122151620.468"><vh>TransformFromCopy.__init__</vh></v>
<v t="ekr.20250122151620.469"><vh>TransformFromCopy.interpolate</vh></v>
</v>
<v t="ekr.20250122151620.437"><vh>class ClockwiseTransform</vh>
<v t="ekr.20250122151620.470"><vh>ClockwiseTransform.__init__</vh></v>
</v>
<v t="ekr.20250122151620.438"><vh>class CounterclockwiseTransform</vh>
<v t="ekr.20250122151620.471"><vh>CounterclockwiseTransform.__init__</vh></v>
</v>
<v t="ekr.20250122151620.439"><vh>class MoveToTarget</vh>
<v t="ekr.20250122151620.472"><vh>MoveToTarget.__init__</vh></v>
<v t="ekr.20250122151620.473"><vh>MoveToTarget.check_validity_of_input</vh></v>
</v>
<v t="ekr.20250122151620.440"><vh>class _MethodAnimation</vh>
<v t="ekr.20250122151620.474"><vh>_MethodAnimation.__init__</vh></v>
<v t="ekr.20250122151620.475"><vh>_MethodAnimation.finish</vh></v>
</v>
<v t="ekr.20250122151620.441"><vh>class ApplyMethod</vh>
<v t="ekr.20250122151620.476"><vh>ApplyMethod.__init__</vh></v>
<v t="ekr.20250122151620.477"><vh>ApplyMethod.check_validity_of_input</vh></v>
<v t="ekr.20250122151620.478"><vh>ApplyMethod.create_target</vh></v>
</v>
<v t="ekr.20250122151620.442"><vh>class ApplyPointwiseFunction</vh>
<v t="ekr.20250122151620.479"><vh>ApplyPointwiseFunction.__init__</vh></v>
</v>
<v t="ekr.20250122151620.443"><vh>class ApplyPointwiseFunctionToCenter</vh>
<v t="ekr.20250122151620.480"><vh>ApplyPointwiseFunctionToCenter.__init__</vh></v>
<v t="ekr.20250122151620.481"><vh>ApplyPointwiseFunctionToCenter.begin</vh></v>
</v>
<v t="ekr.20250122151620.444"><vh>class FadeToColor</vh>
<v t="ekr.20250122151620.482"><vh>FadeToColor.__init__</vh></v>
</v>
<v t="ekr.20250122151620.445"><vh>class ScaleInPlace</vh>
<v t="ekr.20250122151620.483"><vh>ScaleInPlace.__init__</vh></v>
</v>
<v t="ekr.20250122151620.446"><vh>class ShrinkToCenter</vh>
<v t="ekr.20250122151620.484"><vh>ShrinkToCenter.__init__</vh></v>
</v>
<v t="ekr.20250122151620.447"><vh>class Restore</vh>
<v t="ekr.20250122151620.485"><vh>Restore.__init__</vh></v>
</v>
<v t="ekr.20250122151620.448"><vh>class ApplyFunction</vh>
<v t="ekr.20250122151620.486"><vh>ApplyFunction.__init__</vh></v>
<v t="ekr.20250122151620.487"><vh>ApplyFunction.create_target</vh></v>
</v>
<v t="ekr.20250122151620.449"><vh>class ApplyMatrix</vh>
<v t="ekr.20250122151620.488"><vh>ApplyMatrix.__init__</vh></v>
<v t="ekr.20250122151620.489"><vh>ApplyMatrix.initialize_matrix</vh></v>
</v>
<v t="ekr.20250122151620.450"><vh>class ApplyComplexFunction</vh>
<v t="ekr.20250122151620.490"><vh>ApplyComplexFunction.__init__</vh></v>
<v t="ekr.20250122151620.491"><vh>ApplyComplexFunction._init_path_func</vh></v>
</v>
<v t="ekr.20250122151620.451"><vh>class CyclicReplace</vh>
<v t="ekr.20250122151620.492"><vh>CyclicReplace.__init__</vh></v>
<v t="ekr.20250122151620.493"><vh>CyclicReplace.create_target</vh></v>
</v>
<v t="ekr.20250122151620.452"><vh>class Swap</vh></v>
<v t="ekr.20250122151620.453"><vh>class TransformAnimations</vh>
<v t="ekr.20250122151620.494"><vh>TransformAnimations.__init__</vh></v>
<v t="ekr.20250122151620.495"><vh>TransformAnimations.interpolate</vh></v>
</v>
<v t="ekr.20250122151620.454"><vh>class FadeTransform</vh>
<v t="ekr.20250122151620.496"><vh>FadeTransform.__init__</vh></v>
<v t="ekr.20250122151620.497"><vh>FadeTransform.begin</vh></v>
<v t="ekr.20250122151620.498"><vh>FadeTransform.ghost_to</vh></v>
<v t="ekr.20250122151620.499"><vh>FadeTransform.get_all_mobjects</vh></v>
<v t="ekr.20250122151620.500"><vh>FadeTransform.get_all_families_zipped</vh></v>
<v t="ekr.20250122151620.501"><vh>FadeTransform.clean_up_from_scene</vh></v>
</v>
<v t="ekr.20250122151620.455"><vh>class FadeTransformPieces</vh>
<v t="ekr.20250122151620.502"><vh>FadeTransformPieces.begin</vh></v>
<v t="ekr.20250122151620.503"><vh>FadeTransformPieces.ghost_to</vh></v>
</v>
</v>
<v t="ekr.20250122151620.504"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/transform_matching_parts.py</vh>
<v t="ekr.20250122151620.505"><vh>class TransformMatchingAbstractBase</vh>
<v t="ekr.20250122151620.508"><vh>TransformMatchingAbstractBase.__init__</vh></v>
<v t="ekr.20250122151620.509"><vh>TransformMatchingAbstractBase.get_shape_map</vh></v>
<v t="ekr.20250122151620.510"><vh>TransformMatchingAbstractBase.clean_up_from_scene</vh></v>
<v t="ekr.20250122151620.511"><vh>TransformMatchingAbstractBase.get_mobject_parts</vh></v>
<v t="ekr.20250122151620.512"><vh>TransformMatchingAbstractBase.get_mobject_key</vh></v>
</v>
<v t="ekr.20250122151620.506"><vh>class TransformMatchingShapes</vh>
<v t="ekr.20250122151620.513"><vh>TransformMatchingShapes.__init__</vh></v>
<v t="ekr.20250122151620.514"><vh>TransformMatchingShapes.get_mobject_parts</vh></v>
<v t="ekr.20250122151620.515"><vh>TransformMatchingShapes.get_mobject_key</vh></v>
</v>
<v t="ekr.20250122151620.507"><vh>class TransformMatchingTex</vh>
<v t="ekr.20250122151620.516"><vh>TransformMatchingTex.__init__</vh></v>
<v t="ekr.20250122151620.517"><vh>TransformMatchingTex.get_mobject_parts</vh></v>
<v t="ekr.20250122151620.518"><vh>TransformMatchingTex.get_mobject_key</vh></v>
</v>
</v>
<v t="ekr.20250122151620.519"><vh>C:/Python/Python3.12/Lib/site-packages/manim/animation/updaters</vh>
<v t="ekr.20250122151620.520"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/updaters/__init__.py</vh></v>
<v t="ekr.20250122151620.521"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/updaters/mobject_update_utils.py</vh>
<v t="ekr.20250122151620.522"><vh>function: assert_is_mobject_method</vh></v>
<v t="ekr.20250122151620.523"><vh>function: always</vh></v>
<v t="ekr.20250122151620.524"><vh>function: f_always</vh></v>
<v t="ekr.20250122151620.525"><vh>function: always_redraw</vh></v>
<v t="ekr.20250122151620.526"><vh>function: always_shift</vh></v>
<v t="ekr.20250122151620.527"><vh>function: always_rotate</vh></v>
<v t="ekr.20250122151620.528"><vh>function: turn_animation_into_updater</vh></v>
<v t="ekr.20250122151620.529"><vh>function: cycle_animation</vh></v>
</v>
<v t="ekr.20250122151620.530"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/animation/updaters/update.py</vh>
<v t="ekr.20250122151620.531"><vh>class UpdateFromFunc</vh>
<v t="ekr.20250122151620.534"><vh>UpdateFromFunc.__init__</vh></v>
<v t="ekr.20250122151620.535"><vh>UpdateFromFunc.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250122151620.532"><vh>class UpdateFromAlphaFunc</vh>
<v t="ekr.20250122151620.536"><vh>UpdateFromAlphaFunc.interpolate_mobject</vh></v>
</v>
<v t="ekr.20250122151620.533"><vh>class MaintainPositionRelativeTo</vh>
<v t="ekr.20250122151620.537"><vh>MaintainPositionRelativeTo.__init__</vh></v>
<v t="ekr.20250122151620.538"><vh>MaintainPositionRelativeTo.interpolate_mobject</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20250122151620.539"><vh>manim/camera</vh>
<v t="ekr.20250122151620.540"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/camera/__init__.py</vh></v>
<v t="ekr.20250122151620.541"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/camera/camera.py</vh>
<v t="ekr.20250122151620.542"><vh>class Camera</vh>
<v t="ekr.20250122151620.544"><vh>Camera.__init__</vh></v>
<v t="ekr.20250122151620.545"><vh>Camera.__deepcopy__</vh></v>
<v t="ekr.20250122151620.546"><vh>Camera.background_color</vh></v>
<v t="ekr.20250122151620.547"><vh>Camera.background_color</vh></v>
<v t="ekr.20250122151620.548"><vh>Camera.background_opacity</vh></v>
<v t="ekr.20250122151620.549"><vh>Camera.background_opacity</vh></v>
<v t="ekr.20250122151620.550"><vh>Camera.type_or_raise</vh></v>
<v t="ekr.20250122151620.551"><vh>Camera.reset_pixel_shape</vh></v>
<v t="ekr.20250122151620.552"><vh>Camera.resize_frame_shape</vh></v>
<v t="ekr.20250122151620.553"><vh>Camera.init_background</vh></v>
<v t="ekr.20250122151620.554"><vh>Camera.get_image</vh></v>
<v t="ekr.20250122151620.555"><vh>Camera.convert_pixel_array</vh></v>
<v t="ekr.20250122151620.556"><vh>Camera.set_pixel_array</vh></v>
<v t="ekr.20250122151620.557"><vh>Camera.set_background</vh></v>
<v t="ekr.20250122151620.558"><vh>Camera.make_background_from_func</vh></v>
<v t="ekr.20250122151620.559"><vh>Camera.set_background_from_func</vh></v>
<v t="ekr.20250122151620.560"><vh>Camera.reset</vh></v>
<v t="ekr.20250122151620.561"><vh>Camera.set_frame_to_background</vh></v>
<v t="ekr.20250122151620.562"><vh>Camera.get_mobjects_to_display</vh></v>
<v t="ekr.20250122151620.563"><vh>Camera.is_in_frame</vh></v>
<v t="ekr.20250122151620.564"><vh>Camera.capture_mobject</vh></v>
<v t="ekr.20250122151620.565"><vh>Camera.capture_mobjects</vh></v>
<v t="ekr.20250122151620.566"><vh>Camera.get_cached_cairo_context</vh></v>
<v t="ekr.20250122151620.567"><vh>Camera.cache_cairo_context</vh></v>
<v t="ekr.20250122151620.568"><vh>Camera.get_cairo_context</vh></v>
<v t="ekr.20250122151620.569"><vh>Camera.display_multiple_vectorized_mobjects</vh></v>
<v t="ekr.20250122151620.570"><vh>Camera.display_multiple_non_background_colored_vmobjects</vh></v>
<v t="ekr.20250122151620.571"><vh>Camera.display_vectorized</vh></v>
<v t="ekr.20250122151620.572"><vh>Camera.set_cairo_context_path</vh></v>
<v t="ekr.20250122151620.573"><vh>Camera.set_cairo_context_color</vh></v>
<v t="ekr.20250122151620.574"><vh>Camera.apply_fill</vh></v>
<v t="ekr.20250122151620.575"><vh>Camera.apply_stroke</vh></v>
<v t="ekr.20250122151620.576"><vh>Camera.get_stroke_rgbas</vh></v>
<v t="ekr.20250122151620.577"><vh>Camera.get_fill_rgbas</vh></v>
<v t="ekr.20250122151620.578"><vh>Camera.get_background_colored_vmobject_displayer</vh></v>
<v t="ekr.20250122151620.579"><vh>Camera.display_multiple_background_colored_vmobjects</vh></v>
<v t="ekr.20250122151620.580"><vh>Camera.display_multiple_point_cloud_mobjects</vh></v>
<v t="ekr.20250122151620.581"><vh>Camera.display_point_cloud</vh></v>
<v t="ekr.20250122151620.582"><vh>Camera.display_multiple_image_mobjects</vh></v>
<v t="ekr.20250122151620.583"><vh>Camera.display_image_mobject</vh></v>
<v t="ekr.20250122151620.584"><vh>Camera.overlay_rgba_array</vh></v>
<v t="ekr.20250122151620.585"><vh>Camera.overlay_PIL_image</vh></v>
<v t="ekr.20250122151620.586"><vh>Camera.adjust_out_of_range_points</vh></v>
<v t="ekr.20250122151620.587"><vh>Camera.transform_points_pre_display</vh></v>
<v t="ekr.20250122151620.588"><vh>Camera.points_to_pixel_coords</vh></v>
<v t="ekr.20250122151620.589"><vh>Camera.on_screen_pixels</vh></v>
<v t="ekr.20250122151620.590"><vh>Camera.adjusted_thickness</vh></v>
<v t="ekr.20250122151620.591"><vh>Camera.get_thickening_nudges</vh></v>
<v t="ekr.20250122151620.592"><vh>Camera.thickened_coordinates</vh></v>
<v t="ekr.20250122151620.593"><vh>Camera.get_coords_of_all_pixels</vh></v>
</v>
<v t="ekr.20250122151620.543"><vh>class BackgroundColoredVMobjectDisplayer</vh>
<v t="ekr.20250122151620.594"><vh>BackgroundColoredVMobjectDisplayer.__init__</vh></v>
<v t="ekr.20250122151620.595"><vh>BackgroundColoredVMobjectDisplayer.reset_pixel_array</vh></v>
<v t="ekr.20250122151620.596"><vh>BackgroundColoredVMobjectDisplayer.resize_background_array</vh></v>
<v t="ekr.20250122151620.597"><vh>BackgroundColoredVMobjectDisplayer.resize_background_array_to_match</vh></v>
<v t="ekr.20250122151620.598"><vh>BackgroundColoredVMobjectDisplayer.get_background_array</vh></v>
<v t="ekr.20250122151620.599"><vh>BackgroundColoredVMobjectDisplayer.display</vh></v>
</v>
</v>
<v t="ekr.20250122151620.600"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/camera/mapping_camera.py</vh>
<v t="ekr.20250122151620.601"><vh>class MappingCamera</vh>
<v t="ekr.20250122151620.604"><vh>MappingCamera.__init__</vh></v>
<v t="ekr.20250122151620.605"><vh>MappingCamera.points_to_pixel_coords</vh></v>
<v t="ekr.20250122151620.606"><vh>MappingCamera.capture_mobjects</vh></v>
</v>
<v t="ekr.20250122151620.602"><vh>class OldMultiCamera</vh>
<v t="ekr.20250122151620.607"><vh>OldMultiCamera.__init__</vh></v>
<v t="ekr.20250122151620.608"><vh>OldMultiCamera.capture_mobjects</vh></v>
<v t="ekr.20250122151620.609"><vh>OldMultiCamera.set_background</vh></v>
<v t="ekr.20250122151620.610"><vh>OldMultiCamera.set_pixel_array</vh></v>
<v t="ekr.20250122151620.611"><vh>OldMultiCamera.init_background</vh></v>
</v>
<v t="ekr.20250122151620.603"><vh>class SplitScreenCamera</vh>
<v t="ekr.20250122151620.612"><vh>SplitScreenCamera.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.613"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/camera/moving_camera.py</vh>
<v t="ekr.20250122151620.614"><vh>class MovingCamera</vh>
<v t="ekr.20250122151620.615"><vh>MovingCamera.__init__</vh></v>
<v t="ekr.20250122151620.616"><vh>MovingCamera.frame_height</vh></v>
<v t="ekr.20250122151620.617"><vh>MovingCamera.frame_width</vh></v>
<v t="ekr.20250122151620.618"><vh>MovingCamera.frame_center</vh></v>
<v t="ekr.20250122151620.619"><vh>MovingCamera.frame_height</vh></v>
<v t="ekr.20250122151620.620"><vh>MovingCamera.frame_width</vh></v>
<v t="ekr.20250122151620.621"><vh>MovingCamera.frame_center</vh></v>
<v t="ekr.20250122151620.622"><vh>MovingCamera.capture_mobjects</vh></v>
<v t="ekr.20250122151620.623"><vh>MovingCamera.get_cached_cairo_context</vh></v>
<v t="ekr.20250122151620.624"><vh>MovingCamera.cache_cairo_context</vh></v>
<v t="ekr.20250122151620.625"><vh>MovingCamera.get_mobjects_indicating_movement</vh></v>
<v t="ekr.20250122151620.626"><vh>MovingCamera.auto_zoom</vh></v>
</v>
</v>
<v t="ekr.20250122151620.627"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/camera/multi_camera.py</vh>
<v t="ekr.20250122151620.628"><vh>class MultiCamera</vh>
<v t="ekr.20250122151620.629"><vh>MultiCamera.__init__</vh></v>
<v t="ekr.20250122151620.630"><vh>MultiCamera.add_image_mobject_from_camera</vh></v>
<v t="ekr.20250122151620.631"><vh>MultiCamera.update_sub_cameras</vh></v>
<v t="ekr.20250122151620.632"><vh>MultiCamera.reset</vh></v>
<v t="ekr.20250122151620.633"><vh>MultiCamera.capture_mobjects</vh></v>
<v t="ekr.20250122151620.634"><vh>MultiCamera.get_mobjects_indicating_movement</vh></v>
</v>
</v>
<v t="ekr.20250122151620.635"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/camera/three_d_camera.py</vh>
<v t="ekr.20250122151620.636"><vh>class ThreeDCamera</vh>
<v t="ekr.20250122151620.637"><vh>ThreeDCamera.__init__</vh></v>
<v t="ekr.20250122151620.638"><vh>ThreeDCamera.frame_center</vh></v>
<v t="ekr.20250122151620.639"><vh>ThreeDCamera.frame_center</vh></v>
<v t="ekr.20250122151620.640"><vh>ThreeDCamera.capture_mobjects</vh></v>
<v t="ekr.20250122151620.641"><vh>ThreeDCamera.get_value_trackers</vh></v>
<v t="ekr.20250122151620.642"><vh>ThreeDCamera.modified_rgbas</vh></v>
<v t="ekr.20250122151620.643"><vh>ThreeDCamera.get_stroke_rgbas</vh></v>
<v t="ekr.20250122151620.644"><vh>ThreeDCamera.get_fill_rgbas</vh></v>
<v t="ekr.20250122151620.645"><vh>ThreeDCamera.get_mobjects_to_display</vh></v>
<v t="ekr.20250122151620.646"><vh>ThreeDCamera.get_phi</vh></v>
<v t="ekr.20250122151620.647"><vh>ThreeDCamera.get_theta</vh></v>
<v t="ekr.20250122151620.648"><vh>ThreeDCamera.get_focal_distance</vh></v>
<v t="ekr.20250122151620.649"><vh>ThreeDCamera.get_gamma</vh></v>
<v t="ekr.20250122151620.650"><vh>ThreeDCamera.get_zoom</vh></v>
<v t="ekr.20250122151620.651"><vh>ThreeDCamera.set_phi</vh></v>
<v t="ekr.20250122151620.652"><vh>ThreeDCamera.set_theta</vh></v>
<v t="ekr.20250122151620.653"><vh>ThreeDCamera.set_focal_distance</vh></v>
<v t="ekr.20250122151620.654"><vh>ThreeDCamera.set_gamma</vh></v>
<v t="ekr.20250122151620.655"><vh>ThreeDCamera.set_zoom</vh></v>
<v t="ekr.20250122151620.656"><vh>ThreeDCamera.reset_rotation_matrix</vh></v>
<v t="ekr.20250122151620.657"><vh>ThreeDCamera.get_rotation_matrix</vh></v>
<v t="ekr.20250122151620.658"><vh>ThreeDCamera.generate_rotation_matrix</vh></v>
<v t="ekr.20250122151620.659"><vh>ThreeDCamera.project_points</vh></v>
<v t="ekr.20250122151620.660"><vh>ThreeDCamera.project_point</vh></v>
<v t="ekr.20250122151620.661"><vh>ThreeDCamera.transform_points_pre_display</vh></v>
<v t="ekr.20250122151620.662"><vh>ThreeDCamera.add_fixed_orientation_mobjects</vh></v>
<v t="ekr.20250122151620.663"><vh>ThreeDCamera.add_fixed_in_frame_mobjects</vh></v>
<v t="ekr.20250122151620.664"><vh>ThreeDCamera.remove_fixed_orientation_mobjects</vh></v>
<v t="ekr.20250122151620.665"><vh>ThreeDCamera.remove_fixed_in_frame_mobjects</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151620.666"><vh>manim/cli</vh>
<v t="ekr.20250122151620.667"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/__init__.py</vh></v>
<v t="ekr.20250122151620.668"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/default_group.py</vh>
<v t="ekr.20250122151620.669"><vh>class DefaultGroup</vh>
<v t="ekr.20250122151620.670"><vh>DefaultGroup.__init__</vh></v>
<v t="ekr.20250122151620.671"><vh>DefaultGroup.set_default_command</vh></v>
<v t="ekr.20250122151620.672"><vh>DefaultGroup.parse_args</vh></v>
<v t="ekr.20250122151620.673"><vh>DefaultGroup.get_command</vh></v>
<v t="ekr.20250122151620.674"><vh>DefaultGroup.resolve_command</vh></v>
<v t="ekr.20250122151620.675"><vh>DefaultGroup.command</vh></v>
</v>
</v>
<v t="ekr.20250122151620.676"><vh>C:/Python/Python3.12/Lib/site-packages/manim/cli/cfg</vh>
<v t="ekr.20250122151620.677"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/cfg/__init__.py</vh></v>
<v t="ekr.20250122151620.678"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/cfg/group.py</vh>
<v t="ekr.20250122151620.679"><vh>function: value_from_string</vh></v>
<v t="ekr.20250122151620.680"><vh>function: _is_expected_datatype</vh></v>
<v t="ekr.20250122151620.681"><vh>function: is_valid_style</vh></v>
<v t="ekr.20250122151620.682"><vh>function: replace_keys</vh></v>
<v t="ekr.20250122151620.683"><vh>function: cfg</vh></v>
<v t="ekr.20250122151620.684"><vh>function: write</vh></v>
<v t="ekr.20250122151620.685"><vh>function: show</vh></v>
<v t="ekr.20250122151620.686"><vh>function: export</vh></v>
</v>
</v>
<v t="ekr.20250122151620.687"><vh>C:/Python/Python3.12/Lib/site-packages/manim/cli/checkhealth</vh>
<v t="ekr.20250122151620.688"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/checkhealth/__init__.py</vh></v>
<v t="ekr.20250122151620.689"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/checkhealth/checks.py</vh>
<v t="ekr.20250122151620.690"><vh>class HealthCheckFunction</vh>
<v t="ekr.20250122151620.696"><vh>HealthCheckFunction.__call__</vh></v>
</v>
<v t="ekr.20250122151620.691"><vh>function: healthcheck</vh></v>
<v t="ekr.20250122151620.692"><vh>function: is_manim_on_path</vh></v>
<v t="ekr.20250122151620.693"><vh>function: is_manim_executable_associated_to_this_library</vh></v>
<v t="ekr.20250122151620.694"><vh>function: is_latex_available</vh></v>
<v t="ekr.20250122151620.695"><vh>function: is_dvisvgm_available</vh></v>
</v>
<v t="ekr.20250122151620.697"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/checkhealth/commands.py</vh>
<v t="ekr.20250122151620.698"><vh>function: checkhealth</vh>
<v t="ekr.20250122151620.699"><vh>class CheckHealthDemo</vh>
<v t="ekr.20250122151620.700"><vh>CheckHealthDemo._inner_construct</vh></v>
<v t="ekr.20250122151620.701"><vh>CheckHealthDemo.construct</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20250122151620.702"><vh>C:/Python/Python3.12/Lib/site-packages/manim/cli/init</vh>
<v t="ekr.20250122151620.703"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/init/__init__.py</vh></v>
<v t="ekr.20250122151620.704"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/init/commands.py</vh>
<v t="ekr.20250122151620.705"><vh>function: select_resolution</vh></v>
<v t="ekr.20250122151620.706"><vh>function: update_cfg</vh></v>
<v t="ekr.20250122151620.707"><vh>function: project</vh></v>
<v t="ekr.20250122151620.708"><vh>function: scene</vh></v>
<v t="ekr.20250122151620.709"><vh>function: init</vh></v>
</v>
</v>
<v t="ekr.20250122151620.710"><vh>C:/Python/Python3.12/Lib/site-packages/manim/cli/plugins</vh>
<v t="ekr.20250122151620.711"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/plugins/__init__.py</vh></v>
<v t="ekr.20250122151620.712"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/plugins/commands.py</vh>
<v t="ekr.20250122151620.713"><vh>function: plugins</vh></v>
</v>
</v>
<v t="ekr.20250122151620.714"><vh>C:/Python/Python3.12/Lib/site-packages/manim/cli/render</vh>
<v t="ekr.20250122151620.715"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/render/__init__.py</vh></v>
<v t="ekr.20250122151620.716"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/render/commands.py</vh>
<v t="ekr.20250122151620.717"><vh>class ClickArgs</vh>
<v t="ekr.20250122151620.719"><vh>ClickArgs.__init__</vh></v>
<v t="ekr.20250122151620.720"><vh>ClickArgs._get_kwargs</vh></v>
<v t="ekr.20250122151620.721"><vh>ClickArgs.__eq__</vh></v>
<v t="ekr.20250122151620.722"><vh>ClickArgs.__contains__</vh></v>
<v t="ekr.20250122151620.723"><vh>ClickArgs.__repr__</vh></v>
</v>
<v t="ekr.20250122151620.718"><vh>function: render</vh></v>
</v>
<v t="ekr.20250122151620.724"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/render/ease_of_access_options.py</vh></v>
<v t="ekr.20250122151620.725"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/render/global_options.py</vh>
<v t="ekr.20250122151620.726"><vh>function: validate_gui_location</vh></v>
</v>
<v t="ekr.20250122151620.727"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/render/output_options.py</vh></v>
<v t="ekr.20250122151620.728"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/cli/render/render_options.py</vh>
<v t="ekr.20250122151620.729"><vh>function: validate_scene_range</vh></v>
<v t="ekr.20250122151620.730"><vh>function: validate_resolution</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151620.731"><vh>manim/gui</vh>
<v t="ekr.20250122151620.732"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/gui/__init__.py</vh></v>
<v t="ekr.20250122151620.733"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/gui/gui.py</vh>
<v t="ekr.20250122151620.734"><vh>function: configure_pygui</vh></v>
</v>
</v>
<v t="ekr.20250122151620.735"><vh>manim/mobject</vh>
<v t="ekr.20250122151620.736"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/__init__.py</vh></v>
<v t="ekr.20250122151620.737"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/frame.py</vh>
<v t="ekr.20250122151620.738"><vh>class ScreenRectangle</vh>
<v t="ekr.20250122151620.740"><vh>ScreenRectangle.__init__</vh></v>
<v t="ekr.20250122151620.741"><vh>ScreenRectangle.aspect_ratio</vh></v>
<v t="ekr.20250122151620.742"><vh>ScreenRectangle.aspect_ratio</vh></v>
</v>
<v t="ekr.20250122151620.739"><vh>class FullScreenRectangle</vh>
<v t="ekr.20250122151620.743"><vh>FullScreenRectangle.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.744"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/graph.py</vh>
<v t="ekr.20250122151620.745"><vh>class LayoutFunction</vh>
<v t="ekr.20250122151620.753"><vh>LayoutFunction.__call__</vh></v>
</v>
<v t="ekr.20250122151620.746"><vh>function: _partite_layout</vh></v>
<v t="ekr.20250122151620.747"><vh>function: _random_layout</vh></v>
<v t="ekr.20250122151620.748"><vh>function: _tree_layout</vh></v>
<v t="ekr.20250122151620.749"><vh>function: _determine_graph_layout</vh></v>
<v t="ekr.20250122151620.750"><vh>class GenericGraph</vh>
<v t="ekr.20250122151620.754"><vh>GenericGraph.__init__</vh></v>
<v t="ekr.20250122151620.755"><vh>GenericGraph._empty_networkx_graph</vh></v>
<v t="ekr.20250122151620.756"><vh>GenericGraph._populate_edge_dict</vh></v>
<v t="ekr.20250122151620.757"><vh>GenericGraph.__getitem__</vh></v>
<v t="ekr.20250122151620.758"><vh>GenericGraph._create_vertex</vh></v>
<v t="ekr.20250122151620.759"><vh>GenericGraph._add_created_vertex</vh></v>
<v t="ekr.20250122151620.760"><vh>GenericGraph._add_vertex</vh></v>
<v t="ekr.20250122151620.761"><vh>GenericGraph._create_vertices</vh></v>
<v t="ekr.20250122151620.762"><vh>GenericGraph.add_vertices</vh></v>
<v t="ekr.20250122151620.763"><vh>GenericGraph._add_vertices_animation</vh></v>
<v t="ekr.20250122151620.764"><vh>GenericGraph._remove_vertex</vh></v>
<v t="ekr.20250122151620.765"><vh>GenericGraph.remove_vertices</vh></v>
<v t="ekr.20250122151620.766"><vh>GenericGraph._remove_vertices_animation</vh></v>
<v t="ekr.20250122151620.767"><vh>GenericGraph._add_edge</vh></v>
<v t="ekr.20250122151620.768"><vh>GenericGraph.add_edges</vh></v>
<v t="ekr.20250122151620.769"><vh>GenericGraph._add_edges_animation</vh></v>
<v t="ekr.20250122151620.770"><vh>GenericGraph._remove_edge</vh></v>
<v t="ekr.20250122151620.771"><vh>GenericGraph.remove_edges</vh></v>
<v t="ekr.20250122151620.772"><vh>GenericGraph._remove_edges_animation</vh></v>
<v t="ekr.20250122151620.773"><vh>GenericGraph.from_networkx</vh></v>
<v t="ekr.20250122151620.774"><vh>GenericGraph.change_layout</vh></v>
</v>
<v t="ekr.20250122151620.751"><vh>class Graph</vh>
<v t="ekr.20250122151620.775"><vh>Graph._empty_networkx_graph</vh></v>
<v t="ekr.20250122151620.776"><vh>Graph._populate_edge_dict</vh></v>
<v t="ekr.20250122151620.777"><vh>Graph.update_edges</vh></v>
<v t="ekr.20250122151620.778"><vh>Graph.__repr__</vh></v>
</v>
<v t="ekr.20250122151620.752"><vh>class DiGraph</vh>
<v t="ekr.20250122151620.779"><vh>DiGraph._empty_networkx_graph</vh></v>
<v t="ekr.20250122151620.780"><vh>DiGraph._populate_edge_dict</vh></v>
<v t="ekr.20250122151620.781"><vh>DiGraph.update_edges</vh></v>
<v t="ekr.20250122151620.782"><vh>DiGraph.__repr__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.783"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/logo.py</vh>
<v t="ekr.20250122151620.784"><vh>class ManimBanner</vh>
<v t="ekr.20250122151620.785"><vh>ManimBanner.__init__</vh></v>
<v t="ekr.20250122151620.786"><vh>ManimBanner.scale</vh></v>
<v t="ekr.20250122151620.787"><vh>ManimBanner.create</vh></v>
<v t="ekr.20250122151620.788"><vh>ManimBanner.expand</vh></v>
</v>
</v>
<v t="ekr.20250122151620.789"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/matrix.py</vh>
<v t="ekr.20250122151620.790"><vh>function: matrix_to_tex_string</vh></v>
<v t="ekr.20250122151620.791"><vh>function: matrix_to_mobject</vh></v>
<v t="ekr.20250122151620.792"><vh>class Matrix</vh>
<v t="ekr.20250122151620.797"><vh>Matrix.__init__</vh></v>
<v t="ekr.20250122151620.798"><vh>Matrix._matrix_to_mob_matrix</vh></v>
<v t="ekr.20250122151620.799"><vh>Matrix._organize_mob_matrix</vh></v>
<v t="ekr.20250122151620.800"><vh>Matrix._add_brackets</vh></v>
<v t="ekr.20250122151620.801"><vh>Matrix.get_columns</vh></v>
<v t="ekr.20250122151620.802"><vh>Matrix.set_column_colors</vh></v>
<v t="ekr.20250122151620.803"><vh>Matrix.get_rows</vh></v>
<v t="ekr.20250122151620.804"><vh>Matrix.set_row_colors</vh></v>
<v t="ekr.20250122151620.805"><vh>Matrix.add_background_to_entries</vh></v>
<v t="ekr.20250122151620.806"><vh>Matrix.get_mob_matrix</vh></v>
<v t="ekr.20250122151620.807"><vh>Matrix.get_entries</vh></v>
<v t="ekr.20250122151620.808"><vh>Matrix.get_brackets</vh></v>
</v>
<v t="ekr.20250122151620.793"><vh>class DecimalMatrix</vh>
<v t="ekr.20250122151620.809"><vh>DecimalMatrix.__init__</vh></v>
</v>
<v t="ekr.20250122151620.794"><vh>class IntegerMatrix</vh>
<v t="ekr.20250122151620.810"><vh>IntegerMatrix.__init__</vh></v>
</v>
<v t="ekr.20250122151620.795"><vh>class MobjectMatrix</vh>
<v t="ekr.20250122151620.811"><vh>MobjectMatrix.__init__</vh></v>
</v>
<v t="ekr.20250122151620.796"><vh>function: get_det_text</vh></v>
</v>
<v t="ekr.20250122151620.812"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/mobject.py</vh>
<v t="ekr.20250122151620.813"><vh>class Mobject</vh>
<v t="ekr.20250122151620.817"><vh>Mobject.__init_subclass__</vh></v>
<v t="ekr.20250122151620.818"><vh>Mobject.__init__</vh></v>
<v t="ekr.20250122151620.819"><vh>Mobject._assert_valid_submobjects</vh></v>
<v t="ekr.20250122151620.820"><vh>Mobject._assert_valid_submobjects_internal</vh></v>
<v t="ekr.20250122151620.821"><vh>Mobject.animation_override_for</vh></v>
<v t="ekr.20250122151620.822"><vh>Mobject._add_intrinsic_animation_overrides</vh></v>
<v t="ekr.20250122151620.823"><vh>Mobject.add_animation_override</vh></v>
<v t="ekr.20250122151620.824"><vh>Mobject.set_default</vh></v>
<v t="ekr.20250122151620.825"><vh>Mobject.animate</vh></v>
<v t="ekr.20250122151620.826"><vh>Mobject.__deepcopy__</vh></v>
<v t="ekr.20250122151620.827"><vh>Mobject.__repr__</vh></v>
<v t="ekr.20250122151620.828"><vh>Mobject.reset_points</vh></v>
<v t="ekr.20250122151620.829"><vh>Mobject.init_colors</vh></v>
<v t="ekr.20250122151620.830"><vh>Mobject.generate_points</vh></v>
<v t="ekr.20250122151620.831"><vh>Mobject.add</vh></v>
<v t="ekr.20250122151620.832"><vh>Mobject.insert</vh></v>
<v t="ekr.20250122151620.833"><vh>Mobject.__add__</vh></v>
<v t="ekr.20250122151620.834"><vh>Mobject.__iadd__</vh></v>
<v t="ekr.20250122151620.835"><vh>Mobject.add_to_back</vh></v>
<v t="ekr.20250122151620.836"><vh>Mobject.remove</vh></v>
<v t="ekr.20250122151620.837"><vh>Mobject.__sub__</vh></v>
<v t="ekr.20250122151620.838"><vh>Mobject.__isub__</vh></v>
<v t="ekr.20250122151620.839"><vh>Mobject.set</vh></v>
<v t="ekr.20250122151620.840"><vh>Mobject.__getattr__</vh></v>
<v t="ekr.20250122151620.841"><vh>Mobject.width</vh></v>
<v t="ekr.20250122151620.842"><vh>Mobject.width</vh></v>
<v t="ekr.20250122151620.843"><vh>Mobject.height</vh></v>
<v t="ekr.20250122151620.844"><vh>Mobject.height</vh></v>
<v t="ekr.20250122151620.845"><vh>Mobject.depth</vh></v>
<v t="ekr.20250122151620.846"><vh>Mobject.depth</vh></v>
<v t="ekr.20250122151620.847"><vh>Mobject.get_array_attrs</vh></v>
<v t="ekr.20250122151620.848"><vh>Mobject.apply_over_attr_arrays</vh></v>
<v t="ekr.20250122151620.849"><vh>Mobject.get_image</vh></v>
<v t="ekr.20250122151620.850"><vh>Mobject.show</vh></v>
<v t="ekr.20250122151620.851"><vh>Mobject.save_image</vh></v>
<v t="ekr.20250122151620.852"><vh>Mobject.copy</vh></v>
<v t="ekr.20250122151620.853"><vh>Mobject.generate_target</vh></v>
<v t="ekr.20250122151620.854"><vh>Mobject.update</vh></v>
<v t="ekr.20250122151620.855"><vh>Mobject.get_time_based_updaters</vh></v>
<v t="ekr.20250122151620.856"><vh>Mobject.has_time_based_updater</vh></v>
<v t="ekr.20250122151620.857"><vh>Mobject.get_updaters</vh></v>
<v t="ekr.20250122151620.858"><vh>Mobject.get_family_updaters</vh></v>
<v t="ekr.20250122151620.859"><vh>Mobject.add_updater</vh></v>
<v t="ekr.20250122151620.860"><vh>Mobject.remove_updater</vh></v>
<v t="ekr.20250122151620.861"><vh>Mobject.clear_updaters</vh></v>
<v t="ekr.20250122151620.862"><vh>Mobject.match_updaters</vh></v>
<v t="ekr.20250122151620.863"><vh>Mobject.suspend_updating</vh></v>
<v t="ekr.20250122151620.864"><vh>Mobject.resume_updating</vh></v>
<v t="ekr.20250122151620.865"><vh>Mobject.apply_to_family</vh></v>
<v t="ekr.20250122151620.866"><vh>Mobject.shift</vh></v>
<v t="ekr.20250122151620.867"><vh>Mobject.scale</vh></v>
<v t="ekr.20250122151620.868"><vh>Mobject.rotate_about_origin</vh></v>
<v t="ekr.20250122151620.869"><vh>Mobject.rotate</vh></v>
<v t="ekr.20250122151620.870"><vh>Mobject.flip</vh></v>
<v t="ekr.20250122151620.871"><vh>Mobject.stretch</vh></v>
<v t="ekr.20250122151620.872"><vh>Mobject.apply_function</vh></v>
<v t="ekr.20250122151620.873"><vh>Mobject.apply_function_to_position</vh></v>
<v t="ekr.20250122151620.874"><vh>Mobject.apply_function_to_submobject_positions</vh></v>
<v t="ekr.20250122151620.875"><vh>Mobject.apply_matrix</vh></v>
<v t="ekr.20250122151620.876"><vh>Mobject.apply_complex_function</vh></v>
<v t="ekr.20250122151620.877"><vh>Mobject.reverse_points</vh></v>
<v t="ekr.20250122151620.878"><vh>Mobject.repeat</vh></v>
<v t="ekr.20250122151620.879"><vh>Mobject.apply_points_function_about_point</vh></v>
<v t="ekr.20250122151620.880"><vh>Mobject.pose_at_angle</vh></v>
<v t="ekr.20250122151620.881"><vh>Mobject.center</vh></v>
<v t="ekr.20250122151620.882"><vh>Mobject.align_on_border</vh></v>
<v t="ekr.20250122151620.883"><vh>Mobject.to_corner</vh></v>
<v t="ekr.20250122151620.884"><vh>Mobject.to_edge</vh></v>
<v t="ekr.20250122151620.885"><vh>Mobject.next_to</vh></v>
<v t="ekr.20250122151620.886"><vh>Mobject.shift_onto_screen</vh></v>
<v t="ekr.20250122151620.887"><vh>Mobject.is_off_screen</vh></v>
<v t="ekr.20250122151620.888"><vh>Mobject.stretch_about_point</vh></v>
<v t="ekr.20250122151620.889"><vh>Mobject.rescale_to_fit</vh></v>
<v t="ekr.20250122151620.890"><vh>Mobject.scale_to_fit_width</vh></v>
<v t="ekr.20250122151620.891"><vh>Mobject.stretch_to_fit_width</vh></v>
<v t="ekr.20250122151620.892"><vh>Mobject.scale_to_fit_height</vh></v>
<v t="ekr.20250122151620.893"><vh>Mobject.stretch_to_fit_height</vh></v>
<v t="ekr.20250122151620.894"><vh>Mobject.scale_to_fit_depth</vh></v>
<v t="ekr.20250122151620.895"><vh>Mobject.stretch_to_fit_depth</vh></v>
<v t="ekr.20250122151620.896"><vh>Mobject.set_coord</vh></v>
<v t="ekr.20250122151620.897"><vh>Mobject.set_x</vh></v>
<v t="ekr.20250122151620.898"><vh>Mobject.set_y</vh></v>
<v t="ekr.20250122151620.899"><vh>Mobject.set_z</vh></v>
<v t="ekr.20250122151620.900"><vh>Mobject.space_out_submobjects</vh></v>
<v t="ekr.20250122151620.901"><vh>Mobject.move_to</vh></v>
<v t="ekr.20250122151620.902"><vh>Mobject.replace</vh></v>
<v t="ekr.20250122151620.903"><vh>Mobject.surround</vh></v>
<v t="ekr.20250122151620.904"><vh>Mobject.put_start_and_end_on</vh></v>
<v t="ekr.20250122151620.905"><vh>Mobject.add_background_rectangle</vh></v>
<v t="ekr.20250122151620.906"><vh>Mobject.add_background_rectangle_to_submobjects</vh></v>
<v t="ekr.20250122151620.907"><vh>Mobject.add_background_rectangle_to_family_members_with_points</vh></v>
<v t="ekr.20250122151620.908"><vh>Mobject.set_color</vh></v>
<v t="ekr.20250122151620.909"><vh>Mobject.set_color_by_gradient</vh></v>
<v t="ekr.20250122151620.910"><vh>Mobject.set_colors_by_radial_gradient</vh></v>
<v t="ekr.20250122151620.911"><vh>Mobject.set_submobject_colors_by_gradient</vh></v>
<v t="ekr.20250122151620.912"><vh>Mobject.set_submobject_colors_by_radial_gradient</vh></v>
<v t="ekr.20250122151620.913"><vh>Mobject.to_original_color</vh></v>
<v t="ekr.20250122151620.914"><vh>Mobject.fade_to</vh></v>
<v t="ekr.20250122151620.915"><vh>Mobject.fade</vh></v>
<v t="ekr.20250122151620.916"><vh>Mobject.get_color</vh></v>
<v t="ekr.20250122151620.917"><vh>Mobject.save_state</vh></v>
<v t="ekr.20250122151620.918"><vh>Mobject.restore</vh></v>
<v t="ekr.20250122151620.919"><vh>Mobject.reduce_across_dimension</vh></v>
<v t="ekr.20250122151620.920"><vh>Mobject.nonempty_submobjects</vh></v>
<v t="ekr.20250122151620.921"><vh>Mobject.get_merged_array</vh></v>
<v t="ekr.20250122151620.922"><vh>Mobject.get_all_points</vh></v>
<v t="ekr.20250122151620.923"><vh>Mobject.get_points_defining_boundary</vh></v>
<v t="ekr.20250122151620.924"><vh>Mobject.get_num_points</vh></v>
<v t="ekr.20250122151620.925"><vh>Mobject.get_extremum_along_dim</vh></v>
<v t="ekr.20250122151620.926"><vh>Mobject.get_critical_point</vh></v>
<v t="ekr.20250122151620.927"><vh>Mobject.get_edge_center</vh></v>
<v t="ekr.20250122151620.928"><vh>Mobject.get_corner</vh></v>
<v t="ekr.20250122151620.929"><vh>Mobject.get_center</vh></v>
<v t="ekr.20250122151620.930"><vh>Mobject.get_center_of_mass</vh></v>
<v t="ekr.20250122151620.931"><vh>Mobject.get_boundary_point</vh></v>
<v t="ekr.20250122151620.932"><vh>Mobject.get_midpoint</vh></v>
<v t="ekr.20250122151620.933"><vh>Mobject.get_top</vh></v>
<v t="ekr.20250122151620.934"><vh>Mobject.get_bottom</vh></v>
<v t="ekr.20250122151620.935"><vh>Mobject.get_right</vh></v>
<v t="ekr.20250122151620.936"><vh>Mobject.get_left</vh></v>
<v t="ekr.20250122151620.937"><vh>Mobject.get_zenith</vh></v>
<v t="ekr.20250122151620.938"><vh>Mobject.get_nadir</vh></v>
<v t="ekr.20250122151620.939"><vh>Mobject.length_over_dim</vh></v>
<v t="ekr.20250122151620.940"><vh>Mobject.get_coord</vh></v>
<v t="ekr.20250122151620.941"><vh>Mobject.get_x</vh></v>
<v t="ekr.20250122151620.942"><vh>Mobject.get_y</vh></v>
<v t="ekr.20250122151620.943"><vh>Mobject.get_z</vh></v>
<v t="ekr.20250122151620.944"><vh>Mobject.get_start</vh></v>
<v t="ekr.20250122151620.945"><vh>Mobject.get_end</vh></v>
<v t="ekr.20250122151620.946"><vh>Mobject.get_start_and_end</vh></v>
<v t="ekr.20250122151620.947"><vh>Mobject.point_from_proportion</vh></v>
<v t="ekr.20250122151620.948"><vh>Mobject.proportion_from_point</vh></v>
<v t="ekr.20250122151620.949"><vh>Mobject.get_pieces</vh></v>
<v t="ekr.20250122151620.950"><vh>Mobject.get_z_index_reference_point</vh></v>
<v t="ekr.20250122151620.951"><vh>Mobject.has_points</vh></v>
<v t="ekr.20250122151620.952"><vh>Mobject.has_no_points</vh></v>
<v t="ekr.20250122151620.953"><vh>Mobject.match_color</vh></v>
<v t="ekr.20250122151620.954"><vh>Mobject.match_dim_size</vh></v>
<v t="ekr.20250122151620.955"><vh>Mobject.match_width</vh></v>
<v t="ekr.20250122151620.956"><vh>Mobject.match_height</vh></v>
<v t="ekr.20250122151620.957"><vh>Mobject.match_depth</vh></v>
<v t="ekr.20250122151620.958"><vh>Mobject.match_coord</vh></v>
<v t="ekr.20250122151620.959"><vh>Mobject.match_x</vh></v>
<v t="ekr.20250122151620.960"><vh>Mobject.match_y</vh></v>
<v t="ekr.20250122151620.961"><vh>Mobject.match_z</vh></v>
<v t="ekr.20250122151620.962"><vh>Mobject.align_to</vh></v>
<v t="ekr.20250122151620.963"><vh>Mobject.__getitem__</vh></v>
<v t="ekr.20250122151620.964"><vh>Mobject.__iter__</vh></v>
<v t="ekr.20250122151620.965"><vh>Mobject.__len__</vh></v>
<v t="ekr.20250122151620.966"><vh>Mobject.get_group_class</vh></v>
<v t="ekr.20250122151620.967"><vh>Mobject.get_mobject_type_class</vh></v>
<v t="ekr.20250122151620.968"><vh>Mobject.split</vh></v>
<v t="ekr.20250122151620.969"><vh>Mobject.get_family</vh></v>
<v t="ekr.20250122151620.970"><vh>Mobject.family_members_with_points</vh></v>
<v t="ekr.20250122151620.971"><vh>Mobject.arrange</vh></v>
<v t="ekr.20250122151620.972"><vh>Mobject.arrange_in_grid</vh></v>
<v t="ekr.20250122151620.973"><vh>Mobject.sort</vh></v>
<v t="ekr.20250122151620.974"><vh>Mobject.shuffle</vh></v>
<v t="ekr.20250122151620.975"><vh>Mobject.invert</vh></v>
<v t="ekr.20250122151620.976"><vh>Mobject.arrange_submobjects</vh></v>
<v t="ekr.20250122151620.977"><vh>Mobject.sort_submobjects</vh></v>
<v t="ekr.20250122151620.978"><vh>Mobject.shuffle_submobjects</vh></v>
<v t="ekr.20250122151620.979"><vh>Mobject.align_data</vh></v>
<v t="ekr.20250122151620.980"><vh>Mobject.get_point_mobject</vh></v>
<v t="ekr.20250122151620.981"><vh>Mobject.align_points</vh></v>
<v t="ekr.20250122151620.982"><vh>Mobject.align_points_with_larger</vh></v>
<v t="ekr.20250122151620.983"><vh>Mobject.align_submobjects</vh></v>
<v t="ekr.20250122151620.984"><vh>Mobject.null_point_align</vh></v>
<v t="ekr.20250122151620.985"><vh>Mobject.push_self_into_submobjects</vh></v>
<v t="ekr.20250122151620.986"><vh>Mobject.add_n_more_submobjects</vh></v>
<v t="ekr.20250122151620.987"><vh>Mobject.repeat_submobject</vh></v>
<v t="ekr.20250122151620.988"><vh>Mobject.interpolate</vh></v>
<v t="ekr.20250122151620.989"><vh>Mobject.interpolate_color</vh></v>
<v t="ekr.20250122151620.990"><vh>Mobject.become</vh></v>
<v t="ekr.20250122151620.991"><vh>Mobject.match_points</vh></v>
<v t="ekr.20250122151620.992"><vh>Mobject.throw_error_if_no_points</vh></v>
<v t="ekr.20250122151620.993"><vh>Mobject.set_z_index</vh></v>
<v t="ekr.20250122151620.994"><vh>Mobject.set_z_index_by_z_Point3D</vh></v>
</v>
<v t="ekr.20250122151620.814"><vh>class Group</vh>
<v t="ekr.20250122151620.995"><vh>Group.__init__</vh></v>
</v>
<v t="ekr.20250122151620.815"><vh>class _AnimationBuilder</vh>
<v t="ekr.20250122151620.996"><vh>_AnimationBuilder.__init__</vh></v>
<v t="ekr.20250122151620.997"><vh>_AnimationBuilder.__call__</vh></v>
<v t="ekr.20250122151620.998"><vh>_AnimationBuilder.__getattr__</vh></v>
<v t="ekr.20250122151620.999"><vh>_AnimationBuilder.build</vh></v>
</v>
<v t="ekr.20250122151620.816"><vh>function: override_animate</vh></v>
</v>
<v t="ekr.20250122151620.1000"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/table.py</vh>
<v t="ekr.20250122151620.1001"><vh>class Table</vh>
<v t="ekr.20250122151620.1006"><vh>Table.__init__</vh></v>
<v t="ekr.20250122151620.1007"><vh>Table._table_to_mob_table</vh></v>
<v t="ekr.20250122151620.1008"><vh>Table._organize_mob_table</vh></v>
<v t="ekr.20250122151620.1009"><vh>Table._add_labels</vh></v>
<v t="ekr.20250122151620.1010"><vh>Table._add_horizontal_lines</vh></v>
<v t="ekr.20250122151620.1011"><vh>Table._add_vertical_lines</vh></v>
<v t="ekr.20250122151620.1012"><vh>Table.get_horizontal_lines</vh></v>
<v t="ekr.20250122151620.1013"><vh>Table.get_vertical_lines</vh></v>
<v t="ekr.20250122151620.1014"><vh>Table.get_columns</vh></v>
<v t="ekr.20250122151620.1015"><vh>Table.get_rows</vh></v>
<v t="ekr.20250122151620.1016"><vh>Table.set_column_colors</vh></v>
<v t="ekr.20250122151620.1017"><vh>Table.set_row_colors</vh></v>
<v t="ekr.20250122151620.1018"><vh>Table.get_entries</vh></v>
<v t="ekr.20250122151620.1019"><vh>Table.get_entries_without_labels</vh></v>
<v t="ekr.20250122151620.1020"><vh>Table.get_row_labels</vh></v>
<v t="ekr.20250122151620.1021"><vh>Table.get_col_labels</vh></v>
<v t="ekr.20250122151620.1022"><vh>Table.get_labels</vh></v>
<v t="ekr.20250122151620.1023"><vh>Table.add_background_to_entries</vh></v>
<v t="ekr.20250122151620.1024"><vh>Table.get_cell</vh></v>
<v t="ekr.20250122151620.1025"><vh>Table.get_highlighted_cell</vh></v>
<v t="ekr.20250122151620.1026"><vh>Table.add_highlighted_cell</vh></v>
<v t="ekr.20250122151620.1027"><vh>Table.create</vh></v>
<v t="ekr.20250122151620.1028"><vh>Table.scale</vh></v>
</v>
<v t="ekr.20250122151620.1002"><vh>class MathTable</vh>
<v t="ekr.20250122151620.1029"><vh>MathTable.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1003"><vh>class MobjectTable</vh>
<v t="ekr.20250122151620.1030"><vh>MobjectTable.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1004"><vh>class IntegerTable</vh>
<v t="ekr.20250122151620.1031"><vh>IntegerTable.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1005"><vh>class DecimalTable</vh>
<v t="ekr.20250122151620.1032"><vh>DecimalTable.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1033"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/utils.py</vh>
<v t="ekr.20250122151620.1034"><vh>function: get_mobject_class</vh></v>
<v t="ekr.20250122151620.1035"><vh>function: get_vectorized_mobject_class</vh></v>
<v t="ekr.20250122151620.1036"><vh>function: get_point_mobject_class</vh></v>
</v>
<v t="ekr.20250122151620.1037"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/value_tracker.py</vh>
<v t="ekr.20250122151620.1038"><vh>class ValueTracker</vh>
<v t="ekr.20250122151620.1040"><vh>ValueTracker.__init__</vh></v>
<v t="ekr.20250122151620.1041"><vh>ValueTracker.get_value</vh></v>
<v t="ekr.20250122151620.1042"><vh>ValueTracker.set_value</vh></v>
<v t="ekr.20250122151620.1043"><vh>ValueTracker.increment_value</vh></v>
<v t="ekr.20250122151620.1044"><vh>ValueTracker.__bool__</vh></v>
<v t="ekr.20250122151620.1045"><vh>ValueTracker.__iadd__</vh></v>
<v t="ekr.20250122151620.1046"><vh>ValueTracker.__ifloordiv__</vh></v>
<v t="ekr.20250122151620.1047"><vh>ValueTracker.__imod__</vh></v>
<v t="ekr.20250122151620.1048"><vh>ValueTracker.__imul__</vh></v>
<v t="ekr.20250122151620.1049"><vh>ValueTracker.__ipow__</vh></v>
<v t="ekr.20250122151620.1050"><vh>ValueTracker.__isub__</vh></v>
<v t="ekr.20250122151620.1051"><vh>ValueTracker.__itruediv__</vh></v>
<v t="ekr.20250122151620.1052"><vh>ValueTracker.interpolate</vh></v>
</v>
<v t="ekr.20250122151620.1039"><vh>class ComplexValueTracker</vh>
<v t="ekr.20250122151620.1053"><vh>ComplexValueTracker.get_value</vh></v>
<v t="ekr.20250122151620.1054"><vh>ComplexValueTracker.set_value</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1055"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/vector_field.py</vh>
<v t="ekr.20250122151620.1056"><vh>class VectorField</vh>
<v t="ekr.20250122151620.1059"><vh>VectorField.__init__</vh></v>
<v t="ekr.20250122151620.1060"><vh>VectorField.shift_func</vh></v>
<v t="ekr.20250122151620.1061"><vh>VectorField.scale_func</vh></v>
<v t="ekr.20250122151620.1062"><vh>VectorField.fit_to_coordinate_system</vh></v>
<v t="ekr.20250122151620.1063"><vh>VectorField.nudge</vh></v>
<v t="ekr.20250122151620.1064"><vh>VectorField.nudge_submobjects</vh></v>
<v t="ekr.20250122151620.1065"><vh>VectorField.get_nudge_updater</vh></v>
<v t="ekr.20250122151620.1066"><vh>VectorField.start_submobject_movement</vh></v>
<v t="ekr.20250122151620.1067"><vh>VectorField.stop_submobject_movement</vh></v>
<v t="ekr.20250122151620.1068"><vh>VectorField.get_colored_background_image</vh></v>
<v t="ekr.20250122151620.1069"><vh>VectorField.get_vectorized_rgba_gradient_function</vh></v>
</v>
<v t="ekr.20250122151620.1057"><vh>class ArrowVectorField</vh>
<v t="ekr.20250122151620.1070"><vh>ArrowVectorField.__init__</vh></v>
<v t="ekr.20250122151620.1071"><vh>ArrowVectorField.get_vector</vh></v>
</v>
<v t="ekr.20250122151620.1058"><vh>class StreamLines</vh>
<v t="ekr.20250122151620.1072"><vh>StreamLines.__init__</vh></v>
<v t="ekr.20250122151620.1073"><vh>StreamLines.create</vh></v>
<v t="ekr.20250122151620.1074"><vh>StreamLines.start_animation</vh></v>
<v t="ekr.20250122151620.1075"><vh>StreamLines.end_animation</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1076"><vh>C:/Python/Python3.12/Lib/site-packages/manim/mobject/geometry</vh>
<v t="ekr.20250122151620.1077"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/geometry/__init__.py</vh></v>
<v t="ekr.20250122151620.1078"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/geometry/arc.py</vh>
<v t="ekr.20250122151620.1079"><vh>class TipableVMobject</vh>
<v t="ekr.20250122151620.1095"><vh>TipableVMobject.__init__</vh></v>
<v t="ekr.20250122151620.1096"><vh>TipableVMobject.add_tip</vh></v>
<v t="ekr.20250122151620.1097"><vh>TipableVMobject.create_tip</vh></v>
<v t="ekr.20250122151620.1098"><vh>TipableVMobject.get_unpositioned_tip</vh></v>
<v t="ekr.20250122151620.1099"><vh>TipableVMobject.position_tip</vh></v>
<v t="ekr.20250122151620.1100"><vh>TipableVMobject.reset_endpoints_based_on_tip</vh></v>
<v t="ekr.20250122151620.1101"><vh>TipableVMobject.asign_tip_attr</vh></v>
<v t="ekr.20250122151620.1102"><vh>TipableVMobject.has_tip</vh></v>
<v t="ekr.20250122151620.1103"><vh>TipableVMobject.has_start_tip</vh></v>
<v t="ekr.20250122151620.1104"><vh>TipableVMobject.pop_tips</vh></v>
<v t="ekr.20250122151620.1105"><vh>TipableVMobject.get_tips</vh></v>
<v t="ekr.20250122151620.1106"><vh>TipableVMobject.get_tip</vh></v>
<v t="ekr.20250122151620.1107"><vh>TipableVMobject.get_default_tip_length</vh></v>
<v t="ekr.20250122151620.1108"><vh>TipableVMobject.get_first_handle</vh></v>
<v t="ekr.20250122151620.1109"><vh>TipableVMobject.get_last_handle</vh></v>
<v t="ekr.20250122151620.1110"><vh>TipableVMobject.get_end</vh></v>
<v t="ekr.20250122151620.1111"><vh>TipableVMobject.get_start</vh></v>
<v t="ekr.20250122151620.1112"><vh>TipableVMobject.get_length</vh></v>
</v>
<v t="ekr.20250122151620.1080"><vh>class Arc</vh>
<v t="ekr.20250122151620.1113"><vh>Arc.__init__</vh></v>
<v t="ekr.20250122151620.1114"><vh>Arc.generate_points</vh></v>
<v t="ekr.20250122151620.1115"><vh>Arc.init_points</vh></v>
<v t="ekr.20250122151620.1116"><vh>Arc._create_quadratic_bezier_points</vh></v>
<v t="ekr.20250122151620.1117"><vh>Arc._set_pre_positioned_points</vh></v>
<v t="ekr.20250122151620.1118"><vh>Arc.get_arc_center</vh></v>
<v t="ekr.20250122151620.1119"><vh>Arc.move_arc_center_to</vh></v>
<v t="ekr.20250122151620.1120"><vh>Arc.stop_angle</vh></v>
</v>
<v t="ekr.20250122151620.1081"><vh>class ArcBetweenPoints</vh>
<v t="ekr.20250122151620.1121"><vh>ArcBetweenPoints.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1082"><vh>class CurvedArrow</vh>
<v t="ekr.20250122151620.1122"><vh>CurvedArrow.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1083"><vh>class CurvedDoubleArrow</vh>
<v t="ekr.20250122151620.1123"><vh>CurvedDoubleArrow.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1084"><vh>class Circle</vh>
<v t="ekr.20250122151620.1124"><vh>Circle.__init__</vh></v>
<v t="ekr.20250122151620.1125"><vh>Circle.surround</vh></v>
<v t="ekr.20250122151620.1126"><vh>Circle.point_at_angle</vh></v>
<v t="ekr.20250122151620.1127"><vh>Circle.from_three_points</vh></v>
</v>
<v t="ekr.20250122151620.1085"><vh>class Dot</vh>
<v t="ekr.20250122151620.1128"><vh>Dot.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1086"><vh>class AnnotationDot</vh>
<v t="ekr.20250122151620.1129"><vh>AnnotationDot.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1087"><vh>class LabeledDot</vh>
<v t="ekr.20250122151620.1130"><vh>LabeledDot.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1088"><vh>class Ellipse</vh>
<v t="ekr.20250122151620.1131"><vh>Ellipse.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1089"><vh>class AnnularSector</vh>
<v t="ekr.20250122151620.1132"><vh>AnnularSector.__init__</vh></v>
<v t="ekr.20250122151620.1133"><vh>AnnularSector.generate_points</vh></v>
</v>
<v t="ekr.20250122151620.1090"><vh>class Sector</vh>
<v t="ekr.20250122151620.1134"><vh>Sector.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1091"><vh>class Annulus</vh>
<v t="ekr.20250122151620.1135"><vh>Annulus.__init__</vh></v>
<v t="ekr.20250122151620.1136"><vh>Annulus.generate_points</vh></v>
</v>
<v t="ekr.20250122151620.1092"><vh>class CubicBezier</vh>
<v t="ekr.20250122151620.1137"><vh>CubicBezier.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1093"><vh>class ArcPolygon</vh>
<v t="ekr.20250122151620.1138"><vh>ArcPolygon.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1094"><vh>class ArcPolygonFromArcs</vh>
<v t="ekr.20250122151620.1139"><vh>ArcPolygonFromArcs.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1140"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/geometry/boolean_ops.py</vh>
<v t="ekr.20250122151620.1141"><vh>class _BooleanOps</vh>
<v t="ekr.20250122151620.1146"><vh>_BooleanOps._convert_2d_to_3d_array</vh></v>
<v t="ekr.20250122151620.1147"><vh>_BooleanOps._convert_vmobject_to_skia_path</vh></v>
<v t="ekr.20250122151620.1148"><vh>_BooleanOps._convert_skia_path_to_vmobject</vh></v>
</v>
<v t="ekr.20250122151620.1142"><vh>class Union</vh>
<v t="ekr.20250122151620.1149"><vh>Union.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1143"><vh>class Difference</vh>
<v t="ekr.20250122151620.1150"><vh>Difference.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1144"><vh>class Intersection</vh>
<v t="ekr.20250122151620.1151"><vh>Intersection.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1145"><vh>class Exclusion</vh>
<v t="ekr.20250122151620.1152"><vh>Exclusion.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1153"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/geometry/labeled.py</vh>
<v t="ekr.20250122151620.1154"><vh>class Label</vh>
<v t="ekr.20250122151620.1158"><vh>Label.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1155"><vh>class LabeledLine</vh>
<v t="ekr.20250122151620.1159"><vh>LabeledLine.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1156"><vh>class LabeledArrow</vh>
<v t="ekr.20250122151620.1160"><vh>LabeledArrow.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1157"><vh>class LabeledPolygram</vh>
<v t="ekr.20250122151620.1161"><vh>LabeledPolygram.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1162"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/geometry/line.py</vh>
<v t="ekr.20250122151620.1163"><vh>class Line</vh>
<v t="ekr.20250122151620.1172"><vh>Line.__init__</vh></v>
<v t="ekr.20250122151620.1173"><vh>Line.generate_points</vh></v>
<v t="ekr.20250122151620.1174"><vh>Line.set_points_by_ends</vh></v>
<v t="ekr.20250122151620.1175"><vh>Line._account_for_buff</vh></v>
<v t="ekr.20250122151620.1176"><vh>Line._set_start_and_end_attrs</vh></v>
<v t="ekr.20250122151620.1177"><vh>Line._pointify</vh></v>
<v t="ekr.20250122151620.1178"><vh>Line.set_path_arc</vh></v>
<v t="ekr.20250122151620.1179"><vh>Line.put_start_and_end_on</vh></v>
<v t="ekr.20250122151620.1180"><vh>Line.get_vector</vh></v>
<v t="ekr.20250122151620.1181"><vh>Line.get_unit_vector</vh></v>
<v t="ekr.20250122151620.1182"><vh>Line.get_angle</vh></v>
<v t="ekr.20250122151620.1183"><vh>Line.get_projection</vh></v>
<v t="ekr.20250122151620.1184"><vh>Line.get_slope</vh></v>
<v t="ekr.20250122151620.1185"><vh>Line.set_angle</vh></v>
<v t="ekr.20250122151620.1186"><vh>Line.set_length</vh></v>
</v>
<v t="ekr.20250122151620.1164"><vh>class DashedLine</vh>
<v t="ekr.20250122151620.1187"><vh>DashedLine.__init__</vh></v>
<v t="ekr.20250122151620.1188"><vh>DashedLine._calculate_num_dashes</vh></v>
<v t="ekr.20250122151620.1189"><vh>DashedLine.get_start</vh></v>
<v t="ekr.20250122151620.1190"><vh>DashedLine.get_end</vh></v>
<v t="ekr.20250122151620.1191"><vh>DashedLine.get_first_handle</vh></v>
<v t="ekr.20250122151620.1192"><vh>DashedLine.get_last_handle</vh></v>
</v>
<v t="ekr.20250122151620.1165"><vh>class TangentLine</vh>
<v t="ekr.20250122151620.1193"><vh>TangentLine.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1166"><vh>class Elbow</vh>
<v t="ekr.20250122151620.1194"><vh>Elbow.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1167"><vh>class Arrow</vh>
<v t="ekr.20250122151620.1195"><vh>Arrow.__init__</vh></v>
<v t="ekr.20250122151620.1196"><vh>Arrow.scale</vh></v>
<v t="ekr.20250122151620.1197"><vh>Arrow.get_normal_vector</vh></v>
<v t="ekr.20250122151620.1198"><vh>Arrow.reset_normal_vector</vh></v>
<v t="ekr.20250122151620.1199"><vh>Arrow.get_default_tip_length</vh></v>
<v t="ekr.20250122151620.1200"><vh>Arrow._set_stroke_width_from_length</vh></v>
</v>
<v t="ekr.20250122151620.1168"><vh>class Vector</vh>
<v t="ekr.20250122151620.1201"><vh>Vector.__init__</vh></v>
<v t="ekr.20250122151620.1202"><vh>Vector.coordinate_label</vh></v>
</v>
<v t="ekr.20250122151620.1169"><vh>class DoubleArrow</vh>
<v t="ekr.20250122151620.1203"><vh>DoubleArrow.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1170"><vh>class Angle</vh>
<v t="ekr.20250122151620.1204"><vh>Angle.__init__</vh></v>
<v t="ekr.20250122151620.1205"><vh>Angle.get_lines</vh></v>
<v t="ekr.20250122151620.1206"><vh>Angle.get_value</vh></v>
<v t="ekr.20250122151620.1207"><vh>Angle.from_three_points</vh></v>
</v>
<v t="ekr.20250122151620.1171"><vh>class RightAngle</vh>
<v t="ekr.20250122151620.1208"><vh>RightAngle.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1209"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/geometry/polygram.py</vh>
<v t="ekr.20250122151620.1210"><vh>class Polygram</vh>
<v t="ekr.20250122151620.1221"><vh>Polygram.__init__</vh></v>
<v t="ekr.20250122151620.1222"><vh>Polygram.get_vertices</vh></v>
<v t="ekr.20250122151620.1223"><vh>Polygram.get_vertex_groups</vh></v>
<v t="ekr.20250122151620.1224"><vh>Polygram.round_corners</vh></v>
</v>
<v t="ekr.20250122151620.1211"><vh>class Polygon</vh>
<v t="ekr.20250122151620.1225"><vh>Polygon.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1212"><vh>class RegularPolygram</vh>
<v t="ekr.20250122151620.1226"><vh>RegularPolygram.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1213"><vh>class RegularPolygon</vh>
<v t="ekr.20250122151620.1227"><vh>RegularPolygon.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1214"><vh>class Star</vh>
<v t="ekr.20250122151620.1228"><vh>Star.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1215"><vh>class Triangle</vh>
<v t="ekr.20250122151620.1229"><vh>Triangle.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1216"><vh>class Rectangle</vh>
<v t="ekr.20250122151620.1230"><vh>Rectangle.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1217"><vh>class Square</vh>
<v t="ekr.20250122151620.1231"><vh>Square.__init__</vh></v>
<v t="ekr.20250122151620.1232"><vh>Square.side_length</vh></v>
<v t="ekr.20250122151620.1233"><vh>Square.side_length</vh></v>
</v>
<v t="ekr.20250122151620.1218"><vh>class RoundedRectangle</vh>
<v t="ekr.20250122151620.1234"><vh>RoundedRectangle.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1219"><vh>class Cutout</vh>
<v t="ekr.20250122151620.1235"><vh>Cutout.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1220"><vh>class ConvexHull</vh>
<v t="ekr.20250122151620.1236"><vh>ConvexHull.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1237"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/geometry/shape_matchers.py</vh>
<v t="ekr.20250122151620.1238"><vh>class SurroundingRectangle</vh>
<v t="ekr.20250122151620.1242"><vh>SurroundingRectangle.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1239"><vh>class BackgroundRectangle</vh>
<v t="ekr.20250122151620.1243"><vh>BackgroundRectangle.__init__</vh></v>
<v t="ekr.20250122151620.1244"><vh>BackgroundRectangle.pointwise_become_partial</vh></v>
<v t="ekr.20250122151620.1245"><vh>BackgroundRectangle.set_style</vh></v>
<v t="ekr.20250122151620.1246"><vh>BackgroundRectangle.get_fill_color</vh></v>
</v>
<v t="ekr.20250122151620.1240"><vh>class Cross</vh>
<v t="ekr.20250122151620.1247"><vh>Cross.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1241"><vh>class Underline</vh>
<v t="ekr.20250122151620.1248"><vh>Underline.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1249"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/geometry/tips.py</vh>
<v t="ekr.20250122151620.1250"><vh>class ArrowTip</vh>
<v t="ekr.20250122151620.1258"><vh>ArrowTip.__init__</vh></v>
<v t="ekr.20250122151620.1259"><vh>ArrowTip.base</vh></v>
<v t="ekr.20250122151620.1260"><vh>ArrowTip.tip_point</vh></v>
<v t="ekr.20250122151620.1261"><vh>ArrowTip.vector</vh></v>
<v t="ekr.20250122151620.1262"><vh>ArrowTip.tip_angle</vh></v>
<v t="ekr.20250122151620.1263"><vh>ArrowTip.length</vh></v>
</v>
<v t="ekr.20250122151620.1251"><vh>class StealthTip</vh>
<v t="ekr.20250122151620.1264"><vh>StealthTip.__init__</vh></v>
<v t="ekr.20250122151620.1265"><vh>StealthTip.length</vh></v>
</v>
<v t="ekr.20250122151620.1252"><vh>class ArrowTriangleTip</vh>
<v t="ekr.20250122151620.1266"><vh>ArrowTriangleTip.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1253"><vh>class ArrowTriangleFilledTip</vh>
<v t="ekr.20250122151620.1267"><vh>ArrowTriangleFilledTip.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1254"><vh>class ArrowCircleTip</vh>
<v t="ekr.20250122151620.1268"><vh>ArrowCircleTip.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1255"><vh>class ArrowCircleFilledTip</vh>
<v t="ekr.20250122151620.1269"><vh>ArrowCircleFilledTip.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1256"><vh>class ArrowSquareTip</vh>
<v t="ekr.20250122151620.1270"><vh>ArrowSquareTip.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1257"><vh>class ArrowSquareFilledTip</vh>
<v t="ekr.20250122151620.1271"><vh>ArrowSquareFilledTip.__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151620.1272"><vh>C:/Python/Python3.12/Lib/site-packages/manim/mobject/graphing</vh>
<v t="ekr.20250122151620.1273"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/graphing/__init__.py</vh></v>
<v t="ekr.20250122151620.1274"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/graphing/coordinate_systems.py</vh>
<v t="ekr.20250122151620.1275"><vh>class CoordinateSystem</vh>
<v t="ekr.20250122151620.1281"><vh>CoordinateSystem.__init__</vh></v>
<v t="ekr.20250122151620.1282"><vh>CoordinateSystem.coords_to_point</vh></v>
<v t="ekr.20250122151620.1283"><vh>CoordinateSystem.point_to_coords</vh></v>
<v t="ekr.20250122151620.1284"><vh>CoordinateSystem.polar_to_point</vh></v>
<v t="ekr.20250122151620.1285"><vh>CoordinateSystem.point_to_polar</vh></v>
<v t="ekr.20250122151620.1286"><vh>CoordinateSystem.c2p</vh></v>
<v t="ekr.20250122151620.1287"><vh>CoordinateSystem.p2c</vh></v>
<v t="ekr.20250122151620.1288"><vh>CoordinateSystem.pr2pt</vh></v>
<v t="ekr.20250122151620.1289"><vh>CoordinateSystem.pt2pr</vh></v>
<v t="ekr.20250122151620.1290"><vh>CoordinateSystem.get_axes</vh></v>
<v t="ekr.20250122151620.1291"><vh>CoordinateSystem.get_axis</vh></v>
<v t="ekr.20250122151620.1292"><vh>CoordinateSystem.get_origin</vh></v>
<v t="ekr.20250122151620.1293"><vh>CoordinateSystem.get_x_axis</vh></v>
<v t="ekr.20250122151620.1294"><vh>CoordinateSystem.get_y_axis</vh></v>
<v t="ekr.20250122151620.1295"><vh>CoordinateSystem.get_z_axis</vh></v>
<v t="ekr.20250122151620.1296"><vh>CoordinateSystem.get_x_unit_size</vh></v>
<v t="ekr.20250122151620.1297"><vh>CoordinateSystem.get_y_unit_size</vh></v>
<v t="ekr.20250122151620.1298"><vh>CoordinateSystem.get_x_axis_label</vh></v>
<v t="ekr.20250122151620.1299"><vh>CoordinateSystem.get_y_axis_label</vh></v>
<v t="ekr.20250122151620.1300"><vh>CoordinateSystem._get_axis_label</vh></v>
<v t="ekr.20250122151620.1301"><vh>CoordinateSystem.get_axis_labels</vh></v>
<v t="ekr.20250122151620.1302"><vh>CoordinateSystem.add_coordinates</vh></v>
<v t="ekr.20250122151620.1303"><vh>CoordinateSystem.get_line_from_axis_to_point</vh></v>
<v t="ekr.20250122151620.1304"><vh>CoordinateSystem.get_line_from_axis_to_point</vh></v>
<v t="ekr.20250122151620.1305"><vh>CoordinateSystem.get_line_from_axis_to_point</vh></v>
<v t="ekr.20250122151620.1306"><vh>CoordinateSystem.get_vertical_line</vh></v>
<v t="ekr.20250122151620.1307"><vh>CoordinateSystem.get_horizontal_line</vh></v>
<v t="ekr.20250122151620.1308"><vh>CoordinateSystem.get_lines_to_point</vh></v>
<v t="ekr.20250122151620.1309"><vh>CoordinateSystem.plot</vh></v>
<v t="ekr.20250122151620.1310"><vh>CoordinateSystem.plot_implicit_curve</vh></v>
<v t="ekr.20250122151620.1311"><vh>CoordinateSystem.plot_parametric_curve</vh></v>
<v t="ekr.20250122151620.1312"><vh>CoordinateSystem.plot_polar_graph</vh></v>
<v t="ekr.20250122151620.1313"><vh>CoordinateSystem.plot_surface</vh></v>
<v t="ekr.20250122151620.1314"><vh>CoordinateSystem.input_to_graph_point</vh></v>
<v t="ekr.20250122151620.1315"><vh>CoordinateSystem.input_to_graph_coords</vh></v>
<v t="ekr.20250122151620.1316"><vh>CoordinateSystem.i2gc</vh></v>
<v t="ekr.20250122151620.1317"><vh>CoordinateSystem.i2gp</vh></v>
<v t="ekr.20250122151620.1318"><vh>CoordinateSystem.get_graph_label</vh></v>
<v t="ekr.20250122151620.1319"><vh>CoordinateSystem.get_riemann_rectangles</vh></v>
<v t="ekr.20250122151620.1320"><vh>CoordinateSystem.get_area</vh></v>
<v t="ekr.20250122151620.1321"><vh>CoordinateSystem.angle_of_tangent</vh></v>
<v t="ekr.20250122151620.1322"><vh>CoordinateSystem.slope_of_tangent</vh></v>
<v t="ekr.20250122151620.1323"><vh>CoordinateSystem.plot_derivative_graph</vh></v>
<v t="ekr.20250122151620.1324"><vh>CoordinateSystem.plot_antiderivative_graph</vh></v>
<v t="ekr.20250122151620.1325"><vh>CoordinateSystem.get_secant_slope_group</vh></v>
<v t="ekr.20250122151620.1326"><vh>CoordinateSystem.get_vertical_lines_to_graph</vh></v>
<v t="ekr.20250122151620.1327"><vh>CoordinateSystem.get_T_label</vh></v>
<v t="ekr.20250122151620.1328"><vh>CoordinateSystem.__matmul__</vh></v>
<v t="ekr.20250122151620.1329"><vh>CoordinateSystem.__rmatmul__</vh></v>
</v>
<v t="ekr.20250122151620.1276"><vh>class Axes</vh>
<v t="ekr.20250122151620.1330"><vh>Axes.__init__</vh></v>
<v t="ekr.20250122151620.1331"><vh>Axes._update_default_configs</vh></v>
<v t="ekr.20250122151620.1332"><vh>Axes._create_axis</vh></v>
<v t="ekr.20250122151620.1333"><vh>Axes.coords_to_point</vh></v>
<v t="ekr.20250122151620.1334"><vh>Axes.point_to_coords</vh></v>
<v t="ekr.20250122151620.1335"><vh>Axes.get_axes</vh></v>
<v t="ekr.20250122151620.1336"><vh>Axes.get_axis_labels</vh></v>
<v t="ekr.20250122151620.1337"><vh>Axes.plot_line_graph</vh></v>
<v t="ekr.20250122151620.1338"><vh>Axes._origin_shift</vh></v>
</v>
<v t="ekr.20250122151620.1277"><vh>class ThreeDAxes</vh>
<v t="ekr.20250122151620.1339"><vh>ThreeDAxes.__init__</vh></v>
<v t="ekr.20250122151620.1340"><vh>ThreeDAxes._add_3d_pieces</vh></v>
<v t="ekr.20250122151620.1341"><vh>ThreeDAxes._set_axis_shading</vh></v>
<v t="ekr.20250122151620.1342"><vh>ThreeDAxes.get_y_axis_label</vh></v>
<v t="ekr.20250122151620.1343"><vh>ThreeDAxes.get_z_axis_label</vh></v>
<v t="ekr.20250122151620.1344"><vh>ThreeDAxes.get_axis_labels</vh></v>
</v>
<v t="ekr.20250122151620.1278"><vh>class NumberPlane</vh>
<v t="ekr.20250122151620.1345"><vh>NumberPlane.__init__</vh></v>
<v t="ekr.20250122151620.1346"><vh>NumberPlane._init_background_lines</vh></v>
<v t="ekr.20250122151620.1347"><vh>NumberPlane._get_lines</vh></v>
<v t="ekr.20250122151620.1348"><vh>NumberPlane._get_lines_parallel_to_axis</vh></v>
<v t="ekr.20250122151620.1349"><vh>NumberPlane.get_vector</vh></v>
<v t="ekr.20250122151620.1350"><vh>NumberPlane.prepare_for_nonlinear_transform</vh></v>
</v>
<v t="ekr.20250122151620.1279"><vh>class PolarPlane</vh>
<v t="ekr.20250122151620.1351"><vh>PolarPlane.__init__</vh></v>
<v t="ekr.20250122151620.1352"><vh>PolarPlane._init_background_lines</vh></v>
<v t="ekr.20250122151620.1353"><vh>PolarPlane._get_lines</vh></v>
<v t="ekr.20250122151620.1354"><vh>PolarPlane.get_axes</vh></v>
<v t="ekr.20250122151620.1355"><vh>PolarPlane.get_vector</vh></v>
<v t="ekr.20250122151620.1356"><vh>PolarPlane.prepare_for_nonlinear_transform</vh></v>
<v t="ekr.20250122151620.1357"><vh>PolarPlane.get_coordinate_labels</vh></v>
<v t="ekr.20250122151620.1358"><vh>PolarPlane.add_coordinates</vh></v>
<v t="ekr.20250122151620.1359"><vh>PolarPlane.get_radian_label</vh></v>
</v>
<v t="ekr.20250122151620.1280"><vh>class ComplexPlane</vh>
<v t="ekr.20250122151620.1360"><vh>ComplexPlane.__init__</vh></v>
<v t="ekr.20250122151620.1361"><vh>ComplexPlane.number_to_point</vh></v>
<v t="ekr.20250122151620.1362"><vh>ComplexPlane.n2p</vh></v>
<v t="ekr.20250122151620.1363"><vh>ComplexPlane.point_to_number</vh></v>
<v t="ekr.20250122151620.1364"><vh>ComplexPlane.p2n</vh></v>
<v t="ekr.20250122151620.1365"><vh>ComplexPlane._get_default_coordinate_values</vh></v>
<v t="ekr.20250122151620.1366"><vh>ComplexPlane.get_coordinate_labels</vh></v>
<v t="ekr.20250122151620.1367"><vh>ComplexPlane.add_coordinates</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1368"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/graphing/functions.py</vh>
<v t="ekr.20250122151620.1369"><vh>class ParametricFunction</vh>
<v t="ekr.20250122151620.1372"><vh>ParametricFunction.__init__</vh></v>
<v t="ekr.20250122151620.1373"><vh>ParametricFunction.internal_parametric_function</vh></v>
<v t="ekr.20250122151620.1374"><vh>ParametricFunction.get_function</vh></v>
<v t="ekr.20250122151620.1375"><vh>ParametricFunction.get_point_from_function</vh></v>
<v t="ekr.20250122151620.1376"><vh>ParametricFunction.generate_points</vh></v>
</v>
<v t="ekr.20250122151620.1370"><vh>class FunctionGraph</vh>
<v t="ekr.20250122151620.1377"><vh>FunctionGraph.__init__</vh></v>
<v t="ekr.20250122151620.1378"><vh>FunctionGraph.get_function</vh></v>
<v t="ekr.20250122151620.1379"><vh>FunctionGraph.get_point_from_function</vh></v>
</v>
<v t="ekr.20250122151620.1371"><vh>class ImplicitFunction</vh>
<v t="ekr.20250122151620.1380"><vh>ImplicitFunction.__init__</vh></v>
<v t="ekr.20250122151620.1381"><vh>ImplicitFunction.generate_points</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1382"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/graphing/number_line.py</vh>
<v t="ekr.20250122151620.1383"><vh>class NumberLine</vh>
<v t="ekr.20250122151620.1385"><vh>NumberLine.__init__</vh></v>
<v t="ekr.20250122151620.1386"><vh>NumberLine.rotate_about_zero</vh></v>
<v t="ekr.20250122151620.1387"><vh>NumberLine.rotate_about_number</vh></v>
<v t="ekr.20250122151620.1388"><vh>NumberLine.add_ticks</vh></v>
<v t="ekr.20250122151620.1389"><vh>NumberLine.get_tick</vh></v>
<v t="ekr.20250122151620.1390"><vh>NumberLine.get_tick_marks</vh></v>
<v t="ekr.20250122151620.1391"><vh>NumberLine.get_tick_range</vh></v>
<v t="ekr.20250122151620.1392"><vh>NumberLine.number_to_point</vh></v>
<v t="ekr.20250122151620.1393"><vh>NumberLine.point_to_number</vh></v>
<v t="ekr.20250122151620.1394"><vh>NumberLine.n2p</vh></v>
<v t="ekr.20250122151620.1395"><vh>NumberLine.p2n</vh></v>
<v t="ekr.20250122151620.1396"><vh>NumberLine.get_unit_size</vh></v>
<v t="ekr.20250122151620.1397"><vh>NumberLine.get_unit_vector</vh></v>
<v t="ekr.20250122151620.1398"><vh>NumberLine.get_number_mobject</vh></v>
<v t="ekr.20250122151620.1399"><vh>NumberLine.get_number_mobjects</vh></v>
<v t="ekr.20250122151620.1400"><vh>NumberLine.get_labels</vh></v>
<v t="ekr.20250122151620.1401"><vh>NumberLine.add_numbers</vh></v>
<v t="ekr.20250122151620.1402"><vh>NumberLine.add_labels</vh></v>
<v t="ekr.20250122151620.1403"><vh>NumberLine._create_label_tex</vh></v>
<v t="ekr.20250122151620.1404"><vh>NumberLine._decimal_places_from_step</vh></v>
<v t="ekr.20250122151620.1405"><vh>NumberLine.__matmul__</vh></v>
<v t="ekr.20250122151620.1406"><vh>NumberLine.__rmatmul__</vh></v>
</v>
<v t="ekr.20250122151620.1384"><vh>class UnitInterval</vh>
<v t="ekr.20250122151620.1407"><vh>UnitInterval.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1408"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/graphing/probability.py</vh>
<v t="ekr.20250122151620.1409"><vh>class SampleSpace</vh>
<v t="ekr.20250122151620.1411"><vh>SampleSpace.__init__</vh></v>
<v t="ekr.20250122151620.1412"><vh>SampleSpace.add_title</vh></v>
<v t="ekr.20250122151620.1413"><vh>SampleSpace.add_label</vh></v>
<v t="ekr.20250122151620.1414"><vh>SampleSpace.complete_p_list</vh></v>
<v t="ekr.20250122151620.1415"><vh>SampleSpace.get_division_along_dimension</vh></v>
<v t="ekr.20250122151620.1416"><vh>SampleSpace.get_horizontal_division</vh></v>
<v t="ekr.20250122151620.1417"><vh>SampleSpace.get_vertical_division</vh></v>
<v t="ekr.20250122151620.1418"><vh>SampleSpace.divide_horizontally</vh></v>
<v t="ekr.20250122151620.1419"><vh>SampleSpace.divide_vertically</vh></v>
<v t="ekr.20250122151620.1420"><vh>SampleSpace.get_subdivision_braces_and_labels</vh></v>
<v t="ekr.20250122151620.1421"><vh>SampleSpace.get_side_braces_and_labels</vh></v>
<v t="ekr.20250122151620.1422"><vh>SampleSpace.get_top_braces_and_labels</vh></v>
<v t="ekr.20250122151620.1423"><vh>SampleSpace.get_bottom_braces_and_labels</vh></v>
<v t="ekr.20250122151620.1424"><vh>SampleSpace.add_braces_and_labels</vh></v>
<v t="ekr.20250122151620.1425"><vh>SampleSpace.__getitem__</vh></v>
</v>
<v t="ekr.20250122151620.1410"><vh>class BarChart</vh>
<v t="ekr.20250122151620.1426"><vh>BarChart.__init__</vh></v>
<v t="ekr.20250122151620.1427"><vh>BarChart._update_colors</vh></v>
<v t="ekr.20250122151620.1428"><vh>BarChart._add_x_axis_labels</vh></v>
<v t="ekr.20250122151620.1429"><vh>BarChart._create_bar</vh></v>
<v t="ekr.20250122151620.1430"><vh>BarChart._add_bars</vh></v>
<v t="ekr.20250122151620.1431"><vh>BarChart.get_bar_labels</vh></v>
<v t="ekr.20250122151620.1432"><vh>BarChart.change_bar_values</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1433"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/graphing/scale.py</vh>
<v t="ekr.20250122151620.1434"><vh>class _ScaleBase</vh>
<v t="ekr.20250122151620.1437"><vh>_ScaleBase.__init__</vh></v>
<v t="ekr.20250122151620.1438"><vh>_ScaleBase.function</vh></v>
<v t="ekr.20250122151620.1439"><vh>_ScaleBase.inverse_function</vh></v>
<v t="ekr.20250122151620.1440"><vh>_ScaleBase.get_custom_labels</vh></v>
</v>
<v t="ekr.20250122151620.1435"><vh>class LinearBase</vh>
<v t="ekr.20250122151620.1441"><vh>LinearBase.__init__</vh></v>
<v t="ekr.20250122151620.1442"><vh>LinearBase.function</vh></v>
<v t="ekr.20250122151620.1443"><vh>LinearBase.inverse_function</vh></v>
</v>
<v t="ekr.20250122151620.1436"><vh>class LogBase</vh>
<v t="ekr.20250122151620.1444"><vh>LogBase.__init__</vh></v>
<v t="ekr.20250122151620.1445"><vh>LogBase.function</vh></v>
<v t="ekr.20250122151620.1446"><vh>LogBase.inverse_function</vh></v>
<v t="ekr.20250122151620.1447"><vh>LogBase.get_custom_labels</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151620.1448"><vh>C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl</vh>
<v t="ekr.20250122151620.1449"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/__init__.py</vh></v>
<v t="ekr.20250122151620.1450"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/dot_cloud.py</vh>
<v t="ekr.20250122151620.1451"><vh>class DotCloud</vh>
<v t="ekr.20250122151620.1453"><vh>DotCloud.__init__</vh></v>
<v t="ekr.20250122151620.1454"><vh>DotCloud.init_points</vh></v>
<v t="ekr.20250122151620.1455"><vh>DotCloud.make_3d</vh></v>
</v>
<v t="ekr.20250122151620.1452"><vh>class TrueDot</vh>
<v t="ekr.20250122151620.1456"><vh>TrueDot.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1457"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/opengl_compatibility.py</vh>
<v t="ekr.20250122151620.1458"><vh>class ConvertToOpenGL</vh>
<v t="ekr.20250122151620.1459"><vh>ConvertToOpenGL.__new__</vh></v>
<v t="ekr.20250122151620.1460"><vh>ConvertToOpenGL.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1461"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/opengl_geometry.py</vh>
<v t="ekr.20250122151620.1462"><vh>class OpenGLTipableVMobject</vh>
<v t="ekr.20250122151620.1488"><vh>OpenGLTipableVMobject.__init__</vh></v>
<v t="ekr.20250122151620.1489"><vh>OpenGLTipableVMobject.add_tip</vh></v>
<v t="ekr.20250122151620.1490"><vh>OpenGLTipableVMobject.create_tip</vh></v>
<v t="ekr.20250122151620.1491"><vh>OpenGLTipableVMobject.get_unpositioned_tip</vh></v>
<v t="ekr.20250122151620.1492"><vh>OpenGLTipableVMobject.position_tip</vh></v>
<v t="ekr.20250122151620.1493"><vh>OpenGLTipableVMobject.reset_endpoints_based_on_tip</vh></v>
<v t="ekr.20250122151620.1494"><vh>OpenGLTipableVMobject.asign_tip_attr</vh></v>
<v t="ekr.20250122151620.1495"><vh>OpenGLTipableVMobject.has_tip</vh></v>
<v t="ekr.20250122151620.1496"><vh>OpenGLTipableVMobject.has_start_tip</vh></v>
<v t="ekr.20250122151620.1497"><vh>OpenGLTipableVMobject.pop_tips</vh></v>
<v t="ekr.20250122151620.1498"><vh>OpenGLTipableVMobject.get_tips</vh></v>
<v t="ekr.20250122151620.1499"><vh>OpenGLTipableVMobject.get_tip</vh></v>
<v t="ekr.20250122151620.1500"><vh>OpenGLTipableVMobject.get_default_tip_length</vh></v>
<v t="ekr.20250122151620.1501"><vh>OpenGLTipableVMobject.get_first_handle</vh></v>
<v t="ekr.20250122151620.1502"><vh>OpenGLTipableVMobject.get_last_handle</vh></v>
<v t="ekr.20250122151620.1503"><vh>OpenGLTipableVMobject.get_end</vh></v>
<v t="ekr.20250122151620.1504"><vh>OpenGLTipableVMobject.get_start</vh></v>
<v t="ekr.20250122151620.1505"><vh>OpenGLTipableVMobject.get_length</vh></v>
</v>
<v t="ekr.20250122151620.1463"><vh>class OpenGLArc</vh>
<v t="ekr.20250122151620.1506"><vh>OpenGLArc.__init__</vh></v>
<v t="ekr.20250122151620.1507"><vh>OpenGLArc.init_points</vh></v>
<v t="ekr.20250122151620.1508"><vh>OpenGLArc.create_quadratic_bezier_points</vh></v>
<v t="ekr.20250122151620.1509"><vh>OpenGLArc.get_arc_center</vh></v>
<v t="ekr.20250122151620.1510"><vh>OpenGLArc.get_start_angle</vh></v>
<v t="ekr.20250122151620.1511"><vh>OpenGLArc.get_stop_angle</vh></v>
<v t="ekr.20250122151620.1512"><vh>OpenGLArc.move_arc_center_to</vh></v>
</v>
<v t="ekr.20250122151620.1464"><vh>class OpenGLArcBetweenPoints</vh>
<v t="ekr.20250122151620.1513"><vh>OpenGLArcBetweenPoints.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1465"><vh>class OpenGLCurvedArrow</vh>
<v t="ekr.20250122151620.1514"><vh>OpenGLCurvedArrow.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1466"><vh>class OpenGLCurvedDoubleArrow</vh>
<v t="ekr.20250122151620.1515"><vh>OpenGLCurvedDoubleArrow.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1467"><vh>class OpenGLCircle</vh>
<v t="ekr.20250122151620.1516"><vh>OpenGLCircle.__init__</vh></v>
<v t="ekr.20250122151620.1517"><vh>OpenGLCircle.surround</vh></v>
<v t="ekr.20250122151620.1518"><vh>OpenGLCircle.point_at_angle</vh></v>
</v>
<v t="ekr.20250122151620.1468"><vh>class OpenGLDot</vh>
<v t="ekr.20250122151620.1519"><vh>OpenGLDot.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1469"><vh>class OpenGLEllipse</vh>
<v t="ekr.20250122151620.1520"><vh>OpenGLEllipse.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1470"><vh>class OpenGLAnnularSector</vh>
<v t="ekr.20250122151620.1521"><vh>OpenGLAnnularSector.__init__</vh></v>
<v t="ekr.20250122151620.1522"><vh>OpenGLAnnularSector.init_points</vh></v>
</v>
<v t="ekr.20250122151620.1471"><vh>class OpenGLSector</vh>
<v t="ekr.20250122151620.1523"><vh>OpenGLSector.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1472"><vh>class OpenGLAnnulus</vh>
<v t="ekr.20250122151620.1524"><vh>OpenGLAnnulus.__init__</vh></v>
<v t="ekr.20250122151620.1525"><vh>OpenGLAnnulus.init_points</vh></v>
</v>
<v t="ekr.20250122151620.1473"><vh>class OpenGLLine</vh>
<v t="ekr.20250122151620.1526"><vh>OpenGLLine.__init__</vh></v>
<v t="ekr.20250122151620.1527"><vh>OpenGLLine.init_points</vh></v>
<v t="ekr.20250122151620.1528"><vh>OpenGLLine.set_points_by_ends</vh></v>
<v t="ekr.20250122151620.1529"><vh>OpenGLLine.set_path_arc</vh></v>
<v t="ekr.20250122151620.1530"><vh>OpenGLLine.account_for_buff</vh></v>
<v t="ekr.20250122151620.1531"><vh>OpenGLLine.set_start_and_end_attrs</vh></v>
<v t="ekr.20250122151620.1532"><vh>OpenGLLine.pointify</vh></v>
<v t="ekr.20250122151620.1533"><vh>OpenGLLine.put_start_and_end_on</vh></v>
<v t="ekr.20250122151620.1534"><vh>OpenGLLine.get_vector</vh></v>
<v t="ekr.20250122151620.1535"><vh>OpenGLLine.get_unit_vector</vh></v>
<v t="ekr.20250122151620.1536"><vh>OpenGLLine.get_angle</vh></v>
<v t="ekr.20250122151620.1537"><vh>OpenGLLine.get_projection</vh></v>
<v t="ekr.20250122151620.1538"><vh>OpenGLLine.get_slope</vh></v>
<v t="ekr.20250122151620.1539"><vh>OpenGLLine.set_angle</vh></v>
<v t="ekr.20250122151620.1540"><vh>OpenGLLine.set_length</vh></v>
</v>
<v t="ekr.20250122151620.1474"><vh>class OpenGLDashedLine</vh>
<v t="ekr.20250122151620.1541"><vh>OpenGLDashedLine.__init__</vh></v>
<v t="ekr.20250122151620.1542"><vh>OpenGLDashedLine.calculate_num_dashes</vh></v>
<v t="ekr.20250122151620.1543"><vh>OpenGLDashedLine.get_start</vh></v>
<v t="ekr.20250122151620.1544"><vh>OpenGLDashedLine.get_end</vh></v>
<v t="ekr.20250122151620.1545"><vh>OpenGLDashedLine.get_first_handle</vh></v>
<v t="ekr.20250122151620.1546"><vh>OpenGLDashedLine.get_last_handle</vh></v>
</v>
<v t="ekr.20250122151620.1475"><vh>class OpenGLTangentLine</vh>
<v t="ekr.20250122151620.1547"><vh>OpenGLTangentLine.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1476"><vh>class OpenGLElbow</vh>
<v t="ekr.20250122151620.1548"><vh>OpenGLElbow.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1477"><vh>class OpenGLArrow</vh>
<v t="ekr.20250122151620.1549"><vh>OpenGLArrow.__init__</vh></v>
<v t="ekr.20250122151620.1550"><vh>OpenGLArrow.set_points_by_ends</vh></v>
<v t="ekr.20250122151620.1551"><vh>OpenGLArrow.reset_points_around_ends</vh></v>
<v t="ekr.20250122151620.1552"><vh>OpenGLArrow.get_start</vh></v>
<v t="ekr.20250122151620.1553"><vh>OpenGLArrow.get_end</vh></v>
<v t="ekr.20250122151620.1554"><vh>OpenGLArrow.put_start_and_end_on</vh></v>
<v t="ekr.20250122151620.1555"><vh>OpenGLArrow.scale</vh></v>
<v t="ekr.20250122151620.1556"><vh>OpenGLArrow.set_thickness</vh></v>
<v t="ekr.20250122151620.1557"><vh>OpenGLArrow.set_path_arc</vh></v>
</v>
<v t="ekr.20250122151620.1478"><vh>class OpenGLVector</vh>
<v t="ekr.20250122151620.1558"><vh>OpenGLVector.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1479"><vh>class OpenGLDoubleArrow</vh>
<v t="ekr.20250122151620.1559"><vh>OpenGLDoubleArrow.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1480"><vh>class OpenGLCubicBezier</vh>
<v t="ekr.20250122151620.1560"><vh>OpenGLCubicBezier.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1481"><vh>class OpenGLPolygon</vh>
<v t="ekr.20250122151620.1561"><vh>OpenGLPolygon.__init__</vh></v>
<v t="ekr.20250122151620.1562"><vh>OpenGLPolygon.init_points</vh></v>
<v t="ekr.20250122151620.1563"><vh>OpenGLPolygon.get_vertices</vh></v>
<v t="ekr.20250122151620.1564"><vh>OpenGLPolygon.round_corners</vh></v>
</v>
<v t="ekr.20250122151620.1482"><vh>class OpenGLRegularPolygon</vh>
<v t="ekr.20250122151620.1565"><vh>OpenGLRegularPolygon.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1483"><vh>class OpenGLTriangle</vh>
<v t="ekr.20250122151620.1566"><vh>OpenGLTriangle.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1484"><vh>class OpenGLArrowTip</vh>
<v t="ekr.20250122151620.1567"><vh>OpenGLArrowTip.__init__</vh></v>
<v t="ekr.20250122151620.1568"><vh>OpenGLArrowTip.get_base</vh></v>
<v t="ekr.20250122151620.1569"><vh>OpenGLArrowTip.get_tip_point</vh></v>
<v t="ekr.20250122151620.1570"><vh>OpenGLArrowTip.get_vector</vh></v>
<v t="ekr.20250122151620.1571"><vh>OpenGLArrowTip.get_angle</vh></v>
<v t="ekr.20250122151620.1572"><vh>OpenGLArrowTip.get_length</vh></v>
</v>
<v t="ekr.20250122151620.1485"><vh>class OpenGLRectangle</vh>
<v t="ekr.20250122151620.1573"><vh>OpenGLRectangle.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1486"><vh>class OpenGLSquare</vh>
<v t="ekr.20250122151620.1574"><vh>OpenGLSquare.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1487"><vh>class OpenGLRoundedRectangle</vh>
<v t="ekr.20250122151620.1575"><vh>OpenGLRoundedRectangle.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1576"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/opengl_image_mobject.py</vh>
<v t="ekr.20250122151620.1577"><vh>class OpenGLImageMobject</vh>
<v t="ekr.20250122151620.1578"><vh>OpenGLImageMobject.__init__</vh></v>
<v t="ekr.20250122151620.1579"><vh>OpenGLImageMobject.get_image_from_file</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1580"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/opengl_mobject.py</vh>
<v t="ekr.20250122151620.1581"><vh>function: affects_shader_info_id</vh></v>
<v t="ekr.20250122151620.1582"><vh>class OpenGLMobject</vh>
<v t="ekr.20250122151620.1587"><vh>OpenGLMobject.__init__</vh></v>
<v t="ekr.20250122151620.1588"><vh>OpenGLMobject._assert_valid_submobjects</vh></v>
<v t="ekr.20250122151620.1589"><vh>OpenGLMobject._assert_valid_submobjects_internal</vh></v>
<v t="ekr.20250122151620.1590"><vh>OpenGLMobject.__init_subclass__</vh></v>
<v t="ekr.20250122151620.1591"><vh>OpenGLMobject.__str__</vh></v>
<v t="ekr.20250122151620.1592"><vh>OpenGLMobject.__repr__</vh></v>
<v t="ekr.20250122151620.1593"><vh>OpenGLMobject.__sub__</vh></v>
<v t="ekr.20250122151620.1594"><vh>OpenGLMobject.__isub__</vh></v>
<v t="ekr.20250122151620.1595"><vh>OpenGLMobject.__add__</vh></v>
<v t="ekr.20250122151620.1596"><vh>OpenGLMobject.__iadd__</vh></v>
<v t="ekr.20250122151620.1597"><vh>OpenGLMobject.set_default</vh></v>
<v t="ekr.20250122151620.1598"><vh>OpenGLMobject.init_data</vh></v>
<v t="ekr.20250122151620.1599"><vh>OpenGLMobject.init_colors</vh></v>
<v t="ekr.20250122151620.1600"><vh>OpenGLMobject.init_points</vh></v>
<v t="ekr.20250122151620.1601"><vh>OpenGLMobject.set</vh></v>
<v t="ekr.20250122151620.1602"><vh>OpenGLMobject.set_data</vh></v>
<v t="ekr.20250122151620.1603"><vh>OpenGLMobject.set_uniforms</vh></v>
<v t="ekr.20250122151620.1604"><vh>OpenGLMobject.animate</vh></v>
<v t="ekr.20250122151620.1605"><vh>OpenGLMobject.width</vh></v>
<v t="ekr.20250122151620.1606"><vh>OpenGLMobject.width</vh></v>
<v t="ekr.20250122151620.1607"><vh>OpenGLMobject.height</vh></v>
<v t="ekr.20250122151620.1608"><vh>OpenGLMobject.height</vh></v>
<v t="ekr.20250122151620.1609"><vh>OpenGLMobject.depth</vh></v>
<v t="ekr.20250122151620.1610"><vh>OpenGLMobject.depth</vh></v>
<v t="ekr.20250122151620.1611"><vh>OpenGLMobject.resize_points</vh></v>
<v t="ekr.20250122151620.1612"><vh>OpenGLMobject.set_points</vh></v>
<v t="ekr.20250122151620.1613"><vh>OpenGLMobject.apply_over_attr_arrays</vh></v>
<v t="ekr.20250122151620.1614"><vh>OpenGLMobject.append_points</vh></v>
<v t="ekr.20250122151620.1615"><vh>OpenGLMobject.reverse_points</vh></v>
<v t="ekr.20250122151620.1616"><vh>OpenGLMobject.get_midpoint</vh></v>
<v t="ekr.20250122151620.1617"><vh>OpenGLMobject.apply_points_function</vh></v>
<v t="ekr.20250122151620.1618"><vh>OpenGLMobject.match_points</vh></v>
<v t="ekr.20250122151620.1619"><vh>OpenGLMobject.clear_points</vh></v>
<v t="ekr.20250122151620.1620"><vh>OpenGLMobject.get_num_points</vh></v>
<v t="ekr.20250122151620.1621"><vh>OpenGLMobject.get_all_points</vh></v>
<v t="ekr.20250122151620.1622"><vh>OpenGLMobject.has_points</vh></v>
<v t="ekr.20250122151620.1623"><vh>OpenGLMobject.get_bounding_box</vh></v>
<v t="ekr.20250122151620.1624"><vh>OpenGLMobject.compute_bounding_box</vh></v>
<v t="ekr.20250122151620.1625"><vh>OpenGLMobject.refresh_bounding_box</vh></v>
<v t="ekr.20250122151620.1626"><vh>OpenGLMobject.is_point_touching</vh></v>
<v t="ekr.20250122151620.1627"><vh>OpenGLMobject.__getitem__</vh></v>
<v t="ekr.20250122151620.1628"><vh>OpenGLMobject.__iter__</vh></v>
<v t="ekr.20250122151620.1629"><vh>OpenGLMobject.__len__</vh></v>
<v t="ekr.20250122151620.1630"><vh>OpenGLMobject.split</vh></v>
<v t="ekr.20250122151620.1631"><vh>OpenGLMobject.assemble_family</vh></v>
<v t="ekr.20250122151620.1632"><vh>OpenGLMobject.get_family</vh></v>
<v t="ekr.20250122151620.1633"><vh>OpenGLMobject.family_members_with_points</vh></v>
<v t="ekr.20250122151620.1634"><vh>OpenGLMobject.add</vh></v>
<v t="ekr.20250122151620.1635"><vh>OpenGLMobject.insert</vh></v>
<v t="ekr.20250122151620.1636"><vh>OpenGLMobject.remove</vh></v>
<v t="ekr.20250122151620.1637"><vh>OpenGLMobject.add_to_back</vh></v>
<v t="ekr.20250122151620.1638"><vh>OpenGLMobject.replace_submobject</vh></v>
<v t="ekr.20250122151620.1639"><vh>OpenGLMobject.arrange</vh></v>
<v t="ekr.20250122151620.1640"><vh>OpenGLMobject.arrange_in_grid</vh></v>
<v t="ekr.20250122151620.1641"><vh>OpenGLMobject.get_grid</vh></v>
<v t="ekr.20250122151620.1642"><vh>OpenGLMobject.duplicate</vh></v>
<v t="ekr.20250122151620.1643"><vh>OpenGLMobject.sort</vh></v>
<v t="ekr.20250122151620.1644"><vh>OpenGLMobject.shuffle</vh></v>
<v t="ekr.20250122151620.1645"><vh>OpenGLMobject.invert</vh></v>
<v t="ekr.20250122151620.1646"><vh>OpenGLMobject.copy</vh></v>
<v t="ekr.20250122151620.1647"><vh>OpenGLMobject.deepcopy</vh></v>
<v t="ekr.20250122151620.1648"><vh>OpenGLMobject.generate_target</vh></v>
<v t="ekr.20250122151620.1649"><vh>OpenGLMobject.save_state</vh></v>
<v t="ekr.20250122151620.1650"><vh>OpenGLMobject.restore</vh></v>
<v t="ekr.20250122151620.1651"><vh>OpenGLMobject.init_updaters</vh></v>
<v t="ekr.20250122151620.1652"><vh>OpenGLMobject.update</vh></v>
<v t="ekr.20250122151620.1653"><vh>OpenGLMobject.get_time_based_updaters</vh></v>
<v t="ekr.20250122151620.1654"><vh>OpenGLMobject.has_time_based_updater</vh></v>
<v t="ekr.20250122151620.1655"><vh>OpenGLMobject.get_updaters</vh></v>
<v t="ekr.20250122151620.1656"><vh>OpenGLMobject.get_family_updaters</vh></v>
<v t="ekr.20250122151620.1657"><vh>OpenGLMobject.add_updater</vh></v>
<v t="ekr.20250122151620.1658"><vh>OpenGLMobject.remove_updater</vh></v>
<v t="ekr.20250122151620.1659"><vh>OpenGLMobject.clear_updaters</vh></v>
<v t="ekr.20250122151620.1660"><vh>OpenGLMobject.match_updaters</vh></v>
<v t="ekr.20250122151620.1661"><vh>OpenGLMobject.suspend_updating</vh></v>
<v t="ekr.20250122151620.1662"><vh>OpenGLMobject.resume_updating</vh></v>
<v t="ekr.20250122151620.1663"><vh>OpenGLMobject.refresh_has_updater_status</vh></v>
<v t="ekr.20250122151620.1664"><vh>OpenGLMobject.shift</vh></v>
<v t="ekr.20250122151620.1665"><vh>OpenGLMobject.scale</vh></v>
<v t="ekr.20250122151620.1666"><vh>OpenGLMobject.stretch</vh></v>
<v t="ekr.20250122151620.1667"><vh>OpenGLMobject.rotate_about_origin</vh></v>
<v t="ekr.20250122151620.1668"><vh>OpenGLMobject.rotate</vh></v>
<v t="ekr.20250122151620.1669"><vh>OpenGLMobject.flip</vh></v>
<v t="ekr.20250122151620.1670"><vh>OpenGLMobject.apply_function</vh></v>
<v t="ekr.20250122151620.1671"><vh>OpenGLMobject.apply_function_to_position</vh></v>
<v t="ekr.20250122151620.1672"><vh>OpenGLMobject.apply_function_to_submobject_positions</vh></v>
<v t="ekr.20250122151620.1673"><vh>OpenGLMobject.apply_matrix</vh></v>
<v t="ekr.20250122151620.1674"><vh>OpenGLMobject.apply_complex_function</vh></v>
<v t="ekr.20250122151620.1675"><vh>OpenGLMobject.hierarchical_model_matrix</vh></v>
<v t="ekr.20250122151620.1676"><vh>OpenGLMobject.wag</vh></v>
<v t="ekr.20250122151620.1677"><vh>OpenGLMobject.center</vh></v>
<v t="ekr.20250122151620.1678"><vh>OpenGLMobject.align_on_border</vh></v>
<v t="ekr.20250122151620.1679"><vh>OpenGLMobject.to_corner</vh></v>
<v t="ekr.20250122151620.1680"><vh>OpenGLMobject.to_edge</vh></v>
<v t="ekr.20250122151620.1681"><vh>OpenGLMobject.next_to</vh></v>
<v t="ekr.20250122151620.1682"><vh>OpenGLMobject.shift_onto_screen</vh></v>
<v t="ekr.20250122151620.1683"><vh>OpenGLMobject.is_off_screen</vh></v>
<v t="ekr.20250122151620.1684"><vh>OpenGLMobject.stretch_about_point</vh></v>
<v t="ekr.20250122151620.1685"><vh>OpenGLMobject.rescale_to_fit</vh></v>
<v t="ekr.20250122151620.1686"><vh>OpenGLMobject.stretch_to_fit_width</vh></v>
<v t="ekr.20250122151620.1687"><vh>OpenGLMobject.stretch_to_fit_height</vh></v>
<v t="ekr.20250122151620.1688"><vh>OpenGLMobject.stretch_to_fit_depth</vh></v>
<v t="ekr.20250122151620.1689"><vh>OpenGLMobject.set_width</vh></v>
<v t="ekr.20250122151620.1690"><vh>OpenGLMobject.set_height</vh></v>
<v t="ekr.20250122151620.1691"><vh>OpenGLMobject.set_depth</vh></v>
<v t="ekr.20250122151620.1692"><vh>OpenGLMobject.set_coord</vh></v>
<v t="ekr.20250122151620.1693"><vh>OpenGLMobject.set_x</vh></v>
<v t="ekr.20250122151620.1694"><vh>OpenGLMobject.set_y</vh></v>
<v t="ekr.20250122151620.1695"><vh>OpenGLMobject.set_z</vh></v>
<v t="ekr.20250122151620.1696"><vh>OpenGLMobject.space_out_submobjects</vh></v>
<v t="ekr.20250122151620.1697"><vh>OpenGLMobject.move_to</vh></v>
<v t="ekr.20250122151620.1698"><vh>OpenGLMobject.replace</vh></v>
<v t="ekr.20250122151620.1699"><vh>OpenGLMobject.surround</vh></v>
<v t="ekr.20250122151620.1700"><vh>OpenGLMobject.put_start_and_end_on</vh></v>
<v t="ekr.20250122151620.1701"><vh>OpenGLMobject.set_rgba_array</vh></v>
<v t="ekr.20250122151620.1702"><vh>OpenGLMobject.set_rgba_array_direct</vh></v>
<v t="ekr.20250122151620.1703"><vh>OpenGLMobject.set_color</vh></v>
<v t="ekr.20250122151620.1704"><vh>OpenGLMobject.set_opacity</vh></v>
<v t="ekr.20250122151620.1705"><vh>OpenGLMobject.get_color</vh></v>
<v t="ekr.20250122151620.1706"><vh>OpenGLMobject.get_opacity</vh></v>
<v t="ekr.20250122151620.1707"><vh>OpenGLMobject.set_color_by_gradient</vh></v>
<v t="ekr.20250122151620.1708"><vh>OpenGLMobject.set_submobject_colors_by_gradient</vh></v>
<v t="ekr.20250122151620.1709"><vh>OpenGLMobject.fade</vh></v>
<v t="ekr.20250122151620.1710"><vh>OpenGLMobject.get_gloss</vh></v>
<v t="ekr.20250122151620.1711"><vh>OpenGLMobject.set_gloss</vh></v>
<v t="ekr.20250122151620.1712"><vh>OpenGLMobject.get_shadow</vh></v>
<v t="ekr.20250122151620.1713"><vh>OpenGLMobject.set_shadow</vh></v>
<v t="ekr.20250122151620.1714"><vh>OpenGLMobject.add_background_rectangle</vh></v>
<v t="ekr.20250122151620.1715"><vh>OpenGLMobject.add_background_rectangle_to_submobjects</vh></v>
<v t="ekr.20250122151620.1716"><vh>OpenGLMobject.add_background_rectangle_to_family_members_with_points</vh></v>
<v t="ekr.20250122151620.1717"><vh>OpenGLMobject.get_bounding_box_point</vh></v>
<v t="ekr.20250122151620.1718"><vh>OpenGLMobject.get_edge_center</vh></v>
<v t="ekr.20250122151620.1719"><vh>OpenGLMobject.get_corner</vh></v>
<v t="ekr.20250122151620.1720"><vh>OpenGLMobject.get_center</vh></v>
<v t="ekr.20250122151620.1721"><vh>OpenGLMobject.get_center_of_mass</vh></v>
<v t="ekr.20250122151620.1722"><vh>OpenGLMobject.get_boundary_point</vh></v>
<v t="ekr.20250122151620.1723"><vh>OpenGLMobject.get_continuous_bounding_box_point</vh></v>
<v t="ekr.20250122151620.1724"><vh>OpenGLMobject.get_top</vh></v>
<v t="ekr.20250122151620.1725"><vh>OpenGLMobject.get_bottom</vh></v>
<v t="ekr.20250122151620.1726"><vh>OpenGLMobject.get_right</vh></v>
<v t="ekr.20250122151620.1727"><vh>OpenGLMobject.get_left</vh></v>
<v t="ekr.20250122151620.1728"><vh>OpenGLMobject.get_zenith</vh></v>
<v t="ekr.20250122151620.1729"><vh>OpenGLMobject.get_nadir</vh></v>
<v t="ekr.20250122151620.1730"><vh>OpenGLMobject.length_over_dim</vh></v>
<v t="ekr.20250122151620.1731"><vh>OpenGLMobject.get_width</vh></v>
<v t="ekr.20250122151620.1732"><vh>OpenGLMobject.get_height</vh></v>
<v t="ekr.20250122151620.1733"><vh>OpenGLMobject.get_depth</vh></v>
<v t="ekr.20250122151620.1734"><vh>OpenGLMobject.get_coord</vh></v>
<v t="ekr.20250122151620.1735"><vh>OpenGLMobject.get_x</vh></v>
<v t="ekr.20250122151620.1736"><vh>OpenGLMobject.get_y</vh></v>
<v t="ekr.20250122151620.1737"><vh>OpenGLMobject.get_z</vh></v>
<v t="ekr.20250122151620.1738"><vh>OpenGLMobject.get_start</vh></v>
<v t="ekr.20250122151620.1739"><vh>OpenGLMobject.get_end</vh></v>
<v t="ekr.20250122151620.1740"><vh>OpenGLMobject.get_start_and_end</vh></v>
<v t="ekr.20250122151620.1741"><vh>OpenGLMobject.point_from_proportion</vh></v>
<v t="ekr.20250122151620.1742"><vh>OpenGLMobject.pfp</vh></v>
<v t="ekr.20250122151620.1743"><vh>OpenGLMobject.get_pieces</vh></v>
<v t="ekr.20250122151620.1744"><vh>OpenGLMobject.get_z_index_reference_point</vh></v>
<v t="ekr.20250122151620.1745"><vh>OpenGLMobject.match_color</vh></v>
<v t="ekr.20250122151620.1746"><vh>OpenGLMobject.match_dim_size</vh></v>
<v t="ekr.20250122151620.1747"><vh>OpenGLMobject.match_width</vh></v>
<v t="ekr.20250122151620.1748"><vh>OpenGLMobject.match_height</vh></v>
<v t="ekr.20250122151620.1749"><vh>OpenGLMobject.match_depth</vh></v>
<v t="ekr.20250122151620.1750"><vh>OpenGLMobject.match_coord</vh></v>
<v t="ekr.20250122151620.1751"><vh>OpenGLMobject.match_x</vh></v>
<v t="ekr.20250122151620.1752"><vh>OpenGLMobject.match_y</vh></v>
<v t="ekr.20250122151620.1753"><vh>OpenGLMobject.match_z</vh></v>
<v t="ekr.20250122151620.1754"><vh>OpenGLMobject.align_to</vh></v>
<v t="ekr.20250122151620.1755"><vh>OpenGLMobject.get_group_class</vh></v>
<v t="ekr.20250122151620.1756"><vh>OpenGLMobject.get_mobject_type_class</vh></v>
<v t="ekr.20250122151620.1757"><vh>OpenGLMobject.align_data_and_family</vh></v>
<v t="ekr.20250122151620.1758"><vh>OpenGLMobject.align_data</vh></v>
<v t="ekr.20250122151620.1759"><vh>OpenGLMobject.align_points</vh></v>
<v t="ekr.20250122151620.1760"><vh>OpenGLMobject.align_family</vh></v>
<v t="ekr.20250122151620.1761"><vh>OpenGLMobject.push_self_into_submobjects</vh></v>
<v t="ekr.20250122151620.1762"><vh>OpenGLMobject.add_n_more_submobjects</vh></v>
<v t="ekr.20250122151620.1763"><vh>OpenGLMobject.interpolate</vh></v>
<v t="ekr.20250122151620.1764"><vh>OpenGLMobject.pointwise_become_partial</vh></v>
<v t="ekr.20250122151620.1765"><vh>OpenGLMobject.become</vh></v>
<v t="ekr.20250122151620.1766"><vh>OpenGLMobject.lock_data</vh></v>
<v t="ekr.20250122151620.1767"><vh>OpenGLMobject.lock_matching_data</vh></v>
<v t="ekr.20250122151620.1768"><vh>OpenGLMobject.unlock_data</vh></v>
<v t="ekr.20250122151620.1769"><vh>OpenGLMobject.fix_in_frame</vh></v>
<v t="ekr.20250122151620.1770"><vh>OpenGLMobject.fix_orientation</vh></v>
<v t="ekr.20250122151620.1771"><vh>OpenGLMobject.unfix_from_frame</vh></v>
<v t="ekr.20250122151620.1772"><vh>OpenGLMobject.unfix_orientation</vh></v>
<v t="ekr.20250122151620.1773"><vh>OpenGLMobject.apply_depth_test</vh></v>
<v t="ekr.20250122151620.1774"><vh>OpenGLMobject.deactivate_depth_test</vh></v>
<v t="ekr.20250122151620.1775"><vh>OpenGLMobject.replace_shader_code</vh></v>
<v t="ekr.20250122151620.1776"><vh>OpenGLMobject.set_color_by_code</vh></v>
<v t="ekr.20250122151620.1777"><vh>OpenGLMobject.set_color_by_xyz_func</vh></v>
<v t="ekr.20250122151620.1778"><vh>OpenGLMobject.refresh_shader_wrapper_id</vh></v>
<v t="ekr.20250122151620.1779"><vh>OpenGLMobject.get_shader_wrapper</vh></v>
<v t="ekr.20250122151620.1780"><vh>OpenGLMobject.get_shader_wrapper_list</vh></v>
<v t="ekr.20250122151620.1781"><vh>OpenGLMobject.check_data_alignment</vh></v>
<v t="ekr.20250122151620.1782"><vh>OpenGLMobject.get_resized_shader_data_array</vh></v>
<v t="ekr.20250122151620.1783"><vh>OpenGLMobject.read_data_to_shader</vh></v>
<v t="ekr.20250122151620.1784"><vh>OpenGLMobject.get_shader_data</vh></v>
<v t="ekr.20250122151620.1785"><vh>OpenGLMobject.refresh_shader_data</vh></v>
<v t="ekr.20250122151620.1786"><vh>OpenGLMobject.get_shader_uniforms</vh></v>
<v t="ekr.20250122151620.1787"><vh>OpenGLMobject.get_shader_vert_indices</vh></v>
<v t="ekr.20250122151620.1788"><vh>OpenGLMobject.submobjects</vh></v>
<v t="ekr.20250122151620.1789"><vh>OpenGLMobject.submobjects</vh></v>
<v t="ekr.20250122151620.1790"><vh>OpenGLMobject.throw_error_if_no_points</vh></v>
</v>
<v t="ekr.20250122151620.1583"><vh>class OpenGLGroup</vh>
<v t="ekr.20250122151620.1791"><vh>OpenGLGroup.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1584"><vh>class OpenGLPoint</vh>
<v t="ekr.20250122151620.1792"><vh>OpenGLPoint.__init__</vh></v>
<v t="ekr.20250122151620.1793"><vh>OpenGLPoint.get_width</vh></v>
<v t="ekr.20250122151620.1794"><vh>OpenGLPoint.get_height</vh></v>
<v t="ekr.20250122151620.1795"><vh>OpenGLPoint.get_location</vh></v>
<v t="ekr.20250122151620.1796"><vh>OpenGLPoint.get_bounding_box_point</vh></v>
<v t="ekr.20250122151620.1797"><vh>OpenGLPoint.set_location</vh></v>
</v>
<v t="ekr.20250122151620.1585"><vh>class _AnimationBuilder</vh>
<v t="ekr.20250122151620.1798"><vh>_AnimationBuilder.__init__</vh></v>
<v t="ekr.20250122151620.1799"><vh>_AnimationBuilder.__call__</vh></v>
<v t="ekr.20250122151620.1800"><vh>_AnimationBuilder.__getattr__</vh></v>
<v t="ekr.20250122151620.1801"><vh>_AnimationBuilder.build</vh></v>
</v>
<v t="ekr.20250122151620.1586"><vh>function: override_animate</vh></v>
</v>
<v t="ekr.20250122151620.1802"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/opengl_point_cloud_mobject.py</vh>
<v t="ekr.20250122151620.1803"><vh>class OpenGLPMobject</vh>
<v t="ekr.20250122151620.1806"><vh>OpenGLPMobject.__init__</vh></v>
<v t="ekr.20250122151620.1807"><vh>OpenGLPMobject.reset_points</vh></v>
<v t="ekr.20250122151620.1808"><vh>OpenGLPMobject.get_array_attrs</vh></v>
<v t="ekr.20250122151620.1809"><vh>OpenGLPMobject.add_points</vh></v>
<v t="ekr.20250122151620.1810"><vh>OpenGLPMobject.thin_out</vh></v>
<v t="ekr.20250122151620.1811"><vh>OpenGLPMobject.set_color_by_gradient</vh></v>
<v t="ekr.20250122151620.1812"><vh>OpenGLPMobject.set_colors_by_radial_gradient</vh></v>
<v t="ekr.20250122151620.1813"><vh>OpenGLPMobject.match_colors</vh></v>
<v t="ekr.20250122151620.1814"><vh>OpenGLPMobject.fade_to</vh></v>
<v t="ekr.20250122151620.1815"><vh>OpenGLPMobject.filter_out</vh></v>
<v t="ekr.20250122151620.1816"><vh>OpenGLPMobject.sort_points</vh></v>
<v t="ekr.20250122151620.1817"><vh>OpenGLPMobject.ingest_submobjects</vh></v>
<v t="ekr.20250122151620.1818"><vh>OpenGLPMobject.point_from_proportion</vh></v>
<v t="ekr.20250122151620.1819"><vh>OpenGLPMobject.pointwise_become_partial</vh></v>
<v t="ekr.20250122151620.1820"><vh>OpenGLPMobject.get_shader_data</vh></v>
<v t="ekr.20250122151620.1821"><vh>OpenGLPMobject.get_mobject_type_class</vh></v>
</v>
<v t="ekr.20250122151620.1804"><vh>class OpenGLPGroup</vh>
<v t="ekr.20250122151620.1822"><vh>OpenGLPGroup.__init__</vh></v>
<v t="ekr.20250122151620.1823"><vh>OpenGLPGroup.fade_to</vh></v>
</v>
<v t="ekr.20250122151620.1805"><vh>class OpenGLPMPoint</vh>
<v t="ekr.20250122151620.1824"><vh>OpenGLPMPoint.__init__</vh></v>
<v t="ekr.20250122151620.1825"><vh>OpenGLPMPoint.init_points</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1826"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/opengl_surface.py</vh>
<v t="ekr.20250122151620.1827"><vh>class OpenGLSurface</vh>
<v t="ekr.20250122151620.1830"><vh>OpenGLSurface.__init__</vh></v>
<v t="ekr.20250122151620.1831"><vh>OpenGLSurface.uv_func</vh></v>
<v t="ekr.20250122151620.1832"><vh>OpenGLSurface.init_points</vh></v>
<v t="ekr.20250122151620.1833"><vh>OpenGLSurface.compute_triangle_indices</vh></v>
<v t="ekr.20250122151620.1834"><vh>OpenGLSurface.get_triangle_indices</vh></v>
<v t="ekr.20250122151620.1835"><vh>OpenGLSurface.get_surface_points_and_nudged_points</vh></v>
<v t="ekr.20250122151620.1836"><vh>OpenGLSurface.get_unit_normals</vh></v>
<v t="ekr.20250122151620.1837"><vh>OpenGLSurface.pointwise_become_partial</vh></v>
<v t="ekr.20250122151620.1838"><vh>OpenGLSurface.get_partial_points_array</vh></v>
<v t="ekr.20250122151620.1839"><vh>OpenGLSurface.sort_faces_back_to_front</vh></v>
<v t="ekr.20250122151620.1840"><vh>OpenGLSurface.get_shader_data</vh></v>
<v t="ekr.20250122151620.1841"><vh>OpenGLSurface.fill_in_shader_color_info</vh></v>
<v t="ekr.20250122151620.1842"><vh>OpenGLSurface._get_color_by_value</vh></v>
<v t="ekr.20250122151620.1843"><vh>OpenGLSurface.get_shader_vert_indices</vh></v>
</v>
<v t="ekr.20250122151620.1828"><vh>class OpenGLSurfaceGroup</vh>
<v t="ekr.20250122151620.1844"><vh>OpenGLSurfaceGroup.__init__</vh></v>
<v t="ekr.20250122151620.1845"><vh>OpenGLSurfaceGroup.init_points</vh></v>
</v>
<v t="ekr.20250122151620.1829"><vh>class OpenGLTexturedSurface</vh>
<v t="ekr.20250122151620.1846"><vh>OpenGLTexturedSurface.__init__</vh></v>
<v t="ekr.20250122151620.1847"><vh>OpenGLTexturedSurface.get_image_from_file</vh></v>
<v t="ekr.20250122151620.1848"><vh>OpenGLTexturedSurface.init_data</vh></v>
<v t="ekr.20250122151620.1849"><vh>OpenGLTexturedSurface.init_points</vh></v>
<v t="ekr.20250122151620.1850"><vh>OpenGLTexturedSurface.init_colors</vh></v>
<v t="ekr.20250122151620.1851"><vh>OpenGLTexturedSurface.set_opacity</vh></v>
<v t="ekr.20250122151620.1852"><vh>OpenGLTexturedSurface.pointwise_become_partial</vh></v>
<v t="ekr.20250122151620.1853"><vh>OpenGLTexturedSurface.fill_in_shader_color_info</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1854"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/opengl_three_dimensions.py</vh>
<v t="ekr.20250122151620.1855"><vh>class OpenGLSurfaceMesh</vh>
<v t="ekr.20250122151620.1856"><vh>OpenGLSurfaceMesh.__init__</vh></v>
<v t="ekr.20250122151620.1857"><vh>OpenGLSurfaceMesh.init_points</vh></v>
</v>
</v>
<v t="ekr.20250122151620.1858"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/opengl/opengl_vectorized_mobject.py</vh>
<v t="ekr.20250122151620.1859"><vh>function: triggers_refreshed_triangulation</vh></v>
<v t="ekr.20250122151620.1860"><vh>class OpenGLVMobject</vh>
<v t="ekr.20250122151620.1865"><vh>OpenGLVMobject.__init__</vh></v>
<v t="ekr.20250122151620.1866"><vh>OpenGLVMobject._assert_valid_submobjects</vh></v>
<v t="ekr.20250122151620.1867"><vh>OpenGLVMobject.get_group_class</vh></v>
<v t="ekr.20250122151620.1868"><vh>OpenGLVMobject.get_mobject_type_class</vh></v>
<v t="ekr.20250122151620.1869"><vh>OpenGLVMobject.init_data</vh></v>
<v t="ekr.20250122151620.1870"><vh>OpenGLVMobject.init_colors</vh></v>
<v t="ekr.20250122151620.1871"><vh>OpenGLVMobject.set_fill</vh></v>
<v t="ekr.20250122151620.1872"><vh>OpenGLVMobject.set_stroke</vh></v>
<v t="ekr.20250122151620.1873"><vh>OpenGLVMobject.set_style</vh></v>
<v t="ekr.20250122151620.1874"><vh>OpenGLVMobject.get_style</vh></v>
<v t="ekr.20250122151620.1875"><vh>OpenGLVMobject.match_style</vh></v>
<v t="ekr.20250122151620.1876"><vh>OpenGLVMobject.set_color</vh></v>
<v t="ekr.20250122151620.1877"><vh>OpenGLVMobject.set_opacity</vh></v>
<v t="ekr.20250122151620.1878"><vh>OpenGLVMobject.fade</vh></v>
<v t="ekr.20250122151620.1879"><vh>OpenGLVMobject.get_fill_colors</vh></v>
<v t="ekr.20250122151620.1880"><vh>OpenGLVMobject.get_fill_opacities</vh></v>
<v t="ekr.20250122151620.1881"><vh>OpenGLVMobject.get_stroke_colors</vh></v>
<v t="ekr.20250122151620.1882"><vh>OpenGLVMobject.get_stroke_opacities</vh></v>
<v t="ekr.20250122151620.1883"><vh>OpenGLVMobject.get_stroke_widths</vh></v>
<v t="ekr.20250122151620.1884"><vh>OpenGLVMobject.get_fill_color</vh></v>
<v t="ekr.20250122151620.1885"><vh>OpenGLVMobject.get_fill_opacity</vh></v>
<v t="ekr.20250122151620.1886"><vh>OpenGLVMobject.get_stroke_color</vh></v>
<v t="ekr.20250122151620.1887"><vh>OpenGLVMobject.get_stroke_width</vh></v>
<v t="ekr.20250122151620.1888"><vh>OpenGLVMobject.get_stroke_opacity</vh></v>
<v t="ekr.20250122151620.1889"><vh>OpenGLVMobject.get_color</vh></v>
<v t="ekr.20250122151620.1890"><vh>OpenGLVMobject.get_colors</vh></v>
<v t="ekr.20250122151620.1891"><vh>OpenGLVMobject.has_stroke</vh></v>
<v t="ekr.20250122151620.1892"><vh>OpenGLVMobject.has_fill</vh></v>
<v t="ekr.20250122151620.1893"><vh>OpenGLVMobject.get_opacity</vh></v>
<v t="ekr.20250122151620.1894"><vh>OpenGLVMobject.set_flat_stroke</vh></v>
<v t="ekr.20250122151620.1895"><vh>OpenGLVMobject.get_flat_stroke</vh></v>
<v t="ekr.20250122151620.1896"><vh>OpenGLVMobject.set_anchors_and_handles</vh></v>
<v t="ekr.20250122151620.1897"><vh>OpenGLVMobject.start_new_path</vh></v>
<v t="ekr.20250122151620.1898"><vh>OpenGLVMobject.add_cubic_bezier_curve</vh></v>
<v t="ekr.20250122151620.1899"><vh>OpenGLVMobject.add_cubic_bezier_curve_to</vh></v>
<v t="ekr.20250122151620.1900"><vh>OpenGLVMobject.add_quadratic_bezier_curve_to</vh></v>
<v t="ekr.20250122151620.1901"><vh>OpenGLVMobject.add_line_to</vh></v>
<v t="ekr.20250122151620.1902"><vh>OpenGLVMobject.add_smooth_curve_to</vh></v>
<v t="ekr.20250122151620.1903"><vh>OpenGLVMobject.add_smooth_cubic_curve_to</vh></v>
<v t="ekr.20250122151620.1904"><vh>OpenGLVMobject.has_new_path_started</vh></v>
<v t="ekr.20250122151620.1905"><vh>OpenGLVMobject.get_last_point</vh></v>
<v t="ekr.20250122151620.1906"><vh>OpenGLVMobject.get_reflection_of_last_handle</vh></v>
<v t="ekr.20250122151620.1907"><vh>OpenGLVMobject.close_path</vh></v>
<v t="ekr.20250122151620.1908"><vh>OpenGLVMobject.is_closed</vh></v>
<v t="ekr.20250122151620.1909"><vh>OpenGLVMobject.subdivide_sharp_curves</vh></v>
<v t="ekr.20250122151620.1910"><vh>OpenGLVMobject.add_points_as_corners</vh></v>
<v t="ekr.20250122151620.1911"><vh>OpenGLVMobject.set_points_as_corners</vh></v>
<v t="ekr.20250122151620.1912"><vh>OpenGLVMobject.set_points_smoothly</vh></v>
<v t="ekr.20250122151620.1913"><vh>OpenGLVMobject.change_anchor_mode</vh></v>
<v t="ekr.20250122151620.1914"><vh>OpenGLVMobject.make_smooth</vh></v>
<v t="ekr.20250122151620.1915"><vh>OpenGLVMobject.make_approximately_smooth</vh></v>
<v t="ekr.20250122151620.1916"><vh>OpenGLVMobject.make_jagged</vh></v>
<v t="ekr.20250122151620.1917"><vh>OpenGLVMobject.add_subpath</vh></v>
<v t="ekr.20250122151620.1918"><vh>OpenGLVMobject.append_vectorized_mobject</vh></v>
<v t="ekr.20250122151620.1919"><vh>OpenGLVMobject.consider_points_equals</vh></v>
<v t="ekr.20250122151620.1920"><vh>OpenGLVMobject.force_direction</vh></v>
<v t="ekr.20250122151620.1921"><vh>OpenGLVMobject.reverse_direction</vh></v>
<v t="ekr.20250122151620.1922"><vh>OpenGLVMobject.get_bezier_tuples_from_points</vh></v>
<v t="ekr.20250122151620.1923"><vh>OpenGLVMobject.get_bezier_tuples</vh></v>
<v t="ekr.20250122151620.1924"><vh>OpenGLVMobject.get_subpaths_from_points</vh></v>
<v t="ekr.20250122151620.1925"><vh>OpenGLVMobject.get_subpaths</vh></v>
<v t="ekr.20250122151620.1926"><vh>OpenGLVMobject.get_nth_curve_points</vh></v>
<v t="ekr.20250122151620.1927"><vh>OpenGLVMobject.get_nth_curve_function</vh></v>
<v t="ekr.20250122151620.1928"><vh>OpenGLVMobject.get_nth_curve_function_with_length</vh></v>
<v t="ekr.20250122151620.1929"><vh>OpenGLVMobject.get_num_curves</vh></v>
<v t="ekr.20250122151620.1930"><vh>OpenGLVMobject.get_nth_curve_length</vh></v>
<v t="ekr.20250122151620.1931"><vh>OpenGLVMobject.get_curve_functions</vh></v>
<v t="ekr.20250122151620.1932"><vh>OpenGLVMobject.get_nth_curve_length_pieces</vh></v>
<v t="ekr.20250122151620.1933"><vh>OpenGLVMobject.get_curve_functions_with_lengths</vh></v>
<v t="ekr.20250122151620.1934"><vh>OpenGLVMobject.point_from_proportion</vh></v>
<v t="ekr.20250122151620.1935"><vh>OpenGLVMobject.proportion_from_point</vh></v>
<v t="ekr.20250122151620.1936"><vh>OpenGLVMobject.get_anchors_and_handles</vh></v>
<v t="ekr.20250122151620.1937"><vh>OpenGLVMobject.get_start_anchors</vh></v>
<v t="ekr.20250122151620.1938"><vh>OpenGLVMobject.get_end_anchors</vh></v>
<v t="ekr.20250122151620.1939"><vh>OpenGLVMobject.get_anchors</vh></v>
<v t="ekr.20250122151620.1940"><vh>OpenGLVMobject.get_points_without_null_curves</vh></v>
<v t="ekr.20250122151620.1941"><vh>OpenGLVMobject.get_arc_length</vh></v>
<v t="ekr.20250122151620.1942"><vh>OpenGLVMobject.get_area_vector</vh></v>
<v t="ekr.20250122151620.1943"><vh>OpenGLVMobject.get_direction</vh></v>
<v t="ekr.20250122151620.1944"><vh>OpenGLVMobject.get_unit_normal</vh></v>
<v t="ekr.20250122151620.1945"><vh>OpenGLVMobject.refresh_unit_normal</vh></v>
<v t="ekr.20250122151620.1946"><vh>OpenGLVMobject.align_points</vh></v>
<v t="ekr.20250122151620.1947"><vh>OpenGLVMobject.insert_n_curves</vh></v>
<v t="ekr.20250122151620.1948"><vh>OpenGLVMobject.insert_n_curves_to_point_list</vh></v>
<v t="ekr.20250122151620.1949"><vh>OpenGLVMobject.interpolate</vh></v>
<v t="ekr.20250122151620.1950"><vh>OpenGLVMobject.pointwise_become_partial</vh></v>
<v t="ekr.20250122151620.1951"><vh>OpenGLVMobject.get_subcurve</vh></v>
<v t="ekr.20250122151620.1952"><vh>OpenGLVMobject.refresh_triangulation</vh></v>
<v t="ekr.20250122151620.1953"><vh>OpenGLVMobject.get_triangulation</vh></v>
<v t="ekr.20250122151620.1954"><vh>OpenGLVMobject.set_points</vh></v>
<v t="ekr.20250122151620.1955"><vh>OpenGLVMobject.set_data</vh></v>
<v t="ekr.20250122151620.1956"><vh>OpenGLVMobject.apply_function</vh></v>
<v t="ekr.20250122151620.1957"><vh>OpenGLVMobject.apply_points_function</vh></v>
<v t="ekr.20250122151620.1958"><vh>OpenGLVMobject.flip</vh></v>
<v t="ekr.20250122151620.1959"><vh>OpenGLVMobject.init_shader_data</vh></v>
<v t="ekr.20250122151620.1960"><vh>OpenGLVMobject.refresh_shader_wrapper_id</vh></v>
<v t="ekr.20250122151620.1961"><vh>OpenGLVMobject.get_fill_shader_wrapper</vh></v>
<v t="ekr.20250122151620.1962"><vh>OpenGLVMobject.update_fill_shader_wrapper</vh></v>
<v t="ekr.20250122151620.1963"><vh>OpenGLVMobject.get_stroke_shader_wrapper</vh></v>
<v t="ekr.20250122151620.1964"><vh>OpenGLVMobject.update_stroke_shader_wrapper</vh></v>
<v t="ekr.20250122151620.1965"><vh>OpenGLVMobject.get_shader_wrapper_list</vh></v>
<v t="ekr.20250122151620.1966"><vh>OpenGLVMobject.get_stroke_uniforms</vh></v>
<v t="ekr.20250122151620.1967"><vh>OpenGLVMobject.get_fill_uniforms</vh></v>
<v t="ekr.20250122151620.1968"><vh>OpenGLVMobject.get_stroke_shader_data</vh></v>
<v t="ekr.20250122151620.1969"><vh>OpenGLVMobject.get_fill_shader_data</vh></v>
<v t="ekr.20250122151620.1970"><vh>OpenGLVMobject.refresh_shader_data</vh></v>
<v t="ekr.20250122151620.1971"><vh>OpenGLVMobject.get_fill_shader_vert_indices</vh></v>
</v>
<v t="ekr.20250122151620.1861"><vh>class OpenGLVGroup</vh>
<v t="ekr.20250122151620.1972"><vh>OpenGLVGroup.__init__</vh></v>
<v t="ekr.20250122151620.1973"><vh>OpenGLVGroup.__repr__</vh></v>
<v t="ekr.20250122151620.1974"><vh>OpenGLVGroup.__str__</vh></v>
<v t="ekr.20250122151620.1975"><vh>OpenGLVGroup.add</vh></v>
<v t="ekr.20250122151620.1976"><vh>OpenGLVGroup.__add__</vh></v>
<v t="ekr.20250122151620.1977"><vh>OpenGLVGroup.__iadd__</vh></v>
<v t="ekr.20250122151620.1978"><vh>OpenGLVGroup.__sub__</vh></v>
<v t="ekr.20250122151620.1979"><vh>OpenGLVGroup.__isub__</vh></v>
<v t="ekr.20250122151620.1980"><vh>OpenGLVGroup.__setitem__</vh></v>
</v>
<v t="ekr.20250122151620.1862"><vh>class OpenGLVectorizedPoint</vh>
<v t="ekr.20250122151620.1981"><vh>OpenGLVectorizedPoint.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1863"><vh>class OpenGLCurvesAsSubmobjects</vh>
<v t="ekr.20250122151620.1982"><vh>OpenGLCurvesAsSubmobjects.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1864"><vh>class OpenGLDashedVMobject</vh>
<v t="ekr.20250122151620.1983"><vh>OpenGLDashedVMobject.__init__</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151620.1984"><vh>C:/Python/Python3.12/Lib/site-packages/manim/mobject/svg</vh>
<v t="ekr.20250122151620.1985"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/svg/__init__.py</vh></v>
<v t="ekr.20250122151620.1986"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/svg/brace.py</vh>
<v t="ekr.20250122151620.1987"><vh>class Brace</vh>
<v t="ekr.20250122151620.1992"><vh>Brace.__init__</vh></v>
<v t="ekr.20250122151620.1993"><vh>Brace.put_at_tip</vh></v>
<v t="ekr.20250122151620.1994"><vh>Brace.get_text</vh></v>
<v t="ekr.20250122151620.1995"><vh>Brace.get_tex</vh></v>
<v t="ekr.20250122151620.1996"><vh>Brace.get_tip</vh></v>
<v t="ekr.20250122151620.1997"><vh>Brace.get_direction</vh></v>
</v>
<v t="ekr.20250122151620.1988"><vh>class BraceLabel</vh>
<v t="ekr.20250122151620.1998"><vh>BraceLabel.__init__</vh></v>
<v t="ekr.20250122151620.1999"><vh>BraceLabel.creation_anim</vh></v>
<v t="ekr.20250122151620.2000"><vh>BraceLabel.shift_brace</vh></v>
<v t="ekr.20250122151620.2001"><vh>BraceLabel.change_label</vh></v>
<v t="ekr.20250122151620.2002"><vh>BraceLabel.change_brace_label</vh></v>
</v>
<v t="ekr.20250122151620.1989"><vh>class BraceText</vh>
<v t="ekr.20250122151620.2003"><vh>BraceText.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1990"><vh>class BraceBetweenPoints</vh>
<v t="ekr.20250122151620.2004"><vh>BraceBetweenPoints.__init__</vh></v>
</v>
<v t="ekr.20250122151620.1991"><vh>class ArcBrace</vh>
<v t="ekr.20250122151620.2005"><vh>ArcBrace.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.2006"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/svg/svg_mobject.py</vh>
<v t="ekr.20250122151620.2007"><vh>function: _convert_point_to_3d</vh></v>
<v t="ekr.20250122151620.2008"><vh>class SVGMobject</vh>
<v t="ekr.20250122151620.2010"><vh>SVGMobject.__init__</vh></v>
<v t="ekr.20250122151620.2011"><vh>SVGMobject.init_svg_mobject</vh></v>
<v t="ekr.20250122151620.2012"><vh>SVGMobject.hash_seed</vh></v>
<v t="ekr.20250122151620.2013"><vh>SVGMobject.generate_mobject</vh></v>
<v t="ekr.20250122151620.2014"><vh>SVGMobject.get_file_path</vh></v>
<v t="ekr.20250122151620.2015"><vh>SVGMobject.modify_xml_tree</vh></v>
<v t="ekr.20250122151620.2016"><vh>SVGMobject.generate_config_style_dict</vh></v>
<v t="ekr.20250122151620.2017"><vh>SVGMobject.get_mobjects_from</vh></v>
<v t="ekr.20250122151620.2018"><vh>SVGMobject.handle_transform</vh></v>
<v t="ekr.20250122151620.2019"><vh>SVGMobject.apply_style_to_mobject</vh></v>
<v t="ekr.20250122151620.2020"><vh>SVGMobject.path_to_mobject</vh></v>
<v t="ekr.20250122151620.2021"><vh>SVGMobject.line_to_mobject</vh></v>
<v t="ekr.20250122151620.2022"><vh>SVGMobject.rect_to_mobject</vh></v>
<v t="ekr.20250122151620.2023"><vh>SVGMobject.ellipse_to_mobject</vh></v>
<v t="ekr.20250122151620.2024"><vh>SVGMobject.polygon_to_mobject</vh></v>
<v t="ekr.20250122151620.2025"><vh>SVGMobject.polyline_to_mobject</vh></v>
<v t="ekr.20250122151620.2026"><vh>SVGMobject.text_to_mobject</vh></v>
<v t="ekr.20250122151620.2027"><vh>SVGMobject.move_into_position</vh></v>
</v>
<v t="ekr.20250122151620.2009"><vh>class VMobjectFromSVGPath</vh>
<v t="ekr.20250122151620.2028"><vh>VMobjectFromSVGPath.__init__</vh></v>
<v t="ekr.20250122151620.2029"><vh>VMobjectFromSVGPath.init_points</vh></v>
<v t="ekr.20250122151620.2030"><vh>VMobjectFromSVGPath.handle_commands</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151620.2031"><vh>C:/Python/Python3.12/Lib/site-packages/manim/mobject/text</vh>
<v t="ekr.20250122151620.2032"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/text/__init__.py</vh></v>
<v t="ekr.20250122151620.2033"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/text/code_mobject.py</vh>
<v t="ekr.20250122151620.2034"><vh>class Code</vh>
<v t="ekr.20250122151620.2035"><vh>Code.__init__</vh></v>
<v t="ekr.20250122151620.2036"><vh>Code.get_styles_list</vh></v>
</v>
</v>
<v t="ekr.20250122151620.2037"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/text/numbers.py</vh>
<v t="ekr.20250122151620.2038"><vh>class DecimalNumber</vh>
<v t="ekr.20250122151620.2041"><vh>DecimalNumber.__init__</vh></v>
<v t="ekr.20250122151620.2042"><vh>DecimalNumber.font_size</vh></v>
<v t="ekr.20250122151620.2043"><vh>DecimalNumber.font_size</vh></v>
<v t="ekr.20250122151620.2044"><vh>DecimalNumber._set_submobjects_from_number</vh></v>
<v t="ekr.20250122151620.2045"><vh>DecimalNumber._get_num_string</vh></v>
<v t="ekr.20250122151620.2046"><vh>DecimalNumber._string_to_mob</vh></v>
<v t="ekr.20250122151620.2047"><vh>DecimalNumber._get_formatter</vh></v>
<v t="ekr.20250122151620.2048"><vh>DecimalNumber._get_complex_formatter</vh></v>
<v t="ekr.20250122151620.2049"><vh>DecimalNumber.set_value</vh></v>
<v t="ekr.20250122151620.2050"><vh>DecimalNumber.get_value</vh></v>
<v t="ekr.20250122151620.2051"><vh>DecimalNumber.increment_value</vh></v>
</v>
<v t="ekr.20250122151620.2039"><vh>class Integer</vh>
<v t="ekr.20250122151620.2052"><vh>Integer.__init__</vh></v>
<v t="ekr.20250122151620.2053"><vh>Integer.get_value</vh></v>
</v>
<v t="ekr.20250122151620.2040"><vh>class Variable</vh>
<v t="ekr.20250122151620.2054"><vh>Variable.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.2055"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/text/tex_mobject.py</vh>
<v t="ekr.20250122151620.2056"><vh>class SingleStringMathTex</vh>
<v t="ekr.20250122151620.2061"><vh>SingleStringMathTex.__init__</vh></v>
<v t="ekr.20250122151620.2062"><vh>SingleStringMathTex.__repr__</vh></v>
<v t="ekr.20250122151620.2063"><vh>SingleStringMathTex.font_size</vh></v>
<v t="ekr.20250122151620.2064"><vh>SingleStringMathTex.font_size</vh></v>
<v t="ekr.20250122151620.2065"><vh>SingleStringMathTex._get_modified_expression</vh></v>
<v t="ekr.20250122151620.2066"><vh>SingleStringMathTex._modify_special_strings</vh></v>
<v t="ekr.20250122151620.2067"><vh>SingleStringMathTex._remove_stray_braces</vh></v>
<v t="ekr.20250122151620.2068"><vh>SingleStringMathTex._organize_submobjects_left_to_right</vh></v>
<v t="ekr.20250122151620.2069"><vh>SingleStringMathTex.get_tex_string</vh></v>
<v t="ekr.20250122151620.2070"><vh>SingleStringMathTex.init_colors</vh></v>
</v>
<v t="ekr.20250122151620.2057"><vh>class MathTex</vh>
<v t="ekr.20250122151620.2071"><vh>MathTex.__init__</vh></v>
<v t="ekr.20250122151620.2072"><vh>MathTex._break_up_tex_strings</vh></v>
<v t="ekr.20250122151620.2073"><vh>MathTex._break_up_by_substrings</vh></v>
<v t="ekr.20250122151620.2074"><vh>MathTex.get_parts_by_tex</vh></v>
<v t="ekr.20250122151620.2075"><vh>MathTex.get_part_by_tex</vh></v>
<v t="ekr.20250122151620.2076"><vh>MathTex.set_color_by_tex</vh></v>
<v t="ekr.20250122151620.2077"><vh>MathTex.set_opacity_by_tex</vh></v>
<v t="ekr.20250122151620.2078"><vh>MathTex.set_color_by_tex_to_color_map</vh></v>
<v t="ekr.20250122151620.2079"><vh>MathTex.index_of_part</vh></v>
<v t="ekr.20250122151620.2080"><vh>MathTex.index_of_part_by_tex</vh></v>
<v t="ekr.20250122151620.2081"><vh>MathTex.sort_alphabetically</vh></v>
</v>
<v t="ekr.20250122151620.2058"><vh>class Tex</vh>
<v t="ekr.20250122151620.2082"><vh>Tex.__init__</vh></v>
</v>
<v t="ekr.20250122151620.2059"><vh>class BulletedList</vh>
<v t="ekr.20250122151620.2083"><vh>BulletedList.__init__</vh></v>
<v t="ekr.20250122151620.2084"><vh>BulletedList.fade_all_but</vh></v>
</v>
<v t="ekr.20250122151620.2060"><vh>class Title</vh>
<v t="ekr.20250122151620.2085"><vh>Title.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151620.2086"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/text/text_mobject.py</vh>
<v t="ekr.20250122151620.2087"><vh>function: remove_invisible_chars</vh></v>
<v t="ekr.20250122151620.2088"><vh>class Paragraph</vh>
<v t="ekr.20250122151620.2092"><vh>Paragraph.__init__</vh></v>
<v t="ekr.20250122151620.2093"><vh>Paragraph._gen_chars</vh></v>
<v t="ekr.20250122151620.2094"><vh>Paragraph._set_all_lines_alignments</vh></v>
<v t="ekr.20250122151620.2095"><vh>Paragraph._set_line_alignment</vh></v>
<v t="ekr.20250122151620.2096"><vh>Paragraph._set_all_lines_to_initial_positions</vh></v>
<v t="ekr.20250122151620.2097"><vh>Paragraph._set_line_to_initial_position</vh></v>
<v t="ekr.20250122151620.2098"><vh>Paragraph._change_alignment_for_a_line</vh></v>
</v>
<v t="ekr.20250122151620.2089"><vh>class Text</vh>
<v t="ekr.20250122151620.2099"><vh>Text.font_list</vh></v>
<v t="ekr.20250122151620.2100"><vh>Text.__init__</vh></v>
<v t="ekr.20250122151620.2101"><vh>Text.__repr__</vh></v>
<v t="ekr.20250122151620.2102"><vh>Text.font_size</vh></v>
<v t="ekr.20250122151620.2103"><vh>Text.font_size</vh></v>
<v t="ekr.20250122151620.2104"><vh>Text._gen_chars</vh></v>
<v t="ekr.20250122151620.2105"><vh>Text._find_indexes</vh></v>
<v t="ekr.20250122151620.2106"><vh>Text._set_color_by_t2c</vh></v>
<v t="ekr.20250122151620.2107"><vh>Text._set_color_by_t2g</vh></v>
<v t="ekr.20250122151620.2108"><vh>Text._text2hash</vh></v>
<v t="ekr.20250122151620.2109"><vh>Text._merge_settings</vh></v>
<v t="ekr.20250122151620.2110"><vh>Text._get_settings_from_t2xs</vh></v>
<v t="ekr.20250122151620.2111"><vh>Text._get_settings_from_gradient</vh></v>
<v t="ekr.20250122151620.2112"><vh>Text._text2settings</vh></v>
<v t="ekr.20250122151620.2113"><vh>Text._text2svg</vh></v>
<v t="ekr.20250122151620.2114"><vh>Text.init_colors</vh></v>
</v>
<v t="ekr.20250122151620.2090"><vh>class MarkupText</vh>
<v t="ekr.20250122151620.2115"><vh>MarkupText.font_list</vh></v>
<v t="ekr.20250122151620.2116"><vh>MarkupText.__init__</vh></v>
<v t="ekr.20250122151620.2117"><vh>MarkupText.font_size</vh></v>
<v t="ekr.20250122151620.2118"><vh>MarkupText.font_size</vh></v>
<v t="ekr.20250122151620.2119"><vh>MarkupText._text2hash</vh></v>
<v t="ekr.20250122151620.2120"><vh>MarkupText._text2svg</vh></v>
<v t="ekr.20250122151620.2121"><vh>MarkupText._count_real_chars</vh></v>
<v t="ekr.20250122151620.2122"><vh>MarkupText._extract_gradient_tags</vh></v>
<v t="ekr.20250122151620.2123"><vh>MarkupText._parse_color</vh></v>
<v t="ekr.20250122151620.2124"><vh>MarkupText._extract_color_tags</vh></v>
<v t="ekr.20250122151620.2125"><vh>MarkupText.__repr__</vh></v>
</v>
<v t="ekr.20250122151620.2091"><vh>function: register_font</vh></v>
</v>
</v>
<v t="ekr.20250122151621.1"><vh>C:/Python/Python3.12/Lib/site-packages/manim/mobject/three_d</vh>
<v t="ekr.20250122151621.2"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/three_d/__init__.py</vh></v>
<v t="ekr.20250122151621.3"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/three_d/polyhedra.py</vh>
<v t="ekr.20250122151621.4"><vh>class Polyhedron</vh>
<v t="ekr.20250122151621.10"><vh>Polyhedron.__init__</vh></v>
<v t="ekr.20250122151621.11"><vh>Polyhedron.get_edges</vh></v>
<v t="ekr.20250122151621.12"><vh>Polyhedron.create_faces</vh></v>
<v t="ekr.20250122151621.13"><vh>Polyhedron.update_faces</vh></v>
<v t="ekr.20250122151621.14"><vh>Polyhedron.extract_face_coords</vh></v>
</v>
<v t="ekr.20250122151621.5"><vh>class Tetrahedron</vh>
<v t="ekr.20250122151621.15"><vh>Tetrahedron.__init__</vh></v>
</v>
<v t="ekr.20250122151621.6"><vh>class Octahedron</vh>
<v t="ekr.20250122151621.16"><vh>Octahedron.__init__</vh></v>
</v>
<v t="ekr.20250122151621.7"><vh>class Icosahedron</vh>
<v t="ekr.20250122151621.17"><vh>Icosahedron.__init__</vh></v>
</v>
<v t="ekr.20250122151621.8"><vh>class Dodecahedron</vh>
<v t="ekr.20250122151621.18"><vh>Dodecahedron.__init__</vh></v>
</v>
<v t="ekr.20250122151621.9"><vh>class ConvexHull3D</vh>
<v t="ekr.20250122151621.19"><vh>ConvexHull3D.__init__</vh></v>
</v>
</v>
<v t="ekr.20250122151621.20"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/three_d/three_d_utils.py</vh>
<v t="ekr.20250122151621.21"><vh>function: get_3d_vmob_gradient_start_and_end_points</vh></v>
<v t="ekr.20250122151621.22"><vh>function: get_3d_vmob_start_corner_index</vh></v>
<v t="ekr.20250122151621.23"><vh>function: get_3d_vmob_end_corner_index</vh></v>
<v t="ekr.20250122151621.24"><vh>function: get_3d_vmob_start_corner</vh></v>
<v t="ekr.20250122151621.25"><vh>function: get_3d_vmob_end_corner</vh></v>
<v t="ekr.20250122151621.26"><vh>function: get_3d_vmob_unit_normal</vh></v>
<v t="ekr.20250122151621.27"><vh>function: get_3d_vmob_start_corner_unit_normal</vh></v>
<v t="ekr.20250122151621.28"><vh>function: get_3d_vmob_end_corner_unit_normal</vh></v>
</v>
<v t="ekr.20250122151621.29"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/three_d/three_dimensions.py</vh>
<v t="ekr.20250122151621.30"><vh>class ThreeDVMobject</vh>
<v t="ekr.20250122151621.41"><vh>ThreeDVMobject.__init__</vh></v>
</v>
<v t="ekr.20250122151621.31"><vh>class Surface</vh>
<v t="ekr.20250122151621.42"><vh>Surface.__init__</vh></v>
<v t="ekr.20250122151621.43"><vh>Surface.func</vh></v>
<v t="ekr.20250122151621.44"><vh>Surface._get_u_values_and_v_values</vh></v>
<v t="ekr.20250122151621.45"><vh>Surface._setup_in_uv_space</vh></v>
<v t="ekr.20250122151621.46"><vh>Surface.set_fill_by_checkerboard</vh></v>
<v t="ekr.20250122151621.47"><vh>Surface.set_fill_by_value</vh></v>
</v>
<v t="ekr.20250122151621.32"><vh>class Sphere</vh>
<v t="ekr.20250122151621.48"><vh>Sphere.__init__</vh></v>
<v t="ekr.20250122151621.49"><vh>Sphere.func</vh></v>
</v>
<v t="ekr.20250122151621.33"><vh>class Dot3D</vh>
<v t="ekr.20250122151621.50"><vh>Dot3D.__init__</vh></v>
</v>
<v t="ekr.20250122151621.34"><vh>class Cube</vh>
<v t="ekr.20250122151621.51"><vh>Cube.__init__</vh></v>
<v t="ekr.20250122151621.52"><vh>Cube.generate_points</vh></v>
</v>
<v t="ekr.20250122151621.35"><vh>class Prism</vh>
<v t="ekr.20250122151621.53"><vh>Prism.__init__</vh></v>
<v t="ekr.20250122151621.54"><vh>Prism.generate_points</vh></v>
</v>
<v t="ekr.20250122151621.36"><vh>class Cone</vh>
<v t="ekr.20250122151621.55"><vh>Cone.__init__</vh></v>
<v t="ekr.20250122151621.56"><vh>Cone.func</vh></v>
<v t="ekr.20250122151621.57"><vh>Cone.get_start</vh></v>
<v t="ekr.20250122151621.58"><vh>Cone.get_end</vh></v>
<v t="ekr.20250122151621.59"><vh>Cone._rotate_to_direction</vh></v>
<v t="ekr.20250122151621.60"><vh>Cone.set_direction</vh></v>
<v t="ekr.20250122151621.61"><vh>Cone.get_direction</vh></v>
<v t="ekr.20250122151621.62"><vh>Cone._set_start_and_end_attributes</vh></v>
</v>
<v t="ekr.20250122151621.37"><vh>class Cylinder</vh>
<v t="ekr.20250122151621.63"><vh>Cylinder.__init__</vh></v>
<v t="ekr.20250122151621.64"><vh>Cylinder.func</vh></v>
<v t="ekr.20250122151621.65"><vh>Cylinder.add_bases</vh></v>
<v t="ekr.20250122151621.66"><vh>Cylinder._rotate_to_direction</vh></v>
<v t="ekr.20250122151621.67"><vh>Cylinder.set_direction</vh></v>
<v t="ekr.20250122151621.68"><vh>Cylinder.get_direction</vh></v>
</v>
<v t="ekr.20250122151621.38"><vh>class Line3D</vh>
<v t="ekr.20250122151621.69"><vh>Line3D.__init__</vh></v>
<v t="ekr.20250122151621.70"><vh>Line3D.set_start_and_end_attrs</vh></v>
<v t="ekr.20250122151621.71"><vh>Line3D.pointify</vh></v>
<v t="ekr.20250122151621.72"><vh>Line3D.get_start</vh></v>
<v t="ekr.20250122151621.73"><vh>Line3D.get_end</vh></v>
<v t="ekr.20250122151621.74"><vh>Line3D.parallel_to</vh></v>
<v t="ekr.20250122151621.75"><vh>Line3D.perpendicular_to</vh></v>
</v>
<v t="ekr.20250122151621.39"><vh>class Arrow3D</vh>
<v t="ekr.20250122151621.76"><vh>Arrow3D.__init__</vh></v>
<v t="ekr.20250122151621.77"><vh>Arrow3D.get_end</vh></v>
</v>
<v t="ekr.20250122151621.40"><vh>class Torus</vh>
<v t="ekr.20250122151621.78"><vh>Torus.__init__</vh></v>
<v t="ekr.20250122151621.79"><vh>Torus.func</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151621.80"><vh>C:/Python/Python3.12/Lib/site-packages/manim/mobject/types</vh>
<v t="ekr.20250122151621.81"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/types/__init__.py</vh></v>
<v t="ekr.20250122151621.82"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/types/image_mobject.py</vh>
<v t="ekr.20250122151621.83"><vh>class AbstractImageMobject</vh>
<v t="ekr.20250122151621.86"><vh>AbstractImageMobject.__init__</vh></v>
<v t="ekr.20250122151621.87"><vh>AbstractImageMobject.get_pixel_array</vh></v>
<v t="ekr.20250122151621.88"><vh>AbstractImageMobject.set_color</vh></v>
<v t="ekr.20250122151621.89"><vh>AbstractImageMobject.set_resampling_algorithm</vh></v>
<v t="ekr.20250122151621.90"><vh>AbstractImageMobject.reset_points</vh></v>
</v>
<v t="ekr.20250122151621.84"><vh>class ImageMobject</vh>
<v t="ekr.20250122151621.91"><vh>ImageMobject.__init__</vh></v>
<v t="ekr.20250122151621.92"><vh>ImageMobject.get_pixel_array</vh></v>
<v t="ekr.20250122151621.93"><vh>ImageMobject.set_color</vh></v>
<v t="ekr.20250122151621.94"><vh>ImageMobject.set_opacity</vh></v>
<v t="ekr.20250122151621.95"><vh>ImageMobject.fade</vh></v>
<v t="ekr.20250122151621.96"><vh>ImageMobject.interpolate_color</vh></v>
<v t="ekr.20250122151621.97"><vh>ImageMobject.get_style</vh></v>
</v>
<v t="ekr.20250122151621.85"><vh>class ImageMobjectFromCamera</vh>
<v t="ekr.20250122151621.98"><vh>ImageMobjectFromCamera.__init__</vh></v>
<v t="ekr.20250122151621.99"><vh>ImageMobjectFromCamera.get_pixel_array</vh></v>
<v t="ekr.20250122151621.100"><vh>ImageMobjectFromCamera.add_display_frame</vh></v>
<v t="ekr.20250122151621.101"><vh>ImageMobjectFromCamera.interpolate_color</vh></v>
</v>
</v>
<v t="ekr.20250122151621.102"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/types/point_cloud_mobject.py</vh>
<v t="ekr.20250122151621.103"><vh>class PMobject</vh>
<v t="ekr.20250122151621.109"><vh>PMobject.__init__</vh></v>
<v t="ekr.20250122151621.110"><vh>PMobject.reset_points</vh></v>
<v t="ekr.20250122151621.111"><vh>PMobject.get_array_attrs</vh></v>
<v t="ekr.20250122151621.112"><vh>PMobject.add_points</vh></v>
<v t="ekr.20250122151621.113"><vh>PMobject.set_color</vh></v>
<v t="ekr.20250122151621.114"><vh>PMobject.get_stroke_width</vh></v>
<v t="ekr.20250122151621.115"><vh>PMobject.set_stroke_width</vh></v>
<v t="ekr.20250122151621.116"><vh>PMobject.set_color_by_gradient</vh></v>
<v t="ekr.20250122151621.117"><vh>PMobject.set_colors_by_radial_gradient</vh></v>
<v t="ekr.20250122151621.118"><vh>PMobject.match_colors</vh></v>
<v t="ekr.20250122151621.119"><vh>PMobject.filter_out</vh></v>
<v t="ekr.20250122151621.120"><vh>PMobject.thin_out</vh></v>
<v t="ekr.20250122151621.121"><vh>PMobject.sort_points</vh></v>
<v t="ekr.20250122151621.122"><vh>PMobject.fade_to</vh></v>
<v t="ekr.20250122151621.123"><vh>PMobject.get_all_rgbas</vh></v>
<v t="ekr.20250122151621.124"><vh>PMobject.ingest_submobjects</vh></v>
<v t="ekr.20250122151621.125"><vh>PMobject.get_color</vh></v>
<v t="ekr.20250122151621.126"><vh>PMobject.point_from_proportion</vh></v>
<v t="ekr.20250122151621.127"><vh>PMobject.get_mobject_type_class</vh></v>
<v t="ekr.20250122151621.128"><vh>PMobject.align_points_with_larger</vh></v>
<v t="ekr.20250122151621.129"><vh>PMobject.get_point_mobject</vh></v>
<v t="ekr.20250122151621.130"><vh>PMobject.interpolate_color</vh></v>
<v t="ekr.20250122151621.131"><vh>PMobject.pointwise_become_partial</vh></v>
</v>
<v t="ekr.20250122151621.104"><vh>class Mobject1D</vh>
<v t="ekr.20250122151621.132"><vh>Mobject1D.__init__</vh></v>
<v t="ekr.20250122151621.133"><vh>Mobject1D.add_line</vh></v>
</v>
<v t="ekr.20250122151621.105"><vh>class Mobject2D</vh>
<v t="ekr.20250122151621.134"><vh>Mobject2D.__init__</vh></v>
</v>
<v t="ekr.20250122151621.106"><vh>class PGroup</vh>
<v t="ekr.20250122151621.135"><vh>PGroup.__init__</vh></v>
<v t="ekr.20250122151621.136"><vh>PGroup.fade_to</vh></v>
</v>
<v t="ekr.20250122151621.107"><vh>class PointCloudDot</vh>
<v t="ekr.20250122151621.137"><vh>PointCloudDot.__init__</vh></v>
<v t="ekr.20250122151621.138"><vh>PointCloudDot.init_points</vh></v>
<v t="ekr.20250122151621.139"><vh>PointCloudDot.generate_points</vh></v>
</v>
<v t="ekr.20250122151621.108"><vh>class Point</vh>
<v t="ekr.20250122151621.140"><vh>Point.__init__</vh></v>
<v t="ekr.20250122151621.141"><vh>Point.init_points</vh></v>
<v t="ekr.20250122151621.142"><vh>Point.generate_points</vh></v>
</v>
</v>
<v t="ekr.20250122151621.143"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/mobject/types/vectorized_mobject.py</vh>
<v t="ekr.20250122151621.144"><vh>class VMobject</vh>
<v t="ekr.20250122151621.150"><vh>VMobject.__init__</vh></v>
<v t="ekr.20250122151621.151"><vh>VMobject._assert_valid_submobjects</vh></v>
<v t="ekr.20250122151621.152"><vh>VMobject.n_points_per_curve</vh></v>
<v t="ekr.20250122151621.153"><vh>VMobject.get_group_class</vh></v>
<v t="ekr.20250122151621.154"><vh>VMobject.get_mobject_type_class</vh></v>
<v t="ekr.20250122151621.155"><vh>VMobject.init_colors</vh></v>
<v t="ekr.20250122151621.156"><vh>VMobject.generate_rgbas_array</vh></v>
<v t="ekr.20250122151621.157"><vh>VMobject.update_rgbas_array</vh></v>
<v t="ekr.20250122151621.158"><vh>VMobject.set_fill</vh></v>
<v t="ekr.20250122151621.159"><vh>VMobject.set_stroke</vh></v>
<v t="ekr.20250122151621.160"><vh>VMobject.set_cap_style</vh></v>
<v t="ekr.20250122151621.161"><vh>VMobject.set_background_stroke</vh></v>
<v t="ekr.20250122151621.162"><vh>VMobject.set_style</vh></v>
<v t="ekr.20250122151621.163"><vh>VMobject.get_style</vh></v>
<v t="ekr.20250122151621.164"><vh>VMobject.match_style</vh></v>
<v t="ekr.20250122151621.165"><vh>VMobject.set_color</vh></v>
<v t="ekr.20250122151621.166"><vh>VMobject.set_opacity</vh></v>
<v t="ekr.20250122151621.167"><vh>VMobject.scale</vh></v>
<v t="ekr.20250122151621.168"><vh>VMobject.fade</vh></v>
<v t="ekr.20250122151621.169"><vh>VMobject.get_fill_rgbas</vh></v>
<v t="ekr.20250122151621.170"><vh>VMobject.get_fill_color</vh></v>
<v t="ekr.20250122151621.171"><vh>VMobject.get_fill_opacity</vh></v>
<v t="ekr.20250122151621.172"><vh>VMobject.get_fill_colors</vh></v>
<v t="ekr.20250122151621.173"><vh>VMobject.get_fill_opacities</vh></v>
<v t="ekr.20250122151621.174"><vh>VMobject.get_stroke_rgbas</vh></v>
<v t="ekr.20250122151621.175"><vh>VMobject.get_stroke_color</vh></v>
<v t="ekr.20250122151621.176"><vh>VMobject.get_stroke_width</vh></v>
<v t="ekr.20250122151621.177"><vh>VMobject.get_stroke_opacity</vh></v>
<v t="ekr.20250122151621.178"><vh>VMobject.get_stroke_colors</vh></v>
<v t="ekr.20250122151621.179"><vh>VMobject.get_stroke_opacities</vh></v>
<v t="ekr.20250122151621.180"><vh>VMobject.get_color</vh></v>
<v t="ekr.20250122151621.181"><vh>VMobject.set_sheen_direction</vh></v>
<v t="ekr.20250122151621.182"><vh>VMobject.rotate_sheen_direction</vh></v>
<v t="ekr.20250122151621.183"><vh>VMobject.set_sheen</vh></v>
<v t="ekr.20250122151621.184"><vh>VMobject.get_sheen_direction</vh></v>
<v t="ekr.20250122151621.185"><vh>VMobject.get_sheen_factor</vh></v>
<v t="ekr.20250122151621.186"><vh>VMobject.get_gradient_start_and_end_points</vh></v>
<v t="ekr.20250122151621.187"><vh>VMobject.color_using_background_image</vh></v>
<v t="ekr.20250122151621.188"><vh>VMobject.get_background_image</vh></v>
<v t="ekr.20250122151621.189"><vh>VMobject.match_background_image</vh></v>
<v t="ekr.20250122151621.190"><vh>VMobject.set_shade_in_3d</vh></v>
<v t="ekr.20250122151621.191"><vh>VMobject.set_points</vh></v>
<v t="ekr.20250122151621.192"><vh>VMobject.resize_points</vh></v>
<v t="ekr.20250122151621.193"><vh>VMobject.set_anchors_and_handles</vh></v>
<v t="ekr.20250122151621.194"><vh>VMobject.clear_points</vh></v>
<v t="ekr.20250122151621.195"><vh>VMobject.append_points</vh></v>
<v t="ekr.20250122151621.196"><vh>VMobject.start_new_path</vh></v>
<v t="ekr.20250122151621.197"><vh>VMobject.add_cubic_bezier_curve</vh></v>
<v t="ekr.20250122151621.198"><vh>VMobject.add_cubic_bezier_curves</vh></v>
<v t="ekr.20250122151621.199"><vh>VMobject.add_cubic_bezier_curve_to</vh></v>
<v t="ekr.20250122151621.200"><vh>VMobject.add_quadratic_bezier_curve_to</vh></v>
<v t="ekr.20250122151621.201"><vh>VMobject.add_line_to</vh></v>
<v t="ekr.20250122151621.202"><vh>VMobject.add_smooth_curve_to</vh></v>
<v t="ekr.20250122151621.203"><vh>VMobject.has_new_path_started</vh></v>
<v t="ekr.20250122151621.204"><vh>VMobject.get_last_point</vh></v>
<v t="ekr.20250122151621.205"><vh>VMobject.is_closed</vh></v>
<v t="ekr.20250122151621.206"><vh>VMobject.close_path</vh></v>
<v t="ekr.20250122151621.207"><vh>VMobject.add_points_as_corners</vh></v>
<v t="ekr.20250122151621.208"><vh>VMobject.set_points_as_corners</vh></v>
<v t="ekr.20250122151621.209"><vh>VMobject.set_points_smoothly</vh></v>
<v t="ekr.20250122151621.210"><vh>VMobject.change_anchor_mode</vh></v>
<v t="ekr.20250122151621.211"><vh>VMobject.make_smooth</vh></v>
<v t="ekr.20250122151621.212"><vh>VMobject.make_jagged</vh></v>
<v t="ekr.20250122151621.213"><vh>VMobject.add_subpath</vh></v>
<v t="ekr.20250122151621.214"><vh>VMobject.append_vectorized_mobject</vh></v>
<v t="ekr.20250122151621.215"><vh>VMobject.apply_function</vh></v>
<v t="ekr.20250122151621.216"><vh>VMobject.rotate</vh></v>
<v t="ekr.20250122151621.217"><vh>VMobject.scale_handle_to_anchor_distances</vh></v>
<v t="ekr.20250122151621.218"><vh>VMobject.consider_points_equals</vh></v>
<v t="ekr.20250122151621.219"><vh>VMobject.consider_points_equals_2d</vh></v>
<v t="ekr.20250122151621.220"><vh>VMobject.get_cubic_bezier_tuples_from_points</vh></v>
<v t="ekr.20250122151621.221"><vh>VMobject.gen_cubic_bezier_tuples_from_points</vh></v>
<v t="ekr.20250122151621.222"><vh>VMobject.get_cubic_bezier_tuples</vh></v>
<v t="ekr.20250122151621.223"><vh>VMobject._gen_subpaths_from_points</vh></v>
<v t="ekr.20250122151621.224"><vh>VMobject.get_subpaths_from_points</vh></v>
<v t="ekr.20250122151621.225"><vh>VMobject.gen_subpaths_from_points_2d</vh></v>
<v t="ekr.20250122151621.226"><vh>VMobject.get_subpaths</vh></v>
<v t="ekr.20250122151621.227"><vh>VMobject.get_nth_curve_points</vh></v>
<v t="ekr.20250122151621.228"><vh>VMobject.get_nth_curve_function</vh></v>
<v t="ekr.20250122151621.229"><vh>VMobject.get_nth_curve_length_pieces</vh></v>
<v t="ekr.20250122151621.230"><vh>VMobject.get_nth_curve_length</vh></v>
<v t="ekr.20250122151621.231"><vh>VMobject.get_nth_curve_function_with_length</vh></v>
<v t="ekr.20250122151621.232"><vh>VMobject.get_num_curves</vh></v>
<v t="ekr.20250122151621.233"><vh>VMobject.get_curve_functions</vh></v>
<v t="ekr.20250122151621.234"><vh>VMobject.get_curve_functions_with_lengths</vh></v>
<v t="ekr.20250122151621.235"><vh>VMobject.point_from_proportion</vh></v>
<v t="ekr.20250122151621.236"><vh>VMobject.proportion_from_point</vh></v>
<v t="ekr.20250122151621.237"><vh>VMobject.get_anchors_and_handles</vh></v>
<v t="ekr.20250122151621.238"><vh>VMobject.get_start_anchors</vh></v>
<v t="ekr.20250122151621.239"><vh>VMobject.get_end_anchors</vh></v>
<v t="ekr.20250122151621.240"><vh>VMobject.get_anchors</vh></v>
<v t="ekr.20250122151621.241"><vh>VMobject.get_points_defining_boundary</vh></v>
<v t="ekr.20250122151621.242"><vh>VMobject.get_arc_length</vh></v>
<v t="ekr.20250122151621.243"><vh>VMobject.align_points</vh></v>
<v t="ekr.20250122151621.244"><vh>VMobject.insert_n_curves</vh></v>
<v t="ekr.20250122151621.245"><vh>VMobject.insert_n_curves_to_point_list</vh></v>
<v t="ekr.20250122151621.246"><vh>VMobject.align_rgbas</vh></v>
<v t="ekr.20250122151621.247"><vh>VMobject.get_point_mobject</vh></v>
<v t="ekr.20250122151621.248"><vh>VMobject.interpolate_color</vh></v>
<v t="ekr.20250122151621.249"><vh>VMobject.pointwise_become_partial</vh></v>
<v t="ekr.20250122151621.250"><vh>VMobject.get_subcurve</vh></v>
<v t="ekr.20250122151621.251"><vh>VMobject.get_direction</vh></v>
<v t="ekr.20250122151621.252"><vh>VMobject.reverse_direction</vh></v>
<v t="ekr.20250122151621.253"><vh>VMobject.force_direction</vh></v>
</v>
<v t="ekr.20250122151621.145"><vh>class VGroup</vh>
<v t="ekr.20250122151621.254"><vh>VGroup.__init__</vh></v>
<v t="ekr.20250122151621.255"><vh>VGroup.__repr__</vh></v>
<v t="ekr.20250122151621.256"><vh>VGroup.__str__</vh></v>
<v t="ekr.20250122151621.257"><vh>VGroup.add</vh></v>
<v t="ekr.20250122151621.258"><vh>VGroup.__add__</vh></v>
<v t="ekr.20250122151621.259"><vh>VGroup.__iadd__</vh></v>
<v t="ekr.20250122151621.260"><vh>VGroup.__sub__</vh></v>
<v t="ekr.20250122151621.261"><vh>VGroup.__isub__</vh></v>
<v t="ekr.20250122151621.262"><vh>VGroup.__setitem__</vh></v>
</v>
<v t="ekr.20250122151621.146"><vh>class VDict</vh>
<v t="ekr.20250122151621.263"><vh>VDict.__init__</vh></v>
<v t="ekr.20250122151621.264"><vh>VDict.__repr__</vh></v>
<v t="ekr.20250122151621.265"><vh>VDict.add</vh></v>
<v t="ekr.20250122151621.266"><vh>VDict.remove</vh></v>
<v t="ekr.20250122151621.267"><vh>VDict.__getitem__</vh></v>
<v t="ekr.20250122151621.268"><vh>VDict.__setitem__</vh></v>
<v t="ekr.20250122151621.269"><vh>VDict.__delitem__</vh></v>
<v t="ekr.20250122151621.270"><vh>VDict.__contains__</vh></v>
<v t="ekr.20250122151621.271"><vh>VDict.get_all_submobjects</vh></v>
<v t="ekr.20250122151621.272"><vh>VDict.add_key_value_pair</vh></v>
</v>
<v t="ekr.20250122151621.147"><vh>class VectorizedPoint</vh>
<v t="ekr.20250122151621.273"><vh>VectorizedPoint.__init__</vh></v>
<v t="ekr.20250122151621.274"><vh>VectorizedPoint.width</vh></v>
<v t="ekr.20250122151621.275"><vh>VectorizedPoint.height</vh></v>
<v t="ekr.20250122151621.276"><vh>VectorizedPoint.get_location</vh></v>
<v t="ekr.20250122151621.277"><vh>VectorizedPoint.set_location</vh></v>
</v>
<v t="ekr.20250122151621.148"><vh>class CurvesAsSubmobjects</vh>
<v t="ekr.20250122151621.278"><vh>CurvesAsSubmobjects.__init__</vh></v>
<v t="ekr.20250122151621.279"><vh>CurvesAsSubmobjects.point_from_proportion</vh></v>
<v t="ekr.20250122151621.280"><vh>CurvesAsSubmobjects._throw_error_if_no_submobjects</vh></v>
<v t="ekr.20250122151621.281"><vh>CurvesAsSubmobjects._get_submobjects_with_points</vh></v>
</v>
<v t="ekr.20250122151621.149"><vh>class DashedVMobject</vh>
<v t="ekr.20250122151621.282"><vh>DashedVMobject.__init__</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20250122151621.283"><vh>manim/opengl</vh>
<v t="ekr.20250122151621.284"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/opengl/__init__.py</vh></v>
</v>
<v t="ekr.20250122151621.285"><vh>manim/plugins</vh>
<v t="ekr.20250122151621.286"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/plugins/__init__.py</vh></v>
<v t="ekr.20250122151621.287"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/plugins/plugins_flags.py</vh>
<v t="ekr.20250122151621.288"><vh>function: get_plugins</vh></v>
<v t="ekr.20250122151621.289"><vh>function: list_plugins</vh></v>
</v>
</v>
<v t="ekr.20250122151621.290"><vh>manim/renderer</vh>
<v t="ekr.20250122151621.291"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/renderer/__init__.py</vh></v>
<v t="ekr.20250122151621.292"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/renderer/cairo_renderer.py</vh>
<v t="ekr.20250122151621.293"><vh>class CairoRenderer</vh>
<v t="ekr.20250122151621.294"><vh>CairoRenderer.__init__</vh></v>
<v t="ekr.20250122151621.295"><vh>CairoRenderer.init_scene</vh></v>
<v t="ekr.20250122151621.296"><vh>CairoRenderer.play</vh></v>
<v t="ekr.20250122151621.297"><vh>CairoRenderer.update_frame</vh></v>
<v t="ekr.20250122151621.298"><vh>CairoRenderer.render</vh></v>
<v t="ekr.20250122151621.299"><vh>CairoRenderer.get_frame</vh></v>
<v t="ekr.20250122151621.300"><vh>CairoRenderer.add_frame</vh></v>
<v t="ekr.20250122151621.301"><vh>CairoRenderer.freeze_current_frame</vh></v>
<v t="ekr.20250122151621.302"><vh>CairoRenderer.show_frame</vh></v>
<v t="ekr.20250122151621.303"><vh>CairoRenderer.save_static_frame_data</vh></v>
<v t="ekr.20250122151621.304"><vh>CairoRenderer.update_skipping_status</vh></v>
<v t="ekr.20250122151621.305"><vh>CairoRenderer.scene_finished</vh></v>
</v>
</v>
<v t="ekr.20250122151621.306"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/renderer/opengl_renderer.py</vh>
<v t="ekr.20250122151621.307"><vh>class OpenGLCamera</vh>
<v t="ekr.20250122151621.309"><vh>OpenGLCamera.__init__</vh></v>
<v t="ekr.20250122151621.310"><vh>OpenGLCamera.get_position</vh></v>
<v t="ekr.20250122151621.311"><vh>OpenGLCamera.set_position</vh></v>
<v t="ekr.20250122151621.312"><vh>OpenGLCamera.formatted_view_matrix</vh></v>
<v t="ekr.20250122151621.313"><vh>OpenGLCamera.unformatted_view_matrix</vh></v>
<v t="ekr.20250122151621.314"><vh>OpenGLCamera.init_points</vh></v>
<v t="ekr.20250122151621.315"><vh>OpenGLCamera.to_default_state</vh></v>
<v t="ekr.20250122151621.316"><vh>OpenGLCamera.refresh_rotation_matrix</vh></v>
<v t="ekr.20250122151621.317"><vh>OpenGLCamera.rotate</vh></v>
<v t="ekr.20250122151621.318"><vh>OpenGLCamera.set_euler_angles</vh></v>
<v t="ekr.20250122151621.319"><vh>OpenGLCamera.set_theta</vh></v>
<v t="ekr.20250122151621.320"><vh>OpenGLCamera.set_phi</vh></v>
<v t="ekr.20250122151621.321"><vh>OpenGLCamera.set_gamma</vh></v>
<v t="ekr.20250122151621.322"><vh>OpenGLCamera.increment_theta</vh></v>
<v t="ekr.20250122151621.323"><vh>OpenGLCamera.increment_phi</vh></v>
<v t="ekr.20250122151621.324"><vh>OpenGLCamera.increment_gamma</vh></v>
<v t="ekr.20250122151621.325"><vh>OpenGLCamera.get_shape</vh></v>
<v t="ekr.20250122151621.326"><vh>OpenGLCamera.get_center</vh></v>
<v t="ekr.20250122151621.327"><vh>OpenGLCamera.get_width</vh></v>
<v t="ekr.20250122151621.328"><vh>OpenGLCamera.get_height</vh></v>
<v t="ekr.20250122151621.329"><vh>OpenGLCamera.get_focal_distance</vh></v>
<v t="ekr.20250122151621.330"><vh>OpenGLCamera.interpolate</vh></v>
</v>
<v t="ekr.20250122151621.308"><vh>class OpenGLRenderer</vh>
<v t="ekr.20250122151621.331"><vh>OpenGLRenderer.__init__</vh></v>
<v t="ekr.20250122151621.332"><vh>OpenGLRenderer.init_scene</vh></v>
<v t="ekr.20250122151621.333"><vh>OpenGLRenderer.should_create_window</vh></v>
<v t="ekr.20250122151621.334"><vh>OpenGLRenderer.get_pixel_shape</vh></v>
<v t="ekr.20250122151621.335"><vh>OpenGLRenderer.refresh_perspective_uniforms</vh></v>
<v t="ekr.20250122151621.336"><vh>OpenGLRenderer.render_mobject</vh></v>
<v t="ekr.20250122151621.337"><vh>OpenGLRenderer.get_texture_id</vh></v>
<v t="ekr.20250122151621.338"><vh>OpenGLRenderer.update_skipping_status</vh></v>
<v t="ekr.20250122151621.339"><vh>OpenGLRenderer.play</vh></v>
<v t="ekr.20250122151621.340"><vh>OpenGLRenderer.clear_screen</vh></v>
<v t="ekr.20250122151621.341"><vh>OpenGLRenderer.render</vh></v>
<v t="ekr.20250122151621.342"><vh>OpenGLRenderer.update_frame</vh></v>
<v t="ekr.20250122151621.343"><vh>OpenGLRenderer.scene_finished</vh></v>
<v t="ekr.20250122151621.344"><vh>OpenGLRenderer.should_save_last_frame</vh></v>
<v t="ekr.20250122151621.345"><vh>OpenGLRenderer.get_image</vh></v>
<v t="ekr.20250122151621.346"><vh>OpenGLRenderer.save_static_frame_data</vh></v>
<v t="ekr.20250122151621.347"><vh>OpenGLRenderer.get_frame_buffer_object</vh></v>
<v t="ekr.20250122151621.348"><vh>OpenGLRenderer.get_raw_frame_buffer_object_data</vh></v>
<v t="ekr.20250122151621.349"><vh>OpenGLRenderer.get_frame</vh></v>
<v t="ekr.20250122151621.350"><vh>OpenGLRenderer.pixel_coords_to_space_coords</vh></v>
<v t="ekr.20250122151621.351"><vh>OpenGLRenderer.background_color</vh></v>
<v t="ekr.20250122151621.352"><vh>OpenGLRenderer.background_color</vh></v>
</v>
</v>
<v t="ekr.20250122151621.353"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/renderer/opengl_renderer_window.py</vh>
<v t="ekr.20250122151621.354"><vh>class Window</vh>
<v t="ekr.20250122151621.355"><vh>Window.__init__</vh></v>
<v t="ekr.20250122151621.356"><vh>Window.on_mouse_motion</vh></v>
<v t="ekr.20250122151621.357"><vh>Window.on_mouse_scroll</vh></v>
<v t="ekr.20250122151621.358"><vh>Window.on_key_press</vh></v>
<v t="ekr.20250122151621.359"><vh>Window.on_key_release</vh></v>
<v t="ekr.20250122151621.360"><vh>Window.on_mouse_drag</vh></v>
<v t="ekr.20250122151621.361"><vh>Window.find_initial_position</vh></v>
<v t="ekr.20250122151621.362"><vh>Window.on_mouse_press</vh></v>
</v>
</v>
<v t="ekr.20250122151621.363"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/renderer/shader.py</vh>
<v t="ekr.20250122151621.364"><vh>function: get_shader_code_from_file</vh></v>
<v t="ekr.20250122151621.365"><vh>function: filter_attributes</vh></v>
<v t="ekr.20250122151621.366"><vh>class Object3D</vh>
<v t="ekr.20250122151621.370"><vh>Object3D.__init__</vh></v>
<v t="ekr.20250122151621.371"><vh>Object3D.interpolate</vh></v>
<v t="ekr.20250122151621.372"><vh>Object3D.single_copy</vh></v>
<v t="ekr.20250122151621.373"><vh>Object3D.copy</vh></v>
<v t="ekr.20250122151621.374"><vh>Object3D.add</vh></v>
<v t="ekr.20250122151621.375"><vh>Object3D.remove</vh></v>
<v t="ekr.20250122151621.376"><vh>Object3D.get_position</vh></v>
<v t="ekr.20250122151621.377"><vh>Object3D.set_position</vh></v>
<v t="ekr.20250122151621.378"><vh>Object3D.get_meshes</vh></v>
<v t="ekr.20250122151621.379"><vh>Object3D.get_family</vh></v>
<v t="ekr.20250122151621.380"><vh>Object3D.align_data_and_family</vh></v>
<v t="ekr.20250122151621.381"><vh>Object3D.hierarchical_model_matrix</vh></v>
<v t="ekr.20250122151621.382"><vh>Object3D.hierarchical_normal_matrix</vh></v>
<v t="ekr.20250122151621.383"><vh>Object3D.init_updaters</vh></v>
<v t="ekr.20250122151621.384"><vh>Object3D.update</vh></v>
<v t="ekr.20250122151621.385"><vh>Object3D.get_time_based_updaters</vh></v>
<v t="ekr.20250122151621.386"><vh>Object3D.has_time_based_updater</vh></v>
<v t="ekr.20250122151621.387"><vh>Object3D.get_updaters</vh></v>
<v t="ekr.20250122151621.388"><vh>Object3D.add_updater</vh></v>
<v t="ekr.20250122151621.389"><vh>Object3D.remove_updater</vh></v>
<v t="ekr.20250122151621.390"><vh>Object3D.clear_updaters</vh></v>
<v t="ekr.20250122151621.391"><vh>Object3D.match_updaters</vh></v>
<v t="ekr.20250122151621.392"><vh>Object3D.suspend_updating</vh></v>
<v t="ekr.20250122151621.393"><vh>Object3D.resume_updating</vh></v>
<v t="ekr.20250122151621.394"><vh>Object3D.refresh_has_updater_status</vh></v>
</v>
<v t="ekr.20250122151621.367"><vh>class Mesh</vh>
<v t="ekr.20250122151621.395"><vh>Mesh.__init__</vh></v>
<v t="ekr.20250122151621.396"><vh>Mesh.single_copy</vh></v>
<v t="ekr.20250122151621.397"><vh>Mesh.set_uniforms</vh></v>
<v t="ekr.20250122151621.398"><vh>Mesh.render</vh></v>
</v>
<v t="ekr.20250122151621.368"><vh>class Shader</vh>
<v t="ekr.20250122151621.399"><vh>Shader.__init__</vh></v>
<v t="ekr.20250122151621.400"><vh>Shader.set_uniform</vh></v>
</v>
<v t="ekr.20250122151621.369"><vh>class FullScreenQuad</vh>
<v t="ekr.20250122151621.401"><vh>FullScreenQuad.__init__</vh></v>
<v t="ekr.20250122151621.402"><vh>FullScreenQuad.render</vh></v>
</v>
</v>
<v t="ekr.20250122151621.403"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/renderer/shader_wrapper.py</vh>
<v t="ekr.20250122151621.404"><vh>function: get_shader_dir</vh></v>
<v t="ekr.20250122151621.405"><vh>function: find_file</vh></v>
<v t="ekr.20250122151621.406"><vh>class ShaderWrapper</vh>
<v t="ekr.20250122151621.409"><vh>ShaderWrapper.__init__</vh></v>
<v t="ekr.20250122151621.410"><vh>ShaderWrapper.copy</vh></v>
<v t="ekr.20250122151621.411"><vh>ShaderWrapper.is_valid</vh></v>
<v t="ekr.20250122151621.412"><vh>ShaderWrapper.get_id</vh></v>
<v t="ekr.20250122151621.413"><vh>ShaderWrapper.get_program_id</vh></v>
<v t="ekr.20250122151621.414"><vh>ShaderWrapper.create_id</vh></v>
<v t="ekr.20250122151621.415"><vh>ShaderWrapper.refresh_id</vh></v>
<v t="ekr.20250122151621.416"><vh>ShaderWrapper.create_program_id</vh></v>
<v t="ekr.20250122151621.417"><vh>ShaderWrapper.init_program_code</vh></v>
<v t="ekr.20250122151621.418"><vh>ShaderWrapper.get_program_code</vh></v>
<v t="ekr.20250122151621.419"><vh>ShaderWrapper.replace_code</vh></v>
<v t="ekr.20250122151621.420"><vh>ShaderWrapper.combine_with</vh></v>
</v>
<v t="ekr.20250122151621.407"><vh>function: get_shader_code_from_file</vh></v>
<v t="ekr.20250122151621.408"><vh>function: get_colormap_code</vh></v>
</v>
<v t="ekr.20250122151621.421"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/renderer/vectorized_mobject_rendering.py</vh>
<v t="ekr.20250122151621.422"><vh>function: build_matrix_lists</vh></v>
<v t="ekr.20250122151621.423"><vh>function: render_opengl_vectorized_mobject_fill</vh></v>
<v t="ekr.20250122151621.424"><vh>function: render_mobject_fills_with_matrix</vh></v>
<v t="ekr.20250122151621.425"><vh>function: triangulate_mobject</vh></v>
<v t="ekr.20250122151621.426"><vh>function: render_opengl_vectorized_mobject_stroke</vh></v>
<v t="ekr.20250122151621.427"><vh>function: render_mobject_strokes_with_matrix</vh></v>
</v>
</v>
<v t="ekr.20250122151621.429"><vh>manim/scene</vh>
<v t="ekr.20250122151621.430"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/scene/__init__.py</vh></v>
<v t="ekr.20250122151621.431"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/scene/moving_camera_scene.py</vh>
<v t="ekr.20250122151621.432"><vh>class MovingCameraScene</vh>
<v t="ekr.20250122151621.433"><vh>MovingCameraScene.__init__</vh></v>
<v t="ekr.20250122151621.434"><vh>MovingCameraScene.get_moving_mobjects</vh></v>
</v>
</v>
<v t="ekr.20250122151621.435"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/scene/scene.py</vh>
<v t="ekr.20250122151621.436"><vh>class RerunSceneHandler</vh>
<v t="ekr.20250122151621.438"><vh>RerunSceneHandler.__init__</vh></v>
<v t="ekr.20250122151621.439"><vh>RerunSceneHandler.on_modified</vh></v>
</v>
<v t="ekr.20250122151621.437"><vh>class Scene</vh>
<v t="ekr.20250122151621.440"><vh>Scene.__init__</vh></v>
<v t="ekr.20250122151621.441"><vh>Scene.camera</vh></v>
<v t="ekr.20250122151621.442"><vh>Scene.time</vh></v>
<v t="ekr.20250122151621.443"><vh>Scene.__deepcopy__</vh></v>
<v t="ekr.20250122151621.444"><vh>Scene.render</vh></v>
<v t="ekr.20250122151621.445"><vh>Scene.setup</vh></v>
<v t="ekr.20250122151621.446"><vh>Scene.tear_down</vh></v>
<v t="ekr.20250122151621.447"><vh>Scene.construct</vh></v>
<v t="ekr.20250122151621.448"><vh>Scene.next_section</vh></v>
<v t="ekr.20250122151621.449"><vh>Scene.__str__</vh></v>
<v t="ekr.20250122151621.450"><vh>Scene.get_attrs</vh></v>
<v t="ekr.20250122151621.451"><vh>Scene.update_mobjects</vh></v>
<v t="ekr.20250122151621.452"><vh>Scene.update_meshes</vh></v>
<v t="ekr.20250122151621.453"><vh>Scene.update_self</vh></v>
<v t="ekr.20250122151621.454"><vh>Scene.should_update_mobjects</vh></v>
<v t="ekr.20250122151621.455"><vh>Scene.get_top_level_mobjects</vh></v>
<v t="ekr.20250122151621.456"><vh>Scene.get_mobject_family_members</vh></v>
<v t="ekr.20250122151621.457"><vh>Scene.add</vh></v>
<v t="ekr.20250122151621.458"><vh>Scene.add_mobjects_from_animations</vh></v>
<v t="ekr.20250122151621.459"><vh>Scene.remove</vh></v>
<v t="ekr.20250122151621.460"><vh>Scene.replace</vh></v>
<v t="ekr.20250122151621.461"><vh>Scene.add_updater</vh></v>
<v t="ekr.20250122151621.462"><vh>Scene.remove_updater</vh></v>
<v t="ekr.20250122151621.463"><vh>Scene.restructure_mobjects</vh></v>
<v t="ekr.20250122151621.464"><vh>Scene.get_restructured_mobject_list</vh></v>
<v t="ekr.20250122151621.465"><vh>Scene.add_foreground_mobjects</vh></v>
<v t="ekr.20250122151621.466"><vh>Scene.add_foreground_mobject</vh></v>
<v t="ekr.20250122151621.467"><vh>Scene.remove_foreground_mobjects</vh></v>
<v t="ekr.20250122151621.468"><vh>Scene.remove_foreground_mobject</vh></v>
<v t="ekr.20250122151621.469"><vh>Scene.bring_to_front</vh></v>
<v t="ekr.20250122151621.470"><vh>Scene.bring_to_back</vh></v>
<v t="ekr.20250122151621.471"><vh>Scene.clear</vh></v>
<v t="ekr.20250122151621.472"><vh>Scene.get_moving_mobjects</vh></v>
<v t="ekr.20250122151621.473"><vh>Scene.get_moving_and_static_mobjects</vh></v>
<v t="ekr.20250122151621.474"><vh>Scene.compile_animations</vh></v>
<v t="ekr.20250122151621.475"><vh>Scene._get_animation_time_progression</vh></v>
<v t="ekr.20250122151621.476"><vh>Scene.get_time_progression</vh></v>
<v t="ekr.20250122151621.477"><vh>Scene.validate_run_time</vh></v>
<v t="ekr.20250122151621.478"><vh>Scene.get_run_time</vh></v>
<v t="ekr.20250122151621.479"><vh>Scene.play</vh></v>
<v t="ekr.20250122151621.480"><vh>Scene.wait</vh></v>
<v t="ekr.20250122151621.481"><vh>Scene.pause</vh></v>
<v t="ekr.20250122151621.482"><vh>Scene.wait_until</vh></v>
<v t="ekr.20250122151621.483"><vh>Scene.compile_animation_data</vh></v>
<v t="ekr.20250122151621.484"><vh>Scene.begin_animations</vh></v>
<v t="ekr.20250122151621.485"><vh>Scene.is_current_animation_frozen_frame</vh></v>
<v t="ekr.20250122151621.486"><vh>Scene.play_internal</vh></v>
<v t="ekr.20250122151621.487"><vh>Scene.check_interactive_embed_is_valid</vh></v>
<v t="ekr.20250122151621.488"><vh>Scene.interactive_embed</vh></v>
<v t="ekr.20250122151621.489"><vh>Scene.interact</vh></v>
<v t="ekr.20250122151621.490"><vh>Scene.embed</vh></v>
<v t="ekr.20250122151621.491"><vh>Scene.update_to_time</vh></v>
<v t="ekr.20250122151621.492"><vh>Scene.add_subcaption</vh></v>
<v t="ekr.20250122151621.493"><vh>Scene.add_sound</vh></v>
<v t="ekr.20250122151621.494"><vh>Scene.on_mouse_motion</vh></v>
<v t="ekr.20250122151621.495"><vh>Scene.on_mouse_scroll</vh></v>
<v t="ekr.20250122151621.496"><vh>Scene.on_key_press</vh></v>
<v t="ekr.20250122151621.497"><vh>Scene.on_key_release</vh></v>
<v t="ekr.20250122151621.498"><vh>Scene.on_mouse_drag</vh></v>
<v t="ekr.20250122151621.499"><vh>Scene.mouse_scroll_orbit_controls</vh></v>
<v t="ekr.20250122151621.500"><vh>Scene.mouse_drag_orbit_controls</vh></v>
<v t="ekr.20250122151621.501"><vh>Scene.set_key_function</vh></v>
<v t="ekr.20250122151621.502"><vh>Scene.on_mouse_press</vh></v>
</v>
</v>
<v t="ekr.20250122151621.503"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/scene/scene_file_writer.py</vh>
<v t="ekr.20250122151621.504"><vh>function: to_av_frame_rate</vh></v>
<v t="ekr.20250122151621.505"><vh>function: convert_audio</vh></v>
<v t="ekr.20250122151621.506"><vh>class SceneFileWriter</vh>
<v t="ekr.20250122151621.507"><vh>SceneFileWriter.__init__</vh></v>
<v t="ekr.20250122151621.508"><vh>SceneFileWriter.init_output_directories</vh></v>
<v t="ekr.20250122151621.509"><vh>SceneFileWriter.finish_last_section</vh></v>
<v t="ekr.20250122151621.510"><vh>SceneFileWriter.next_section</vh></v>
<v t="ekr.20250122151621.511"><vh>SceneFileWriter.add_partial_movie_file</vh></v>
<v t="ekr.20250122151621.512"><vh>SceneFileWriter.get_resolution_directory</vh></v>
<v t="ekr.20250122151621.513"><vh>SceneFileWriter.init_audio</vh></v>
<v t="ekr.20250122151621.514"><vh>SceneFileWriter.create_audio_segment</vh></v>
<v t="ekr.20250122151621.515"><vh>SceneFileWriter.add_audio_segment</vh></v>
<v t="ekr.20250122151621.516"><vh>SceneFileWriter.add_sound</vh></v>
<v t="ekr.20250122151621.517"><vh>SceneFileWriter.begin_animation</vh></v>
<v t="ekr.20250122151621.518"><vh>SceneFileWriter.end_animation</vh></v>
<v t="ekr.20250122151621.519"><vh>SceneFileWriter.listen_and_write</vh></v>
<v t="ekr.20250122151621.520"><vh>SceneFileWriter.encode_and_write_frame</vh></v>
<v t="ekr.20250122151621.521"><vh>SceneFileWriter.write_frame</vh></v>
<v t="ekr.20250122151621.522"><vh>SceneFileWriter.output_image</vh></v>
<v t="ekr.20250122151621.523"><vh>SceneFileWriter.save_final_image</vh></v>
<v t="ekr.20250122151621.524"><vh>SceneFileWriter.finish</vh></v>
<v t="ekr.20250122151621.525"><vh>SceneFileWriter.open_partial_movie_stream</vh></v>
<v t="ekr.20250122151621.526"><vh>SceneFileWriter.close_partial_movie_stream</vh></v>
<v t="ekr.20250122151621.527"><vh>SceneFileWriter.is_already_cached</vh></v>
<v t="ekr.20250122151621.528"><vh>SceneFileWriter.combine_files</vh></v>
<v t="ekr.20250122151621.529"><vh>SceneFileWriter.combine_to_movie</vh></v>
<v t="ekr.20250122151621.530"><vh>SceneFileWriter.combine_to_section_videos</vh></v>
<v t="ekr.20250122151621.531"><vh>SceneFileWriter.clean_cache</vh></v>
<v t="ekr.20250122151621.532"><vh>SceneFileWriter.flush_cache_directory</vh></v>
<v t="ekr.20250122151621.533"><vh>SceneFileWriter.write_subcaption_file</vh></v>
<v t="ekr.20250122151621.534"><vh>SceneFileWriter.print_file_ready_message</vh></v>
</v>
</v>
<v t="ekr.20250122151621.535"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/scene/section.py</vh>
<v t="ekr.20250122151621.536"><vh>class DefaultSectionType</vh></v>
<v t="ekr.20250122151621.537"><vh>class Section</vh>
<v t="ekr.20250122151621.538"><vh>Section.__init__</vh></v>
<v t="ekr.20250122151621.539"><vh>Section.is_empty</vh></v>
<v t="ekr.20250122151621.540"><vh>Section.get_clean_partial_movie_files</vh></v>
<v t="ekr.20250122151621.541"><vh>Section.get_dict</vh></v>
<v t="ekr.20250122151621.542"><vh>Section.__repr__</vh></v>
</v>
</v>
<v t="ekr.20250122151621.543"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/scene/three_d_scene.py</vh>
<v t="ekr.20250122151621.544"><vh>class ThreeDScene</vh>
<v t="ekr.20250122151621.546"><vh>ThreeDScene.__init__</vh></v>
<v t="ekr.20250122151621.547"><vh>ThreeDScene.set_camera_orientation</vh></v>
<v t="ekr.20250122151621.548"><vh>ThreeDScene.begin_ambient_camera_rotation</vh></v>
<v t="ekr.20250122151621.549"><vh>ThreeDScene.stop_ambient_camera_rotation</vh></v>
<v t="ekr.20250122151621.550"><vh>ThreeDScene.begin_3dillusion_camera_rotation</vh></v>
<v t="ekr.20250122151621.551"><vh>ThreeDScene.stop_3dillusion_camera_rotation</vh></v>
<v t="ekr.20250122151621.552"><vh>ThreeDScene.move_camera</vh></v>
<v t="ekr.20250122151621.553"><vh>ThreeDScene.get_moving_mobjects</vh></v>
<v t="ekr.20250122151621.554"><vh>ThreeDScene.add_fixed_orientation_mobjects</vh></v>
<v t="ekr.20250122151621.555"><vh>ThreeDScene.add_fixed_in_frame_mobjects</vh></v>
<v t="ekr.20250122151621.556"><vh>ThreeDScene.remove_fixed_orientation_mobjects</vh></v>
<v t="ekr.20250122151621.557"><vh>ThreeDScene.remove_fixed_in_frame_mobjects</vh></v>
<v t="ekr.20250122151621.558"><vh>ThreeDScene.set_to_default_angled_camera_orientation</vh></v>
</v>
<v t="ekr.20250122151621.545"><vh>class SpecialThreeDScene</vh>
<v t="ekr.20250122151621.559"><vh>SpecialThreeDScene.__init__</vh></v>
<v t="ekr.20250122151621.560"><vh>SpecialThreeDScene.get_axes</vh></v>
<v t="ekr.20250122151621.561"><vh>SpecialThreeDScene.get_sphere</vh></v>
<v t="ekr.20250122151621.562"><vh>SpecialThreeDScene.get_default_camera_position</vh></v>
<v t="ekr.20250122151621.563"><vh>SpecialThreeDScene.set_camera_to_default_position</vh></v>
</v>
</v>
<v t="ekr.20250122151621.564"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/scene/vector_space_scene.py</vh>
<v t="ekr.20250122151621.565"><vh>class VectorScene</vh>
<v t="ekr.20250122151621.567"><vh>VectorScene.__init__</vh></v>
<v t="ekr.20250122151621.568"><vh>VectorScene.add_plane</vh></v>
<v t="ekr.20250122151621.569"><vh>VectorScene.add_axes</vh></v>
<v t="ekr.20250122151621.570"><vh>VectorScene.lock_in_faded_grid</vh></v>
<v t="ekr.20250122151621.571"><vh>VectorScene.get_vector</vh></v>
<v t="ekr.20250122151621.572"><vh>VectorScene.add_vector</vh></v>
<v t="ekr.20250122151621.573"><vh>VectorScene.write_vector_coordinates</vh></v>
<v t="ekr.20250122151621.574"><vh>VectorScene.get_basis_vectors</vh></v>
<v t="ekr.20250122151621.575"><vh>VectorScene.get_basis_vector_labels</vh></v>
<v t="ekr.20250122151621.576"><vh>VectorScene.get_vector_label</vh></v>
<v t="ekr.20250122151621.577"><vh>VectorScene.label_vector</vh></v>
<v t="ekr.20250122151621.578"><vh>VectorScene.position_x_coordinate</vh></v>
<v t="ekr.20250122151621.579"><vh>VectorScene.position_y_coordinate</vh></v>
<v t="ekr.20250122151621.580"><vh>VectorScene.coords_to_vector</vh></v>
<v t="ekr.20250122151621.581"><vh>VectorScene.vector_to_coords</vh></v>
<v t="ekr.20250122151621.582"><vh>VectorScene.show_ghost_movement</vh></v>
</v>
<v t="ekr.20250122151621.566"><vh>class LinearTransformationScene</vh>
<v t="ekr.20250122151621.583"><vh>LinearTransformationScene.__init__</vh></v>
<v t="ekr.20250122151621.584"><vh>LinearTransformationScene.update_default_configs</vh></v>
<v t="ekr.20250122151621.585"><vh>LinearTransformationScene.setup</vh></v>
<v t="ekr.20250122151621.586"><vh>LinearTransformationScene.add_special_mobjects</vh></v>
<v t="ekr.20250122151621.587"><vh>LinearTransformationScene.add_background_mobject</vh></v>
<v t="ekr.20250122151621.588"><vh>LinearTransformationScene.add_foreground_mobject</vh></v>
<v t="ekr.20250122151621.589"><vh>LinearTransformationScene.add_transformable_mobject</vh></v>
<v t="ekr.20250122151621.590"><vh>LinearTransformationScene.add_moving_mobject</vh></v>
<v t="ekr.20250122151621.591"><vh>LinearTransformationScene.get_ghost_vectors</vh></v>
<v t="ekr.20250122151621.592"><vh>LinearTransformationScene.get_unit_square</vh></v>
<v t="ekr.20250122151621.593"><vh>LinearTransformationScene.add_unit_square</vh></v>
<v t="ekr.20250122151621.594"><vh>LinearTransformationScene.add_vector</vh></v>
<v t="ekr.20250122151621.595"><vh>LinearTransformationScene.write_vector_coordinates</vh></v>
<v t="ekr.20250122151621.596"><vh>LinearTransformationScene.add_transformable_label</vh></v>
<v t="ekr.20250122151621.597"><vh>LinearTransformationScene.add_title</vh></v>
<v t="ekr.20250122151621.598"><vh>LinearTransformationScene.get_matrix_transformation</vh></v>
<v t="ekr.20250122151621.599"><vh>LinearTransformationScene.get_transposed_matrix_transformation</vh></v>
<v t="ekr.20250122151621.600"><vh>LinearTransformationScene.get_piece_movement</vh></v>
<v t="ekr.20250122151621.601"><vh>LinearTransformationScene.get_moving_mobject_movement</vh></v>
<v t="ekr.20250122151621.602"><vh>LinearTransformationScene.get_vector_movement</vh></v>
<v t="ekr.20250122151621.603"><vh>LinearTransformationScene.get_transformable_label_movement</vh></v>
<v t="ekr.20250122151621.604"><vh>LinearTransformationScene.apply_matrix</vh></v>
<v t="ekr.20250122151621.605"><vh>LinearTransformationScene.apply_inverse</vh></v>
<v t="ekr.20250122151621.606"><vh>LinearTransformationScene.apply_transposed_matrix</vh></v>
<v t="ekr.20250122151621.607"><vh>LinearTransformationScene.apply_inverse_transpose</vh></v>
<v t="ekr.20250122151621.608"><vh>LinearTransformationScene.apply_nonlinear_transformation</vh></v>
<v t="ekr.20250122151621.609"><vh>LinearTransformationScene.apply_function</vh></v>
</v>
</v>
<v t="ekr.20250122151621.610"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/scene/zoomed_scene.py</vh>
<v t="ekr.20250122151621.611"><vh>class ZoomedScene</vh>
<v t="ekr.20250122151621.612"><vh>ZoomedScene.__init__</vh></v>
<v t="ekr.20250122151621.613"><vh>ZoomedScene.setup</vh></v>
<v t="ekr.20250122151621.614"><vh>ZoomedScene.activate_zooming</vh></v>
<v t="ekr.20250122151621.615"><vh>ZoomedScene.get_zoom_in_animation</vh></v>
<v t="ekr.20250122151621.616"><vh>ZoomedScene.get_zoomed_display_pop_out_animation</vh></v>
<v t="ekr.20250122151621.617"><vh>ZoomedScene.get_zoom_factor</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151621.618"><vh>manim/utils</vh>
<v t="ekr.20250122151621.619"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/__init__.py</vh></v>
<v t="ekr.20250122151621.620"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/bezier.py</vh>
<v t="ekr.20250122151621.621"><vh>function: bezier</vh></v>
<v t="ekr.20250122151621.622"><vh>function: bezier</vh></v>
<v t="ekr.20250122151621.623"><vh>function: bezier</vh></v>
<v t="ekr.20250122151621.624"><vh>function: partial_bezier_points</vh></v>
<v t="ekr.20250122151621.625"><vh>function: split_bezier</vh></v>
<v t="ekr.20250122151621.626"><vh>function: _get_subdivision_matrix</vh></v>
<v t="ekr.20250122151621.627"><vh>function: subdivide_bezier</vh></v>
<v t="ekr.20250122151621.628"><vh>function: bezier_remap</vh></v>
<v t="ekr.20250122151621.629"><vh>function: interpolate</vh></v>
<v t="ekr.20250122151621.630"><vh>function: interpolate</vh></v>
<v t="ekr.20250122151621.631"><vh>function: interpolate</vh></v>
<v t="ekr.20250122151621.632"><vh>function: interpolate</vh></v>
<v t="ekr.20250122151621.633"><vh>function: interpolate</vh></v>
<v t="ekr.20250122151621.634"><vh>function: integer_interpolate</vh></v>
<v t="ekr.20250122151621.635"><vh>function: mid</vh></v>
<v t="ekr.20250122151621.636"><vh>function: mid</vh></v>
<v t="ekr.20250122151621.637"><vh>function: mid</vh></v>
<v t="ekr.20250122151621.638"><vh>function: inverse_interpolate</vh></v>
<v t="ekr.20250122151621.639"><vh>function: inverse_interpolate</vh></v>
<v t="ekr.20250122151621.640"><vh>function: inverse_interpolate</vh></v>
<v t="ekr.20250122151621.641"><vh>function: inverse_interpolate</vh></v>
<v t="ekr.20250122151621.642"><vh>function: match_interpolate</vh></v>
<v t="ekr.20250122151621.643"><vh>function: match_interpolate</vh></v>
<v t="ekr.20250122151621.644"><vh>function: match_interpolate</vh></v>
<v t="ekr.20250122151621.645"><vh>function: get_smooth_cubic_bezier_handle_points</vh></v>
<v t="ekr.20250122151621.646"><vh>function: get_smooth_closed_cubic_bezier_handle_points</vh></v>
<v t="ekr.20250122151621.647"><vh>function: get_smooth_open_cubic_bezier_handle_points</vh></v>
<v t="ekr.20250122151621.648"><vh>function: get_quadratic_approximation_of_cubic</vh></v>
<v t="ekr.20250122151621.649"><vh>function: get_quadratic_approximation_of_cubic</vh></v>
<v t="ekr.20250122151621.650"><vh>function: get_quadratic_approximation_of_cubic</vh></v>
<v t="ekr.20250122151621.651"><vh>function: is_closed</vh></v>
<v t="ekr.20250122151621.652"><vh>function: proportions_along_bezier_curve_for_point</vh></v>
<v t="ekr.20250122151621.653"><vh>function: point_lies_on_bezier</vh></v>
</v>
<v t="ekr.20250122151621.654"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/caching.py</vh>
<v t="ekr.20250122151621.655"><vh>function: handle_caching_play</vh></v>
</v>
<v t="ekr.20250122151621.656"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/commands.py</vh>
<v t="ekr.20250122151621.657"><vh>function: capture</vh></v>
<v t="ekr.20250122151621.658"><vh>class VideoMetadata</vh></v>
<v t="ekr.20250122151621.659"><vh>function: get_video_metadata</vh></v>
<v t="ekr.20250122151621.660"><vh>function: get_dir_layout</vh></v>
</v>
<v t="ekr.20250122151621.661"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/config_ops.py</vh>
<v t="ekr.20250122151621.662"><vh>function: merge_dicts_recursively</vh></v>
<v t="ekr.20250122151621.663"><vh>function: update_dict_recursively</vh></v>
<v t="ekr.20250122151621.664"><vh>class DictAsObject</vh>
<v t="ekr.20250122151621.667"><vh>DictAsObject.__init__</vh></v>
</v>
<v t="ekr.20250122151621.665"><vh>class _Data</vh>
<v t="ekr.20250122151621.668"><vh>_Data.__set_name__</vh></v>
<v t="ekr.20250122151621.669"><vh>_Data.__get__</vh></v>
<v t="ekr.20250122151621.670"><vh>_Data.__set__</vh></v>
</v>
<v t="ekr.20250122151621.666"><vh>class _Uniforms</vh>
<v t="ekr.20250122151621.671"><vh>_Uniforms.__set_name__</vh></v>
<v t="ekr.20250122151621.672"><vh>_Uniforms.__get__</vh></v>
<v t="ekr.20250122151621.673"><vh>_Uniforms.__set__</vh></v>
</v>
</v>
<v t="ekr.20250122151621.674"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/debug.py</vh>
<v t="ekr.20250122151621.675"><vh>function: print_family</vh></v>
<v t="ekr.20250122151621.676"><vh>function: index_labels</vh></v>
</v>
<v t="ekr.20250122151621.677"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/deprecation.py</vh>
<v t="ekr.20250122151621.678"><vh>function: _get_callable_info</vh></v>
<v t="ekr.20250122151621.679"><vh>function: _deprecation_text_component</vh></v>
<v t="ekr.20250122151621.680"><vh>function: deprecated</vh></v>
<v t="ekr.20250122151621.681"><vh>function: deprecated</vh></v>
<v t="ekr.20250122151621.682"><vh>function: deprecated</vh></v>
<v t="ekr.20250122151621.683"><vh>function: deprecated_params</vh></v>
<v t="ekr.20250122151621.684"><vh>function: warning_msg</vh></v>
<v t="ekr.20250122151621.685"><vh>function: redirect_params</vh></v>
<v t="ekr.20250122151621.686"><vh>function: deprecate_params</vh></v>
</v>
<v t="ekr.20250122151621.687"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/exceptions.py</vh>
<v t="ekr.20250122151621.688"><vh>class EndSceneEarlyException</vh></v>
<v t="ekr.20250122151621.689"><vh>class RerunSceneException</vh></v>
<v t="ekr.20250122151621.690"><vh>class MultiAnimationOverrideException</vh></v>
</v>
<v t="ekr.20250122151621.691"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/family.py</vh>
<v t="ekr.20250122151621.692"><vh>function: extract_mobject_family_members</vh></v>
</v>
<v t="ekr.20250122151621.693"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/family_ops.py</vh>
<v t="ekr.20250122151621.694"><vh>function: extract_mobject_family_members</vh></v>
<v t="ekr.20250122151621.695"><vh>function: restructure_list_to_exclude_certain_family_members</vh></v>
</v>
<v t="ekr.20250122151621.696"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/file_ops.py</vh>
<v t="ekr.20250122151621.697"><vh>function: is_mp4_format</vh></v>
<v t="ekr.20250122151621.698"><vh>function: is_gif_format</vh></v>
<v t="ekr.20250122151621.699"><vh>function: is_webm_format</vh></v>
<v t="ekr.20250122151621.700"><vh>function: is_mov_format</vh></v>
<v t="ekr.20250122151621.701"><vh>function: is_png_format</vh></v>
<v t="ekr.20250122151621.702"><vh>function: write_to_movie</vh></v>
<v t="ekr.20250122151621.703"><vh>function: ensure_executable</vh></v>
<v t="ekr.20250122151621.704"><vh>function: add_extension_if_not_present</vh></v>
<v t="ekr.20250122151621.705"><vh>function: add_version_before_extension</vh></v>
<v t="ekr.20250122151621.706"><vh>function: guarantee_existence</vh></v>
<v t="ekr.20250122151621.707"><vh>function: guarantee_empty_existence</vh></v>
<v t="ekr.20250122151621.708"><vh>function: seek_full_path_from_defaults</vh></v>
<v t="ekr.20250122151621.709"><vh>function: modify_atime</vh></v>
<v t="ekr.20250122151621.710"><vh>function: open_file</vh></v>
<v t="ekr.20250122151621.711"><vh>function: open_media_file</vh></v>
<v t="ekr.20250122151621.712"><vh>function: get_template_names</vh></v>
<v t="ekr.20250122151621.713"><vh>function: get_template_path</vh></v>
<v t="ekr.20250122151621.714"><vh>function: add_import_statement</vh></v>
<v t="ekr.20250122151621.715"><vh>function: copy_template_files</vh></v>
</v>
<v t="ekr.20250122151621.716"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/hashing.py</vh>
<v t="ekr.20250122151621.717"><vh>class _Memoizer</vh>
<v t="ekr.20250122151621.721"><vh>_Memoizer.reset_already_processed</vh></v>
<v t="ekr.20250122151621.722"><vh>_Memoizer.check_already_processed_decorator</vh></v>
<v t="ekr.20250122151621.723"><vh>_Memoizer.check_already_processed</vh></v>
<v t="ekr.20250122151621.724"><vh>_Memoizer.mark_as_processed</vh></v>
<v t="ekr.20250122151621.725"><vh>_Memoizer._handle_already_processed</vh></v>
<v t="ekr.20250122151621.726"><vh>_Memoizer._return</vh></v>
</v>
<v t="ekr.20250122151621.718"><vh>class _CustomEncoder</vh>
<v t="ekr.20250122151621.727"><vh>_CustomEncoder.default</vh></v>
<v t="ekr.20250122151621.728"><vh>_CustomEncoder._cleaned_iterable</vh></v>
<v t="ekr.20250122151621.729"><vh>_CustomEncoder.encode</vh></v>
</v>
<v t="ekr.20250122151621.719"><vh>function: get_json</vh></v>
<v t="ekr.20250122151621.720"><vh>function: get_hash_from_play_call</vh></v>
</v>
<v t="ekr.20250122151621.730"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/images.py</vh>
<v t="ekr.20250122151621.731"><vh>function: get_full_raster_image_path</vh></v>
<v t="ekr.20250122151621.732"><vh>function: get_full_vector_image_path</vh></v>
<v t="ekr.20250122151621.733"><vh>function: drag_pixels</vh></v>
<v t="ekr.20250122151621.734"><vh>function: invert_image</vh></v>
<v t="ekr.20250122151621.735"><vh>function: change_to_rgba_array</vh></v>
</v>
<v t="ekr.20250122151621.736"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/ipython_magic.py</vh>
<v t="ekr.20250122151621.737"><vh>class ManimMagic</vh>
<v t="ekr.20250122151621.739"><vh>ManimMagic.__init__</vh></v>
<v t="ekr.20250122151621.740"><vh>ManimMagic.manim</vh></v>
<v t="ekr.20250122151621.741"><vh>ManimMagic.add_additional_args</vh></v>
</v>
<v t="ekr.20250122151621.738"><vh>function: _generate_file_name</vh></v>
</v>
<v t="ekr.20250122151621.742"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/iterables.py</vh>
<v t="ekr.20250122151621.743"><vh>function: adjacent_n_tuples</vh></v>
<v t="ekr.20250122151621.744"><vh>function: adjacent_pairs</vh></v>
<v t="ekr.20250122151621.745"><vh>function: all_elements_are_instances</vh></v>
<v t="ekr.20250122151621.746"><vh>function: batch_by_property</vh></v>
<v t="ekr.20250122151621.747"><vh>function: concatenate_lists</vh></v>
<v t="ekr.20250122151621.748"><vh>function: list_difference_update</vh></v>
<v t="ekr.20250122151621.749"><vh>function: list_update</vh></v>
<v t="ekr.20250122151621.750"><vh>function: listify</vh></v>
<v t="ekr.20250122151621.751"><vh>function: listify</vh></v>
<v t="ekr.20250122151621.752"><vh>function: listify</vh></v>
<v t="ekr.20250122151621.753"><vh>function: listify</vh></v>
<v t="ekr.20250122151621.754"><vh>function: make_even</vh></v>
<v t="ekr.20250122151621.755"><vh>function: make_even_by_cycling</vh></v>
<v t="ekr.20250122151621.756"><vh>function: remove_list_redundancies</vh></v>
<v t="ekr.20250122151621.757"><vh>function: remove_nones</vh></v>
<v t="ekr.20250122151621.758"><vh>function: resize_array</vh></v>
<v t="ekr.20250122151621.759"><vh>function: resize_preserving_order</vh></v>
<v t="ekr.20250122151621.760"><vh>function: resize_with_interpolation</vh></v>
<v t="ekr.20250122151621.761"><vh>function: stretch_array_to_length</vh></v>
<v t="ekr.20250122151621.762"><vh>function: tuplify</vh></v>
<v t="ekr.20250122151621.763"><vh>function: tuplify</vh></v>
<v t="ekr.20250122151621.764"><vh>function: tuplify</vh></v>
<v t="ekr.20250122151621.765"><vh>function: tuplify</vh></v>
<v t="ekr.20250122151621.766"><vh>function: uniq_chain</vh></v>
<v t="ekr.20250122151621.767"><vh>function: hash_obj</vh></v>
</v>
<v t="ekr.20250122151621.768"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/module_ops.py</vh>
<v t="ekr.20250122151621.769"><vh>function: get_module</vh></v>
<v t="ekr.20250122151621.770"><vh>function: get_scene_classes_from_module</vh></v>
<v t="ekr.20250122151621.771"><vh>function: get_scenes_to_render</vh></v>
<v t="ekr.20250122151621.772"><vh>function: prompt_user_for_choice</vh></v>
<v t="ekr.20250122151621.773"><vh>function: scene_classes_from_file</vh></v>
<v t="ekr.20250122151621.774"><vh>function: scene_classes_from_file</vh></v>
<v t="ekr.20250122151621.775"><vh>function: scene_classes_from_file</vh></v>
<v t="ekr.20250122151621.776"><vh>function: scene_classes_from_file</vh></v>
</v>
<v t="ekr.20250122151621.777"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/opengl.py</vh>
<v t="ekr.20250122151621.778"><vh>function: matrix_to_shader_input</vh></v>
<v t="ekr.20250122151621.779"><vh>function: orthographic_projection_matrix</vh></v>
<v t="ekr.20250122151621.780"><vh>function: perspective_projection_matrix</vh></v>
<v t="ekr.20250122151621.781"><vh>function: translation_matrix</vh></v>
<v t="ekr.20250122151621.782"><vh>function: x_rotation_matrix</vh></v>
<v t="ekr.20250122151621.783"><vh>function: y_rotation_matrix</vh></v>
<v t="ekr.20250122151621.784"><vh>function: z_rotation_matrix</vh></v>
<v t="ekr.20250122151621.785"><vh>function: rotate_in_place_matrix</vh></v>
<v t="ekr.20250122151621.786"><vh>function: rotation_matrix</vh></v>
<v t="ekr.20250122151621.787"><vh>function: scale_matrix</vh></v>
<v t="ekr.20250122151621.788"><vh>function: view_matrix</vh></v>
</v>
<v t="ekr.20250122151621.789"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/parameter_parsing.py</vh>
<v t="ekr.20250122151621.790"><vh>function: flatten_iterable_parameters</vh></v>
</v>
<v t="ekr.20250122151621.791"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/paths.py</vh>
<v t="ekr.20250122151621.792"><vh>function: straight_path</vh></v>
<v t="ekr.20250122151621.793"><vh>function: path_along_circles</vh></v>
<v t="ekr.20250122151621.794"><vh>function: path_along_arc</vh></v>
<v t="ekr.20250122151621.795"><vh>function: clockwise_path</vh></v>
<v t="ekr.20250122151621.796"><vh>function: counterclockwise_path</vh></v>
<v t="ekr.20250122151621.797"><vh>function: spiral_path</vh></v>
</v>
<v t="ekr.20250122151621.798"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/polylabel.py</vh>
<v t="ekr.20250122151621.799"><vh>class Polygon</vh>
<v t="ekr.20250122151621.802"><vh>Polygon.__init__</vh></v>
<v t="ekr.20250122151621.803"><vh>Polygon.compute_distance</vh></v>
<v t="ekr.20250122151621.804"><vh>Polygon.inside</vh></v>
</v>
<v t="ekr.20250122151621.800"><vh>class Cell</vh>
<v t="ekr.20250122151621.805"><vh>Cell.__init__</vh></v>
<v t="ekr.20250122151621.806"><vh>Cell.__lt__</vh></v>
<v t="ekr.20250122151621.807"><vh>Cell.__gt__</vh></v>
<v t="ekr.20250122151621.808"><vh>Cell.__le__</vh></v>
<v t="ekr.20250122151621.809"><vh>Cell.__ge__</vh></v>
</v>
<v t="ekr.20250122151621.801"><vh>function: polylabel</vh></v>
</v>
<v t="ekr.20250122151621.810"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/qhull.py</vh>
<v t="ekr.20250122151621.811"><vh>class QuickHullPoint</vh>
<v t="ekr.20250122151621.816"><vh>QuickHullPoint.__init__</vh></v>
<v t="ekr.20250122151621.817"><vh>QuickHullPoint.__hash__</vh></v>
<v t="ekr.20250122151621.818"><vh>QuickHullPoint.__eq__</vh></v>
</v>
<v t="ekr.20250122151621.812"><vh>class SubFacet</vh>
<v t="ekr.20250122151621.819"><vh>SubFacet.__init__</vh></v>
<v t="ekr.20250122151621.820"><vh>SubFacet.__hash__</vh></v>
<v t="ekr.20250122151621.821"><vh>SubFacet.__eq__</vh></v>
</v>
<v t="ekr.20250122151621.813"><vh>class Facet</vh>
<v t="ekr.20250122151621.822"><vh>Facet.__init__</vh></v>
<v t="ekr.20250122151621.823"><vh>Facet.compute_normal</vh></v>
<v t="ekr.20250122151621.824"><vh>Facet.__hash__</vh></v>
<v t="ekr.20250122151621.825"><vh>Facet.__eq__</vh></v>
</v>
<v t="ekr.20250122151621.814"><vh>class Horizon</vh>
<v t="ekr.20250122151621.826"><vh>Horizon.__init__</vh></v>
</v>
<v t="ekr.20250122151621.815"><vh>class QuickHull</vh>
<v t="ekr.20250122151621.827"><vh>QuickHull.__init__</vh></v>
<v t="ekr.20250122151621.828"><vh>QuickHull.initialize</vh></v>
<v t="ekr.20250122151621.829"><vh>QuickHull.classify</vh></v>
<v t="ekr.20250122151621.830"><vh>QuickHull.compute_horizon</vh></v>
<v t="ekr.20250122151621.831"><vh>QuickHull._recursive_horizon</vh></v>
<v t="ekr.20250122151621.832"><vh>QuickHull.build</vh></v>
</v>
</v>
<v t="ekr.20250122151621.833"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/rate_functions.py</vh>
<v t="ekr.20250122151621.834"><vh>class RateFunction</vh>
<v t="ekr.20250122151621.884"><vh>RateFunction.__call__</vh></v>
</v>
<v t="ekr.20250122151621.835"><vh>function: unit_interval</vh></v>
<v t="ekr.20250122151621.836"><vh>function: zero</vh></v>
<v t="ekr.20250122151621.837"><vh>function: linear</vh></v>
<v t="ekr.20250122151621.838"><vh>function: smooth</vh></v>
<v t="ekr.20250122151621.839"><vh>function: smoothstep</vh></v>
<v t="ekr.20250122151621.840"><vh>function: smootherstep</vh></v>
<v t="ekr.20250122151621.841"><vh>function: smoothererstep</vh></v>
<v t="ekr.20250122151621.842"><vh>function: rush_into</vh></v>
<v t="ekr.20250122151621.843"><vh>function: rush_from</vh></v>
<v t="ekr.20250122151621.844"><vh>function: slow_into</vh></v>
<v t="ekr.20250122151621.845"><vh>function: double_smooth</vh></v>
<v t="ekr.20250122151621.846"><vh>function: there_and_back</vh></v>
<v t="ekr.20250122151621.847"><vh>function: there_and_back_with_pause</vh></v>
<v t="ekr.20250122151621.848"><vh>function: running_start</vh></v>
<v t="ekr.20250122151621.849"><vh>function: not_quite_there</vh></v>
<v t="ekr.20250122151621.850"><vh>function: wiggle</vh></v>
<v t="ekr.20250122151621.851"><vh>function: squish_rate_func</vh></v>
<v t="ekr.20250122151621.852"><vh>function: lingering</vh></v>
<v t="ekr.20250122151621.853"><vh>function: exponential_decay</vh></v>
<v t="ekr.20250122151621.854"><vh>function: ease_in_sine</vh></v>
<v t="ekr.20250122151621.855"><vh>function: ease_out_sine</vh></v>
<v t="ekr.20250122151621.856"><vh>function: ease_in_out_sine</vh></v>
<v t="ekr.20250122151621.857"><vh>function: ease_in_quad</vh></v>
<v t="ekr.20250122151621.858"><vh>function: ease_out_quad</vh></v>
<v t="ekr.20250122151621.859"><vh>function: ease_in_out_quad</vh></v>
<v t="ekr.20250122151621.860"><vh>function: ease_in_cubic</vh></v>
<v t="ekr.20250122151621.861"><vh>function: ease_out_cubic</vh></v>
<v t="ekr.20250122151621.862"><vh>function: ease_in_out_cubic</vh></v>
<v t="ekr.20250122151621.863"><vh>function: ease_in_quart</vh></v>
<v t="ekr.20250122151621.864"><vh>function: ease_out_quart</vh></v>
<v t="ekr.20250122151621.865"><vh>function: ease_in_out_quart</vh></v>
<v t="ekr.20250122151621.866"><vh>function: ease_in_quint</vh></v>
<v t="ekr.20250122151621.867"><vh>function: ease_out_quint</vh></v>
<v t="ekr.20250122151621.868"><vh>function: ease_in_out_quint</vh></v>
<v t="ekr.20250122151621.869"><vh>function: ease_in_expo</vh></v>
<v t="ekr.20250122151621.870"><vh>function: ease_out_expo</vh></v>
<v t="ekr.20250122151621.871"><vh>function: ease_in_out_expo</vh></v>
<v t="ekr.20250122151621.872"><vh>function: ease_in_circ</vh></v>
<v t="ekr.20250122151621.873"><vh>function: ease_out_circ</vh></v>
<v t="ekr.20250122151621.874"><vh>function: ease_in_out_circ</vh></v>
<v t="ekr.20250122151621.875"><vh>function: ease_in_back</vh></v>
<v t="ekr.20250122151621.876"><vh>function: ease_out_back</vh></v>
<v t="ekr.20250122151621.877"><vh>function: ease_in_out_back</vh></v>
<v t="ekr.20250122151621.878"><vh>function: ease_in_elastic</vh></v>
<v t="ekr.20250122151621.879"><vh>function: ease_out_elastic</vh></v>
<v t="ekr.20250122151621.880"><vh>function: ease_in_out_elastic</vh></v>
<v t="ekr.20250122151621.881"><vh>function: ease_in_bounce</vh></v>
<v t="ekr.20250122151621.882"><vh>function: ease_out_bounce</vh></v>
<v t="ekr.20250122151621.883"><vh>function: ease_in_out_bounce</vh></v>
</v>
<v t="ekr.20250122151621.885"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/simple_functions.py</vh>
<v t="ekr.20250122151621.886"><vh>function: binary_search</vh></v>
<v t="ekr.20250122151621.887"><vh>function: choose</vh></v>
<v t="ekr.20250122151621.888"><vh>class Comparable</vh>
<v t="ekr.20250122151621.891"><vh>Comparable.__lt__</vh></v>
<v t="ekr.20250122151621.892"><vh>Comparable.__gt__</vh></v>
</v>
<v t="ekr.20250122151621.889"><vh>function: clip</vh></v>
<v t="ekr.20250122151621.890"><vh>function: sigmoid</vh></v>
</v>
<v t="ekr.20250122151621.893"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/sounds.py</vh>
<v t="ekr.20250122151621.894"><vh>function: get_full_sound_file_path</vh></v>
</v>
<v t="ekr.20250122151621.895"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/space_ops.py</vh>
<v t="ekr.20250122151621.896"><vh>function: norm_squared</vh></v>
<v t="ekr.20250122151621.897"><vh>function: cross</vh></v>
<v t="ekr.20250122151621.898"><vh>function: quaternion_mult</vh></v>
<v t="ekr.20250122151621.899"><vh>function: quaternion_from_angle_axis</vh></v>
<v t="ekr.20250122151621.900"><vh>function: angle_axis_from_quaternion</vh></v>
<v t="ekr.20250122151621.901"><vh>function: quaternion_conjugate</vh></v>
<v t="ekr.20250122151621.902"><vh>function: rotate_vector</vh></v>
<v t="ekr.20250122151621.903"><vh>function: thick_diagonal</vh></v>
<v t="ekr.20250122151621.904"><vh>function: rotation_matrix_transpose_from_quaternion</vh></v>
<v t="ekr.20250122151621.905"><vh>function: rotation_matrix_from_quaternion</vh></v>
<v t="ekr.20250122151621.906"><vh>function: rotation_matrix_transpose</vh></v>
<v t="ekr.20250122151621.907"><vh>function: rotation_matrix</vh></v>
<v t="ekr.20250122151621.908"><vh>function: rotation_about_z</vh></v>
<v t="ekr.20250122151621.909"><vh>function: z_to_vector</vh></v>
<v t="ekr.20250122151621.910"><vh>function: angle_of_vector</vh></v>
<v t="ekr.20250122151621.911"><vh>function: angle_between_vectors</vh></v>
<v t="ekr.20250122151621.912"><vh>function: normalize</vh></v>
<v t="ekr.20250122151621.913"><vh>function: normalize_along_axis</vh></v>
<v t="ekr.20250122151621.914"><vh>function: get_unit_normal</vh></v>
<v t="ekr.20250122151621.915"><vh>function: compass_directions</vh></v>
<v t="ekr.20250122151621.916"><vh>function: regular_vertices</vh></v>
<v t="ekr.20250122151621.917"><vh>function: complex_to_R3</vh></v>
<v t="ekr.20250122151621.918"><vh>function: R3_to_complex</vh></v>
<v t="ekr.20250122151621.919"><vh>function: complex_func_to_R3_func</vh></v>
<v t="ekr.20250122151621.920"><vh>function: center_of_mass</vh></v>
<v t="ekr.20250122151621.921"><vh>function: midpoint</vh></v>
<v t="ekr.20250122151621.922"><vh>function: line_intersection</vh></v>
<v t="ekr.20250122151621.923"><vh>function: find_intersection</vh></v>
<v t="ekr.20250122151621.924"><vh>function: get_winding_number</vh></v>
<v t="ekr.20250122151621.925"><vh>function: shoelace</vh></v>
<v t="ekr.20250122151621.926"><vh>function: shoelace_direction</vh></v>
<v t="ekr.20250122151621.927"><vh>function: cross2d</vh></v>
<v t="ekr.20250122151621.928"><vh>function: earclip_triangulation</vh></v>
<v t="ekr.20250122151621.929"><vh>function: cartesian_to_spherical</vh></v>
<v t="ekr.20250122151621.930"><vh>function: spherical_to_cartesian</vh></v>
<v t="ekr.20250122151621.931"><vh>function: perpendicular_bisector</vh></v>
</v>
<v t="ekr.20250122151621.932"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/tex.py</vh>
<v t="ekr.20250122151621.933"><vh>class TexTemplate</vh>
<v t="ekr.20250122151621.935"><vh>TexTemplate.body</vh></v>
<v t="ekr.20250122151621.936"><vh>TexTemplate.body</vh></v>
<v t="ekr.20250122151621.937"><vh>TexTemplate.from_file</vh></v>
<v t="ekr.20250122151621.938"><vh>TexTemplate.add_to_preamble</vh></v>
<v t="ekr.20250122151621.939"><vh>TexTemplate.add_to_document</vh></v>
<v t="ekr.20250122151621.940"><vh>TexTemplate.get_texcode_for_expression</vh></v>
<v t="ekr.20250122151621.941"><vh>TexTemplate.get_texcode_for_expression_in_env</vh></v>
<v t="ekr.20250122151621.942"><vh>TexTemplate.copy</vh></v>
</v>
<v t="ekr.20250122151621.934"><vh>function: _texcode_for_environment</vh></v>
</v>
<v t="ekr.20250122151621.943"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/tex_file_writing.py</vh>
<v t="ekr.20250122151621.944"><vh>function: tex_hash</vh></v>
<v t="ekr.20250122151621.945"><vh>function: tex_to_svg_file</vh></v>
<v t="ekr.20250122151621.946"><vh>function: generate_tex_file</vh></v>
<v t="ekr.20250122151621.947"><vh>function: make_tex_compilation_command</vh></v>
<v t="ekr.20250122151621.948"><vh>function: insight_inputenc_error</vh></v>
<v t="ekr.20250122151621.949"><vh>function: insight_package_not_found_error</vh></v>
<v t="ekr.20250122151621.950"><vh>function: compile_tex</vh></v>
<v t="ekr.20250122151621.951"><vh>function: convert_to_svg</vh></v>
<v t="ekr.20250122151621.952"><vh>function: delete_nonsvg_files</vh></v>
<v t="ekr.20250122151621.953"><vh>function: print_all_tex_errors</vh></v>
<v t="ekr.20250122151621.954"><vh>function: print_tex_error</vh></v>
</v>
<v t="ekr.20250122151621.955"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/tex_templates.py</vh>
<v t="ekr.20250122151621.956"><vh>function: _new_ams_template</vh></v>
<v t="ekr.20250122151621.957"><vh>class TexTemplateLibrary</vh></v>
<v t="ekr.20250122151621.958"><vh>class TexFontTemplates</vh></v>
</v>
<v t="ekr.20250122151621.959"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/unit.py</vh>
<v t="ekr.20250122151621.960"><vh>class _PixelUnits</vh>
<v t="ekr.20250122151621.962"><vh>_PixelUnits.__mul__</vh></v>
<v t="ekr.20250122151621.963"><vh>_PixelUnits.__rmul__</vh></v>
</v>
<v t="ekr.20250122151621.961"><vh>class Percent</vh>
<v t="ekr.20250122151621.964"><vh>Percent.__init__</vh></v>
<v t="ekr.20250122151621.965"><vh>Percent.__mul__</vh></v>
<v t="ekr.20250122151621.966"><vh>Percent.__rmul__</vh></v>
</v>
</v>
<v t="ekr.20250122151621.967"><vh>C:/Python/Python3.12/Lib/site-packages/manim/utils/color</vh>
<v t="ekr.20250122151621.968"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/color/AS2700.py</vh></v>
<v t="ekr.20250122151621.969"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/color/BS381.py</vh></v>
<v t="ekr.20250122151621.970"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/color/DVIPSNAMES.py</vh></v>
<v t="ekr.20250122151621.971"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/color/SVGNAMES.py</vh></v>
<v t="ekr.20250122151621.972"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/color/X11.py</vh></v>
<v t="ekr.20250122151621.973"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/color/XKCD.py</vh></v>
<v t="ekr.20250122151621.974"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/color/__init__.py</vh></v>
<v t="ekr.20250122151621.975"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/color/core.py</vh>
<v t="ekr.20250122151621.976"><vh>class ManimColor</vh>
<v t="ekr.20250122151621.993"><vh>ManimColor.__init__</vh></v>
<v t="ekr.20250122151621.994"><vh>ManimColor._internal_space</vh></v>
<v t="ekr.20250122151621.995"><vh>ManimColor._internal_value</vh></v>
<v t="ekr.20250122151621.996"><vh>ManimColor._internal_value</vh></v>
<v t="ekr.20250122151621.997"><vh>ManimColor._construct_from_space</vh></v>
<v t="ekr.20250122151621.998"><vh>ManimColor._internal_from_integer</vh></v>
<v t="ekr.20250122151621.999"><vh>ManimColor._internal_from_hex_string</vh></v>
<v t="ekr.20250122151621.1000"><vh>ManimColor._internal_from_int_rgb</vh></v>
<v t="ekr.20250122151621.1001"><vh>ManimColor._internal_from_rgb</vh></v>
<v t="ekr.20250122151621.1002"><vh>ManimColor._internal_from_int_rgba</vh></v>
<v t="ekr.20250122151621.1003"><vh>ManimColor._internal_from_rgba</vh></v>
<v t="ekr.20250122151621.1004"><vh>ManimColor._internal_from_string</vh></v>
<v t="ekr.20250122151621.1005"><vh>ManimColor.to_integer</vh></v>
<v t="ekr.20250122151621.1006"><vh>ManimColor.to_rgb</vh></v>
<v t="ekr.20250122151621.1007"><vh>ManimColor.to_int_rgb</vh></v>
<v t="ekr.20250122151621.1008"><vh>ManimColor.to_rgba</vh></v>
<v t="ekr.20250122151621.1009"><vh>ManimColor.to_int_rgba</vh></v>
<v t="ekr.20250122151621.1010"><vh>ManimColor.to_rgba_with_alpha</vh></v>
<v t="ekr.20250122151621.1011"><vh>ManimColor.to_int_rgba_with_alpha</vh></v>
<v t="ekr.20250122151621.1012"><vh>ManimColor.to_hex</vh></v>
<v t="ekr.20250122151621.1013"><vh>ManimColor.to_hsv</vh></v>
<v t="ekr.20250122151621.1014"><vh>ManimColor.to_hsl</vh></v>
<v t="ekr.20250122151621.1015"><vh>ManimColor.invert</vh></v>
<v t="ekr.20250122151621.1016"><vh>ManimColor.interpolate</vh></v>
<v t="ekr.20250122151621.1017"><vh>ManimColor.darker</vh></v>
<v t="ekr.20250122151621.1018"><vh>ManimColor.lighter</vh></v>
<v t="ekr.20250122151621.1019"><vh>ManimColor.contrasting</vh></v>
<v t="ekr.20250122151621.1020"><vh>ManimColor.opacity</vh></v>
<v t="ekr.20250122151621.1021"><vh>ManimColor.into</vh></v>
<v t="ekr.20250122151621.1022"><vh>ManimColor._from_internal</vh></v>
<v t="ekr.20250122151621.1023"><vh>ManimColor.from_rgb</vh></v>
<v t="ekr.20250122151621.1024"><vh>ManimColor.from_rgba</vh></v>
<v t="ekr.20250122151621.1025"><vh>ManimColor.from_hex</vh></v>
<v t="ekr.20250122151621.1026"><vh>ManimColor.from_hsv</vh></v>
<v t="ekr.20250122151621.1027"><vh>ManimColor.from_hsl</vh></v>
<v t="ekr.20250122151621.1028"><vh>ManimColor.parse</vh></v>
<v t="ekr.20250122151621.1029"><vh>ManimColor.parse</vh></v>
<v t="ekr.20250122151621.1030"><vh>ManimColor.parse</vh></v>
<v t="ekr.20250122151621.1031"><vh>ManimColor.gradient</vh></v>
<v t="ekr.20250122151621.1032"><vh>ManimColor.__repr__</vh></v>
<v t="ekr.20250122151621.1033"><vh>ManimColor.__str__</vh></v>
<v t="ekr.20250122151621.1034"><vh>ManimColor.__eq__</vh></v>
<v t="ekr.20250122151621.1035"><vh>ManimColor.__add__</vh></v>
<v t="ekr.20250122151621.1036"><vh>ManimColor.__radd__</vh></v>
<v t="ekr.20250122151621.1037"><vh>ManimColor.__sub__</vh></v>
<v t="ekr.20250122151621.1038"><vh>ManimColor.__rsub__</vh></v>
<v t="ekr.20250122151621.1039"><vh>ManimColor.__mul__</vh></v>
<v t="ekr.20250122151621.1040"><vh>ManimColor.__rmul__</vh></v>
<v t="ekr.20250122151621.1041"><vh>ManimColor.__truediv__</vh></v>
<v t="ekr.20250122151621.1042"><vh>ManimColor.__rtruediv__</vh></v>
<v t="ekr.20250122151621.1043"><vh>ManimColor.__floordiv__</vh></v>
<v t="ekr.20250122151621.1044"><vh>ManimColor.__rfloordiv__</vh></v>
<v t="ekr.20250122151621.1045"><vh>ManimColor.__mod__</vh></v>
<v t="ekr.20250122151621.1046"><vh>ManimColor.__rmod__</vh></v>
<v t="ekr.20250122151621.1047"><vh>ManimColor.__pow__</vh></v>
<v t="ekr.20250122151621.1048"><vh>ManimColor.__rpow__</vh></v>
<v t="ekr.20250122151621.1049"><vh>ManimColor.__invert__</vh></v>
<v t="ekr.20250122151621.1050"><vh>ManimColor.__int__</vh></v>
<v t="ekr.20250122151621.1051"><vh>ManimColor.__getitem__</vh></v>
<v t="ekr.20250122151621.1052"><vh>ManimColor.__and__</vh></v>
<v t="ekr.20250122151621.1053"><vh>ManimColor.__or__</vh></v>
<v t="ekr.20250122151621.1054"><vh>ManimColor.__xor__</vh></v>
<v t="ekr.20250122151621.1055"><vh>ManimColor.__hash__</vh></v>
</v>
<v t="ekr.20250122151621.977"><vh>class HSV</vh>
<v t="ekr.20250122151621.1056"><vh>HSV.__init__</vh></v>
<v t="ekr.20250122151621.1057"><vh>HSV._from_internal</vh></v>
<v t="ekr.20250122151621.1058"><vh>HSV.hue</vh></v>
<v t="ekr.20250122151621.1059"><vh>HSV.hue</vh></v>
<v t="ekr.20250122151621.1060"><vh>HSV.saturation</vh></v>
<v t="ekr.20250122151621.1061"><vh>HSV.saturation</vh></v>
<v t="ekr.20250122151621.1062"><vh>HSV.value</vh></v>
<v t="ekr.20250122151621.1063"><vh>HSV.value</vh></v>
<v t="ekr.20250122151621.1064"><vh>HSV.h</vh></v>
<v t="ekr.20250122151621.1065"><vh>HSV.h</vh></v>
<v t="ekr.20250122151621.1066"><vh>HSV.s</vh></v>
<v t="ekr.20250122151621.1067"><vh>HSV.s</vh></v>
<v t="ekr.20250122151621.1068"><vh>HSV.v</vh></v>
<v t="ekr.20250122151621.1069"><vh>HSV.v</vh></v>
<v t="ekr.20250122151621.1070"><vh>HSV._internal_space</vh></v>
<v t="ekr.20250122151621.1071"><vh>HSV._internal_value</vh></v>
<v t="ekr.20250122151621.1072"><vh>HSV._internal_value</vh></v>
</v>
<v t="ekr.20250122151621.978"><vh>function: color_to_rgb</vh></v>
<v t="ekr.20250122151621.979"><vh>function: color_to_rgba</vh></v>
<v t="ekr.20250122151621.980"><vh>function: color_to_int_rgb</vh></v>
<v t="ekr.20250122151621.981"><vh>function: color_to_int_rgba</vh></v>
<v t="ekr.20250122151621.982"><vh>function: rgb_to_color</vh></v>
<v t="ekr.20250122151621.983"><vh>function: rgba_to_color</vh></v>
<v t="ekr.20250122151621.984"><vh>function: rgb_to_hex</vh></v>
<v t="ekr.20250122151621.985"><vh>function: hex_to_rgb</vh></v>
<v t="ekr.20250122151621.986"><vh>function: invert_color</vh></v>
<v t="ekr.20250122151621.987"><vh>function: color_gradient</vh></v>
<v t="ekr.20250122151621.988"><vh>function: interpolate_color</vh></v>
<v t="ekr.20250122151621.989"><vh>function: average_color</vh></v>
<v t="ekr.20250122151621.990"><vh>function: random_bright_color</vh></v>
<v t="ekr.20250122151621.991"><vh>function: random_color</vh></v>
<v t="ekr.20250122151621.992"><vh>function: get_shaded_rgb</vh></v>
</v>
<v t="ekr.20250122151621.1073"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/color/manim_colors.py</vh></v>
</v>
<v t="ekr.20250122151621.1074"><vh>C:/Python/Python3.12/Lib/site-packages/manim/utils/docbuild</vh>
<v t="ekr.20250122151621.1075"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/docbuild/__init__.py</vh></v>
<v t="ekr.20250122151621.1076"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/docbuild/autoaliasattr_directive.py</vh>
<v t="ekr.20250122151621.1077"><vh>function: smart_replace</vh></v>
<v t="ekr.20250122151621.1078"><vh>function: setup</vh></v>
<v t="ekr.20250122151621.1079"><vh>class AliasAttrDocumenter</vh>
<v t="ekr.20250122151621.1080"><vh>AliasAttrDocumenter.run</vh></v>
</v>
</v>
<v t="ekr.20250122151621.1081"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/docbuild/autocolor_directive.py</vh>
<v t="ekr.20250122151621.1082"><vh>function: setup</vh></v>
<v t="ekr.20250122151621.1083"><vh>class ManimColorModuleDocumenter</vh>
<v t="ekr.20250122151621.1084"><vh>ManimColorModuleDocumenter.add_directive_header</vh></v>
<v t="ekr.20250122151621.1085"><vh>ManimColorModuleDocumenter.run</vh></v>
</v>
</v>
<v t="ekr.20250122151621.1086"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/docbuild/manim_directive.py</vh>
<v t="ekr.20250122151621.1087"><vh>class SetupMetadata</vh></v>
<v t="ekr.20250122151621.1088"><vh>class SkipManimNode</vh></v>
<v t="ekr.20250122151621.1089"><vh>function: visit</vh></v>
<v t="ekr.20250122151621.1090"><vh>function: depart</vh></v>
<v t="ekr.20250122151621.1091"><vh>function: process_name_list</vh></v>
<v t="ekr.20250122151621.1092"><vh>class ManimDirective</vh>
<v t="ekr.20250122151621.1097"><vh>ManimDirective.run</vh></v>
</v>
<v t="ekr.20250122151621.1093"><vh>function: _write_rendering_stats</vh></v>
<v t="ekr.20250122151621.1094"><vh>function: _log_rendering_times</vh></v>
<v t="ekr.20250122151621.1095"><vh>function: _delete_rendering_times</vh></v>
<v t="ekr.20250122151621.1096"><vh>function: setup</vh></v>
</v>
<v t="ekr.20250122151621.1098"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/docbuild/module_parsing.py</vh>
<v t="ekr.20250122151621.1099"><vh>function: parse_module_attributes</vh></v>
</v>
</v>
<v t="ekr.20250122151621.1100"><vh>C:/Python/Python3.12/Lib/site-packages/manim/utils/testing</vh>
<v t="ekr.20250122151621.1101"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/testing/__init__.py</vh></v>
<v t="ekr.20250122151621.1102"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/testing/_frames_testers.py</vh>
<v t="ekr.20250122151621.1103"><vh>class _FramesTester</vh>
<v t="ekr.20250122151621.1105"><vh>_FramesTester.__init__</vh></v>
<v t="ekr.20250122151621.1106"><vh>_FramesTester.testing</vh></v>
<v t="ekr.20250122151621.1107"><vh>_FramesTester.check_frame</vh></v>
</v>
<v t="ekr.20250122151621.1104"><vh>class _ControlDataWriter</vh>
<v t="ekr.20250122151621.1108"><vh>_ControlDataWriter.__init__</vh></v>
<v t="ekr.20250122151621.1109"><vh>_ControlDataWriter.check_frame</vh></v>
<v t="ekr.20250122151621.1110"><vh>_ControlDataWriter.testing</vh></v>
<v t="ekr.20250122151621.1111"><vh>_ControlDataWriter.save_contol_data</vh></v>
</v>
</v>
<v t="ekr.20250122151621.1112"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/testing/_show_diff.py</vh>
<v t="ekr.20250122151621.1113"><vh>function: show_diff_helper</vh></v>
</v>
<v t="ekr.20250122151621.1114"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/testing/_test_class_makers.py</vh>
<v t="ekr.20250122151621.1115"><vh>function: _make_test_scene_class</vh>
<v t="ekr.20250122151621.1119"><vh>class _TestedScene</vh>
<v t="ekr.20250122151621.1131"><vh>_TestedScene.__init__</vh></v>
<v t="ekr.20250122151621.1132"><vh>_TestedScene.construct</vh></v>
</v>
</v>
<v t="ekr.20250122151621.1116"><vh>function: _make_test_renderer_class</vh>
<v t="ekr.20250122151621.1120"><vh>class _TestRenderer</vh></v>
</v>
<v t="ekr.20250122151621.1117"><vh>class DummySceneFileWriter</vh>
<v t="ekr.20250122151621.1121"><vh>DummySceneFileWriter.__init__</vh></v>
<v t="ekr.20250122151621.1122"><vh>DummySceneFileWriter.init_output_directories</vh></v>
<v t="ekr.20250122151621.1123"><vh>DummySceneFileWriter.add_partial_movie_file</vh></v>
<v t="ekr.20250122151621.1124"><vh>DummySceneFileWriter.begin_animation</vh></v>
<v t="ekr.20250122151621.1125"><vh>DummySceneFileWriter.end_animation</vh></v>
<v t="ekr.20250122151621.1126"><vh>DummySceneFileWriter.combine_to_movie</vh></v>
<v t="ekr.20250122151621.1127"><vh>DummySceneFileWriter.combine_to_section_videos</vh></v>
<v t="ekr.20250122151621.1128"><vh>DummySceneFileWriter.clean_cache</vh></v>
<v t="ekr.20250122151621.1129"><vh>DummySceneFileWriter.write_frame</vh></v>
</v>
<v t="ekr.20250122151621.1118"><vh>function: _make_scene_file_writer_class</vh>
<v t="ekr.20250122151621.1130"><vh>class TestSceneFileWriter</vh>
<v t="ekr.20250122151621.1133"><vh>TestSceneFileWriter.write_frame</vh></v>
</v>
</v>
</v>
<v t="ekr.20250122151621.1134"><vh>@clean C:/Python/Python3.12/Lib/site-packages/manim/utils/testing/frames_comparison.py</vh>
<v t="ekr.20250122151621.1135"><vh>function: frames_comparison</vh></v>
<v t="ekr.20250122151621.1136"><vh>function: _make_test_comparing_frames</vh></v>
<v t="ekr.20250122151621.1137"><vh>function: _control_data_path</vh></v>
<v t="ekr.20250122151621.1138"><vh>function: _config_test</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20250122152515.1"><vh>--- embed</vh></v>
<v t="ekr.20250122151621.490"></v>
<v t="ekr.20250122151621.488"></v>
</vnodes>
<tnodes>
<t tx="ekr.20250121054642.1">@language rest

A study outline for manim CE (community edition):
https://github.com/ManimCommunity/manim

@language python
</t>
<t tx="ekr.20250121054646.1">g.execute_shell_commands(f"manim -p -ql -v WARNING main.py")  # SquareToCircle
</t>
<t tx="ekr.20250121054839.1"></t>
<t tx="ekr.20250121054955.1">"""Recursively import all python files in a directory and clean the result."""
@language python
@tabwidth -4 # For a better match.
g.cls()
dir_ = r'C:\Python\Python3.12\Lib\site-packages\manim'
c.recursiveImport(
    dir_=dir_,
    kind = '@clean', # '@auto', '@clean', '@nosent','@file',
    recursive = True,
    safe_at_file = False,
    theTypes = ['.py',],
    verbose = True,
)
if 1:
    last = c.lastTopLevel()
    last.expand()
    if last.hasChildren():
        last.firstChild().expand()
    c.redraw(last)
print('Done')</t>
<t tx="ekr.20250121055447.154">"""
Back up this .leo file.

os.environ['LEO_BACKUP'] must be the path to an existing (writable) directory.
"""
c.backup_helper(sub_dir='ekr-study')
</t>
<t tx="ekr.20250121055447.163">manim

</t>
<t tx="ekr.20250121055447.164" annotate="7d71002858080000007072696f7269747971014d0f27580a000000707269736574646174657102580a000000323032312d30332d33307103752e">@language python

# Recommended plugins, from leoSettings.leo:

plugins_menu.py
# contextmenu.py      # Required by the vim.py and xemacs.py plugins.
mod_scripting.py
nav_qt.py
# Both VR plugins may be enabled.
viewrendered.py
# viewrendered3.py
</t>
<t tx="ekr.20250121055447.2" __bookmarks="7d7100580700000069735f6475706571014930300a732e"></t>
<t tx="ekr.20250122043559.1">The default language if no @language or @comment is in effect.

Valid values are (case is ignored):

actionscript,c,csharp,css,cweb,elisp,html,java,latex,
pascal,perl,perlpod,php,plain,plsql,python,rapidq,rebol,shell,tcltk.</t>
<t tx="ekr.20250122151620.10"># Video qualities
QUALITIES: dict[str, QualityDict] = {
    "fourk_quality": {
        "flag": "k",
        "pixel_height": 2160,
        "pixel_width": 3840,
        "frame_rate": 60,
    },
    "production_quality": {
        "flag": "p",
        "pixel_height": 1440,
        "pixel_width": 2560,
        "frame_rate": 60,
    },
    "high_quality": {
        "flag": "h",
        "pixel_height": 1080,
        "pixel_width": 1920,
        "frame_rate": 60,
    },
    "medium_quality": {
        "flag": "m",
        "pixel_height": 720,
        "pixel_width": 1280,
        "frame_rate": 30,
    },
    "low_quality": {
        "flag": "l",
        "pixel_height": 480,
        "pixel_width": 854,
        "frame_rate": 15,
    },
    "example_quality": {
        "flag": None,
        "pixel_height": 480,
        "pixel_width": 854,
        "frame_rate": 30,
    },
}

DEFAULT_QUALITY = "high_quality"

EPILOG = "Made with &lt;3 by Manim Community developers."
SHIFT_VALUE = 65505
CTRL_VALUE = 65507

CONTEXT_SETTINGS = Context.settings(
    align_option_groups=True,
    align_sections=True,
    show_constraints=True,
)


class RendererType(Enum):
    """An enumeration of all renderer types that can be assigned to
    the ``config.renderer`` attribute.

    Manim's configuration allows assigning string values to the renderer
    setting, the values are then replaced by the corresponding enum object.
    In other words, you can run::

        config.renderer = "opengl"

    and checking the renderer afterwards reveals that the attribute has
    assumed the value::

        &lt;RendererType.OPENGL: 'opengl'&gt;
    """

    CAIRO = "cairo"  #: A renderer based on the cairo backend.
    OPENGL = "opengl"  #: An OpenGL-based renderer.


</t>
<t tx="ekr.20250122151620.100">@property
def frame_height(self) -&gt; float:
    """Frame height in logical units (no flag)."""
    return self._d["frame_height"]

</t>
<t tx="ekr.20250122151620.1000">r"""Mobjects representing tables.

Examples
--------

.. manim:: TableExamples
    :save_last_frame:

    class TableExamples(Scene):
        def construct(self):
            t0 = Table(
                [["First", "Second"],
                ["Third","Fourth"]],
                row_labels=[Text("R1"), Text("R2")],
                col_labels=[Text("C1"), Text("C2")],
                top_left_entry=Text("TOP"))
            t0.add_highlighted_cell((2,2), color=GREEN)
            x_vals = np.linspace(-2,2,5)
            y_vals = np.exp(x_vals)
            t1 = DecimalTable(
                [x_vals, y_vals],
                row_labels=[MathTex("x"), MathTex("f(x)")],
                include_outer_lines=True)
            t1.add(t1.get_cell((2,2), color=RED))
            t2 = MathTable(
                [["+", 0, 5, 10],
                [0, 0, 5, 10],
                [2, 2, 7, 12],
                [4, 4, 9, 14]],
                include_outer_lines=True)
            t2.get_horizontal_lines()[:3].set_color(BLUE)
            t2.get_vertical_lines()[:3].set_color(BLUE)
            t2.get_horizontal_lines()[:3].set_z_index(1)
            cross = VGroup(
                Line(UP + LEFT, DOWN + RIGHT),
                Line(UP + RIGHT, DOWN + LEFT))
            a = Circle().set_color(RED).scale(0.5)
            b = cross.set_color(BLUE).scale(0.5)
            t3 = MobjectTable(
                [[a.copy(),b.copy(),a.copy()],
                [b.copy(),a.copy(),a.copy()],
                [a.copy(),b.copy(),b.copy()]])
            t3.add(Line(
                t3.get_corner(DL), t3.get_corner(UR)
            ).set_color(RED))
            vals = np.arange(1,21).reshape(5,4)
            t4 = IntegerTable(
                vals,
                include_outer_lines=True
            )
            g1 = Group(t0, t1).scale(0.5).arrange(buff=1).to_edge(UP, buff=1)
            g2 = Group(t2, t3, t4).scale(0.5).arrange(buff=1).to_edge(DOWN, buff=1)
            self.add(g1, g2)
"""

from __future__ import annotations

__all__ = [
    "Table",
    "MathTable",
    "MobjectTable",
    "IntegerTable",
    "DecimalTable",
]


import itertools as it
from collections.abc import Iterable, Sequence
from typing import Callable

from manim.mobject.geometry.line import Line
from manim.mobject.geometry.polygram import Polygon
from manim.mobject.geometry.shape_matchers import BackgroundRectangle
from manim.mobject.text.numbers import DecimalNumber, Integer
from manim.mobject.text.tex_mobject import MathTex
from manim.mobject.text.text_mobject import Paragraph

from ..animation.animation import Animation
from ..animation.composition import AnimationGroup
from ..animation.creation import Create, Write
from ..animation.fading import FadeIn
from ..mobject.types.vectorized_mobject import VGroup, VMobject
from ..utils.color import BLACK, YELLOW, ManimColor, ParsableManimColor
from .utils import get_vectorized_mobject_class


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1001">class Table(VGroup):
    @others
</t>
<t tx="ekr.20250122151620.1002">class MathTable(Table):
    """A specialized :class:`~.Table` mobject for use with LaTeX.

    Examples
    --------

    .. manim:: MathTableExample
        :save_last_frame:

        class MathTableExample(Scene):
            def construct(self):
                t0 = MathTable(
                    [["+", 0, 5, 10],
                    [0, 0, 5, 10],
                    [2, 2, 7, 12],
                    [4, 4, 9, 14]],
                    include_outer_lines=True)
                self.add(t0)
    """

    @others
</t>
<t tx="ekr.20250122151620.1003">class MobjectTable(Table):
    """A specialized :class:`~.Table` mobject for use with :class:`~.Mobject`.

    Examples
    --------

    .. manim:: MobjectTableExample
        :save_last_frame:

        class MobjectTableExample(Scene):
            def construct(self):
                cross = VGroup(
                    Line(UP + LEFT, DOWN + RIGHT),
                    Line(UP + RIGHT, DOWN + LEFT),
                )
                a = Circle().set_color(RED).scale(0.5)
                b = cross.set_color(BLUE).scale(0.5)
                t0 = MobjectTable(
                    [[a.copy(),b.copy(),a.copy()],
                    [b.copy(),a.copy(),a.copy()],
                    [a.copy(),b.copy(),b.copy()]]
                )
                line = Line(
                    t0.get_corner(DL), t0.get_corner(UR)
                ).set_color(RED)
                self.add(t0, line)
    """

    @others
</t>
<t tx="ekr.20250122151620.1004">class IntegerTable(Table):
    @others
</t>
<t tx="ekr.20250122151620.1005">class DecimalTable(Table):
    """A specialized :class:`~.Table` mobject for use with :class:`~.DecimalNumber` to display decimal entries.

    Examples
    --------

    .. manim:: DecimalTableExample
        :save_last_frame:

        class DecimalTableExample(Scene):
            def construct(self):
                x_vals = [-2,-1,0,1,2]
                y_vals = np.exp(x_vals)
                t0 = DecimalTable(
                    [x_vals, y_vals],
                    row_labels=[MathTex("x"), MathTex("f(x)=e^{x}")],
                    h_buff=1,
                    element_to_mobject_config={"num_decimal_places": 2})
                self.add(t0)
    """

    @others
</t>
<t tx="ekr.20250122151620.1006">r"""A mobject that displays a table on the screen.

Parameters
----------
table
    A 2D array or list of lists. Content of the table has to be a valid input
    for the callable set in ``element_to_mobject``.
row_labels
    List of :class:`~.VMobject` representing the labels of each row.
col_labels
    List of :class:`~.VMobject` representing the labels of each column.
top_left_entry
    The top-left entry of the table, can only be specified if row and
    column labels are given.
v_buff
    Vertical buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 0.8.
h_buff
    Horizontal buffer passed to :meth:`~.Mobject.arrange_in_grid`, by default 1.3.
include_outer_lines
    ``True`` if the table should include outer lines, by default False.
add_background_rectangles_to_entries
    ``True`` if background rectangles should be added to entries, by default ``False``.
entries_background_color
    Background color of entries if ``add_background_rectangles_to_entries`` is ``True``.
include_background_rectangle
    ``True`` if the table should have a background rectangle, by default ``False``.
background_rectangle_color
    Background color of table if ``include_background_rectangle`` is ``True``.
element_to_mobject
    The :class:`~.Mobject` class applied to the table entries. by default :class:`~.Paragraph`. For common choices, see :mod:`~.text_mobject`/:mod:`~.tex_mobject`.
element_to_mobject_config
    Custom configuration passed to :attr:`element_to_mobject`, by default {}.
arrange_in_grid_config
    Dict passed to :meth:`~.Mobject.arrange_in_grid`, customizes the arrangement of the table.
line_config
    Dict passed to :class:`~.Line`, customizes the lines of the table.
kwargs
    Additional arguments to be passed to :class:`~.VGroup`.

Examples
--------

.. manim:: TableExamples
    :save_last_frame:

    class TableExamples(Scene):
        def construct(self):
            t0 = Table(
                [["This", "is a"],
                ["simple", "Table in \\n Manim."]])
            t1 = Table(
                [["This", "is a"],
                ["simple", "Table."]],
                row_labels=[Text("R1"), Text("R2")],
                col_labels=[Text("C1"), Text("C2")])
            t1.add_highlighted_cell((2,2), color=YELLOW)
            t2 = Table(
                [["This", "is a"],
                ["simple", "Table."]],
                row_labels=[Text("R1"), Text("R2")],
                col_labels=[Text("C1"), Text("C2")],
                top_left_entry=Star().scale(0.3),
                include_outer_lines=True,
                arrange_in_grid_config={"cell_alignment": RIGHT})
            t2.add(t2.get_cell((2,2), color=RED))
            t3 = Table(
                [["This", "is a"],
                ["simple", "Table."]],
                row_labels=[Text("R1"), Text("R2")],
                col_labels=[Text("C1"), Text("C2")],
                top_left_entry=Star().scale(0.3),
                include_outer_lines=True,
                line_config={"stroke_width": 1, "color": YELLOW})
            t3.remove(*t3.get_vertical_lines())
            g = Group(
                t0,t1,t2,t3
            ).scale(0.7).arrange_in_grid(buff=1)
            self.add(g)

.. manim:: BackgroundRectanglesExample
    :save_last_frame:

    class BackgroundRectanglesExample(Scene):
        def construct(self):
            background = Rectangle(height=6.5, width=13)
            background.set_fill(opacity=.5)
            background.set_color([TEAL, RED, YELLOW])
            self.add(background)
            t0 = Table(
                [["This", "is a"],
                ["simple", "Table."]],
                add_background_rectangles_to_entries=True)
            t1 = Table(
                [["This", "is a"],
                ["simple", "Table."]],
                include_background_rectangle=True)
            g = Group(t0, t1).scale(0.7).arrange(buff=0.5)
            self.add(g)
"""

def __init__(
    self,
    table: Iterable[Iterable[float | str | VMobject]],
    row_labels: Iterable[VMobject] | None = None,
    col_labels: Iterable[VMobject] | None = None,
    top_left_entry: VMobject | None = None,
    v_buff: float = 0.8,
    h_buff: float = 1.3,
    include_outer_lines: bool = False,
    add_background_rectangles_to_entries: bool = False,
    entries_background_color: ParsableManimColor = BLACK,
    include_background_rectangle: bool = False,
    background_rectangle_color: ParsableManimColor = BLACK,
    element_to_mobject: Callable[
        [float | str | VMobject],
        VMobject,
    ] = Paragraph,
    element_to_mobject_config: dict = {},
    arrange_in_grid_config: dict = {},
    line_config: dict = {},
    **kwargs,
):
    self.row_labels = row_labels
    self.col_labels = col_labels
    self.top_left_entry = top_left_entry
    self.row_dim = len(table)
    self.col_dim = len(table[0])
    self.v_buff = v_buff
    self.h_buff = h_buff
    self.include_outer_lines = include_outer_lines
    self.add_background_rectangles_to_entries = add_background_rectangles_to_entries
    self.entries_background_color = ManimColor(entries_background_color)
    self.include_background_rectangle = include_background_rectangle
    self.background_rectangle_color = ManimColor(background_rectangle_color)
    self.element_to_mobject = element_to_mobject
    self.element_to_mobject_config = element_to_mobject_config
    self.arrange_in_grid_config = arrange_in_grid_config
    self.line_config = line_config

    for row in table:
        if len(row) == len(table[0]):
            pass
        else:
            raise ValueError("Not all rows in table have the same length.")

    super().__init__(**kwargs)
    mob_table = self._table_to_mob_table(table)
    self.elements_without_labels = VGroup(*it.chain(*mob_table))
    mob_table = self._add_labels(mob_table)
    self._organize_mob_table(mob_table)
    self.elements = VGroup(*it.chain(*mob_table))

    if len(self.elements[0].get_all_points()) == 0:
        self.elements.remove(self.elements[0])

    self.add(self.elements)
    self.center()
    self.mob_table = mob_table
    self._add_horizontal_lines()
    self._add_vertical_lines()
    if self.add_background_rectangles_to_entries:
        self.add_background_to_entries(color=self.entries_background_color)
    if self.include_background_rectangle:
        self.add_background_rectangle(color=self.background_rectangle_color)

</t>
<t tx="ekr.20250122151620.1007">def _table_to_mob_table(
    self,
    table: Iterable[Iterable[float | str | VMobject]],
) -&gt; list:
    """Initilaizes the entries of ``table`` as :class:`~.VMobject`.

    Parameters
    ----------
    table
        A 2D array or list of lists. Content of the table has to be a valid input
        for the callable set in ``element_to_mobject``.

    Returns
    --------
    List
        List of :class:`~.VMobject` from the entries of ``table``.
    """
    return [
        [
            self.element_to_mobject(item, **self.element_to_mobject_config)
            for item in row
        ]
        for row in table
    ]

</t>
<t tx="ekr.20250122151620.1008">def _organize_mob_table(self, table: Iterable[Iterable[VMobject]]) -&gt; VGroup:
    """Arranges the :class:`~.VMobject` of ``table`` in a grid.

    Parameters
    ----------
    table
        A 2D iterable object with :class:`~.VMobject` entries.

    Returns
    --------
    :class:`~.VGroup`
        The :class:`~.VMobject` of the ``table`` in a :class:`~.VGroup` already
        arranged in a table-like grid.
    """
    help_table = VGroup()
    for i, row in enumerate(table):
        for j, _ in enumerate(row):
            help_table.add(table[i][j])
    help_table.arrange_in_grid(
        rows=len(table),
        cols=len(table[0]),
        buff=(self.h_buff, self.v_buff),
        **self.arrange_in_grid_config,
    )
    return help_table

</t>
<t tx="ekr.20250122151620.1009">def _add_labels(self, mob_table: VGroup) -&gt; VGroup:
    """Adds labels to an in a grid arranged :class:`~.VGroup`.

    Parameters
    ----------
    mob_table
        An in a grid organized class:`~.VGroup`.

    Returns
    --------
    :class:`~.VGroup`
        Returns the ``mob_table`` with added labels.
    """
    if self.row_labels is not None:
        for k in range(len(self.row_labels)):
            mob_table[k] = [self.row_labels[k]] + mob_table[k]
    if self.col_labels is not None:
        if self.row_labels is not None:
            if self.top_left_entry is not None:
                col_labels = [self.top_left_entry] + self.col_labels
                mob_table.insert(0, col_labels)
            else:
                # Placeholder to use arrange_in_grid if top_left_entry is not set.
                # Import OpenGLVMobject to work with --renderer=opengl
                dummy_mobject = get_vectorized_mobject_class()()
                col_labels = [dummy_mobject] + self.col_labels
                mob_table.insert(0, col_labels)
        else:
            mob_table.insert(0, self.col_labels)
    return mob_table

</t>
<t tx="ekr.20250122151620.101">@frame_height.setter
def frame_height(self, value: float) -&gt; None:
    self._d.__setitem__("frame_height", value)

</t>
<t tx="ekr.20250122151620.1010">def _add_horizontal_lines(self) -&gt; Table:
    """Adds the horizontal lines to the table."""
    anchor_left = self.get_left()[0] - 0.5 * self.h_buff
    anchor_right = self.get_right()[0] + 0.5 * self.h_buff
    line_group = VGroup()
    if self.include_outer_lines:
        anchor = self.get_rows()[0].get_top()[1] + 0.5 * self.v_buff
        line = Line(
            [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config
        )
        line_group.add(line)
        self.add(line)
        anchor = self.get_rows()[-1].get_bottom()[1] - 0.5 * self.v_buff
        line = Line(
            [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config
        )
        line_group.add(line)
        self.add(line)
    for k in range(len(self.mob_table) - 1):
        anchor = self.get_rows()[k + 1].get_top()[1] + 0.5 * (
            self.get_rows()[k].get_bottom()[1] - self.get_rows()[k + 1].get_top()[1]
        )
        line = Line(
            [anchor_left, anchor, 0], [anchor_right, anchor, 0], **self.line_config
        )
        line_group.add(line)
        self.add(line)
    self.horizontal_lines = line_group
    return self

</t>
<t tx="ekr.20250122151620.1011">def _add_vertical_lines(self) -&gt; Table:
    """Adds the vertical lines to the table"""
    anchor_top = self.get_rows().get_top()[1] + 0.5 * self.v_buff
    anchor_bottom = self.get_rows().get_bottom()[1] - 0.5 * self.v_buff
    line_group = VGroup()
    if self.include_outer_lines:
        anchor = self.get_columns()[0].get_left()[0] - 0.5 * self.h_buff
        line = Line(
            [anchor, anchor_top, 0], [anchor, anchor_bottom, 0], **self.line_config
        )
        line_group.add(line)
        self.add(line)
        anchor = self.get_columns()[-1].get_right()[0] + 0.5 * self.h_buff
        line = Line(
            [anchor, anchor_top, 0], [anchor, anchor_bottom, 0], **self.line_config
        )
        line_group.add(line)
        self.add(line)
    for k in range(len(self.mob_table[0]) - 1):
        anchor = self.get_columns()[k + 1].get_left()[0] + 0.5 * (
            self.get_columns()[k].get_right()[0]
            - self.get_columns()[k + 1].get_left()[0]
        )
        line = Line(
            [anchor, anchor_bottom, 0], [anchor, anchor_top, 0], **self.line_config
        )
        line_group.add(line)
        self.add(line)
    self.vertical_lines = line_group
    return self

</t>
<t tx="ekr.20250122151620.1012">def get_horizontal_lines(self) -&gt; VGroup:
    """Return the horizontal lines of the table.

    Returns
    --------
    :class:`~.VGroup`
        :class:`~.VGroup` containing all the horizontal lines of the table.

    Examples
    --------

    .. manim:: GetHorizontalLinesExample
        :save_last_frame:

        class GetHorizontalLinesExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                table.get_horizontal_lines().set_color(RED)
                self.add(table)
    """
    return self.horizontal_lines

</t>
<t tx="ekr.20250122151620.1013">def get_vertical_lines(self) -&gt; VGroup:
    """Return the vertical lines of the table.

    Returns
    --------
    :class:`~.VGroup`
        :class:`~.VGroup` containing all the vertical lines of the table.

    Examples
    --------

    .. manim:: GetVerticalLinesExample
        :save_last_frame:

        class GetVerticalLinesExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                table.get_vertical_lines()[0].set_color(RED)
                self.add(table)
    """
    return self.vertical_lines

</t>
<t tx="ekr.20250122151620.1014">def get_columns(self) -&gt; VGroup:
    """Return columns of the table as a :class:`~.VGroup` of :class:`~.VGroup`.

    Returns
    --------
    :class:`~.VGroup`
        :class:`~.VGroup` containing each column in a :class:`~.VGroup`.

    Examples
    --------

    .. manim:: GetColumnsExample
        :save_last_frame:

        class GetColumnsExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                table.add(SurroundingRectangle(table.get_columns()[1]))
                self.add(table)
    """
    return VGroup(
        *(
            VGroup(*(row[i] for row in self.mob_table))
            for i in range(len(self.mob_table[0]))
        )
    )

</t>
<t tx="ekr.20250122151620.1015">def get_rows(self) -&gt; VGroup:
    """Return the rows of the table as a :class:`~.VGroup` of :class:`~.VGroup`.

    Returns
    --------
    :class:`~.VGroup`
        :class:`~.VGroup` containing each row in a :class:`~.VGroup`.

    Examples
    --------

    .. manim:: GetRowsExample
        :save_last_frame:

        class GetRowsExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                table.add(SurroundingRectangle(table.get_rows()[1]))
                self.add(table)
    """
    return VGroup(*(VGroup(*row) for row in self.mob_table))

</t>
<t tx="ekr.20250122151620.1016">def set_column_colors(self, *colors: Iterable[ParsableManimColor]) -&gt; Table:
    """Set individual colors for each column of the table.

    Parameters
    ----------
    colors
        An iterable of colors; each color corresponds to a column.

    Examples
    --------

    .. manim:: SetColumnColorsExample
        :save_last_frame:

        class SetColumnColorsExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")]
                ).set_column_colors([RED,BLUE], GREEN)
                self.add(table)
    """
    columns = self.get_columns()
    for color, column in zip(colors, columns):
        column.set_color(color)
    return self

</t>
<t tx="ekr.20250122151620.1017">def set_row_colors(self, *colors: Iterable[ParsableManimColor]) -&gt; Table:
    """Set individual colors for each row of the table.

    Parameters
    ----------
    colors
        An iterable of colors; each color corresponds to a row.

    Examples
    --------

    .. manim:: SetRowColorsExample
        :save_last_frame:

        class SetRowColorsExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")]
                ).set_row_colors([RED,BLUE], GREEN)
                self.add(table)
    """
    rows = self.get_rows()
    for color, row in zip(colors, rows):
        row.set_color(color)
    return self

</t>
<t tx="ekr.20250122151620.1018">def get_entries(
    self,
    pos: Sequence[int] | None = None,
) -&gt; VMobject | VGroup:
    """Return the individual entries of the table (including labels) or one specific entry
    if the parameter, ``pos``,  is set.

    Parameters
    ----------
    pos
        The position of a specific entry on the table. ``(1,1)`` being the top left entry
        of the table.

    Returns
    -------
    Union[:class:`~.VMobject`, :class:`~.VGroup`]
        :class:`~.VGroup` containing all entries of the table (including labels)
        or the :class:`~.VMobject` at the given position if ``pos`` is set.

    Examples
    --------

    .. manim:: GetEntriesExample
        :save_last_frame:

        class GetEntriesExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                ent = table.get_entries()
                for item in ent:
                    item.set_color(random_bright_color())
                table.get_entries((2,2)).rotate(PI)
                self.add(table)
    """
    if pos is not None:
        if (
            self.row_labels is not None
            and self.col_labels is not None
            and self.top_left_entry is None
        ):
            index = len(self.mob_table[0]) * (pos[0] - 1) + pos[1] - 2
            return self.elements[index]
        else:
            index = len(self.mob_table[0]) * (pos[0] - 1) + pos[1] - 1
            return self.elements[index]
    else:
        return self.elements

</t>
<t tx="ekr.20250122151620.1019">def get_entries_without_labels(
    self,
    pos: Sequence[int] | None = None,
) -&gt; VMobject | VGroup:
    """Return the individual entries of the table (without labels) or one specific entry
    if the parameter, ``pos``, is set.

    Parameters
    ----------
    pos
        The position of a specific entry on the table. ``(1,1)`` being the top left entry
        of the table (without labels).

    Returns
    -------
    Union[:class:`~.VMobject`, :class:`~.VGroup`]
        :class:`~.VGroup` containing all entries of the table (without labels)
        or the :class:`~.VMobject` at the given position if ``pos`` is set.

    Examples
    --------

    .. manim:: GetEntriesWithoutLabelsExample
        :save_last_frame:

        class GetEntriesWithoutLabelsExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                ent = table.get_entries_without_labels()
                colors = [BLUE, GREEN, YELLOW, RED]
                for k in range(len(colors)):
                    ent[k].set_color(colors[k])
                table.get_entries_without_labels((2,2)).rotate(PI)
                self.add(table)
    """
    if pos is not None:
        index = self.col_dim * (pos[0] - 1) + pos[1] - 1
        return self.elements_without_labels[index]
    else:
        return self.elements_without_labels

</t>
<t tx="ekr.20250122151620.102">@property
def frame_width(self) -&gt; float:
    """Frame width in logical units (no flag)."""
    return self._d["frame_width"]

</t>
<t tx="ekr.20250122151620.1020">def get_row_labels(self) -&gt; VGroup:
    """Return the row labels of the table.

    Returns
    -------
    :class:`~.VGroup`
        :class:`~.VGroup` containing the row labels of the table.

    Examples
    --------

    .. manim:: GetRowLabelsExample
        :save_last_frame:

        class GetRowLabelsExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                lab = table.get_row_labels()
                for item in lab:
                    item.set_color(random_bright_color())
                self.add(table)
    """
    return VGroup(*self.row_labels)

</t>
<t tx="ekr.20250122151620.1021">def get_col_labels(self) -&gt; VGroup:
    """Return the column labels of the table.

    Returns
    --------
    :class:`~.VGroup`
        VGroup containing the column labels of the table.

    Examples
    --------

    .. manim:: GetColLabelsExample
        :save_last_frame:

        class GetColLabelsExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                lab = table.get_col_labels()
                for item in lab:
                    item.set_color(random_bright_color())
                self.add(table)
    """
    return VGroup(*self.col_labels)

</t>
<t tx="ekr.20250122151620.1022">def get_labels(self) -&gt; VGroup:
    """Returns the labels of the table.

    Returns
    --------
    :class:`~.VGroup`
        :class:`~.VGroup` containing all the labels of the table.

    Examples
    --------

    .. manim:: GetLabelsExample
        :save_last_frame:

        class GetLabelsExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                lab = table.get_labels()
                colors = [BLUE, GREEN, YELLOW, RED]
                for k in range(len(colors)):
                    lab[k].set_color(colors[k])
                self.add(table)
    """
    label_group = VGroup()
    if self.top_left_entry is not None:
        label_group.add(self.top_left_entry)
    for label in (self.col_labels, self.row_labels):
        if label is not None:
            label_group.add(*label)
    return label_group

</t>
<t tx="ekr.20250122151620.1023">def add_background_to_entries(self, color: ParsableManimColor = BLACK) -&gt; Table:
    """Adds a black :class:`~.BackgroundRectangle` to each entry of the table."""
    for mob in self.get_entries():
        mob.add_background_rectangle(color=ManimColor(color))
    return self

</t>
<t tx="ekr.20250122151620.1024">def get_cell(self, pos: Sequence[int] = (1, 1), **kwargs) -&gt; Polygon:
    """Returns one specific cell as a rectangular :class:`~.Polygon` without the entry.

    Parameters
    ----------
    pos
        The position of a specific entry on the table. ``(1,1)`` being the top left entry
        of the table.
    kwargs
        Additional arguments to be passed to :class:`~.Polygon`.

    Returns
    -------
    :class:`~.Polygon`
        Polygon mimicking one specific cell of the Table.

    Examples
    --------

    .. manim:: GetCellExample
        :save_last_frame:

        class GetCellExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                cell = table.get_cell((2,2), color=RED)
                self.add(table, cell)
    """
    row = self.get_rows()[pos[0] - 1]
    col = self.get_columns()[pos[1] - 1]
    edge_UL = [
        col.get_left()[0] - self.h_buff / 2,
        row.get_top()[1] + self.v_buff / 2,
        0,
    ]
    edge_UR = [
        col.get_right()[0] + self.h_buff / 2,
        row.get_top()[1] + self.v_buff / 2,
        0,
    ]
    edge_DL = [
        col.get_left()[0] - self.h_buff / 2,
        row.get_bottom()[1] - self.v_buff / 2,
        0,
    ]
    edge_DR = [
        col.get_right()[0] + self.h_buff / 2,
        row.get_bottom()[1] - self.v_buff / 2,
        0,
    ]
    rec = Polygon(edge_UL, edge_UR, edge_DR, edge_DL, **kwargs)
    return rec

</t>
<t tx="ekr.20250122151620.1025">def get_highlighted_cell(
    self, pos: Sequence[int] = (1, 1), color: ParsableManimColor = YELLOW, **kwargs
</t>
<t tx="ekr.20250122151620.1026">) -&gt; BackgroundRectangle:
    """Returns a :class:`~.BackgroundRectangle` of the cell at the given position.

    Parameters
    ----------
    pos
        The position of a specific entry on the table. ``(1,1)`` being the top left entry
        of the table.
    color
        The color used to highlight the cell.
    kwargs
        Additional arguments to be passed to :class:`~.BackgroundRectangle`.

    Examples
    --------

    .. manim:: GetHighlightedCellExample
        :save_last_frame:

        class GetHighlightedCellExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                highlight = table.get_highlighted_cell((2,2), color=GREEN)
                table.add_to_back(highlight)
                self.add(table)
    """
    cell = self.get_cell(pos)
    bg_cell = BackgroundRectangle(cell, color=ManimColor(color), **kwargs)
    return bg_cell

def add_highlighted_cell(
    self, pos: Sequence[int] = (1, 1), color: ParsableManimColor = YELLOW, **kwargs
</t>
<t tx="ekr.20250122151620.1027">) -&gt; Table:
    """Highlights one cell at a specific position on the table by adding a :class:`~.BackgroundRectangle`.

    Parameters
    ----------
    pos
        The position of a specific entry on the table. ``(1,1)`` being the top left entry
        of the table.
    color
        The color used to highlight the cell.
    kwargs
        Additional arguments to be passed to :class:`~.BackgroundRectangle`.

    Examples
    --------

    .. manim:: AddHighlightedCellExample
        :save_last_frame:

        class AddHighlightedCellExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")])
                table.add_highlighted_cell((2,2), color=GREEN)
                self.add(table)
    """
    bg_cell = self.get_highlighted_cell(pos, color=ManimColor(color), **kwargs)
    self.add_to_back(bg_cell)
    entry = self.get_entries(pos)
    entry.background_rectangle = bg_cell
    return self

def create(
    self,
    lag_ratio: float = 1,
    line_animation: Callable[[VMobject | VGroup], Animation] = Create,
    label_animation: Callable[[VMobject | VGroup], Animation] = Write,
    element_animation: Callable[[VMobject | VGroup], Animation] = Create,
    entry_animation: Callable[[VMobject | VGroup], Animation] = FadeIn,
    **kwargs,
) -&gt; AnimationGroup:
    """Customized create-type function for tables.

    Parameters
    ----------
    lag_ratio
        The lag ratio of the animation.
    line_animation
        The animation style of the table lines, see :mod:`~.creation` for examples.
    label_animation
        The animation style of the table labels, see :mod:`~.creation` for examples.
    element_animation
        The animation style of the table elements, see :mod:`~.creation` for examples.
    entry_animation
        The entry animation of the table background, see :mod:`~.creation` for examples.
    kwargs
        Further arguments passed to the creation animations.

    Returns
    -------
    :class:`~.AnimationGroup`
        AnimationGroup containing creation of the lines and of the elements.

    Examples
    --------

    .. manim:: CreateTableExample

        class CreateTableExample(Scene):
            def construct(self):
                table = Table(
                    [["First", "Second"],
                    ["Third","Fourth"]],
                    row_labels=[Text("R1"), Text("R2")],
                    col_labels=[Text("C1"), Text("C2")],
                    include_outer_lines=True)
                self.play(table.create())
                self.wait()
    """
    animations: Sequence[Animation] = [
        line_animation(
            VGroup(self.vertical_lines, self.horizontal_lines),
            **kwargs,
        ),
        element_animation(self.elements_without_labels.set_z_index(2), **kwargs),
    ]

    if self.get_labels():
        animations += [
            label_animation(self.get_labels(), **kwargs),
        ]

    if self.get_entries():
        for entry in self.elements_without_labels:
            try:
                animations += [
                    entry_animation(
                        entry.background_rectangle,
                        **kwargs,
                    )
                ]
            except AttributeError:
                continue

    return AnimationGroup(*animations, lag_ratio=lag_ratio)

</t>
<t tx="ekr.20250122151620.1028">def scale(self, scale_factor: float, **kwargs):
    # h_buff and v_buff must be adjusted so that Table.get_cell
    # can construct an accurate polygon for a cell.
    self.h_buff *= scale_factor
    self.v_buff *= scale_factor
    super().scale(scale_factor, **kwargs)
    return self


</t>
<t tx="ekr.20250122151620.1029">def __init__(
    self,
    table: Iterable[Iterable[float | str]],
    element_to_mobject: Callable[[float | str], VMobject] = MathTex,
    **kwargs,
):
    """
    Special case of :class:`~.Table` with `element_to_mobject` set to :class:`~.MathTex`.
    Every entry in `table` is set in a Latex `align` environment.

    Parameters
    ----------
    table
        A 2d array or list of lists. Content of the table have to be valid input
        for :class:`~.MathTex`.
    element_to_mobject
        The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.MathTex`.
    kwargs
        Additional arguments to be passed to :class:`~.Table`.
    """
    super().__init__(
        table,
        element_to_mobject=element_to_mobject,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.103">@frame_width.setter
def frame_width(self, value: float) -&gt; None:
    self._d.__setitem__("frame_width", value)

</t>
<t tx="ekr.20250122151620.1030">def __init__(
    self,
    table: Iterable[Iterable[VMobject]],
    element_to_mobject: Callable[[VMobject], VMobject] = lambda m: m,
    **kwargs,
):
    """
    Special case of :class:`~.Table` with ``element_to_mobject`` set to an identity function.
    Here, every item in ``table`` must already be of type :class:`~.Mobject`.

    Parameters
    ----------
    table
        A 2D array or list of lists. Content of the table must be of type :class:`~.Mobject`.
    element_to_mobject
        The :class:`~.Mobject` class applied to the table entries. Set as ``lambda m : m`` to return itself.
    kwargs
        Additional arguments to be passed to :class:`~.Table`.
    """
    super().__init__(table, element_to_mobject=element_to_mobject, **kwargs)


</t>
<t tx="ekr.20250122151620.1031">r"""A specialized :class:`~.Table` mobject for use with :class:`~.Integer`.

Examples
--------

.. manim:: IntegerTableExample
    :save_last_frame:

    class IntegerTableExample(Scene):
        def construct(self):
            t0 = IntegerTable(
                [[0,30,45,60,90],
                [90,60,45,30,0]],
                col_labels=[
                    MathTex(r"\frac{\sqrt{0}}{2}"),
                    MathTex(r"\frac{\sqrt{1}}{2}"),
                    MathTex(r"\frac{\sqrt{2}}{2}"),
                    MathTex(r"\frac{\sqrt{3}}{2}"),
                    MathTex(r"\frac{\sqrt{4}}{2}")],
                row_labels=[MathTex(r"\sin"), MathTex(r"\cos")],
                h_buff=1,
                element_to_mobject_config={"unit": r"^{\circ}"})
            self.add(t0)
"""

def __init__(
    self,
    table: Iterable[Iterable[float | str]],
    element_to_mobject: Callable[[float | str], VMobject] = Integer,
    **kwargs,
):
    """
    Special case of :class:`~.Table` with `element_to_mobject` set to :class:`~.Integer`.
    Will round if there are decimal entries in the table.

    Parameters
    ----------
    table
        A 2d array or list of lists. Content of the table has to be valid input
        for :class:`~.Integer`.
    element_to_mobject
        The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.Integer`.
    kwargs
        Additional arguments to be passed to :class:`~.Table`.
    """
    super().__init__(table, element_to_mobject=element_to_mobject, **kwargs)


</t>
<t tx="ekr.20250122151620.1032">def __init__(
    self,
    table: Iterable[Iterable[float | str]],
    element_to_mobject: Callable[[float | str], VMobject] = DecimalNumber,
    element_to_mobject_config: dict = {"num_decimal_places": 1},
    **kwargs,
):
    """
    Special case of :class:`~.Table` with ``element_to_mobject`` set to :class:`~.DecimalNumber`.
    By default, ``num_decimal_places`` is set to 1.
    Will round/truncate the decimal places based on the provided ``element_to_mobject_config``.

    Parameters
    ----------
    table
        A 2D array, or a list of lists. Content of the table must be valid input
        for :class:`~.DecimalNumber`.
    element_to_mobject
        The :class:`~.Mobject` class applied to the table entries. Set as :class:`~.DecimalNumber`.
    element_to_mobject_config
        Element to mobject config, here set as {"num_decimal_places": 1}.
    kwargs
        Additional arguments to be passed to :class:`~.Table`.
    """
    super().__init__(
        table,
        element_to_mobject=element_to_mobject,
        element_to_mobject_config=element_to_mobject_config,
        **kwargs,
    )
</t>
<t tx="ekr.20250122151620.1033">"""Utilities for working with mobjects."""

from __future__ import annotations

__all__ = [
    "get_mobject_class",
    "get_point_mobject_class",
    "get_vectorized_mobject_class",
]

from .._config import config
from ..constants import RendererType
from .mobject import Mobject
from .opengl.opengl_mobject import OpenGLMobject
from .opengl.opengl_point_cloud_mobject import OpenGLPMobject
from .opengl.opengl_vectorized_mobject import OpenGLVMobject
from .types.point_cloud_mobject import PMobject
from .types.vectorized_mobject import VMobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1034">def get_mobject_class() -&gt; type:
    """Gets the base mobject class, depending on the currently active renderer.

    .. NOTE::

        This method is intended to be used in the code base of Manim itself
        or in plugins where code should work independent of the selected
        renderer.

    Examples
    --------

    The function has to be explicitly imported. We test that
    the name of the returned class is one of the known mobject
    base classes::

        &gt;&gt;&gt; from manim.mobject.utils import get_mobject_class
        &gt;&gt;&gt; get_mobject_class().__name__ in ['Mobject', 'OpenGLMobject']
        True
    """
    if config.renderer == RendererType.CAIRO:
        return Mobject
    if config.renderer == RendererType.OPENGL:
        return OpenGLMobject
    raise NotImplementedError(
        "Base mobjects are not implemented for the active renderer."
    )


</t>
<t tx="ekr.20250122151620.1035">def get_vectorized_mobject_class() -&gt; type:
    """Gets the vectorized mobject class, depending on the currently
    active renderer.

    .. NOTE::

        This method is intended to be used in the code base of Manim itself
        or in plugins where code should work independent of the selected
        renderer.

    Examples
    --------

    The function has to be explicitly imported. We test that
    the name of the returned class is one of the known mobject
    base classes::

        &gt;&gt;&gt; from manim.mobject.utils import get_vectorized_mobject_class
        &gt;&gt;&gt; get_vectorized_mobject_class().__name__ in ['VMobject', 'OpenGLVMobject']
        True
    """
    if config.renderer == RendererType.CAIRO:
        return VMobject
    if config.renderer == RendererType.OPENGL:
        return OpenGLVMobject
    raise NotImplementedError(
        "Vectorized mobjects are not implemented for the active renderer."
    )


</t>
<t tx="ekr.20250122151620.1036">def get_point_mobject_class() -&gt; type:
    """Gets the point cloud mobject class, depending on the currently
    active renderer.

    .. NOTE::

        This method is intended to be used in the code base of Manim itself
        or in plugins where code should work independent of the selected
        renderer.

    Examples
    --------

    The function has to be explicitly imported. We test that
    the name of the returned class is one of the known mobject
    base classes::

        &gt;&gt;&gt; from manim.mobject.utils import get_point_mobject_class
        &gt;&gt;&gt; get_point_mobject_class().__name__ in ['PMobject', 'OpenGLPMobject']
        True
    """
    if config.renderer == RendererType.CAIRO:
        return PMobject
    if config.renderer == RendererType.OPENGL:
        return OpenGLPMobject
    raise NotImplementedError(
        "Point cloud mobjects are not implemented for the active renderer."
    )
</t>
<t tx="ekr.20250122151620.1037">"""Simple mobjects that can be used for storing (and updating) a value."""

from __future__ import annotations

__all__ = ["ValueTracker", "ComplexValueTracker"]


import numpy as np

from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.utils.paths import straight_path


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1038">class ValueTracker(Mobject, metaclass=ConvertToOpenGL):
    """A mobject that can be used for tracking (real-valued) parameters.
    Useful for animating parameter changes.

    Not meant to be displayed.  Instead the position encodes some
    number, often one which another animation or continual_animation
    uses for its update function, and by treating it as a mobject it can
    still be animated and manipulated just like anything else.

    This value changes continuously when animated using the :attr:`animate` syntax.

    Examples
    --------
    .. manim:: ValueTrackerExample

        class ValueTrackerExample(Scene):
            def construct(self):
                number_line = NumberLine()
                pointer = Vector(DOWN)
                label = MathTex("x").add_updater(lambda m: m.next_to(pointer, UP))

                tracker = ValueTracker(0)
                pointer.add_updater(
                    lambda m: m.next_to(
                                number_line.n2p(tracker.get_value()),
                                UP
                            )
                )
                self.add(number_line, pointer,label)
                tracker += 1.5
                self.wait(1)
                tracker -= 4
                self.wait(0.5)
                self.play(tracker.animate.set_value(5))
                self.wait(0.5)
                self.play(tracker.animate.set_value(3))
                self.play(tracker.animate.increment_value(-2))
                self.wait(0.5)

    .. note::

        You can also link ValueTrackers to updaters. In this case, you have to make sure that the
        ValueTracker is added to the scene by ``add``

    .. manim:: ValueTrackerExample

        class ValueTrackerExample(Scene):
            def construct(self):
                tracker = ValueTracker(0)
                label = Dot(radius=3).add_updater(lambda x : x.set_x(tracker.get_value()))
                self.add(label)
                self.add(tracker)
                tracker.add_updater(lambda mobject, dt: mobject.increment_value(dt))
                self.wait(2)

    """

    @others
</t>
<t tx="ekr.20250122151620.1039">class ComplexValueTracker(ValueTracker):
    """Tracks a complex-valued parameter.

    When the value is set through :attr:`animate`, the value will take a straight path from the
    source point to the destination point.

    Examples
    --------
    .. manim:: ComplexValueTrackerExample

        class ComplexValueTrackerExample(Scene):
            def construct(self):
                tracker = ComplexValueTracker(-2+1j)
                dot = Dot().add_updater(
                    lambda x: x.move_to(tracker.points)
                )

                self.add(NumberPlane(), dot)

                self.play(tracker.animate.set_value(3+2j))
                self.play(tracker.animate.set_value(tracker.get_value() * 1j))
                self.play(tracker.animate.set_value(tracker.get_value() - 2j))
                self.play(tracker.animate.set_value(tracker.get_value() / (-2 + 3j)))
    """

    @others
</t>
<t tx="ekr.20250122151620.104">@property
def frame_y_radius(self) -&gt; float:
    """Half the frame height (no flag)."""
    return self._d["frame_height"] / 2

</t>
<t tx="ekr.20250122151620.1040">def __init__(self, value=0, **kwargs):
    super().__init__(**kwargs)
    self.set(points=np.zeros((1, 3)))
    self.set_value(value)

</t>
<t tx="ekr.20250122151620.1041">def get_value(self) -&gt; float:
    """Get the current value of this ValueTracker."""
    return self.points[0, 0]

</t>
<t tx="ekr.20250122151620.1042">def set_value(self, value: float):
    """Sets a new scalar value to the ValueTracker"""
    self.points[0, 0] = value
    return self

</t>
<t tx="ekr.20250122151620.1043">def increment_value(self, d_value: float):
    """Increments (adds) a scalar value  to the ValueTracker"""
    self.set_value(self.get_value() + d_value)
    return self

</t>
<t tx="ekr.20250122151620.1044">def __bool__(self):
    """Return whether the value of this value tracker evaluates as true."""
    return bool(self.get_value())

</t>
<t tx="ekr.20250122151620.1045">def __iadd__(self, d_value: float):
    """adds ``+=`` syntax to increment the value of the ValueTracker"""
    self.increment_value(d_value)
    return self

</t>
<t tx="ekr.20250122151620.1046">def __ifloordiv__(self, d_value: float):
    """Set the value of this value tracker to the floor division of the current value by ``d_value``."""
    self.set_value(self.get_value() // d_value)
    return self

</t>
<t tx="ekr.20250122151620.1047">def __imod__(self, d_value: float):
    """Set the value of this value tracker to the current value modulo ``d_value``."""
    self.set_value(self.get_value() % d_value)
    return self

</t>
<t tx="ekr.20250122151620.1048">def __imul__(self, d_value: float):
    """Set the value of this value tracker to the product of the current value and ``d_value``."""
    self.set_value(self.get_value() * d_value)
    return self

</t>
<t tx="ekr.20250122151620.1049">def __ipow__(self, d_value: float):
    """Set the value of this value tracker to the current value raised to the power of ``d_value``."""
    self.set_value(self.get_value() ** d_value)
    return self

</t>
<t tx="ekr.20250122151620.105">@frame_y_radius.setter
def frame_y_radius(self, value: float) -&gt; None:
    self._d.__setitem__("frame_y_radius", value) or self._d.__setitem__(
        "frame_height", 2 * value
    )

</t>
<t tx="ekr.20250122151620.1050">def __isub__(self, d_value: float):
    """adds ``-=`` syntax to decrement the value of the ValueTracker"""
    self.increment_value(-d_value)
    return self

</t>
<t tx="ekr.20250122151620.1051">def __itruediv__(self, d_value: float):
    """Sets the value of this value tracker to the current value divided by ``d_value``."""
    self.set_value(self.get_value() / d_value)
    return self

</t>
<t tx="ekr.20250122151620.1052">def interpolate(self, mobject1, mobject2, alpha, path_func=straight_path()):
    """
    Turns self into an interpolation between mobject1
    and mobject2.
    """
    self.set(points=path_func(mobject1.points, mobject2.points, alpha))
    return self


</t>
<t tx="ekr.20250122151620.1053">def get_value(self):
    """Get the current value of this value tracker as a complex number.

    The value is internally stored as a points array [a, b, 0]. This can be accessed directly
    to represent the value geometrically, see the usage example.
    """
    return complex(*self.points[0, :2])

</t>
<t tx="ekr.20250122151620.1054">def set_value(self, z):
    """Sets a new complex value to the ComplexValueTracker"""
    z = complex(z)
    self.points[0, :2] = (z.real, z.imag)
    return self
</t>
<t tx="ekr.20250122151620.1055">"""Mobjects representing vector fields."""

from __future__ import annotations

__all__ = [
    "VectorField",
    "ArrowVectorField",
    "StreamLines",
]

import itertools as it
import random
from collections.abc import Iterable, Sequence
from math import ceil, floor
from typing import Callable

import numpy as np
from PIL import Image

from manim.animation.updaters.update import UpdateFromAlphaFunc
from manim.mobject.geometry.line import Vector
from manim.mobject.graphing.coordinate_systems import CoordinateSystem

from .. import config
from ..animation.composition import AnimationGroup, Succession
from ..animation.creation import Create
from ..animation.indication import ShowPassingFlash
from ..constants import OUT, RIGHT, UP, RendererType
from ..mobject.mobject import Mobject
from ..mobject.types.vectorized_mobject import VGroup
from ..mobject.utils import get_vectorized_mobject_class
from ..utils.bezier import interpolate, inverse_interpolate
from ..utils.color import (
    BLUE_E,
    GREEN,
    RED,
    YELLOW,
    ManimColor,
    ParsableManimColor,
    color_to_rgb,
    rgb_to_color,
)
from ..utils.rate_functions import ease_out_sine, linear
from ..utils.simple_functions import sigmoid

DEFAULT_SCALAR_FIELD_COLORS: list = [BLUE_E, GREEN, YELLOW, RED]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1056">class VectorField(VGroup):
    """A vector field.

    Vector fields are based on a function defining a vector at every position.
    This class does by default not include any visible elements but provides
    methods to move other :class:`~.Mobject` s along the vector field.

    Parameters
    ----------
    func
        The function defining the rate of change at every position of the `VectorField`.
    color
        The color of the vector field. If set, position-specific coloring is disabled.
    color_scheme
        A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.
    min_color_scheme_value
        The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.
    max_color_scheme_value
        The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.
    colors
        The colors defining the color gradient of the vector field.
    kwargs
        Additional arguments to be passed to the :class:`~.VGroup` constructor

    """

    @others
</t>
<t tx="ekr.20250122151620.1057">class ArrowVectorField(VectorField):
    """A :class:`VectorField` represented by a set of change vectors.

    Vector fields are always based on a function defining the :class:`~.Vector` at every position.
    The values of this functions is displayed as a grid of vectors.
    By default the color of each vector is determined by it's magnitude.
    Other color schemes can be used however.

    Parameters
    ----------
    func
        The function defining the rate of change at every position of the vector field.
    color
        The color of the vector field. If set, position-specific coloring is disabled.
    color_scheme
        A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.
    min_color_scheme_value
        The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.
    max_color_scheme_value
        The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.
    colors
        The colors defining the color gradient of the vector field.
    x_range
        A sequence of x_min, x_max, delta_x
    y_range
        A sequence of y_min, y_max, delta_y
    z_range
        A sequence of z_min, z_max, delta_z
    three_dimensions
        Enables three_dimensions. Default set to False, automatically turns True if
        z_range is not None.
    length_func
        The function determining the displayed size of the vectors. The actual size
        of the vector is passed, the returned value will be used as display size for the
        vector. By default this is used to cap the displayed size of vectors to reduce the clutter.
    opacity
        The opacity of the arrows.
    vector_config
        Additional arguments to be passed to the :class:`~.Vector` constructor
    kwargs
        Additional arguments to be passed to the :class:`~.VGroup` constructor

    Examples
    --------

    .. manim:: BasicUsage
        :save_last_frame:

        class BasicUsage(Scene):
            def construct(self):
                func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3
                self.add(ArrowVectorField(func))

    .. manim:: SizingAndSpacing

        class SizingAndSpacing(Scene):
            def construct(self):
                func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
                vf = ArrowVectorField(func, x_range=[-7, 7, 1])
                self.add(vf)
                self.wait()

                length_func = lambda x: x / 3
                vf2 = ArrowVectorField(func, x_range=[-7, 7, 1], length_func=length_func)
                self.play(vf.animate.become(vf2))
                self.wait()

    .. manim:: Coloring
        :save_last_frame:

        class Coloring(Scene):
            def construct(self):
                func = lambda pos: pos - LEFT * 5
                colors = [RED, YELLOW, BLUE, DARK_GRAY]
                min_radius = Circle(radius=2, color=colors[0]).shift(LEFT * 5)
                max_radius = Circle(radius=10, color=colors[-1]).shift(LEFT * 5)
                vf = ArrowVectorField(
                    func, min_color_scheme_value=2, max_color_scheme_value=10, colors=colors
                )
                self.add(vf, min_radius, max_radius)

    """

    @others
</t>
<t tx="ekr.20250122151620.1058">class StreamLines(VectorField):
    """StreamLines represent the flow of a :class:`VectorField` using the trace of moving agents.

    Vector fields are always based on a function defining the vector at every position.
    The values of this functions is displayed by moving many agents along the vector field
    and showing their trace.

    Parameters
    ----------
    func
        The function defining the rate of change at every position of the vector field.
    color
        The color of the vector field. If set, position-specific coloring is disabled.
    color_scheme
        A function mapping a vector to a single value. This value gives the position in the color gradient defined using `min_color_scheme_value`, `max_color_scheme_value` and `colors`.
    min_color_scheme_value
        The value of the color_scheme function to be mapped to the first color in `colors`. Lower values also result in the first color of the gradient.
    max_color_scheme_value
        The value of the color_scheme function to be mapped to the last color in `colors`. Higher values also result in the last color of the gradient.
    colors
        The colors defining the color gradient of the vector field.
    x_range
        A sequence of x_min, x_max, delta_x
    y_range
        A sequence of y_min, y_max, delta_y
    z_range
        A sequence of z_min, z_max, delta_z
    three_dimensions
        Enables three_dimensions. Default set to False, automatically turns True if
        z_range is not None.
    noise_factor
        The amount by which the starting position of each agent is altered along each axis. Defaults to :code:`delta_y / 2` if not defined.
    n_repeats
        The number of agents generated at each starting point.
    dt
        The factor by which the distance an agent moves per step is stretched. Lower values result in a better approximation of the trajectories in the vector field.
    virtual_time
        The time the agents get to move in the vector field. Higher values therefore result in longer stream lines. However, this whole time gets simulated upon creation.
    max_anchors_per_line
        The maximum number of anchors per line. Lines with more anchors get reduced in complexity, not in length.
    padding
        The distance agents can move out of the generation area before being terminated.
    stroke_width
        The stroke with of the stream lines.
    opacity
        The opacity of the stream lines.

    Examples
    --------

    .. manim:: BasicUsage
        :save_last_frame:

        class BasicUsage(Scene):
            def construct(self):
                func = lambda pos: ((pos[0] * UR + pos[1] * LEFT) - pos) / 3
                self.add(StreamLines(func))

    .. manim:: SpawningAndFlowingArea
        :save_last_frame:

        class SpawningAndFlowingArea(Scene):
            def construct(self):
                func = lambda pos: np.sin(pos[0]) * UR + np.cos(pos[1]) * LEFT + pos / 5
                stream_lines = StreamLines(
                    func, x_range=[-3, 3, 0.2], y_range=[-2, 2, 0.2], padding=1
                )

                spawning_area = Rectangle(width=6, height=4)
                flowing_area = Rectangle(width=8, height=6)
                labels = [Tex("Spawning Area"), Tex("Flowing Area").shift(DOWN * 2.5)]
                for lbl in labels:
                    lbl.add_background_rectangle(opacity=0.6, buff=0.05)

                self.add(stream_lines, spawning_area, flowing_area, *labels)

    """

    @others
# TODO: Variant of StreamLines that is able to respond to changes in the vector field function
</t>
<t tx="ekr.20250122151620.1059">def __init__(
    self,
    func: Callable[[np.ndarray], np.ndarray],
    color: ParsableManimColor | None = None,
    color_scheme: Callable[[np.ndarray], float] | None = None,
    min_color_scheme_value: float = 0,
    max_color_scheme_value: float = 2,
    colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,
    **kwargs,
):
    super().__init__(**kwargs)
    self.func = func
    if color is None:
        self.single_color = False
        if color_scheme is None:

            def color_scheme(p):
                return np.linalg.norm(p)

        self.color_scheme = color_scheme  # TODO maybe other default for direction?
        self.rgbs = np.array(list(map(color_to_rgb, colors)))

        def pos_to_rgb(pos: np.ndarray) -&gt; tuple[float, float, float, float]:
            vec = self.func(pos)
            color_value = np.clip(
                self.color_scheme(vec),
                min_color_scheme_value,
                max_color_scheme_value,
            )
            alpha = inverse_interpolate(
                min_color_scheme_value,
                max_color_scheme_value,
                color_value,
            )
            alpha *= len(self.rgbs) - 1
            c1 = self.rgbs[int(alpha)]
            c2 = self.rgbs[min(int(alpha + 1), len(self.rgbs) - 1)]
            alpha %= 1
            return interpolate(c1, c2, alpha)

        self.pos_to_rgb = pos_to_rgb
        self.pos_to_color = lambda pos: rgb_to_color(self.pos_to_rgb(pos))
    else:
        self.single_color = True
        self.color = ManimColor.parse(color)
    self.submob_movement_updater = None

</t>
<t tx="ekr.20250122151620.106">@property
def frame_x_radius(self) -&gt; float:
    """Half the frame width (no flag)."""
    return self._d["frame_width"] / 2

</t>
<t tx="ekr.20250122151620.1060">@staticmethod
def shift_func(
    func: Callable[[np.ndarray], np.ndarray],
    shift_vector: np.ndarray,
) -&gt; Callable[[np.ndarray], np.ndarray]:
    """Shift a vector field function.

    Parameters
    ----------
    func
        The function defining a vector field.
    shift_vector
        The shift to be applied to the vector field.

    Returns
    -------
    `Callable[[np.ndarray], np.ndarray]`
        The shifted vector field function.

    """
    return lambda p: func(p - shift_vector)

</t>
<t tx="ekr.20250122151620.1061">@staticmethod
def scale_func(
    func: Callable[[np.ndarray], np.ndarray],
    scalar: float,
) -&gt; Callable[[np.ndarray], np.ndarray]:
    """Scale a vector field function.

    Parameters
    ----------
    func
        The function defining a vector field.
    scalar
        The scalar to be applied to the vector field.

    Examples
    --------
    .. manim:: ScaleVectorFieldFunction

        class ScaleVectorFieldFunction(Scene):
            def construct(self):
                func = lambda pos: np.sin(pos[1]) * RIGHT + np.cos(pos[0]) * UP
                vector_field = ArrowVectorField(func)
                self.add(vector_field)
                self.wait()

                func = VectorField.scale_func(func, 0.5)
                self.play(vector_field.animate.become(ArrowVectorField(func)))
                self.wait()

    Returns
    -------
    `Callable[[np.ndarray], np.ndarray]`
        The scaled vector field function.

    """
    return lambda p: func(p * scalar)

</t>
<t tx="ekr.20250122151620.1062">def fit_to_coordinate_system(self, coordinate_system: CoordinateSystem):
    """Scale the vector field to fit a coordinate system.

    This method is useful when the vector field is defined in a coordinate system
    different from the one used to display the vector field.

    This method can only be used once because it transforms the origin of each vector.

    Parameters
    ----------
    coordinate_system
        The coordinate system to fit the vector field to.

    """
    self.apply_function(lambda pos: coordinate_system.coords_to_point(*pos))

</t>
<t tx="ekr.20250122151620.1063">def nudge(
    self,
    mob: Mobject,
    dt: float = 1,
    substeps: int = 1,
    pointwise: bool = False,
) -&gt; VectorField:
    """Nudge a :class:`~.Mobject` along the vector field.

    Parameters
    ----------
    mob
        The mobject to move along the vector field
    dt
        A scalar to the amount the mobject is moved along the vector field.
        The actual distance is based on the magnitude of the vector field.
    substeps
        The amount of steps the whole nudge is divided into. Higher values
        give more accurate approximations.
    pointwise
        Whether to move the mobject along the vector field. If `False` the
        vector field takes effect on the center of the given
        :class:`~.Mobject`. If `True` the vector field takes effect on the
        points of the individual points of the :class:`~.Mobject`,
        potentially distorting it.

    Returns
    -------
    VectorField
        This vector field.

    Examples
    --------

    .. manim:: Nudging

        class Nudging(Scene):
            def construct(self):
                func = lambda pos: np.sin(pos[1] / 2) * RIGHT + np.cos(pos[0] / 2) * UP
                vector_field = ArrowVectorField(
                    func, x_range=[-7, 7, 1], y_range=[-4, 4, 1], length_func=lambda x: x / 2
                )
                self.add(vector_field)
                circle = Circle(radius=2).shift(LEFT)
                self.add(circle.copy().set_color(GRAY))
                dot = Dot().move_to(circle)

                vector_field.nudge(circle, -2, 60, True)
                vector_field.nudge(dot, -2, 60)

                circle.add_updater(vector_field.get_nudge_updater(pointwise=True))
                dot.add_updater(vector_field.get_nudge_updater())
                self.add(circle, dot)
                self.wait(6)

    """

    def runge_kutta(self, p: Sequence[float], step_size: float) -&gt; float:
        """Returns the change in position of a point along a vector field.
        Parameters
        ----------
        p
           The position of each point being moved along the vector field.
        step_size
           A scalar that is used to determine how much a point is shifted in a single step.

        Returns
        -------
        float
           How much the point is shifted.
        """
        k_1 = self.func(p)
        k_2 = self.func(p + step_size * (k_1 * 0.5))
        k_3 = self.func(p + step_size * (k_2 * 0.5))
        k_4 = self.func(p + step_size * k_3)
        return step_size / 6.0 * (k_1 + 2.0 * k_2 + 2.0 * k_3 + k_4)

    step_size = dt / substeps
    for _ in range(substeps):
        if pointwise:
            mob.apply_function(lambda p: p + runge_kutta(self, p, step_size))
        else:
            mob.shift(runge_kutta(self, mob.get_center(), step_size))
    return self

</t>
<t tx="ekr.20250122151620.1064">def nudge_submobjects(
    self,
    dt: float = 1,
    substeps: int = 1,
    pointwise: bool = False,
) -&gt; VectorField:
    """Apply a nudge along the vector field to all submobjects.

    Parameters
    ----------
    dt
        A scalar to the amount the mobject is moved along the vector field.
        The actual distance is based on the magnitude of the vector field.
    substeps
        The amount of steps the whole nudge is divided into. Higher values
        give more accurate approximations.
    pointwise
        Whether to move the mobject along the vector field. See :meth:`nudge` for details.

    Returns
    -------
    VectorField
        This vector field.

    """
    for mob in self.submobjects:
        self.nudge(mob, dt, substeps, pointwise)
    return self

</t>
<t tx="ekr.20250122151620.1065">def get_nudge_updater(
    self,
    speed: float = 1,
    pointwise: bool = False,
) -&gt; Callable[[Mobject, float], Mobject]:
    """Get an update function to move a :class:`~.Mobject` along the vector field.

    When used with :meth:`~.Mobject.add_updater`, the mobject will move along the vector field, where its speed is determined by the magnitude of the vector field.

    Parameters
    ----------
    speed
        At `speed=1` the distance a mobject moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of such a mobject.
    pointwise
        Whether to move the mobject along the vector field. See :meth:`nudge` for details.

    Returns
    -------
    Callable[[Mobject, float], Mobject]
        The update function.
    """
    return lambda mob, dt: self.nudge(mob, dt * speed, pointwise=pointwise)

</t>
<t tx="ekr.20250122151620.1066">def start_submobject_movement(
    self,
    speed: float = 1,
    pointwise: bool = False,
) -&gt; VectorField:
    """Start continuously moving all submobjects along the vector field.

    Calling this method multiple times will result in removing the previous updater created by this method.

    Parameters
    ----------
    speed
        The speed at which to move the submobjects. See :meth:`get_nudge_updater` for details.
    pointwise
        Whether to move the mobject along the vector field. See :meth:`nudge` for details.

    Returns
    -------
    VectorField
        This vector field.

    """
    self.stop_submobject_movement()
    self.submob_movement_updater = lambda mob, dt: mob.nudge_submobjects(
        dt * speed,
        pointwise=pointwise,
    )
    self.add_updater(self.submob_movement_updater)
    return self

</t>
<t tx="ekr.20250122151620.1067">def stop_submobject_movement(self) -&gt; VectorField:
    """Stops the continuous movement started using :meth:`start_submobject_movement`.

    Returns
    -------
    VectorField
        This vector field.
    """
    self.remove_updater(self.submob_movement_updater)
    self.submob_movement_updater = None
    return self

</t>
<t tx="ekr.20250122151620.1068">def get_colored_background_image(self, sampling_rate: int = 5) -&gt; Image.Image:
    """Generate an image that displays the vector field.

    The color at each position is calculated by passing the positing through a
    series of steps:
    Calculate the vector field function at that position, map that vector to a
    single value using `self.color_scheme` and finally generate a color from
    that value using the color gradient.

    Parameters
    ----------
    sampling_rate
        The stepsize at which pixels get included in the image. Lower values give
        more accurate results, but may take a long time to compute.

    Returns
    -------
    Image.Imgae
        The vector field image.
    """
    if self.single_color:
        raise ValueError(
            "There is no point in generating an image if the vector field uses a single color.",
        )
    ph = int(config["pixel_height"] / sampling_rate)
    pw = int(config["pixel_width"] / sampling_rate)
    fw = config["frame_width"]
    fh = config["frame_height"]
    points_array = np.zeros((ph, pw, 3))
    x_array = np.linspace(-fw / 2, fw / 2, pw)
    y_array = np.linspace(fh / 2, -fh / 2, ph)
    x_array = x_array.reshape((1, len(x_array)))
    y_array = y_array.reshape((len(y_array), 1))
    x_array = x_array.repeat(ph, axis=0)
    y_array.repeat(pw, axis=1)  # TODO why not y_array = y_array.repeat(...)?
    points_array[:, :, 0] = x_array
    points_array[:, :, 1] = y_array
    rgbs = np.apply_along_axis(self.pos_to_rgb, 2, points_array)
    return Image.fromarray((rgbs * 255).astype("uint8"))

</t>
<t tx="ekr.20250122151620.1069">def get_vectorized_rgba_gradient_function(
    self,
    start: float,
    end: float,
    colors: Iterable[ParsableManimColor],
):
    """
    Generates a gradient of rgbas as a numpy array

    Parameters
    ----------
    start
        start value used for inverse interpolation at :func:`~.inverse_interpolate`
    end
        end value used for inverse interpolation at :func:`~.inverse_interpolate`
    colors
        list of colors to generate the gradient

    Returns
    -------
        function to generate the gradients as numpy arrays representing rgba values
    """
    rgbs = np.array([color_to_rgb(c) for c in colors])

    def func(values, opacity=1):
        alphas = inverse_interpolate(start, end, np.array(values))
        alphas = np.clip(alphas, 0, 1)
        scaled_alphas = alphas * (len(rgbs) - 1)
        indices = scaled_alphas.astype(int)
        next_indices = np.clip(indices + 1, 0, len(rgbs) - 1)
        inter_alphas = scaled_alphas % 1
        inter_alphas = inter_alphas.repeat(3).reshape((len(indices), 3))
        result = interpolate(rgbs[indices], rgbs[next_indices], inter_alphas)
        result = np.concatenate(
            (result, np.full([len(result), 1], opacity)),
            axis=1,
        )
        return result

    return func


</t>
<t tx="ekr.20250122151620.107">@frame_x_radius.setter
def frame_x_radius(self, value: float) -&gt; None:
    self._d.__setitem__("frame_x_radius", value) or self._d.__setitem__(
        "frame_width", 2 * value
    )

</t>
<t tx="ekr.20250122151620.1070">def __init__(
    self,
    func: Callable[[np.ndarray], np.ndarray],
    color: ParsableManimColor | None = None,
    color_scheme: Callable[[np.ndarray], float] | None = None,
    min_color_scheme_value: float = 0,
    max_color_scheme_value: float = 2,
    colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,
    # Determining Vector positions:
    x_range: Sequence[float] = None,
    y_range: Sequence[float] = None,
    z_range: Sequence[float] = None,
    three_dimensions: bool = False,  # Automatically True if z_range is set
    # Takes in actual norm, spits out displayed norm
    length_func: Callable[[float], float] = lambda norm: 0.45 * sigmoid(norm),
    opacity: float = 1.0,
    vector_config: dict | None = None,
    **kwargs,
</t>
<t tx="ekr.20250122151620.1071">):
    self.x_range = x_range or [
        floor(-config["frame_width"] / 2),
        ceil(config["frame_width"] / 2),
    ]
    self.y_range = y_range or [
        floor(-config["frame_height"] / 2),
        ceil(config["frame_height"] / 2),
    ]
    self.ranges = [self.x_range, self.y_range]

    if three_dimensions or z_range:
        self.z_range = z_range or self.y_range.copy()
        self.ranges += [self.z_range]
    else:
        self.ranges += [[0, 0]]

    for i in range(len(self.ranges)):
        if len(self.ranges[i]) == 2:
            self.ranges[i] += [0.5]
        self.ranges[i][1] += self.ranges[i][2]

    self.x_range, self.y_range, self.z_range = self.ranges

    super().__init__(
        func,
        color,
        color_scheme,
        min_color_scheme_value,
        max_color_scheme_value,
        colors,
        **kwargs,
    )

    self.length_func = length_func
    self.opacity = opacity
    if vector_config is None:
        vector_config = {}
    self.vector_config = vector_config
    self.func = func

    x_range = np.arange(*self.x_range)
    y_range = np.arange(*self.y_range)
    z_range = np.arange(*self.z_range)
    self.add(
        *[
            self.get_vector(x * RIGHT + y * UP + z * OUT)
            for x, y, z in it.product(x_range, y_range, z_range)
        ]
    )
    self.set_opacity(self.opacity)

def get_vector(self, point: np.ndarray):
    """Creates a vector in the vector field.

    The created vector is based on the function of the vector field and is
    rooted in the given point. Color and length fit the specifications of
    this vector field.

    Parameters
    ----------
    point
        The root point of the vector.

    """
    output = np.array(self.func(point))
    norm = np.linalg.norm(output)
    if norm != 0:
        output *= self.length_func(norm) / norm
    vect = Vector(output, **self.vector_config)
    vect.shift(point)
    if self.single_color:
        vect.set_color(self.color)
    else:
        vect.set_color(self.pos_to_color(point))
    return vect


</t>
<t tx="ekr.20250122151620.1072">def __init__(
    self,
    func: Callable[[np.ndarray], np.ndarray],
    color: ParsableManimColor | None = None,
    color_scheme: Callable[[np.ndarray], float] | None = None,
    min_color_scheme_value: float = 0,
    max_color_scheme_value: float = 2,
    colors: Sequence[ParsableManimColor] = DEFAULT_SCALAR_FIELD_COLORS,
    # Determining stream line starting positions:
    x_range: Sequence[float] = None,
    y_range: Sequence[float] = None,
    z_range: Sequence[float] = None,
    three_dimensions: bool = False,
    noise_factor: float | None = None,
    n_repeats=1,
    # Determining how lines are drawn
    dt=0.05,
    virtual_time=3,
    max_anchors_per_line=100,
    padding=3,
    # Determining stream line appearance:
    stroke_width=1,
    opacity=1,
    **kwargs,
):
    self.x_range = x_range or [
        floor(-config["frame_width"] / 2),
        ceil(config["frame_width"] / 2),
    ]
    self.y_range = y_range or [
        floor(-config["frame_height"] / 2),
        ceil(config["frame_height"] / 2),
    ]
    self.ranges = [self.x_range, self.y_range]

    if three_dimensions or z_range:
        self.z_range = z_range or self.y_range.copy()
        self.ranges += [self.z_range]
    else:
        self.ranges += [[0, 0]]

    for i in range(len(self.ranges)):
        if len(self.ranges[i]) == 2:
            self.ranges[i] += [0.5]
        self.ranges[i][1] += self.ranges[i][2]

    self.x_range, self.y_range, self.z_range = self.ranges

    super().__init__(
        func,
        color,
        color_scheme,
        min_color_scheme_value,
        max_color_scheme_value,
        colors,
        **kwargs,
    )

    self.noise_factor = (
        noise_factor if noise_factor is not None else self.y_range[2] / 2
    )
    self.n_repeats = n_repeats
    self.virtual_time = virtual_time
    self.max_anchors_per_line = max_anchors_per_line
    self.padding = padding
    self.stroke_width = stroke_width

    half_noise = self.noise_factor / 2
    np.random.seed(0)
    start_points = np.array(
        [
            (x - half_noise) * RIGHT
            + (y - half_noise) * UP
            + (z - half_noise) * OUT
            + self.noise_factor * np.random.random(3)
            for n in range(self.n_repeats)
            for x in np.arange(*self.x_range)
            for y in np.arange(*self.y_range)
            for z in np.arange(*self.z_range)
        ],
    )

    def outside_box(p):
        return (
            p[0] &lt; self.x_range[0] - self.padding
            or p[0] &gt; self.x_range[1] + self.padding - self.x_range[2]
            or p[1] &lt; self.y_range[0] - self.padding
            or p[1] &gt; self.y_range[1] + self.padding - self.y_range[2]
            or p[2] &lt; self.z_range[0] - self.padding
            or p[2] &gt; self.z_range[1] + self.padding - self.z_range[2]
        )

    max_steps = ceil(virtual_time / dt) + 1
    if not self.single_color:
        self.background_img = self.get_colored_background_image()
        if config["renderer"] == RendererType.OPENGL:
            self.values_to_rgbas = self.get_vectorized_rgba_gradient_function(
                min_color_scheme_value,
                max_color_scheme_value,
                colors,
            )
    for point in start_points:
        points = [point]
        for _ in range(max_steps):
            last_point = points[-1]
            new_point = last_point + dt * func(last_point)
            if outside_box(new_point):
                break
            points.append(new_point)
        step = max_steps
        if not step:
            continue
        line = get_vectorized_mobject_class()()
        line.duration = step * dt
        step = max(1, int(len(points) / self.max_anchors_per_line))
        line.set_points_smoothly(points[::step])
        if self.single_color:
            line.set_stroke(
                color=self.color, width=self.stroke_width, opacity=opacity
            )
        else:
            if config.renderer == RendererType.OPENGL:
                # scaled for compatibility with cairo
                line.set_stroke(width=self.stroke_width / 4.0)
                norms = np.array(
                    [np.linalg.norm(self.func(point)) for point in line.points],
                )
                line.set_rgba_array_direct(
                    self.values_to_rgbas(norms, opacity),
                    name="stroke_rgba",
                )
            else:
                if np.any(self.z_range != np.array([0, 0.5, 0.5])):
                    line.set_stroke(
                        [self.pos_to_color(p) for p in line.get_anchors()],
                    )
                else:
                    line.color_using_background_image(self.background_img)
                line.set_stroke(width=self.stroke_width, opacity=opacity)
        self.add(line)
    self.stream_lines = [*self.submobjects]

</t>
<t tx="ekr.20250122151620.1073">def create(
    self,
    lag_ratio: float | None = None,
    run_time: Callable[[float], float] | None = None,
    **kwargs,
) -&gt; AnimationGroup:
    """The creation animation of the stream lines.

    The stream lines appear in random order.

    Parameters
    ----------
    lag_ratio
        The lag ratio of the animation.
        If undefined, it will be selected so that the total animation length is 1.5 times the run time of each stream line creation.
    run_time
        The run time of every single stream line creation. The runtime of the whole animation might be longer due to the `lag_ratio`.
        If undefined, the virtual time of the stream lines is used as run time.

    Returns
    -------
    :class:`~.AnimationGroup`
        The creation animation of the stream lines.

    Examples
    --------

    .. manim:: StreamLineCreation

        class StreamLineCreation(Scene):
            def construct(self):
                func = lambda pos: (pos[0] * UR + pos[1] * LEFT) - pos
                stream_lines = StreamLines(
                    func,
                    color=YELLOW,
                    x_range=[-7, 7, 1],
                    y_range=[-4, 4, 1],
                    stroke_width=3,
                    virtual_time=1,  # use shorter lines
                    max_anchors_per_line=5,  # better performance with fewer anchors
                )
                self.play(stream_lines.create())  # uses virtual_time as run_time
                self.wait()

    """
    if run_time is None:
        run_time = self.virtual_time
    if lag_ratio is None:
        lag_ratio = run_time / 2 / len(self.submobjects)

    animations = [
        Create(line, run_time=run_time, **kwargs) for line in self.stream_lines
    ]
    random.shuffle(animations)
    return AnimationGroup(*animations, lag_ratio=lag_ratio)

</t>
<t tx="ekr.20250122151620.1074">def start_animation(
    self,
    warm_up: bool = True,
    flow_speed: float = 1,
    time_width: float = 0.3,
    rate_func: Callable[[float], float] = linear,
    line_animation_class: type[ShowPassingFlash] = ShowPassingFlash,
    **kwargs,
) -&gt; None:
    """Animates the stream lines using an updater.

    The stream lines will continuously flow

    Parameters
    ----------
    warm_up
        If `True` the animation is initialized line by line. Otherwise it starts with all lines shown.
    flow_speed
        At `flow_speed=1` the distance the flow moves per second is equal to the magnitude of the vector field along its path. The speed value scales the speed of this flow.
    time_width
        The proportion of the stream line shown while being animated
    rate_func
        The rate function of each stream line flashing
    line_animation_class
        The animation class being used

    Examples
    --------

    .. manim:: ContinuousMotion

        class ContinuousMotion(Scene):
            def construct(self):
                func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
                stream_lines = StreamLines(func, stroke_width=3, max_anchors_per_line=30)
                self.add(stream_lines)
                stream_lines.start_animation(warm_up=False, flow_speed=1.5)
                self.wait(stream_lines.virtual_time / stream_lines.flow_speed)

    """
    for line in self.stream_lines:
        run_time = line.duration / flow_speed
        line.anim = line_animation_class(
            line,
            run_time=run_time,
            rate_func=rate_func,
            time_width=time_width,
            **kwargs,
        )
        line.anim.begin()
        line.time = random.random() * self.virtual_time
        if warm_up:
            line.time *= -1
        self.add(line.anim.mobject)

    def updater(mob, dt):
        for line in mob.stream_lines:
            line.time += dt * flow_speed
            if line.time &gt;= self.virtual_time:
                line.time -= self.virtual_time
            line.anim.interpolate(np.clip(line.time / line.anim.run_time, 0, 1))

    self.add_updater(updater)
    self.flow_animation = updater
    self.flow_speed = flow_speed
    self.time_width = time_width

</t>
<t tx="ekr.20250122151620.1075">def end_animation(self) -&gt; AnimationGroup:
    """End the stream line animation smoothly.

    Returns an animation resulting in fully displayed stream lines without a noticeable cut.

    Returns
    -------
    :class:`~.AnimationGroup`
        The animation fading out the running stream animation.

    Raises
    ------
    ValueError
        if no stream line animation is running

    Examples
    --------

    .. manim:: EndAnimation

        class EndAnimation(Scene):
            def construct(self):
                func = lambda pos: np.sin(pos[0] / 2) * UR + np.cos(pos[1] / 2) * LEFT
                stream_lines = StreamLines(
                    func, stroke_width=3, max_anchors_per_line=5, virtual_time=1, color=BLUE
                )
                self.add(stream_lines)
                stream_lines.start_animation(warm_up=False, flow_speed=1.5, time_width=0.5)
                self.wait(1)
                self.play(stream_lines.end_animation())

    """
    if self.flow_animation is None:
        raise ValueError("You have to start the animation before fading it out.")

    def hide_and_wait(mob, alpha):
        if alpha == 0:
            mob.set_stroke(opacity=0)
        elif alpha == 1:
            mob.set_stroke(opacity=1)

    def finish_updater_cycle(line, alpha):
        line.time += dt * self.flow_speed
        line.anim.interpolate(min(line.time / line.anim.run_time, 1))
        if alpha == 1:
            self.remove(line.anim.mobject)
            line.anim.finish()

    max_run_time = self.virtual_time / self.flow_speed
    creation_rate_func = ease_out_sine
    creation_staring_speed = creation_rate_func(0.001) * 1000
    creation_run_time = (
        max_run_time / (1 + self.time_width) * creation_staring_speed
    )
    # creation_run_time is calculated so that the creation animation starts at the same speed
    # as the regular line flash animation but eases out.

    dt = 1 / config["frame_rate"]
    animations = []
    self.remove_updater(self.flow_animation)
    self.flow_animation = None

    for line in self.stream_lines:
        create = Create(
            line,
            run_time=creation_run_time,
            rate_func=creation_rate_func,
        )
        if line.time &lt;= 0:
            animations.append(
                Succession(
                    UpdateFromAlphaFunc(
                        line,
                        hide_and_wait,
                        run_time=-line.time / self.flow_speed,
                    ),
                    create,
                ),
            )
            self.remove(line.anim.mobject)
            line.anim.finish()
        else:
            remaining_time = max_run_time - line.time / self.flow_speed
            animations.append(
                Succession(
                    UpdateFromAlphaFunc(
                        line,
                        finish_updater_cycle,
                        run_time=remaining_time,
                    ),
                    create,
                ),
            )
    return AnimationGroup(*animations)


</t>
<t tx="ekr.20250122151620.1076"></t>
<t tx="ekr.20250122151620.1077">"""Various geometric Mobjects.

Modules
=======

.. autosummary::
    :toctree: ../reference

    ~arc
    ~boolean_ops
    ~labeled
    ~line
    ~polygram
    ~shape_matchers
    ~tips
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1078">r"""Mobjects that are curved.

Examples
--------
.. manim:: UsefulAnnotations
    :save_last_frame:

    class UsefulAnnotations(Scene):
        def construct(self):
            m0 = Dot()
            m1 = AnnotationDot()
            m2 = LabeledDot("ii")
            m3 = LabeledDot(MathTex(r"\alpha").set_color(ORANGE))
            m4 = CurvedArrow(2*LEFT, 2*RIGHT, radius= -5)
            m5 = CurvedArrow(2*LEFT, 2*RIGHT, radius= 8)
            m6 = CurvedDoubleArrow(ORIGIN, 2*RIGHT)

            self.add(m0, m1, m2, m3, m4, m5, m6)
            for i, mobj in enumerate(self.mobjects):
                mobj.shift(DOWN * (i-3))

"""

from __future__ import annotations

__all__ = [
    "TipableVMobject",
    "Arc",
    "ArcBetweenPoints",
    "CurvedArrow",
    "CurvedDoubleArrow",
    "Circle",
    "Dot",
    "AnnotationDot",
    "LabeledDot",
    "Ellipse",
    "AnnularSector",
    "Sector",
    "Annulus",
    "CubicBezier",
    "ArcPolygon",
    "ArcPolygonFromArcs",
]

import itertools
import warnings
from typing import TYPE_CHECKING, cast

import numpy as np
from typing_extensions import Self

from manim.constants import *
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from manim.utils.color import BLACK, BLUE, RED, WHITE, ParsableManimColor
from manim.utils.iterables import adjacent_pairs
from manim.utils.space_ops import (
    angle_of_vector,
    cartesian_to_spherical,
    line_intersection,
    perpendicular_bisector,
    rotate_vector,
)

if TYPE_CHECKING:
    from collections.abc import Iterable
    from typing import Any

    import manim.mobject.geometry.tips as tips
    from manim.mobject.mobject import Mobject
    from manim.mobject.text.tex_mobject import SingleStringMathTex, Tex
    from manim.mobject.text.text_mobject import Text
    from manim.typing import (
        Point3D,
        Point3DLike,
        QuadraticSpline,
        Vector3D,
    )


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1079">class TipableVMobject(VMobject, metaclass=ConvertToOpenGL):
    """Meant for shared functionality between Arc and Line.
    Functionality can be classified broadly into these groups:

        * Adding, Creating, Modifying tips
            - add_tip calls create_tip, before pushing the new tip
                into the TipableVMobject's list of submobjects
            - stylistic and positional configuration

        * Checking for tips
            - Boolean checks for whether the TipableVMobject has a tip
                and a starting tip

        * Getters
            - Straightforward accessors, returning information pertaining
                to the TipableVMobject instance's tip(s), its length etc
    """

    @others
</t>
<t tx="ekr.20250122151620.108">@property
def top(self) -&gt; Vector3D:
    """Coordinate at the center top of the frame."""
    return self.frame_y_radius * constants.UP

</t>
<t tx="ekr.20250122151620.1080">class Arc(TipableVMobject):
    """A circular arc.

    Examples
    --------
    A simple arc of angle Pi.

    .. manim:: ArcExample
        :save_last_frame:

        class ArcExample(Scene):
            def construct(self):
                self.add(Arc(angle=PI))
    """

    @others
</t>
<t tx="ekr.20250122151620.1081">class ArcBetweenPoints(Arc):
    """Inherits from Arc and additionally takes 2 points between which the arc is spanned.

    Example
    -------
    .. manim:: ArcBetweenPointsExample

      class ArcBetweenPointsExample(Scene):
          def construct(self):
              circle = Circle(radius=2, stroke_color=GREY)
              dot_1 = Dot(color=GREEN).move_to([2, 0, 0]).scale(0.5)
              dot_1_text = Tex("(2,0)").scale(0.5).next_to(dot_1, RIGHT).set_color(BLUE)
              dot_2 = Dot(color=GREEN).move_to([0, 2, 0]).scale(0.5)
              dot_2_text = Tex("(0,2)").scale(0.5).next_to(dot_2, UP).set_color(BLUE)
              arc= ArcBetweenPoints(start=2 * RIGHT, end=2 * UP, stroke_color=YELLOW)
              self.add(circle, dot_1, dot_2, dot_1_text, dot_2_text)
              self.play(Create(arc))
    """

    @others
</t>
<t tx="ekr.20250122151620.1082">class CurvedArrow(ArcBetweenPoints):
    @others
</t>
<t tx="ekr.20250122151620.1083">class CurvedDoubleArrow(CurvedArrow):
    @others
</t>
<t tx="ekr.20250122151620.1084">class Circle(Arc):
    """A circle.

    Parameters
    ----------
    color
        The color of the shape.
    kwargs
        Additional arguments to be passed to :class:`Arc`

    Examples
    --------
    .. manim:: CircleExample
        :save_last_frame:

        class CircleExample(Scene):
            def construct(self):
                circle_1 = Circle(radius=1.0)
                circle_2 = Circle(radius=1.5, color=GREEN)
                circle_3 = Circle(radius=1.0, color=BLUE_B, fill_opacity=1)

                circle_group = Group(circle_1, circle_2, circle_3).arrange(buff=1)
                self.add(circle_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.1085">class Dot(Circle):
    """A circle with a very small radius.

    Parameters
    ----------
    point
        The location of the dot.
    radius
        The radius of the dot.
    stroke_width
        The thickness of the outline of the dot.
    fill_opacity
        The opacity of the dot's fill_colour
    color
        The color of the dot.
    kwargs
        Additional arguments to be passed to :class:`Circle`

    Examples
    --------
    .. manim:: DotExample
        :save_last_frame:

        class DotExample(Scene):
            def construct(self):
                dot1 = Dot(point=LEFT, radius=0.08)
                dot2 = Dot(point=ORIGIN)
                dot3 = Dot(point=RIGHT)
                self.add(dot1,dot2,dot3)
    """

    @others
</t>
<t tx="ekr.20250122151620.1086">class AnnotationDot(Dot):
    """A dot with bigger radius and bold stroke to annotate scenes."""

    @others
</t>
<t tx="ekr.20250122151620.1087">class LabeledDot(Dot):
    """A :class:`Dot` containing a label in its center.

    Parameters
    ----------
    label
        The label of the :class:`Dot`. This is rendered as :class:`~.MathTex`
        by default (i.e., when passing a :class:`str`), but other classes
        representing rendered strings like :class:`~.Text` or :class:`~.Tex`
        can be passed as well.
    radius
        The radius of the :class:`Dot`. If ``None`` (the default), the radius
        is calculated based on the size of the ``label``.

    Examples
    --------
    .. manim:: SeveralLabeledDots
        :save_last_frame:

        class SeveralLabeledDots(Scene):
            def construct(self):
                sq = Square(fill_color=RED, fill_opacity=1)
                self.add(sq)
                dot1 = LabeledDot(Tex("42", color=RED))
                dot2 = LabeledDot(MathTex("a", color=GREEN))
                dot3 = LabeledDot(Text("ii", color=BLUE))
                dot4 = LabeledDot("3")
                dot1.next_to(sq, UL)
                dot2.next_to(sq, UR)
                dot3.next_to(sq, DL)
                dot4.next_to(sq, DR)
                self.add(dot1, dot2, dot3, dot4)
    """

    @others
</t>
<t tx="ekr.20250122151620.1088">class Ellipse(Circle):
    """A circular shape; oval, circle.

    Parameters
    ----------
    width
       The horizontal width of the ellipse.
    height
       The vertical height of the ellipse.
    kwargs
       Additional arguments to be passed to :class:`Circle`.

    Examples
    --------
    .. manim:: EllipseExample
        :save_last_frame:

        class EllipseExample(Scene):
            def construct(self):
                ellipse_1 = Ellipse(width=2.0, height=4.0, color=BLUE_B)
                ellipse_2 = Ellipse(width=4.0, height=1.0, color=BLUE_D)
                ellipse_group = Group(ellipse_1,ellipse_2).arrange(buff=1)
                self.add(ellipse_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.1089">class AnnularSector(Arc):
    """A sector of an annulus.


    Parameters
    ----------
    inner_radius
       The inside radius of the Annular Sector.
    outer_radius
       The outside radius of the Annular Sector.
    angle
       The clockwise angle of the Annular Sector.
    start_angle
       The starting clockwise angle of the Annular Sector.
    fill_opacity
       The opacity of the color filled in the Annular Sector.
    stroke_width
       The stroke width of the Annular Sector.
    color
       The color filled into the Annular Sector.

    Examples
    --------
    .. manim:: AnnularSectorExample
        :save_last_frame:

        class AnnularSectorExample(Scene):
            def construct(self):
                # Changes background color to clearly visualize changes in fill_opacity.
                self.camera.background_color = WHITE

                # The default parameter start_angle is 0, so the AnnularSector starts from the +x-axis.
                s1 = AnnularSector(color=YELLOW).move_to(2 * UL)

                # Different inner_radius and outer_radius than the default.
                s2 = AnnularSector(inner_radius=1.5, outer_radius=2, angle=45 * DEGREES, color=RED).move_to(2 * UR)

                # fill_opacity is typically a number &gt; 0 and &lt;= 1. If fill_opacity=0, the AnnularSector is transparent.
                s3 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=PI, fill_opacity=0.25, color=BLUE).move_to(2 * DL)

                # With a negative value for the angle, the AnnularSector is drawn clockwise from the start value.
                s4 = AnnularSector(inner_radius=1, outer_radius=1.5, angle=-3 * PI / 2, color=GREEN).move_to(2 * DR)

                self.add(s1, s2, s3, s4)
    """

    @others
    init_points = generate_points


</t>
<t tx="ekr.20250122151620.109">@property
def bottom(self) -&gt; Vector3D:
    """Coordinate at the center bottom of the frame."""
    return self.frame_y_radius * constants.DOWN

</t>
<t tx="ekr.20250122151620.1090">class Sector(AnnularSector):
    """A sector of a circle.

    Examples
    --------
    .. manim:: ExampleSector
        :save_last_frame:

        class ExampleSector(Scene):
            def construct(self):
                sector = Sector(radius=2)
                sector2 = Sector(radius=2.5, angle=60*DEGREES).move_to([-3, 0, 0])
                sector.set_color(RED)
                sector2.set_color(PINK)
                self.add(sector, sector2)
    """

    @others
</t>
<t tx="ekr.20250122151620.1091">class Annulus(Circle):
    """Region between two concentric :class:`Circles &lt;.Circle&gt;`.

    Parameters
    ----------
    inner_radius
        The radius of the inner :class:`Circle`.
    outer_radius
        The radius of the outer :class:`Circle`.
    kwargs
        Additional arguments to be passed to :class:`Annulus`

    Examples
    --------
    .. manim:: AnnulusExample
        :save_last_frame:

        class AnnulusExample(Scene):
            def construct(self):
                annulus_1 = Annulus(inner_radius=0.5, outer_radius=1).shift(UP)
                annulus_2 = Annulus(inner_radius=0.3, outer_radius=0.6, color=RED).next_to(annulus_1, DOWN)
                self.add(annulus_1, annulus_2)
    """

    @others
    init_points = generate_points


</t>
<t tx="ekr.20250122151620.1092">class CubicBezier(VMobject, metaclass=ConvertToOpenGL):
    """A cubic Bézier curve.

    Example
    -------
    .. manim:: BezierSplineExample
        :save_last_frame:

        class BezierSplineExample(Scene):
            def construct(self):
                p1 = np.array([-3, 1, 0])
                p1b = p1 + [1, 0, 0]
                d1 = Dot(point=p1).set_color(BLUE)
                l1 = Line(p1, p1b)
                p2 = np.array([3, -1, 0])
                p2b = p2 - [1, 0, 0]
                d2 = Dot(point=p2).set_color(RED)
                l2 = Line(p2, p2b)
                bezier = CubicBezier(p1b, p1b + 3 * RIGHT, p2b - 3 * RIGHT, p2b)
                self.add(l1, d1, l2, d2, bezier)

    """

    @others
</t>
<t tx="ekr.20250122151620.1093">class ArcPolygon(VMobject, metaclass=ConvertToOpenGL):
    """A generalized polygon allowing for points to be connected with arcs.

    This version tries to stick close to the way :class:`Polygon` is used. Points
    can be passed to it directly which are used to generate the according arcs
    (using :class:`ArcBetweenPoints`). An angle or radius can be passed to it to
    use across all arcs, but to configure arcs individually an ``arc_config`` list
    has to be passed with the syntax explained below.

    Parameters
    ----------
    vertices
        A list of vertices, start and end points for the arc segments.
    angle
        The angle used for constructing the arcs. If no other parameters
        are set, this angle is used to construct all arcs.
    radius
        The circle radius used to construct the arcs. If specified,
        overrides the specified ``angle``.
    arc_config
        When passing a ``dict``, its content will be passed as keyword
        arguments to :class:`~.ArcBetweenPoints`. Otherwise, a list
        of dictionaries containing values that are passed as keyword
        arguments for every individual arc can be passed.
    kwargs
        Further keyword arguments that are passed to the constructor of
        :class:`~.VMobject`.

    Attributes
    ----------
    arcs : :class:`list`
        The arcs created from the input parameters::

            &gt;&gt;&gt; from manim import ArcPolygon
            &gt;&gt;&gt; ap = ArcPolygon([0, 0, 0], [2, 0, 0], [0, 2, 0])
            &gt;&gt;&gt; ap.arcs
            [ArcBetweenPoints, ArcBetweenPoints, ArcBetweenPoints]


    .. tip::

        Two instances of :class:`ArcPolygon` can be transformed properly into one
        another as well. Be advised that any arc initialized with ``angle=0``
        will actually be a straight line, so if a straight section should seamlessly
        transform into an arced section or vice versa, initialize the straight section
        with a negligible angle instead (such as ``angle=0.0001``).

    .. note::
        There is an alternative version (:class:`ArcPolygonFromArcs`) that is instantiated
        with pre-defined arcs.

    See Also
    --------
    :class:`ArcPolygonFromArcs`


    Examples
    --------
    .. manim:: SeveralArcPolygons

        class SeveralArcPolygons(Scene):
            def construct(self):
                a = [0, 0, 0]
                b = [2, 0, 0]
                c = [0, 2, 0]
                ap1 = ArcPolygon(a, b, c, radius=2)
                ap2 = ArcPolygon(a, b, c, angle=45*DEGREES)
                ap3 = ArcPolygon(a, b, c, arc_config={'radius': 1.7, 'color': RED})
                ap4 = ArcPolygon(a, b, c, color=RED, fill_opacity=1,
                                            arc_config=[{'radius': 1.7, 'color': RED},
                                            {'angle': 20*DEGREES, 'color': BLUE},
                                            {'radius': 1}])
                ap_group = VGroup(ap1, ap2, ap3, ap4).arrange()
                self.play(*[Create(ap) for ap in [ap1, ap2, ap3, ap4]])
                self.wait()

    For further examples see :class:`ArcPolygonFromArcs`.
    """

    @others
</t>
<t tx="ekr.20250122151620.1094">class ArcPolygonFromArcs(VMobject, metaclass=ConvertToOpenGL):
    """A generalized polygon allowing for points to be connected with arcs.

    This version takes in pre-defined arcs to generate the arcpolygon and introduces
    little new syntax. However unlike :class:`Polygon` it can't be created with points
    directly.

    For proper appearance the passed arcs should connect seamlessly:
    ``[a,b][b,c][c,a]``

    If there are any gaps between the arcs, those will be filled in
    with straight lines, which can be used deliberately for any straight
    sections. Arcs can also be passed as straight lines such as an arc
    initialized with ``angle=0``.

    Parameters
    ----------
    arcs
        These are the arcs from which the arcpolygon is assembled.
    kwargs
        Keyword arguments that are passed to the constructor of
        :class:`~.VMobject`. Affects how the ArcPolygon itself is drawn,
        but doesn't affect passed arcs.

    Attributes
    ----------
    arcs
        The arcs used to initialize the ArcPolygonFromArcs::

            &gt;&gt;&gt; from manim import ArcPolygonFromArcs, Arc, ArcBetweenPoints
            &gt;&gt;&gt; ap = ArcPolygonFromArcs(Arc(), ArcBetweenPoints([1,0,0], [0,1,0]), Arc())
            &gt;&gt;&gt; ap.arcs
            [Arc, ArcBetweenPoints, Arc]


    .. tip::

        Two instances of :class:`ArcPolygon` can be transformed properly into
        one another as well. Be advised that any arc initialized with ``angle=0``
        will actually be a straight line, so if a straight section should seamlessly
        transform into an arced section or vice versa, initialize the straight
        section with a negligible angle instead (such as ``angle=0.0001``).

    .. note::
        There is an alternative version (:class:`ArcPolygon`) that can be instantiated
        with points.

    .. seealso::
        :class:`ArcPolygon`

    Examples
    --------
    One example of an arcpolygon is the Reuleaux triangle.
    Instead of 3 straight lines connecting the outer points,
    a Reuleaux triangle has 3 arcs connecting those points,
    making a shape with constant width.

    Passed arcs are stored as submobjects in the arcpolygon.
    This means that the arcs are changed along with the arcpolygon,
    for example when it's shifted, and these arcs can be manipulated
    after the arcpolygon has been initialized.

    Also both the arcs contained in an :class:`~.ArcPolygonFromArcs`, as well as the
    arcpolygon itself are drawn, which affects draw time in :class:`~.Create`
    for example. In most cases the arcs themselves don't
    need to be drawn, in which case they can be passed as invisible.

    .. manim:: ArcPolygonExample

        class ArcPolygonExample(Scene):
            def construct(self):
                arc_conf = {"stroke_width": 0}
                poly_conf = {"stroke_width": 10, "stroke_color": BLUE,
                      "fill_opacity": 1, "color": PURPLE}
                a = [-1, 0, 0]
                b = [1, 0, 0]
                c = [0, np.sqrt(3), 0]
                arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
                arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
                arc2 = ArcBetweenPoints(c, a, radius=2, **arc_conf)
                reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
                self.play(FadeIn(reuleaux_tri))
                self.wait(2)

    The arcpolygon itself can also be hidden so that instead only the contained
    arcs are drawn. This can be used to easily debug arcs or to highlight them.

    .. manim:: ArcPolygonExample2

        class ArcPolygonExample2(Scene):
            def construct(self):
                arc_conf = {"stroke_width": 3, "stroke_color": BLUE,
                    "fill_opacity": 0.5, "color": GREEN}
                poly_conf = {"color": None}
                a = [-1, 0, 0]
                b = [1, 0, 0]
                c = [0, np.sqrt(3), 0]
                arc0 = ArcBetweenPoints(a, b, radius=2, **arc_conf)
                arc1 = ArcBetweenPoints(b, c, radius=2, **arc_conf)
                arc2 = ArcBetweenPoints(c, a, radius=2, stroke_color=RED)
                reuleaux_tri = ArcPolygonFromArcs(arc0, arc1, arc2, **poly_conf)
                self.play(FadeIn(reuleaux_tri))
                self.wait(2)
    """

    @others
</t>
<t tx="ekr.20250122151620.1095">def __init__(
    self,
    tip_length: float = DEFAULT_ARROW_TIP_LENGTH,
    normal_vector: Vector3D = OUT,
    tip_style: dict = {},
    **kwargs: Any,
) -&gt; None:
    self.tip_length: float = tip_length
    self.normal_vector: Vector3D = normal_vector
    self.tip_style: dict = tip_style
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.1096"># Adding, Creating, Modifying tips

def add_tip(
    self,
    tip: tips.ArrowTip | None = None,
    tip_shape: type[tips.ArrowTip] | None = None,
    tip_length: float | None = None,
    tip_width: float | None = None,
    at_start: bool = False,
) -&gt; Self:
    """Adds a tip to the TipableVMobject instance, recognising
    that the endpoints might need to be switched if it's
    a 'starting tip' or not.
    """
    if tip is None:
        tip = self.create_tip(tip_shape, tip_length, tip_width, at_start)
    else:
        self.position_tip(tip, at_start)
    self.reset_endpoints_based_on_tip(tip, at_start)
    self.asign_tip_attr(tip, at_start)
    self.add(tip)
    return self

</t>
<t tx="ekr.20250122151620.1097">def create_tip(
    self,
    tip_shape: type[tips.ArrowTip] | None = None,
    tip_length: float | None = None,
    tip_width: float | None = None,
    at_start: bool = False,
) -&gt; tips.ArrowTip:
    """Stylises the tip, positions it spatially, and returns
    the newly instantiated tip to the caller.
    """
    tip = self.get_unpositioned_tip(tip_shape, tip_length, tip_width)
    self.position_tip(tip, at_start)
    return tip

</t>
<t tx="ekr.20250122151620.1098">def get_unpositioned_tip(
    self,
    tip_shape: type[tips.ArrowTip] | None = None,
    tip_length: float | None = None,
    tip_width: float | None = None,
) -&gt; tips.ArrowTip | tips.ArrowTriangleFilledTip:
    """Returns a tip that has been stylistically configured,
    but has not yet been given a position in space.
    """
    from manim.mobject.geometry.tips import ArrowTriangleFilledTip

    style: dict[str, Any] = {}

    if tip_shape is None:
        tip_shape = ArrowTriangleFilledTip

    if tip_shape is ArrowTriangleFilledTip:
        if tip_width is None:
            tip_width = self.get_default_tip_length()
        style.update({"width": tip_width})
    if tip_length is None:
        tip_length = self.get_default_tip_length()

    color = self.get_color()
    style.update({"fill_color": color, "stroke_color": color})
    style.update(self.tip_style)
    tip = tip_shape(length=tip_length, **style)
    return tip

</t>
<t tx="ekr.20250122151620.1099">def position_tip(self, tip: tips.ArrowTip, at_start: bool = False) -&gt; tips.ArrowTip:
    # Last two control points, defining both
    # the end, and the tangency direction
    if at_start:
        anchor = self.get_start()
        handle = self.get_first_handle()
    else:
        handle = self.get_last_handle()
        anchor = self.get_end()
    angles = cartesian_to_spherical((handle - anchor).tolist())
    tip.rotate(
        angles[1] - PI - tip.tip_angle,
    )  # Rotates the tip along the azimuthal
    if not hasattr(self, "_init_positioning_axis"):
        axis = np.array(
            [
                np.sin(angles[1]),
                -np.cos(angles[1]),
                0,
            ]
        )  # Obtains the perpendicular of the tip
        tip.rotate(
            -angles[2] + PI / 2,
            axis=axis,
        )  # Rotates the tip along the vertical wrt the axis
        self._init_positioning_axis = axis
    tip.shift(anchor - tip.tip_point)
    return tip

</t>
<t tx="ekr.20250122151620.11">class LineJointType(Enum):
    """Collection of available line joint types.

    See the example below for a visual illustration of the different
    joint types.

    Examples
    --------

    .. manim:: LineJointVariants
        :save_last_frame:

        class LineJointVariants(Scene):
            def construct(self):
                mob = VMobject(stroke_width=20, color=GREEN).set_points_as_corners([
                    np.array([-2, 0, 0]),
                    np.array([0, 0, 0]),
                    np.array([-2, 1, 0]),
                ])
                lines = VGroup(*[mob.copy() for _ in range(len(LineJointType))])
                for line, joint_type in zip(lines, LineJointType):
                    line.joint_type = joint_type

                lines.arrange(RIGHT, buff=1)
                self.add(lines)
                for line in lines:
                    label = Text(line.joint_type.name).next_to(line, DOWN)
                    self.add(label)
    """

    AUTO = 0
    ROUND = 1
    BEVEL = 2
    MITER = 3


</t>
<t tx="ekr.20250122151620.110">@property
def left_side(self) -&gt; Vector3D:
    """Coordinate at the middle left of the frame."""
    return self.frame_x_radius * constants.LEFT

</t>
<t tx="ekr.20250122151620.1100">def reset_endpoints_based_on_tip(self, tip: tips.ArrowTip, at_start: bool) -&gt; Self:
    if self.get_length() == 0:
        # Zero length, put_start_and_end_on wouldn't work
        return self

    if at_start:
        self.put_start_and_end_on(tip.base, self.get_end())
    else:
        self.put_start_and_end_on(self.get_start(), tip.base)
    return self

</t>
<t tx="ekr.20250122151620.1101">def asign_tip_attr(self, tip: tips.ArrowTip, at_start: bool) -&gt; Self:
    if at_start:
        self.start_tip = tip
    else:
        self.tip = tip
    return self

</t>
<t tx="ekr.20250122151620.1102"># Checking for tips

def has_tip(self) -&gt; bool:
    return hasattr(self, "tip") and self.tip in self

</t>
<t tx="ekr.20250122151620.1103">def has_start_tip(self) -&gt; bool:
    return hasattr(self, "start_tip") and self.start_tip in self

</t>
<t tx="ekr.20250122151620.1104"># Getters

def pop_tips(self) -&gt; VGroup:
    start, end = self.get_start_and_end()
    result = self.get_group_class()()
    if self.has_tip():
        result.add(self.tip)
        self.remove(self.tip)
    if self.has_start_tip():
        result.add(self.start_tip)
        self.remove(self.start_tip)
    self.put_start_and_end_on(start, end)
    return result

</t>
<t tx="ekr.20250122151620.1105">def get_tips(self) -&gt; VGroup:
    """Returns a VGroup (collection of VMobjects) containing
    the TipableVMObject instance's tips.
    """
    result = self.get_group_class()()
    if hasattr(self, "tip"):
        result.add(self.tip)
    if hasattr(self, "start_tip"):
        result.add(self.start_tip)
    return result

</t>
<t tx="ekr.20250122151620.1106">def get_tip(self) -&gt; VMobject:
    """Returns the TipableVMobject instance's (first) tip,
    otherwise throws an exception.
    """
    tips = self.get_tips()
    if len(tips) == 0:
        raise Exception("tip not found")
    else:
        tip: VMobject = tips[0]
        return tip

</t>
<t tx="ekr.20250122151620.1107">def get_default_tip_length(self) -&gt; float:
    return self.tip_length

</t>
<t tx="ekr.20250122151620.1108">def get_first_handle(self) -&gt; Point3D:
    # Type inference of extracting an element from a list, is not
    # supported by numpy, see this numpy issue
    # https://github.com/numpy/numpy/issues/16544
    first_handle: Point3D = self.points[1]
    return first_handle

</t>
<t tx="ekr.20250122151620.1109">def get_last_handle(self) -&gt; Point3D:
    # Type inference of extracting an element from a list, is not
    # supported by numpy, see this numpy issue
    # https://github.com/numpy/numpy/issues/16544
    last_handle: Point3D = self.points[-2]
    return last_handle

</t>
<t tx="ekr.20250122151620.111">@property
def right_side(self) -&gt; Vector3D:
    """Coordinate at the middle right of the frame."""
    return self.frame_x_radius * constants.RIGHT

</t>
<t tx="ekr.20250122151620.1110">def get_end(self) -&gt; Point3D:
    if self.has_tip():
        return self.tip.get_start()
    else:
        return super().get_end()

</t>
<t tx="ekr.20250122151620.1111">def get_start(self) -&gt; Point3D:
    if self.has_start_tip():
        return self.start_tip.get_start()
    else:
        return super().get_start()

</t>
<t tx="ekr.20250122151620.1112">def get_length(self) -&gt; float:
    start, end = self.get_start_and_end()
    return float(np.linalg.norm(start - end))


</t>
<t tx="ekr.20250122151620.1113">def __init__(
    self,
    radius: float | None = 1.0,
    start_angle: float = 0,
    angle: float = TAU / 4,
    num_components: int = 9,
    arc_center: Point3DLike = ORIGIN,
    **kwargs: Any,
):
    if radius is None:  # apparently None is passed by ArcBetweenPoints
        radius = 1.0
    self.radius = radius
    self.num_components = num_components
    self.arc_center: Point3D = np.asarray(arc_center)
    self.start_angle = start_angle
    self.angle = angle
    self._failed_to_get_center: bool = False
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.1114">def generate_points(self) -&gt; None:
    self._set_pre_positioned_points()
    self.scale(self.radius, about_point=ORIGIN)
    self.shift(self.arc_center)

</t>
<t tx="ekr.20250122151620.1115"># Points are set a bit differently when rendering via OpenGL.
# TODO: refactor Arc so that only one strategy for setting points
# has to be used.
def init_points(self) -&gt; None:
    self.set_points(
        Arc._create_quadratic_bezier_points(
            angle=self.angle,
            start_angle=self.start_angle,
            n_components=self.num_components,
        ),
    )
    self.scale(self.radius, about_point=ORIGIN)
    self.shift(self.arc_center)

</t>
<t tx="ekr.20250122151620.1116">@staticmethod
def _create_quadratic_bezier_points(
    angle: float, start_angle: float = 0, n_components: int = 8
) -&gt; QuadraticSpline:
    samples = np.array(
        [
            [np.cos(a), np.sin(a), 0]
            for a in np.linspace(
                start_angle,
                start_angle + angle,
                2 * n_components + 1,
            )
        ],
    )
    theta = angle / n_components
    samples[1::2] /= np.cos(theta / 2)

    points = np.zeros((3 * n_components, 3))
    points[0::3] = samples[0:-1:2]
    points[1::3] = samples[1::2]
    points[2::3] = samples[2::2]
    return points

</t>
<t tx="ekr.20250122151620.1117">def _set_pre_positioned_points(self) -&gt; None:
    anchors = np.array(
        [
            np.cos(a) * RIGHT + np.sin(a) * UP
            for a in np.linspace(
                self.start_angle,
                self.start_angle + self.angle,
                self.num_components,
            )
        ],
    )
    # Figure out which control points will give the
    # Appropriate tangent lines to the circle
    d_theta = self.angle / (self.num_components - 1.0)
    tangent_vectors = np.zeros(anchors.shape)
    # Rotate all 90 degrees, via (x, y) -&gt; (-y, x)
    tangent_vectors[:, 1] = anchors[:, 0]
    tangent_vectors[:, 0] = -anchors[:, 1]
    # Use tangent vectors to deduce anchors
    factor = 4 / 3 * np.tan(d_theta / 4)
    handles1 = anchors[:-1] + factor * tangent_vectors[:-1]
    handles2 = anchors[1:] - factor * tangent_vectors[1:]
    self.set_anchors_and_handles(anchors[:-1], handles1, handles2, anchors[1:])

</t>
<t tx="ekr.20250122151620.1118">def get_arc_center(self, warning: bool = True) -&gt; Point3D:
    """Looks at the normals to the first two
    anchors, and finds their intersection points
    """
    # First two anchors and handles
    a1, h1, h2, a2 = self.points[:4]

    if np.all(a1 == a2):
        # For a1 and a2 to lie at the same point arc radius
        # must be zero. Thus arc_center will also lie at
        # that point.
        return np.copy(a1)
    # Tangent vectors
    t1 = h1 - a1
    t2 = h2 - a2
    # Normals
    n1 = rotate_vector(t1, TAU / 4)
    n2 = rotate_vector(t2, TAU / 4)
    try:
        return line_intersection(line1=(a1, a1 + n1), line2=(a2, a2 + n2))
    except Exception:
        if warning:
            warnings.warn(
                "Can't find Arc center, using ORIGIN instead", stacklevel=1
            )
        self._failed_to_get_center = True
        return np.array(ORIGIN)

</t>
<t tx="ekr.20250122151620.1119">def move_arc_center_to(self, point: Point3DLike) -&gt; Self:
    self.shift(point - self.get_arc_center())
    return self

</t>
<t tx="ekr.20250122151620.112">@property
def frame_rate(self) -&gt; float:
    """Frame rate in frames per second."""
    return self._d["frame_rate"]

</t>
<t tx="ekr.20250122151620.1120">def stop_angle(self) -&gt; float:
    return cast(
        float,
        angle_of_vector(self.points[-1] - self.get_arc_center()) % TAU,
    )


</t>
<t tx="ekr.20250122151620.1121">def __init__(
    self,
    start: Point3DLike,
    end: Point3DLike,
    angle: float = TAU / 4,
    radius: float | None = None,
    **kwargs: Any,
) -&gt; None:
    if radius is not None:
        self.radius = radius
        if radius &lt; 0:
            sign = -2
            radius *= -1
        else:
            sign = 2
        halfdist = np.linalg.norm(np.array(start) - np.array(end)) / 2
        if radius &lt; halfdist:
            raise ValueError(
                """ArcBetweenPoints called with a radius that is
                        smaller than half the distance between the points.""",
            )
        arc_height = radius - np.sqrt(radius**2 - halfdist**2)
        angle = np.arccos((radius - arc_height) / radius) * sign

    super().__init__(radius=radius, angle=angle, **kwargs)
    if angle == 0:
        self.set_points_as_corners(np.array([LEFT, RIGHT]))
    self.put_start_and_end_on(start, end)

    if radius is None:
        center = self.get_arc_center(warning=False)
        if not self._failed_to_get_center:
            # np.linalg.norm returns floating[Any] which is not compatible with float
            self.radius = cast(
                float, np.linalg.norm(np.array(start) - np.array(center))
            )
        else:
            self.radius = np.inf


</t>
<t tx="ekr.20250122151620.1122">def __init__(
    self, start_point: Point3DLike, end_point: Point3DLike, **kwargs: Any
) -&gt; None:
    from manim.mobject.geometry.tips import ArrowTriangleFilledTip

    tip_shape = kwargs.pop("tip_shape", ArrowTriangleFilledTip)
    super().__init__(start_point, end_point, **kwargs)
    self.add_tip(tip_shape=tip_shape)


</t>
<t tx="ekr.20250122151620.1123">def __init__(
    self, start_point: Point3DLike, end_point: Point3DLike, **kwargs: Any
) -&gt; None:
    if "tip_shape_end" in kwargs:
        kwargs["tip_shape"] = kwargs.pop("tip_shape_end")
    from manim.mobject.geometry.tips import ArrowTriangleFilledTip

    tip_shape_start = kwargs.pop("tip_shape_start", ArrowTriangleFilledTip)
    super().__init__(start_point, end_point, **kwargs)
    self.add_tip(at_start=True, tip_shape=tip_shape_start)


</t>
<t tx="ekr.20250122151620.1124">def __init__(
    self,
    radius: float | None = None,
    color: ParsableManimColor = RED,
    **kwargs: Any,
) -&gt; None:
    super().__init__(
        radius=radius,
        start_angle=0,
        angle=TAU,
        color=color,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.1125">def surround(
    self,
    mobject: Mobject,
    dim_to_match: int = 0,
    stretch: bool = False,
    buffer_factor: float = 1.2,
) -&gt; Self:
    """Modifies a circle so that it surrounds a given mobject.

    Parameters
    ----------
    mobject
        The mobject that the circle will be surrounding.
    dim_to_match
    buffer_factor
        Scales the circle with respect to the mobject. A `buffer_factor` &lt; 1 makes the circle smaller than the mobject.
    stretch
        Stretches the circle to fit more tightly around the mobject. Note: Does not work with :class:`Line`

    Examples
    --------
    .. manim:: CircleSurround
        :save_last_frame:

        class CircleSurround(Scene):
            def construct(self):
                triangle1 = Triangle()
                circle1 = Circle().surround(triangle1)
                group1 = Group(triangle1,circle1) # treat the two mobjects as one

                line2 = Line()
                circle2 = Circle().surround(line2, buffer_factor=2.0)
                group2 = Group(line2,circle2)

                # buffer_factor &lt; 1, so the circle is smaller than the square
                square3 = Square()
                circle3 = Circle().surround(square3, buffer_factor=0.5)
                group3 = Group(square3, circle3)

                group = Group(group1, group2, group3).arrange(buff=1)
                self.add(group)
    """
    # Ignores dim_to_match and stretch; result will always be a circle
    # TODO: Perhaps create an ellipse class to handle single-dimension stretching

    # Something goes wrong here when surrounding lines?
    # TODO: Figure out and fix
    self.replace(mobject, dim_to_match, stretch)

    self.width = np.sqrt(mobject.width**2 + mobject.height**2)
    return self.scale(buffer_factor)

</t>
<t tx="ekr.20250122151620.1126">def point_at_angle(self, angle: float) -&gt; Point3D:
    """Returns the position of a point on the circle.

    Parameters
    ----------
    angle
        The angle of the point along the circle in radians.

    Returns
    -------
    :class:`numpy.ndarray`
        The location of the point along the circle's circumference.

    Examples
    --------
    .. manim:: PointAtAngleExample
        :save_last_frame:

        class PointAtAngleExample(Scene):
            def construct(self):
                circle = Circle(radius=2.0)
                p1 = circle.point_at_angle(PI/2)
                p2 = circle.point_at_angle(270*DEGREES)

                s1 = Square(side_length=0.25).move_to(p1)
                s2 = Square(side_length=0.25).move_to(p2)
                self.add(circle, s1, s2)

    """
    start_angle = angle_of_vector(self.points[0] - self.get_center())
    proportion = (angle - start_angle) / TAU
    proportion -= np.floor(proportion)
    return self.point_from_proportion(proportion)

</t>
<t tx="ekr.20250122151620.1127">@staticmethod
def from_three_points(
    p1: Point3DLike, p2: Point3DLike, p3: Point3DLike, **kwargs: Any
) -&gt; Circle:
    """Returns a circle passing through the specified
    three points.

    Example
    -------
    .. manim:: CircleFromPointsExample
        :save_last_frame:

        class CircleFromPointsExample(Scene):
            def construct(self):
                circle = Circle.from_three_points(LEFT, LEFT + UP, UP * 2, color=RED)
                dots = VGroup(
                    Dot(LEFT),
                    Dot(LEFT + UP),
                    Dot(UP * 2),
                )
                self.add(NumberPlane(), circle, dots)
    """
    center = line_intersection(
        perpendicular_bisector([np.asarray(p1), np.asarray(p2)]),
        perpendicular_bisector([np.asarray(p2), np.asarray(p3)]),
    )
    # np.linalg.norm returns floating[Any] which is not compatible with float
    radius = cast(float, np.linalg.norm(p1 - center))
    return Circle(radius=radius, **kwargs).shift(center)


</t>
<t tx="ekr.20250122151620.1128">def __init__(
    self,
    point: Point3DLike = ORIGIN,
    radius: float = DEFAULT_DOT_RADIUS,
    stroke_width: float = 0,
    fill_opacity: float = 1.0,
    color: ParsableManimColor = WHITE,
    **kwargs: Any,
) -&gt; None:
    super().__init__(
        arc_center=point,
        radius=radius,
        stroke_width=stroke_width,
        fill_opacity=fill_opacity,
        color=color,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.1129">def __init__(
    self,
    radius: float = DEFAULT_DOT_RADIUS * 1.3,
    stroke_width: float = 5,
    stroke_color: ParsableManimColor = WHITE,
    fill_color: ParsableManimColor = BLUE,
    **kwargs: Any,
) -&gt; None:
    super().__init__(
        radius=radius,
        stroke_width=stroke_width,
        stroke_color=stroke_color,
        fill_color=fill_color,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.113">@frame_rate.setter
def frame_rate(self, value: float) -&gt; None:
    self._d.__setitem__("frame_rate", value)

</t>
<t tx="ekr.20250122151620.1130">def __init__(
    self,
    label: str | SingleStringMathTex | Text | Tex,
    radius: float | None = None,
    **kwargs: Any,
) -&gt; None:
    if isinstance(label, str):
        from manim import MathTex

        rendered_label: VMobject = MathTex(label, color=BLACK)
    else:
        rendered_label = label

    if radius is None:
        radius = 0.1 + max(rendered_label.width, rendered_label.height) / 2
    super().__init__(radius=radius, **kwargs)
    rendered_label.move_to(self.get_center())
    self.add(rendered_label)


</t>
<t tx="ekr.20250122151620.1131">def __init__(self, width: float = 2, height: float = 1, **kwargs: Any) -&gt; None:
    super().__init__(**kwargs)
    self.stretch_to_fit_width(width)
    self.stretch_to_fit_height(height)


</t>
<t tx="ekr.20250122151620.1132">def __init__(
    self,
    inner_radius: float = 1,
    outer_radius: float = 2,
    angle: float = TAU / 4,
    start_angle: float = 0,
    fill_opacity: float = 1,
    stroke_width: float = 0,
    color: ParsableManimColor = WHITE,
    **kwargs: Any,
) -&gt; None:
    self.inner_radius = inner_radius
    self.outer_radius = outer_radius
    super().__init__(
        start_angle=start_angle,
        angle=angle,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        color=color,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.1133">def generate_points(self) -&gt; None:
    inner_arc, outer_arc = (
        Arc(
            start_angle=self.start_angle,
            angle=self.angle,
            radius=radius,
            arc_center=self.arc_center,
        )
        for radius in (self.inner_radius, self.outer_radius)
    )
    outer_arc.reverse_points()
    self.append_points(inner_arc.points)
    self.add_line_to(outer_arc.points[0])
    self.append_points(outer_arc.points)
    self.add_line_to(inner_arc.points[0])

</t>
<t tx="ekr.20250122151620.1134">def __init__(self, radius: float = 1, **kwargs: Any) -&gt; None:
    super().__init__(inner_radius=0, outer_radius=radius, **kwargs)


</t>
<t tx="ekr.20250122151620.1135">def __init__(
    self,
    inner_radius: float = 1,
    outer_radius: float = 2,
    fill_opacity: float = 1,
    stroke_width: float = 0,
    color: ParsableManimColor = WHITE,
    mark_paths_closed: bool = False,
    **kwargs: Any,
) -&gt; None:
    self.mark_paths_closed = mark_paths_closed  # is this even used?
    self.inner_radius = inner_radius
    self.outer_radius = outer_radius
    super().__init__(
        fill_opacity=fill_opacity, stroke_width=stroke_width, color=color, **kwargs
    )

</t>
<t tx="ekr.20250122151620.1136">def generate_points(self) -&gt; None:
    self.radius = self.outer_radius
    outer_circle = Circle(radius=self.outer_radius)
    inner_circle = Circle(radius=self.inner_radius)
    inner_circle.reverse_points()
    self.append_points(outer_circle.points)
    self.append_points(inner_circle.points)
    self.shift(self.arc_center)

</t>
<t tx="ekr.20250122151620.1137">def __init__(
    self,
    start_anchor: Point3DLike,
    start_handle: Point3DLike,
    end_handle: Point3DLike,
    end_anchor: Point3DLike,
    **kwargs: Any,
) -&gt; None:
    super().__init__(**kwargs)
    self.add_cubic_bezier_curve(start_anchor, start_handle, end_handle, end_anchor)


</t>
<t tx="ekr.20250122151620.1138">def __init__(
    self,
    *vertices: Point3DLike,
    angle: float = PI / 4,
    radius: float | None = None,
    arc_config: list[dict] | None = None,
    **kwargs: Any,
) -&gt; None:
    n = len(vertices)
    point_pairs = [(vertices[k], vertices[(k + 1) % n]) for k in range(n)]

    if not arc_config:
        if radius:
            all_arc_configs: Iterable[dict] = itertools.repeat(
                {"radius": radius}, len(point_pairs)
            )
        else:
            all_arc_configs = itertools.repeat({"angle": angle}, len(point_pairs))
    elif isinstance(arc_config, dict):
        all_arc_configs = itertools.repeat(arc_config, len(point_pairs))
    else:
        assert len(arc_config) == n
        all_arc_configs = arc_config

    arcs = [
        ArcBetweenPoints(*pair, **conf)
        for (pair, conf) in zip(point_pairs, all_arc_configs)
    ]

    super().__init__(**kwargs)
    # Adding the arcs like this makes ArcPolygon double as a VGroup.
    # Also makes changes to the ArcPolygon, such as scaling, affect
    # the arcs, so that their new values are usable.
    self.add(*arcs)
    for arc in arcs:
        self.append_points(arc.points)

    # This enables the use of ArcPolygon.arcs as a convenience
    # because ArcPolygon[0] returns itself, not the first Arc.
    self.arcs = arcs


</t>
<t tx="ekr.20250122151620.1139">def __init__(self, *arcs: Arc | ArcBetweenPoints, **kwargs: Any) -&gt; None:
    if not all(isinstance(m, (Arc, ArcBetweenPoints)) for m in arcs):
        raise ValueError(
            "All ArcPolygon submobjects must be of type Arc/ArcBetweenPoints",
        )
    super().__init__(**kwargs)
    # Adding the arcs like this makes ArcPolygonFromArcs double as a VGroup.
    # Also makes changes to the ArcPolygonFromArcs, such as scaling, affect
    # the arcs, so that their new values are usable.
    self.add(*arcs)
    # This enables the use of ArcPolygonFromArcs.arcs as a convenience
    # because ArcPolygonFromArcs[0] returns itself, not the first Arc.
    self.arcs = [*arcs]
    from .line import Line

    for arc1, arc2 in adjacent_pairs(arcs):
        self.append_points(arc1.points)
        line = Line(arc1.get_end(), arc2.get_start())
        len_ratio = line.get_length() / arc1.get_arc_length()
        if np.isnan(len_ratio) or np.isinf(len_ratio):
            continue
        line.insert_n_curves(int(arc1.get_num_curves() * len_ratio))
        self.append_points(line.points)
</t>
<t tx="ekr.20250122151620.114"># TODO: This was parsed before maybe add ManimColor(val), but results in circular import
@property
def background_color(self) -&gt; ManimColor:
    """Background color of the scene (-c)."""
    return self._d["background_color"]

</t>
<t tx="ekr.20250122151620.1140">"""Boolean operations for two-dimensional mobjects."""

from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np
from pathops import Path as SkiaPath
from pathops import PathVerb, difference, intersection, union, xor

from manim import config
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.types.vectorized_mobject import VMobject

if TYPE_CHECKING:
    from typing import Any

    from manim.typing import Point2DLike_Array, Point3D_Array, Point3DLike_Array

from ...constants import RendererType

__all__ = ["Union", "Intersection", "Difference", "Exclusion"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1141">class _BooleanOps(VMobject, metaclass=ConvertToOpenGL):
    """This class contains some helper functions which
    helps to convert to and from skia objects and manim
    objects (:class:`~.VMobject`).
    """

    @others
</t>
<t tx="ekr.20250122151620.1142">class Union(_BooleanOps):
    """Union of two or more :class:`~.VMobject` s. This returns the common region of
    the :class:`~VMobject` s.

    Parameters
    ----------
    vmobjects
        The :class:`~.VMobject` s to find the union of.

    Raises
    ------
    ValueError
        If less than 2 :class:`~.VMobject` s are passed.

    Example
    -------
    .. manim:: UnionExample
        :save_last_frame:

        class UnionExample(Scene):
            def construct(self):
                sq = Square(color=RED, fill_opacity=1)
                sq.move_to([-2, 0, 0])
                cr = Circle(color=BLUE, fill_opacity=1)
                cr.move_to([-1.3, 0.7, 0])
                un = Union(sq, cr, color=GREEN, fill_opacity=1)
                un.move_to([1.5, 0.3, 0])
                self.add(sq, cr, un)

    """

    @others
</t>
<t tx="ekr.20250122151620.1143">class Difference(_BooleanOps):
    """Subtracts one :class:`~.VMobject` from another one.

    Parameters
    ----------
    subject
        The 1st :class:`~.VMobject`.
    clip
        The 2nd :class:`~.VMobject`

    Example
    -------
    .. manim:: DifferenceExample
        :save_last_frame:

        class DifferenceExample(Scene):
            def construct(self):
                sq = Square(color=RED, fill_opacity=1)
                sq.move_to([-2, 0, 0])
                cr = Circle(color=BLUE, fill_opacity=1)
                cr.move_to([-1.3, 0.7, 0])
                un = Difference(sq, cr, color=GREEN, fill_opacity=1)
                un.move_to([1.5, 0, 0])
                self.add(sq, cr, un)

    """

    @others
</t>
<t tx="ekr.20250122151620.1144">class Intersection(_BooleanOps):
    """Find the intersection of two :class:`~.VMobject` s.
    This keeps the parts covered by both :class:`~.VMobject` s.

    Parameters
    ----------
    vmobjects
        The :class:`~.VMobject` to find the intersection.

    Raises
    ------
    ValueError
        If less the 2 :class:`~.VMobject` are passed.

    Example
    -------
    .. manim:: IntersectionExample
        :save_last_frame:

        class IntersectionExample(Scene):
            def construct(self):
                sq = Square(color=RED, fill_opacity=1)
                sq.move_to([-2, 0, 0])
                cr = Circle(color=BLUE, fill_opacity=1)
                cr.move_to([-1.3, 0.7, 0])
                un = Intersection(sq, cr, color=GREEN, fill_opacity=1)
                un.move_to([1.5, 0, 0])
                self.add(sq, cr, un)

    """

    @others
</t>
<t tx="ekr.20250122151620.1145">class Exclusion(_BooleanOps):
    """Find the XOR between two :class:`~.VMobject`.
    This creates a new :class:`~.VMobject` consisting of the region
    covered by exactly one of them.

    Parameters
    ----------
    subject
        The 1st :class:`~.VMobject`.
    clip
        The 2nd :class:`~.VMobject`

    Example
    -------
    .. manim:: IntersectionExample
        :save_last_frame:

        class IntersectionExample(Scene):
            def construct(self):
                sq = Square(color=RED, fill_opacity=1)
                sq.move_to([-2, 0, 0])
                cr = Circle(color=BLUE, fill_opacity=1)
                cr.move_to([-1.3, 0.7, 0])
                un = Exclusion(sq, cr, color=GREEN, fill_opacity=1)
                un.move_to([1.5, 0.4, 0])
                self.add(sq, cr, un)

    """

    @others
</t>
<t tx="ekr.20250122151620.1146">def _convert_2d_to_3d_array(
    self,
    points: Point2DLike_Array | Point3DLike_Array,
    z_dim: float = 0.0,
) -&gt; Point3D_Array:
    """Converts an iterable with coordinates in 2D to 3D by adding
    :attr:`z_dim` as the Z coordinate.

    Parameters
    ----------
    points
        An iterable of points.
    z_dim
        Default value for the Z coordinate.

    Returns
    -------
    Point3D_Array
        A list of the points converted to 3D.

    Example
    -------
    &gt;&gt;&gt; a = _BooleanOps()
    &gt;&gt;&gt; p = [(1, 2), (3, 4)]
    &gt;&gt;&gt; a._convert_2d_to_3d_array(p)
    array([[1., 2., 0.],
           [3., 4., 0.]])
    """
    list_of_points = list(points)
    for i, point in enumerate(list_of_points):
        if len(point) == 2:
            list_of_points[i] = np.array(list(point) + [z_dim])
    return np.asarray(list_of_points)

</t>
<t tx="ekr.20250122151620.1147">def _convert_vmobject_to_skia_path(self, vmobject: VMobject) -&gt; SkiaPath:
    """Converts a :class:`~.VMobject` to SkiaPath. This method only works for
    cairo renderer because it treats the points as Cubic beizer curves.

    Parameters
    ----------
    vmobject:
        The :class:`~.VMobject` to convert from.

    Returns
    -------
    SkiaPath
        The converted path.
    """
    path = SkiaPath()

    if not np.all(np.isfinite(vmobject.points)):
        points = np.zeros((1, 3))  # point invalid?
    else:
        points = vmobject.points

    if len(points) == 0:  # what? No points so return empty path
        return path

    # In OpenGL it's quadratic beizer curves while on Cairo it's cubic...
    if config.renderer == RendererType.OPENGL:
        subpaths = vmobject.get_subpaths_from_points(points)
        for subpath in subpaths:
            quads = vmobject.get_bezier_tuples_from_points(subpath)
            start = subpath[0]
            path.moveTo(*start[:2])
            for _p0, p1, p2 in quads:
                path.quadTo(*p1[:2], *p2[:2])
            if vmobject.consider_points_equals(subpath[0], subpath[-1]):
                path.close()
    elif config.renderer == RendererType.CAIRO:
        subpaths = vmobject.gen_subpaths_from_points_2d(points)  # type: ignore[assignment]
        for subpath in subpaths:
            quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)
            start = subpath[0]
            path.moveTo(*start[:2])
            for _p0, p1, p2, p3 in quads:
                path.cubicTo(*p1[:2], *p2[:2], *p3[:2])

            if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):
                path.close()

    return path

</t>
<t tx="ekr.20250122151620.1148">def _convert_skia_path_to_vmobject(self, path: SkiaPath) -&gt; VMobject:
    """Converts SkiaPath back to VMobject.
    Parameters
    ----------
    path:
        The SkiaPath to convert.

    Returns
    -------
    VMobject:
        The converted VMobject.
    """
    vmobject = self
    current_path_start = np.array([0, 0, 0])

    for path_verb, points in path:
        if path_verb == PathVerb.MOVE:
            parts = self._convert_2d_to_3d_array(points)
            for part in parts:
                current_path_start = part
                vmobject.start_new_path(part)
                # vmobject.move_to(*part)
        elif path_verb == PathVerb.CUBIC:
            n1, n2, n3 = self._convert_2d_to_3d_array(points)
            vmobject.add_cubic_bezier_curve_to(n1, n2, n3)
        elif path_verb == PathVerb.LINE:
            parts = self._convert_2d_to_3d_array(points)
            vmobject.add_line_to(parts[0])
        elif path_verb == PathVerb.CLOSE:
            vmobject.add_line_to(current_path_start)
        elif path_verb == PathVerb.QUAD:
            n1, n2 = self._convert_2d_to_3d_array(points)
            vmobject.add_quadratic_bezier_curve_to(n1, n2)
        else:
            raise Exception(f"Unsupported: {path_verb}")
    return vmobject


</t>
<t tx="ekr.20250122151620.1149">def __init__(self, *vmobjects: VMobject, **kwargs: Any) -&gt; None:
    if len(vmobjects) &lt; 2:
        raise ValueError("At least 2 mobjects needed for Union.")
    super().__init__(**kwargs)
    paths = []
    for vmobject in vmobjects:
        paths.append(self._convert_vmobject_to_skia_path(vmobject))
    outpen = SkiaPath()
    union(paths, outpen.getPen())
    self._convert_skia_path_to_vmobject(outpen)


</t>
<t tx="ekr.20250122151620.115">@background_color.setter
def background_color(self, value: Any) -&gt; None:
    self._d.__setitem__("background_color", ManimColor(value))

</t>
<t tx="ekr.20250122151620.1150">def __init__(self, subject: VMobject, clip: VMobject, **kwargs: Any) -&gt; None:
    super().__init__(**kwargs)
    outpen = SkiaPath()
    difference(
        [self._convert_vmobject_to_skia_path(subject)],
        [self._convert_vmobject_to_skia_path(clip)],
        outpen.getPen(),
    )
    self._convert_skia_path_to_vmobject(outpen)


</t>
<t tx="ekr.20250122151620.1151">def __init__(self, *vmobjects: VMobject, **kwargs: Any) -&gt; None:
    if len(vmobjects) &lt; 2:
        raise ValueError("At least 2 mobjects needed for Intersection.")

    super().__init__(**kwargs)
    outpen = SkiaPath()
    intersection(
        [self._convert_vmobject_to_skia_path(vmobjects[0])],
        [self._convert_vmobject_to_skia_path(vmobjects[1])],
        outpen.getPen(),
    )
    new_outpen = outpen
    for _i in range(2, len(vmobjects)):
        new_outpen = SkiaPath()
        intersection(
            [outpen],
            [self._convert_vmobject_to_skia_path(vmobjects[_i])],
            new_outpen.getPen(),
        )
        outpen = new_outpen

    self._convert_skia_path_to_vmobject(outpen)


</t>
<t tx="ekr.20250122151620.1152">def __init__(self, subject: VMobject, clip: VMobject, **kwargs: Any) -&gt; None:
    super().__init__(**kwargs)
    outpen = SkiaPath()
    xor(
        [self._convert_vmobject_to_skia_path(subject)],
        [self._convert_vmobject_to_skia_path(clip)],
        outpen.getPen(),
    )
    self._convert_skia_path_to_vmobject(outpen)
</t>
<t tx="ekr.20250122151620.1153">r"""Mobjects that inherit from lines and contain a label along the length."""

from __future__ import annotations

__all__ = ["Label", "LabeledLine", "LabeledArrow", "LabeledPolygram"]

from typing import TYPE_CHECKING

import numpy as np

from manim.constants import *
from manim.mobject.geometry.line import Arrow, Line
from manim.mobject.geometry.polygram import Polygram
from manim.mobject.geometry.shape_matchers import (
    BackgroundRectangle,
    SurroundingRectangle,
)
from manim.mobject.text.tex_mobject import MathTex, Tex
from manim.mobject.text.text_mobject import Text
from manim.mobject.types.vectorized_mobject import VGroup
from manim.utils.color import WHITE
from manim.utils.polylabel import polylabel

if TYPE_CHECKING:
    from typing import Any

    from manim.typing import Point3DLike_Array


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1154">class Label(VGroup):
    """A Label consisting of text surrounded by a frame.

    Parameters
    ----------
    label
        Label that will be displayed.
    label_config
        A dictionary containing the configuration for the label.
        This is only applied if ``label`` is of type ``str``.
    box_config
        A dictionary containing the configuration for the background box.
    frame_config
         A dictionary containing the configuration for the frame.

    Examples
    --------
    .. manim:: LabelExample
        :save_last_frame:
        :quality: high

        class LabelExample(Scene):
            def construct(self):
                label = Label(
                    label=Text('Label Text', font='sans-serif'),
                    box_config = {
                        "color" : BLUE,
                        "fill_opacity" : 0.75
                    }
                )
                label.scale(3)
                self.add(label)
    """

    @others
</t>
<t tx="ekr.20250122151620.1155">class LabeledLine(Line):
    """Constructs a line containing a label box somewhere along its length.

    Parameters
    ----------
    label
        Label that will be displayed on the line.
    label_position
        A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.
    label_config
        A dictionary containing the configuration for the label.
        This is only applied if ``label`` is of type ``str``.
    box_config
        A dictionary containing the configuration for the background box.
    frame_config
         A dictionary containing the configuration for the frame.

        .. seealso::
            :class:`LabeledArrow`

    Examples
    --------
    .. manim:: LabeledLineExample
        :save_last_frame:
        :quality: high

        class LabeledLineExample(Scene):
            def construct(self):
                line = LabeledLine(
                    label          = '0.5',
                    label_position = 0.8,
                    label_config = {
                        "font_size" : 20
                    },
                    start=LEFT+DOWN,
                    end=RIGHT+UP)

                line.set_length(line.get_length() * 2)
                self.add(line)
    """

    @others
</t>
<t tx="ekr.20250122151620.1156">class LabeledArrow(LabeledLine, Arrow):
    """Constructs an arrow containing a label box somewhere along its length.
    This class inherits its label properties from `LabeledLine`, so the main parameters controlling it are the same.

    Parameters
    ----------
    label
        Label that will be displayed on the Arrow.
    label_position
        A ratio in the range [0-1] to indicate the position of the label with respect to the length of the line. Default value is 0.5.
    label_config
        A dictionary containing the configuration for the label.
        This is only applied if ``label`` is of type ``str``.
    box_config
        A dictionary containing the configuration for the background box.
    frame_config
         A dictionary containing the configuration for the frame.

        .. seealso::
            :class:`LabeledLine`

    Examples
    --------
    .. manim:: LabeledArrowExample
        :save_last_frame:
        :quality: high

        class LabeledArrowExample(Scene):
            def construct(self):
                l_arrow = LabeledArrow("0.5", start=LEFT*3, end=RIGHT*3 + UP*2, label_position=0.5)

                self.add(l_arrow)
    """

    @others
</t>
<t tx="ekr.20250122151620.1157">class LabeledPolygram(Polygram):
    """Constructs a polygram containing a label box at its pole of inaccessibility.

    Parameters
    ----------
    vertex_groups
        Vertices passed to the :class:`~.Polygram` constructor.
    label
        Label that will be displayed on the Polygram.
    precision
        The precision used by the PolyLabel algorithm.
    label_config
        A dictionary containing the configuration for the label.
        This is only applied if ``label`` is of type ``str``.
    box_config
        A dictionary containing the configuration for the background box.
    frame_config
         A dictionary containing the configuration for the frame.

        .. note::
            The PolyLabel Algorithm expects each vertex group to form a closed ring.
            If the input is open, :class:`LabeledPolygram` will attempt to close it.
            This may cause the polygon to intersect itself leading to unexpected results.

        .. tip::
            Make sure the precision corresponds to the scale of your inputs!
            For instance, if the bounding box of your polygon stretches from 0 to 10,000, a precision of 1.0 or 10.0 should be sufficient.

    Examples
    --------
    .. manim:: LabeledPolygramExample
        :save_last_frame:
        :quality: high

        class LabeledPolygramExample(Scene):
            def construct(self):
                # Define Rings
                ring1 = [
                    [-3.8, -2.4, 0], [-2.4, -2.5, 0], [-1.3, -1.6, 0], [-0.2, -1.7, 0],
                    [1.7, -2.5, 0], [2.9, -2.6, 0], [3.5, -1.5, 0], [4.9, -1.4, 0],
                    [4.5, 0.2, 0], [4.7, 1.6, 0], [3.5, 2.4, 0], [1.1, 2.5, 0],
                    [-0.1, 0.9, 0], [-1.2, 0.5, 0], [-1.6, 0.7, 0], [-1.4, 1.9, 0],
                    [-2.6, 2.6, 0], [-4.4, 1.2, 0], [-4.9, -0.8, 0], [-3.8, -2.4, 0]
                ]
                ring2 = [
                    [0.2, -1.2, 0], [0.9, -1.2, 0], [1.4, -2.0, 0], [2.1, -1.6, 0],
                    [2.2, -0.5, 0], [1.4, 0.0, 0], [0.4, -0.2, 0], [0.2, -1.2, 0]
                ]
                ring3 = [[-2.7, 1.4, 0], [-2.3, 1.7, 0], [-2.8, 1.9, 0], [-2.7, 1.4, 0]]

                # Create Polygons (for reference)
                p1 = Polygon(*ring1, fill_opacity=0.75)
                p2 = Polygon(*ring2, fill_color=BLACK, fill_opacity=1)
                p3 = Polygon(*ring3, fill_color=BLACK, fill_opacity=1)

                # Create Labeled Polygram
                polygram = LabeledPolygram(
                    *[ring1, ring2, ring3],
                    label=Text('Pole', font='sans-serif'),
                    precision=0.01,
                )

                # Display Circle (for reference)
                circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)

                self.add(p1, p2, p3)
                self.add(polygram)
                self.add(circle)

    .. manim:: LabeledCountryExample
        :save_last_frame:
        :quality: high

        import requests
        import json

        class LabeledCountryExample(Scene):
            def construct(self):
                # Fetch JSON data and process arcs
                data = requests.get('https://cdn.jsdelivr.net/npm/us-atlas@3/nation-10m.json').json()
                arcs, transform = data['arcs'], data['transform']
                sarcs = [np.cumsum(arc, axis=0) * transform['scale'] + transform['translate'] for arc in arcs]
                ssarcs = sorted(sarcs, key=len, reverse=True)[:1]

                # Compute Bounding Box
                points = np.concatenate(ssarcs)
                mins, maxs = np.min(points, axis=0), np.max(points, axis=0)

                # Build Axes
                ax = Axes(
                    x_range=[mins[0], maxs[0], maxs[0] - mins[0]], x_length=10,
                    y_range=[mins[1], maxs[1], maxs[1] - mins[1]], y_length=7,
                    tips=False
                )

                # Adjust Coordinates
                array = [[ax.c2p(*point) for point in sarc] for sarc in ssarcs]

                # Add Polygram
                polygram = LabeledPolygram(
                    *array,
                    label=Text('USA', font='sans-serif'),
                    precision=0.01,
                    fill_color=BLUE,
                    stroke_width=0,
                    fill_opacity=0.75
                )

                # Display Circle (for reference)
                circle = Circle(radius=polygram.radius, color=WHITE).move_to(polygram.pole)

                self.add(ax)
                self.add(polygram)
                self.add(circle)
    """

    @others
</t>
<t tx="ekr.20250122151620.1158">def __init__(
    self,
    label: str | Tex | MathTex | Text,
    label_config: dict[str, Any] | None = None,
    box_config: dict[str, Any] | None = None,
    frame_config: dict[str, Any] | None = None,
    **kwargs: Any,
) -&gt; None:
    super().__init__(**kwargs)

    # Setup Defaults
    default_label_config: dict[str, Any] = {
        "color": WHITE,
        "font_size": DEFAULT_FONT_SIZE,
    }

    default_box_config: dict[str, Any] = {
        "color": None,
        "buff": 0.05,
        "fill_opacity": 1,
        "stroke_width": 0.5,
    }

    default_frame_config: dict[str, Any] = {
        "color": WHITE,
        "buff": 0.05,
        "stroke_width": 0.5,
    }

    # Merge Defaults
    label_config = default_label_config | (label_config or {})
    box_config = default_box_config | (box_config or {})
    frame_config = default_frame_config | (frame_config or {})

    # Determine the type of label and instantiate the appropriate object
    self.rendered_label: MathTex | Tex | Text
    if isinstance(label, str):
        self.rendered_label = MathTex(label, **label_config)
    elif isinstance(label, (MathTex, Tex, Text)):
        self.rendered_label = label
    else:
        raise TypeError("Unsupported label type. Must be MathTex, Tex, or Text.")

    # Add a background box
    self.background_rect = BackgroundRectangle(self.rendered_label, **box_config)

    # Add a frame around the label
    self.frame = SurroundingRectangle(self.rendered_label, **frame_config)

    # Add components to the VGroup
    self.add(self.background_rect, self.rendered_label, self.frame)


</t>
<t tx="ekr.20250122151620.1159">def __init__(
    self,
    label: str | Tex | MathTex | Text,
    label_position: float = 0.5,
    label_config: dict[str, Any] | None = None,
    box_config: dict[str, Any] | None = None,
    frame_config: dict[str, Any] | None = None,
    *args: Any,
    **kwargs: Any,
) -&gt; None:
    super().__init__(*args, **kwargs)

    # Create Label
    self.label = Label(
        label=label,
        label_config=label_config,
        box_config=box_config,
        frame_config=frame_config,
    )

    # Compute Label Position
    line_start, line_end = self.get_start_and_end()
    new_vec = (line_end - line_start) * label_position
    label_coords = line_start + new_vec

    self.label.move_to(label_coords)
    self.add(self.label)


</t>
<t tx="ekr.20250122151620.116">@property
def from_animation_number(self) -&gt; int:
    """Start rendering animations at this number (-n)."""
    return self._d["from_animation_number"]

</t>
<t tx="ekr.20250122151620.1160">def __init__(
    self,
    *args: Any,
    **kwargs: Any,
) -&gt; None:
    super().__init__(*args, **kwargs)


</t>
<t tx="ekr.20250122151620.1161">def __init__(
    self,
    *vertex_groups: Point3DLike_Array,
    label: str | Tex | MathTex | Text,
    precision: float = 0.01,
    label_config: dict[str, Any] | None = None,
    box_config: dict[str, Any] | None = None,
    frame_config: dict[str, Any] | None = None,
    **kwargs: Any,
) -&gt; None:
    # Initialize the Polygram with the vertex groups
    super().__init__(*vertex_groups, **kwargs)

    # Create Label
    self.label = Label(
        label=label,
        label_config=label_config,
        box_config=box_config,
        frame_config=frame_config,
    )

    # Close Vertex Groups
    rings = [
        group if np.array_equal(group[0], group[-1]) else list(group) + [group[0]]
        for group in vertex_groups
    ]

    # Compute the Pole of Inaccessibility
    cell = polylabel(rings, precision=precision)
    self.pole, self.radius = np.pad(cell.c, (0, 1), "constant"), cell.d

    # Position the label at the pole
    self.label.move_to(self.pole)
    self.add(self.label)
</t>
<t tx="ekr.20250122151620.1162">r"""Mobjects that are lines or variations of them."""

from __future__ import annotations

__all__ = [
    "Line",
    "DashedLine",
    "TangentLine",
    "Elbow",
    "Arrow",
    "Vector",
    "DoubleArrow",
    "Angle",
    "RightAngle",
]

from typing import TYPE_CHECKING

import numpy as np

from manim import config
from manim.constants import *
from manim.mobject.geometry.arc import Arc, ArcBetweenPoints, Dot, TipableVMobject
from manim.mobject.geometry.tips import ArrowTriangleFilledTip
from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.mobject.types.vectorized_mobject import DashedVMobject, VGroup, VMobject
from manim.utils.color import WHITE
from manim.utils.space_ops import angle_of_vector, line_intersection, normalize

if TYPE_CHECKING:
    from typing import Any

    from typing_extensions import Literal, Self, TypeAlias

    from manim.typing import Point2DLike, Point3D, Point3DLike, Vector3D
    from manim.utils.color import ParsableManimColor

    from ..matrix import Matrix  # Avoid circular import

    AngleQuadrant: TypeAlias = tuple[Literal[-1, 1], Literal[-1, 1]]
    r"""A tuple of 2 integers which can be either +1 or -1, allowing to select
    one of the 4 quadrants of the Cartesian plane.

    Let :math:`L_1,\ L_2` be two lines defined by start points
    :math:`S_1,\ S_2` and end points :math:`E_1,\ E_2`. We define the "positive
    direction" of :math:`L_1` as the direction from :math:`S_1` to :math:`E_1`,
    and its "negative direction" as the opposite one. We do the same with
    :math:`L_2`.

    If :math:`L_1` and :math:`L_2` intersect, they divide the plane into 4
    quadrants. To pick one quadrant, choose the integers in this tuple in the
    following way:

    -   If the 1st integer is +1, select one of the 2 quadrants towards the
        positive direction of :math:`L_1`, i.e. closest to `E_1`. Otherwise, if
        the 1st integer is -1, select one of the 2 quadrants towards the
        negative direction of :math:`L_1`, i.e. closest to `S_1`.

    -   Similarly, the sign of the 2nd integer picks the positive or negative
        direction of :math:`L_2` and, thus, selects one of the 2 quadrants
        which  are closest to :math:`E_2` or :math:`S_2` respectively.
    """


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1163">class Line(TipableVMobject):
    @others
</t>
<t tx="ekr.20250122151620.1164">class DashedLine(Line):
    """A dashed :class:`Line`.

    Parameters
    ----------
    args
        Arguments to be passed to :class:`Line`
    dash_length
        The length of each individual dash of the line.
    dashed_ratio
        The ratio of dash space to empty space. Range of 0-1.
    kwargs
        Additional arguments to be passed to :class:`Line`


    .. seealso::
        :class:`~.DashedVMobject`

    Examples
    --------
    .. manim:: DashedLineExample
        :save_last_frame:

        class DashedLineExample(Scene):
            def construct(self):
                # dash_length increased
                dashed_1 = DashedLine(config.left_side, config.right_side, dash_length=2.0).shift(UP*2)
                # normal
                dashed_2 = DashedLine(config.left_side, config.right_side)
                # dashed_ratio decreased
                dashed_3 = DashedLine(config.left_side, config.right_side, dashed_ratio=0.1).shift(DOWN*2)
                self.add(dashed_1, dashed_2, dashed_3)
    """

    @others
</t>
<t tx="ekr.20250122151620.1165">class TangentLine(Line):
    """Constructs a line tangent to a :class:`~.VMobject` at a specific point.

    Parameters
    ----------
    vmob
        The VMobject on which the tangent line is drawn.
    alpha
        How far along the shape that the line will be constructed. range: 0-1.
    length
        Length of the tangent line.
    d_alpha
        The ``dx`` value
    kwargs
        Additional arguments to be passed to :class:`Line`


    .. seealso::
        :meth:`~.VMobject.point_from_proportion`

    Examples
    --------
    .. manim:: TangentLineExample
        :save_last_frame:

        class TangentLineExample(Scene):
            def construct(self):
                circle = Circle(radius=2)
                line_1 = TangentLine(circle, alpha=0.0, length=4, color=BLUE_D) # right
                line_2 = TangentLine(circle, alpha=0.4, length=4, color=GREEN) # top left
                self.add(circle, line_1, line_2)
    """

    @others
</t>
<t tx="ekr.20250122151620.1166">class Elbow(VMobject, metaclass=ConvertToOpenGL):
    """Two lines that create a right angle about each other: L-shape.

    Parameters
    ----------
    width
        The length of the elbow's sides.
    angle
        The rotation of the elbow.
    kwargs
        Additional arguments to be passed to :class:`~.VMobject`

    .. seealso::
        :class:`RightAngle`

    Examples
    --------
    .. manim:: ElbowExample
        :save_last_frame:

        class ElbowExample(Scene):
            def construct(self):
                elbow_1 = Elbow()
                elbow_2 = Elbow(width=2.0)
                elbow_3 = Elbow(width=2.0, angle=5*PI/4)

                elbow_group = Group(elbow_1, elbow_2, elbow_3).arrange(buff=1)
                self.add(elbow_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.1167">class Arrow(Line):
    """An arrow.

    Parameters
    ----------
    args
        Arguments to be passed to :class:`Line`.
    stroke_width
        The thickness of the arrow. Influenced by :attr:`max_stroke_width_to_length_ratio`.
    buff
        The distance of the arrow from its start and end points.
    max_tip_length_to_length_ratio
        :attr:`tip_length` scales with the length of the arrow. Increasing this ratio raises the max value of :attr:`tip_length`.
    max_stroke_width_to_length_ratio
        :attr:`stroke_width` scales with the length of the arrow. Increasing this ratio ratios the max value of :attr:`stroke_width`.
    kwargs
        Additional arguments to be passed to :class:`Line`.


    .. seealso::
        :class:`ArrowTip`
        :class:`CurvedArrow`

    Examples
    --------
    .. manim:: ArrowExample
        :save_last_frame:

        from manim.mobject.geometry.tips import ArrowSquareTip
        class ArrowExample(Scene):
            def construct(self):
                arrow_1 = Arrow(start=RIGHT, end=LEFT, color=GOLD)
                arrow_2 = Arrow(start=RIGHT, end=LEFT, color=GOLD, tip_shape=ArrowSquareTip).shift(DOWN)
                g1 = Group(arrow_1, arrow_2)

                # the effect of buff
                square = Square(color=MAROON_A)
                arrow_3 = Arrow(start=LEFT, end=RIGHT)
                arrow_4 = Arrow(start=LEFT, end=RIGHT, buff=0).next_to(arrow_1, UP)
                g2 = Group(arrow_3, arrow_4, square)

                # a shorter arrow has a shorter tip and smaller stroke width
                arrow_5 = Arrow(start=ORIGIN, end=config.top).shift(LEFT * 4)
                arrow_6 = Arrow(start=config.top + DOWN, end=config.top).shift(LEFT * 3)
                g3 = Group(arrow_5, arrow_6)

                self.add(Group(g1, g2, g3).arrange(buff=2))


    .. manim:: ArrowExample
        :save_last_frame:

        class ArrowExample(Scene):
            def construct(self):
                left_group = VGroup()
                # As buff increases, the size of the arrow decreases.
                for buff in np.arange(0, 2.2, 0.45):
                    left_group += Arrow(buff=buff, start=2 * LEFT, end=2 * RIGHT)
                # Required to arrange arrows.
                left_group.arrange(DOWN)
                left_group.move_to(4 * LEFT)

                middle_group = VGroup()
                # As max_stroke_width_to_length_ratio gets bigger,
                # the width of stroke increases.
                for i in np.arange(0, 5, 0.5):
                    middle_group += Arrow(max_stroke_width_to_length_ratio=i)
                middle_group.arrange(DOWN)

                UR_group = VGroup()
                # As max_tip_length_to_length_ratio increases,
                # the length of the tip increases.
                for i in np.arange(0, 0.3, 0.1):
                    UR_group += Arrow(max_tip_length_to_length_ratio=i)
                UR_group.arrange(DOWN)
                UR_group.move_to(4 * RIGHT + 2 * UP)

                DR_group = VGroup()
                DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareTip)
                DR_group += Arrow(start=LEFT, end=RIGHT, color=BLUE, tip_shape=ArrowSquareFilledTip)
                DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleTip)
                DR_group += Arrow(start=LEFT, end=RIGHT, color=YELLOW, tip_shape=ArrowCircleFilledTip)
                DR_group.arrange(DOWN)
                DR_group.move_to(4 * RIGHT + 2 * DOWN)

                self.add(left_group, middle_group, UR_group, DR_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.1168">class Vector(Arrow):
    """A vector specialized for use in graphs.

    .. caution::
        Do not confuse with the :class:`~.Vector2D`,
        :class:`~.Vector3D` or :class:`~.VectorND` type aliases,
        which are not Mobjects!

    Parameters
    ----------
    direction
        The direction of the arrow.
    buff
         The distance of the vector from its endpoints.
    kwargs
        Additional arguments to be passed to :class:`Arrow`

    Examples
    --------
    .. manim:: VectorExample
        :save_last_frame:

        class VectorExample(Scene):
            def construct(self):
                plane = NumberPlane()
                vector_1 = Vector([1,2])
                vector_2 = Vector([-5,-2])
                self.add(plane, vector_1, vector_2)
    """

    @others
</t>
<t tx="ekr.20250122151620.1169">class DoubleArrow(Arrow):
    """An arrow with tips on both ends.

    Parameters
    ----------
    args
        Arguments to be passed to :class:`Arrow`
    kwargs
        Additional arguments to be passed to :class:`Arrow`


    .. seealso::
        :class:`.~ArrowTip`
        :class:`.~CurvedDoubleArrow`

    Examples
    --------
    .. manim:: DoubleArrowExample
        :save_last_frame:

        from manim.mobject.geometry.tips import ArrowCircleFilledTip
        class DoubleArrowExample(Scene):
            def construct(self):
                circle = Circle(radius=2.0)
                d_arrow = DoubleArrow(start=circle.get_left(), end=circle.get_right())
                d_arrow_2 = DoubleArrow(tip_shape_end=ArrowCircleFilledTip, tip_shape_start=ArrowCircleFilledTip)
                group = Group(Group(circle, d_arrow), d_arrow_2).arrange(UP, buff=1)
                self.add(group)


    .. manim:: DoubleArrowExample2
        :save_last_frame:

        class DoubleArrowExample2(Scene):
            def construct(self):
                box = Square()
                p1 = box.get_left()
                p2 = box.get_right()
                d1 = DoubleArrow(p1, p2, buff=0)
                d2 = DoubleArrow(p1, p2, buff=0, tip_length=0.2, color=YELLOW)
                d3 = DoubleArrow(p1, p2, buff=0, tip_length=0.4, color=BLUE)
                Group(d1, d2, d3).arrange(DOWN)
                self.add(box, d1, d2, d3)
    """

    @others
</t>
<t tx="ekr.20250122151620.117">@from_animation_number.setter
def from_animation_number(self, value: int) -&gt; None:
    self._d.__setitem__("from_animation_number", value)

</t>
<t tx="ekr.20250122151620.1170">class Angle(VMobject, metaclass=ConvertToOpenGL):
    """A circular arc or elbow-type mobject representing an angle of two lines.

    Parameters
    ----------
    line1 :
        The first line.
    line2 :
        The second line.
    radius :
        The radius of the :class:`Arc`.
    quadrant
        A sequence of two :class:`int` numbers determining which of the 4 quadrants should be used.
        The first value indicates whether to anchor the arc on the first line closer to the end point (1)
        or start point (-1), and the second value functions similarly for the
        end (1) or start (-1) of the second line.
        Possibilities: (1,1), (-1,1), (1,-1), (-1,-1).
    other_angle :
        Toggles between the two possible angles defined by two points and an arc center. If set to
        False (default), the arc will always go counterclockwise from the point on line1 until
        the point on line2 is reached. If set to True, the angle will go clockwise from line1 to line2.
    dot
        Allows for a :class:`Dot` in the arc. Mainly used as an convention to indicate a right angle.
        The dot can be customized in the next three parameters.
    dot_radius
        The radius of the :class:`Dot`. If not specified otherwise, this radius will be 1/10 of the arc radius.
    dot_distance
        Relative distance from the center to the arc: 0 puts the dot in the center and 1 on the arc itself.
    dot_color
        The color of the :class:`Dot`.
    elbow
        Produces an elbow-type mobject indicating a right angle, see :class:`RightAngle` for more information
        and a shorthand.
    **kwargs
        Further keyword arguments that are passed to the constructor of :class:`Arc` or :class:`Elbow`.

    Examples
    --------
    The first example shows some right angles with a dot in the middle while the second example shows
    all 8 possible angles defined by two lines.

    .. manim:: RightArcAngleExample
        :save_last_frame:

        class RightArcAngleExample(Scene):
            def construct(self):
                line1 = Line( LEFT, RIGHT )
                line2 = Line( DOWN, UP )
                rightarcangles = [
                    Angle(line1, line2, dot=True),
                    Angle(line1, line2, radius=0.4, quadrant=(1,-1), dot=True, other_angle=True),
                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, dot=True, dot_color=YELLOW, dot_radius=0.04, other_angle=True),
                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, dot=True, dot_color=GREEN, dot_radius=0.08),
                ]
                plots = VGroup()
                for angle in rightarcangles:
                    plot=VGroup(line1.copy(),line2.copy(), angle)
                    plots.add(plot)
                plots.arrange(buff=1.5)
                self.add(plots)

    .. manim:: AngleExample
        :save_last_frame:

        class AngleExample(Scene):
            def construct(self):
                line1 = Line( LEFT + (1/3) * UP, RIGHT + (1/3) * DOWN )
                line2 = Line( DOWN + (1/3) * RIGHT, UP + (1/3) * LEFT )
                angles = [
                    Angle(line1, line2),
                    Angle(line1, line2, radius=0.4, quadrant=(1,-1), other_angle=True),
                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8, other_angle=True),
                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED),
                    Angle(line1, line2, other_angle=True),
                    Angle(line1, line2, radius=0.4, quadrant=(1,-1)),
                    Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),
                    Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),
                ]
                plots = VGroup()
                for angle in angles:
                    plot=VGroup(line1.copy(),line2.copy(), angle)
                    plots.add(VGroup(plot,SurroundingRectangle(plot, buff=0.3)))
                plots.arrange_in_grid(rows=2,buff=1)
                self.add(plots)

    .. manim:: FilledAngle
        :save_last_frame:

        class FilledAngle(Scene):
            def construct(self):
                l1 = Line(ORIGIN, 2 * UP + RIGHT).set_color(GREEN)
                l2 = (
                    Line(ORIGIN, 2 * UP + RIGHT)
                    .set_color(GREEN)
                    .rotate(-20 * DEGREES, about_point=ORIGIN)
                )
                norm = l1.get_length()
                a1 = Angle(l1, l2, other_angle=True, radius=norm - 0.5).set_color(GREEN)
                a2 = Angle(l1, l2, other_angle=True, radius=norm).set_color(GREEN)
                q1 = a1.points #  save all coordinates of points of angle a1
                q2 = a2.reverse_direction().points  #  save all coordinates of points of angle a1 (in reversed direction)
                pnts = np.concatenate([q1, q2, q1[0].reshape(1, 3)])  # adds points and ensures that path starts and ends at same point
                mfill = VMobject().set_color(ORANGE)
                mfill.set_points_as_corners(pnts).set_fill(GREEN, opacity=1)
                self.add(l1, l2)
                self.add(mfill)

    """

    @others
</t>
<t tx="ekr.20250122151620.1171">class RightAngle(Angle):
    """An elbow-type mobject representing a right angle between two lines.

    Parameters
    ----------
    line1
        The first line.
    line2
        The second line.
    length
        The length of the arms.
    **kwargs
        Further keyword arguments that are passed to the constructor of :class:`Angle`.

    Examples
    --------
    .. manim:: RightAngleExample
        :save_last_frame:

        class RightAngleExample(Scene):
            def construct(self):
                line1 = Line( LEFT, RIGHT )
                line2 = Line( DOWN, UP )
                rightangles = [
                    RightAngle(line1, line2),
                    RightAngle(line1, line2, length=0.4, quadrant=(1,-1)),
                    RightAngle(line1, line2, length=0.5, quadrant=(-1,1), stroke_width=8),
                    RightAngle(line1, line2, length=0.7, quadrant=(-1,-1), color=RED),
                ]
                plots = VGroup()
                for rightangle in rightangles:
                    plot=VGroup(line1.copy(),line2.copy(), rightangle)
                    plots.add(plot)
                plots.arrange(buff=1.5)
                self.add(plots)
    """

    @others
</t>
<t tx="ekr.20250122151620.1172">def __init__(
    self,
    start: Point3DLike | Mobject = LEFT,
    end: Point3DLike | Mobject = RIGHT,
    buff: float = 0,
    path_arc: float | None = None,
    **kwargs: Any,
) -&gt; None:
    self.dim = 3
    self.buff = buff
    self.path_arc = path_arc
    self._set_start_and_end_attrs(start, end)
    super().__init__(**kwargs)
</t>
<t tx="ekr.20250122151620.1173">    # TODO: Deal with the situation where path_arc is None

def generate_points(self) -&gt; None:
    self.set_points_by_ends(
        start=self.start,
        end=self.end,
        buff=self.buff,
        path_arc=self.path_arc,  # type: ignore[arg-type]
    )

</t>
<t tx="ekr.20250122151620.1174">def set_points_by_ends(
    self,
    start: Point3DLike | Mobject,
    end: Point3DLike | Mobject,
    buff: float = 0,
    path_arc: float = 0,
) -&gt; None:
    """Sets the points of the line based on its start and end points.
    Unlike :meth:`put_start_and_end_on`, this method respects `self.buff` and
    Mobject bounding boxes.

    Parameters
    ----------
    start
        The start point or Mobject of the line.
    end
        The end point or Mobject of the line.
    buff
        The empty space between the start and end of the line, by default 0.
    path_arc
        The angle of a circle spanned by this arc, by default 0 which is a straight line.
    """
    self._set_start_and_end_attrs(start, end)
    if path_arc:
        # self.path_arc could potentially be None, which is not accepted
        # as parameter.
        assert self.path_arc is not None
        arc = ArcBetweenPoints(self.start, self.end, angle=self.path_arc)
        self.set_points(arc.points)
    else:
        self.set_points_as_corners(np.asarray([self.start, self.end]))

    self._account_for_buff(buff)

</t>
<t tx="ekr.20250122151620.1175">init_points = generate_points

def _account_for_buff(self, buff: float) -&gt; None:
    if buff == 0:
        return
    #
    length = self.get_length() if self.path_arc == 0 else self.get_arc_length()
    #
    if length &lt; 2 * buff:
        return
    buff_proportion = buff / length
    self.pointwise_become_partial(self, buff_proportion, 1 - buff_proportion)
    return

</t>
<t tx="ekr.20250122151620.1176">def _set_start_and_end_attrs(
    self, start: Point3DLike | Mobject, end: Point3DLike | Mobject
) -&gt; None:
    # If either start or end are Mobjects, this
    # gives their centers
    rough_start = self._pointify(start)
    rough_end = self._pointify(end)
    vect = normalize(rough_end - rough_start)
    # Now that we know the direction between them,
    # we can find the appropriate boundary point from
    # start and end, if they're mobjects
    self.start = self._pointify(start, vect)
    self.end = self._pointify(end, -vect)

</t>
<t tx="ekr.20250122151620.1177">def _pointify(
    self,
    mob_or_point: Mobject | Point3DLike,
    direction: Vector3D | None = None,
) -&gt; Point3D:
    """Transforms a mobject into its corresponding point. Does nothing if a point is passed.

    ``direction`` determines the location of the point along its bounding box in that direction.

    Parameters
    ----------
    mob_or_point
        The mobject or point.
    direction
        The direction.
    """
    if isinstance(mob_or_point, (Mobject, OpenGLMobject)):
        mob = mob_or_point
        if direction is None:
            return mob.get_center()
        else:
            return mob.get_boundary_point(direction)
    return np.array(mob_or_point)

</t>
<t tx="ekr.20250122151620.1178">def set_path_arc(self, new_value: float) -&gt; None:
    self.path_arc = new_value
    self.init_points()

</t>
<t tx="ekr.20250122151620.1179">def put_start_and_end_on(
    self,
    start: Point3DLike,
    end: Point3DLike,
) -&gt; Self:
    """Sets starts and end coordinates of a line.

    Examples
    --------
    .. manim:: LineExample

        class LineExample(Scene):
            def construct(self):
                d = VGroup()
                for i in range(0,10):
                    d.add(Dot())
                d.arrange_in_grid(buff=1)
                self.add(d)
                l= Line(d[0], d[1])
                self.add(l)
                self.wait()
                l.put_start_and_end_on(d[1].get_center(), d[2].get_center())
                self.wait()
                l.put_start_and_end_on(d[4].get_center(), d[7].get_center())
                self.wait()
    """
    curr_start, curr_end = self.get_start_and_end()
    if np.all(curr_start == curr_end):
        # TODO, any problems with resetting
        # these attrs?
        self.start = np.asarray(start)
        self.end = np.asarray(end)
        self.generate_points()
    return super().put_start_and_end_on(start, end)

</t>
<t tx="ekr.20250122151620.118">@property
def upto_animation_number(self) -&gt; int:
    """Stop rendering animations at this number. Use -1 to avoid skipping (-n)."""
    return self._d["upto_animation_number"]

</t>
<t tx="ekr.20250122151620.1180">def get_vector(self) -&gt; Vector3D:
    return self.get_end() - self.get_start()

</t>
<t tx="ekr.20250122151620.1181">def get_unit_vector(self) -&gt; Vector3D:
    return normalize(self.get_vector())

</t>
<t tx="ekr.20250122151620.1182">def get_angle(self) -&gt; float:
    return angle_of_vector(self.get_vector())

</t>
<t tx="ekr.20250122151620.1183">def get_projection(self, point: Point3DLike) -&gt; Point3D:
    """Returns the projection of a point onto a line.

    Parameters
    ----------
    point
        The point to which the line is projected.
    """
    start = self.get_start()
    end = self.get_end()
    unit_vect = normalize(end - start)
    return start + float(np.dot(point - start, unit_vect)) * unit_vect

</t>
<t tx="ekr.20250122151620.1184">def get_slope(self) -&gt; float:
    return float(np.tan(self.get_angle()))

</t>
<t tx="ekr.20250122151620.1185">def set_angle(self, angle: float, about_point: Point3DLike | None = None) -&gt; Self:
    if about_point is None:
        about_point = self.get_start()

    self.rotate(
        angle - self.get_angle(),
        about_point=about_point,
    )

    return self

</t>
<t tx="ekr.20250122151620.1186">def set_length(self, length: float) -&gt; Self:
    scale_factor: float = length / self.get_length()
    return self.scale(scale_factor)


</t>
<t tx="ekr.20250122151620.1187">def __init__(
    self,
    *args: Any,
    dash_length: float = DEFAULT_DASH_LENGTH,
    dashed_ratio: float = 0.5,
    **kwargs: Any,
) -&gt; None:
    self.dash_length = dash_length
    self.dashed_ratio = dashed_ratio
    super().__init__(*args, **kwargs)
    dashes = DashedVMobject(
        self,
        num_dashes=self._calculate_num_dashes(),
        dashed_ratio=dashed_ratio,
    )
    self.clear_points()
    self.add(*dashes)

</t>
<t tx="ekr.20250122151620.1188">def _calculate_num_dashes(self) -&gt; int:
    """Returns the number of dashes in the dashed line.

    Examples
    --------
    ::

        &gt;&gt;&gt; DashedLine()._calculate_num_dashes()
        20
    """
    # Minimum number of dashes has to be 2
    return max(
        2,
        int(np.ceil((self.get_length() / self.dash_length) * self.dashed_ratio)),
    )

</t>
<t tx="ekr.20250122151620.1189">def get_start(self) -&gt; Point3D:
    """Returns the start point of the line.

    Examples
    --------
    ::

        &gt;&gt;&gt; DashedLine().get_start()
        array([-1.,  0.,  0.])
    """
    if len(self.submobjects) &gt; 0:
        return self.submobjects[0].get_start()
    else:
        return super().get_start()

</t>
<t tx="ekr.20250122151620.119">@upto_animation_number.setter
def upto_animation_number(self, value: int) -&gt; None:
    self._set_pos_number("upto_animation_number", value, True)

</t>
<t tx="ekr.20250122151620.1190">def get_end(self) -&gt; Point3D:
    """Returns the end point of the line.

    Examples
    --------
    ::

        &gt;&gt;&gt; DashedLine().get_end()
        array([1., 0., 0.])
    """
    if len(self.submobjects) &gt; 0:
        return self.submobjects[-1].get_end()
    else:
        return super().get_end()

</t>
<t tx="ekr.20250122151620.1191">def get_first_handle(self) -&gt; Point3D:
    """Returns the point of the first handle.

    Examples
    --------
    ::

        &gt;&gt;&gt; DashedLine().get_first_handle()
        array([-0.98333333,  0.        ,  0.        ])
    """
    # Type inference of extracting an element from a list, is not
    # supported by numpy, see this numpy issue
    # https://github.com/numpy/numpy/issues/16544
    first_handle: Point3D = self.submobjects[0].points[1]
    return first_handle

</t>
<t tx="ekr.20250122151620.1192">def get_last_handle(self) -&gt; Point3D:
    """Returns the point of the last handle.

    Examples
    --------
    ::

        &gt;&gt;&gt; DashedLine().get_last_handle()
        array([0.98333333, 0.        , 0.        ])
    """
    # Type inference of extracting an element from a list, is not
    # supported by numpy, see this numpy issue
    # https://github.com/numpy/numpy/issues/16544
    last_handle: Point3D = self.submobjects[-1].points[2]
    return last_handle


</t>
<t tx="ekr.20250122151620.1193">def __init__(
    self,
    vmob: VMobject,
    alpha: float,
    length: float = 1,
    d_alpha: float = 1e-6,
    **kwargs: Any,
) -&gt; None:
    self.length = length
    self.d_alpha = d_alpha
    da = self.d_alpha
    a1 = np.clip(alpha - da, 0, 1)
    a2 = np.clip(alpha + da, 0, 1)
    super().__init__(
        vmob.point_from_proportion(a1), vmob.point_from_proportion(a2), **kwargs
    )
    self.scale(self.length / self.get_length())


</t>
<t tx="ekr.20250122151620.1194">def __init__(self, width: float = 0.2, angle: float = 0, **kwargs: Any) -&gt; None:
    self.angle = angle
    super().__init__(**kwargs)
    self.set_points_as_corners(np.array([UP, UP + RIGHT, RIGHT]))
    self.scale_to_fit_width(width, about_point=ORIGIN)
    self.rotate(self.angle, about_point=ORIGIN)


</t>
<t tx="ekr.20250122151620.1195">def __init__(
    self,
    *args: Any,
    stroke_width: float = 6,
    buff: float = MED_SMALL_BUFF,
    max_tip_length_to_length_ratio: float = 0.25,
    max_stroke_width_to_length_ratio: float = 5,
    **kwargs: Any,
) -&gt; None:
    self.max_tip_length_to_length_ratio = max_tip_length_to_length_ratio
    self.max_stroke_width_to_length_ratio = max_stroke_width_to_length_ratio
    tip_shape = kwargs.pop("tip_shape", ArrowTriangleFilledTip)
    super().__init__(*args, buff=buff, stroke_width=stroke_width, **kwargs)  # type: ignore[misc]
    # TODO, should this be affected when
    # Arrow.set_stroke is called?
    self.initial_stroke_width = self.stroke_width
    self.add_tip(tip_shape=tip_shape)
    self._set_stroke_width_from_length()

</t>
<t tx="ekr.20250122151620.1196">def scale(self, factor: float, scale_tips: bool = False, **kwargs: Any) -&gt; Self:  # type: ignore[override]
    r"""Scale an arrow, but keep stroke width and arrow tip size fixed.


    .. seealso::
        :meth:`~.Mobject.scale`

    Examples
    --------
    ::

        &gt;&gt;&gt; arrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)
        &gt;&gt;&gt; scaled_arrow = arrow.scale(2)
        &gt;&gt;&gt; np.round(scaled_arrow.get_start_and_end(), 8) + 0
        array([[-2., -2.,  0.],
               [ 2.,  2.,  0.]])
        &gt;&gt;&gt; arrow.tip.length == scaled_arrow.tip.length
        True

    Manually scaling the object using the default method
    :meth:`~.Mobject.scale` does not have the same properties::

        &gt;&gt;&gt; new_arrow = Arrow(np.array([-1, -1, 0]), np.array([1, 1, 0]), buff=0)
        &gt;&gt;&gt; another_scaled_arrow = VMobject.scale(new_arrow, 2)
        &gt;&gt;&gt; another_scaled_arrow.tip.length == arrow.tip.length
        False

    """
    if self.get_length() == 0:
        return self

    if scale_tips:
        super().scale(factor, **kwargs)
        self._set_stroke_width_from_length()
        return self

    has_tip = self.has_tip()
    has_start_tip = self.has_start_tip()
    if has_tip or has_start_tip:
        old_tips = self.pop_tips()

    super().scale(factor, **kwargs)
    self._set_stroke_width_from_length()

    if has_tip:
        self.add_tip(tip=old_tips[0])
    if has_start_tip:
        self.add_tip(tip=old_tips[1], at_start=True)
    return self

</t>
<t tx="ekr.20250122151620.1197">def get_normal_vector(self) -&gt; Vector3D:
    """Returns the normal of a vector.

    Examples
    --------
    ::

        &gt;&gt;&gt; np.round(Arrow().get_normal_vector()) + 0. # add 0. to avoid negative 0 in output
        array([ 0.,  0., -1.])
    """
    p0, p1, p2 = self.tip.get_start_anchors()[:3]
    return normalize(np.cross(p2 - p1, p1 - p0))

</t>
<t tx="ekr.20250122151620.1198">def reset_normal_vector(self) -&gt; Self:
    """Resets the normal of a vector"""
    self.normal_vector = self.get_normal_vector()
    return self

</t>
<t tx="ekr.20250122151620.1199">def get_default_tip_length(self) -&gt; float:
    """Returns the default tip_length of the arrow.

    Examples
    --------

    ::

        &gt;&gt;&gt; Arrow().get_default_tip_length()
        0.35
    """
    max_ratio = self.max_tip_length_to_length_ratio
    return min(self.tip_length, max_ratio * self.get_length())

</t>
<t tx="ekr.20250122151620.12">class CapStyleType(Enum):
    """Collection of available cap styles.

    See the example below for a visual illustration of the different
    cap styles.

    Examples
    --------

    .. manim:: CapStyleVariants
        :save_last_frame:

        class CapStyleVariants(Scene):
            def construct(self):
                arcs = VGroup(*[
                    Arc(
                        radius=1,
                        start_angle=0,
                        angle=TAU / 4,
                        stroke_width=20,
                        color=GREEN,
                        cap_style=cap_style,
                    )
                    for cap_style in CapStyleType
                ])
                arcs.arrange(RIGHT, buff=1)
                self.add(arcs)
                for arc in arcs:
                    label = Text(arc.cap_style.name, font_size=24).next_to(arc, DOWN)
                    self.add(label)
    """

    AUTO = 0
    ROUND = 1
    BUTT = 2
    SQUARE = 3
</t>
<t tx="ekr.20250122151620.120">@property
def max_files_cached(self) -&gt; int:
    """Maximum number of files cached.  Use -1 for infinity (no flag)."""
    return self._d["max_files_cached"]

</t>
<t tx="ekr.20250122151620.1200">def _set_stroke_width_from_length(self) -&gt; Self:
    """Sets stroke width based on length."""
    max_ratio = self.max_stroke_width_to_length_ratio
    if config.renderer == RendererType.OPENGL:
        # Mypy does not recognize that the self object in this case
        # is a OpenGLVMobject and that the set_stroke method is
        # defined here:
        # mobject/opengl/opengl_vectorized_mobject.py#L248
        self.set_stroke(  # type: ignore[call-arg]
            width=min(self.initial_stroke_width, max_ratio * self.get_length()),
            recurse=False,
        )
    else:
        self.set_stroke(
            width=min(self.initial_stroke_width, max_ratio * self.get_length()),
            family=False,
        )
    return self


</t>
<t tx="ekr.20250122151620.1201">def __init__(
    self,
    direction: Point2DLike | Point3DLike = RIGHT,
    buff: float = 0,
    **kwargs: Any,
) -&gt; None:
    self.buff = buff
    if len(direction) == 2:
        direction = np.hstack([direction, 0])

    super().__init__(ORIGIN, direction, buff=buff, **kwargs)

</t>
<t tx="ekr.20250122151620.1202">def coordinate_label(
    self,
    integer_labels: bool = True,
    n_dim: int = 2,
    color: ParsableManimColor | None = None,
    **kwargs: Any,
) -&gt; Matrix:
    """Creates a label based on the coordinates of the vector.

    Parameters
    ----------
    integer_labels
        Whether or not to round the coordinates to integers.
    n_dim
        The number of dimensions of the vector.
    color
        Sets the color of label, optional.
    kwargs
        Additional arguments to be passed to :class:`~.Matrix`.

    Returns
    -------
    :class:`~.Matrix`
        The label.

    Examples
    --------
    .. manim:: VectorCoordinateLabel
        :save_last_frame:

        class VectorCoordinateLabel(Scene):
            def construct(self):
                plane = NumberPlane()

                vec_1 = Vector([1, 2])
                vec_2 = Vector([-3, -2])
                label_1 = vec_1.coordinate_label()
                label_2 = vec_2.coordinate_label(color=YELLOW)

                self.add(plane, vec_1, vec_2, label_1, label_2)
    """
    # avoiding circular imports
    from ..matrix import Matrix

    vect = np.array(self.get_end())
    if integer_labels:
        vect = np.round(vect).astype(int)
    vect = vect[:n_dim]
    vect = vect.reshape((n_dim, 1))
    label = Matrix(vect, **kwargs)
    label.scale(LARGE_BUFF - 0.2)

    shift_dir = np.array(self.get_end())
    if shift_dir[0] &gt;= 0:  # Pointing right
        shift_dir -= label.get_left() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * LEFT
    else:  # Pointing left
        shift_dir -= label.get_right() + DEFAULT_MOBJECT_TO_MOBJECT_BUFFER * RIGHT
    label.shift(shift_dir)
    if color is not None:
        label.set_color(color)
    return label


</t>
<t tx="ekr.20250122151620.1203">def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
    if "tip_shape_end" in kwargs:
        kwargs["tip_shape"] = kwargs.pop("tip_shape_end")
    tip_shape_start = kwargs.pop("tip_shape_start", ArrowTriangleFilledTip)
    super().__init__(*args, **kwargs)
    self.add_tip(at_start=True, tip_shape=tip_shape_start)


</t>
<t tx="ekr.20250122151620.1204">def __init__(
    self,
    line1: Line,
    line2: Line,
    radius: float | None = None,
    quadrant: AngleQuadrant = (1, 1),
    other_angle: bool = False,
    dot: bool = False,
    dot_radius: float | None = None,
    dot_distance: float = 0.55,
    dot_color: ParsableManimColor = WHITE,
    elbow: bool = False,
    **kwargs: Any,
</t>
<t tx="ekr.20250122151620.1205">) -&gt; None:
    super().__init__(**kwargs)
    self.lines = (line1, line2)
    self.quadrant = quadrant
    self.dot_distance = dot_distance
    self.elbow = elbow
    inter = line_intersection(
        [line1.get_start(), line1.get_end()],
        [line2.get_start(), line2.get_end()],
    )

    if radius is None:
        if quadrant[0] == 1:
            dist_1 = np.linalg.norm(line1.get_end() - inter)
        else:
            dist_1 = np.linalg.norm(line1.get_start() - inter)
        if quadrant[1] == 1:
            dist_2 = np.linalg.norm(line2.get_end() - inter)
        else:
            dist_2 = np.linalg.norm(line2.get_start() - inter)
        if np.minimum(dist_1, dist_2) &lt; 0.6:
            radius = (2 / 3) * np.minimum(dist_1, dist_2)
        else:
            radius = 0.4
    else:
        self.radius = radius

    anchor_angle_1 = inter + quadrant[0] * radius * line1.get_unit_vector()
    anchor_angle_2 = inter + quadrant[1] * radius * line2.get_unit_vector()

    if elbow:
        anchor_middle = (
            inter
            + quadrant[0] * radius * line1.get_unit_vector()
            + quadrant[1] * radius * line2.get_unit_vector()
        )
        angle_mobject: VMobject = Elbow(**kwargs)
        angle_mobject.set_points_as_corners(
            np.array([anchor_angle_1, anchor_middle, anchor_angle_2]),
        )
    else:
        angle_1 = angle_of_vector(anchor_angle_1 - inter)
        angle_2 = angle_of_vector(anchor_angle_2 - inter)

        if not other_angle:
            start_angle = angle_1
            if angle_2 &gt; angle_1:
                angle_fin = angle_2 - angle_1
            else:
                angle_fin = 2 * np.pi - (angle_1 - angle_2)
        else:
            start_angle = angle_1
            if angle_2 &lt; angle_1:
                angle_fin = -angle_1 + angle_2
            else:
                angle_fin = -2 * np.pi + (angle_2 - angle_1)

        self.angle_value = angle_fin

        angle_mobject = Arc(
            radius=radius,
            angle=self.angle_value,
            start_angle=start_angle,
            arc_center=inter,
            **kwargs,
        )

        if dot:
            if dot_radius is None:
                dot_radius = radius / 10
            else:
                self.dot_radius = dot_radius
            right_dot = Dot(ORIGIN, radius=dot_radius, color=dot_color)
            dot_anchor = (
                inter
                + (angle_mobject.get_center() - inter)
                / np.linalg.norm(angle_mobject.get_center() - inter)
                * radius
                * dot_distance
            )
            right_dot.move_to(dot_anchor)
            self.add(right_dot)

    self.set_points(angle_mobject.points)

def get_lines(self) -&gt; VGroup:
    """Get the lines forming an angle of the :class:`Angle` class.

    Returns
    -------
    :class:`~.VGroup`
        A :class:`~.VGroup` containing the lines that form the angle of the :class:`Angle` class.

    Examples
    --------
    ::

        &gt;&gt;&gt; line_1, line_2 = Line(ORIGIN, RIGHT), Line(ORIGIN, UR)
        &gt;&gt;&gt; angle = Angle(line_1, line_2)
        &gt;&gt;&gt; angle.get_lines()
        VGroup(Line, Line)
    """
    return VGroup(*self.lines)

</t>
<t tx="ekr.20250122151620.1206">def get_value(self, degrees: bool = False) -&gt; float:
    r"""Get the value of an angle of the :class:`Angle` class.

    Parameters
    ----------
    degrees
        A boolean to decide the unit (deg/rad) in which the value of the angle is returned.

    Returns
    -------
    :class:`float`
        The value in degrees/radians of an angle of the :class:`Angle` class.

    Examples
    --------

    .. manim:: GetValueExample
        :save_last_frame:

        class GetValueExample(Scene):
            def construct(self):
                line1 = Line(LEFT+(1/3)*UP, RIGHT+(1/3)*DOWN)
                line2 = Line(DOWN+(1/3)*RIGHT, UP+(1/3)*LEFT)

                angle = Angle(line1, line2, radius=0.4)

                value = DecimalNumber(angle.get_value(degrees=True), unit=r"^{\circ}")
                value.next_to(angle, UR)

                self.add(line1, line2, angle, value)
    """
    return self.angle_value / DEGREES if degrees else self.angle_value

</t>
<t tx="ekr.20250122151620.1207">@staticmethod
def from_three_points(
    A: Point3DLike, B: Point3DLike, C: Point3DLike, **kwargs: Any
) -&gt; Angle:
    r"""The angle between the lines AB and BC.

    This constructs the angle :math:`\\angle ABC`.

    Parameters
    ----------
    A
        The endpoint of the first angle leg
    B
        The vertex of the angle
    C
        The endpoint of the second angle leg

    **kwargs
        Further keyword arguments are passed to :class:`.Angle`

    Returns
    -------
    The Angle calculated from the three points

                Angle(line1, line2, radius=0.5, quadrant=(-1,1), stroke_width=8),
                Angle(line1, line2, radius=0.7, quadrant=(-1,-1), color=RED, other_angle=True),

    Examples
    --------
    .. manim:: AngleFromThreePointsExample
        :save_last_frame:

        class AngleFromThreePointsExample(Scene):
            def construct(self):
                sample_angle = Angle.from_three_points(UP, ORIGIN, LEFT)
                red_angle = Angle.from_three_points(LEFT + UP, ORIGIN, RIGHT, radius=.8, quadrant=(-1,-1), color=RED, stroke_width=8, other_angle=True)
                self.add(red_angle, sample_angle)
    """
    return Angle(Line(B, A), Line(B, C), **kwargs)


</t>
<t tx="ekr.20250122151620.1208">def __init__(
    self,
    line1: Line,
    line2: Line,
    length: float | None = None,
    **kwargs: Any,
) -&gt; None:
    super().__init__(line1, line2, radius=length, elbow=True, **kwargs)
</t>
<t tx="ekr.20250122151620.1209">r"""Mobjects that are simple geometric shapes."""

from __future__ import annotations

__all__ = [
    "Polygram",
    "Polygon",
    "RegularPolygram",
    "RegularPolygon",
    "Star",
    "Triangle",
    "Rectangle",
    "Square",
    "RoundedRectangle",
    "Cutout",
    "ConvexHull",
]


from math import ceil
from typing import TYPE_CHECKING

import numpy as np

from manim.constants import *
from manim.mobject.geometry.arc import ArcBetweenPoints
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from manim.utils.color import BLUE, WHITE, ParsableManimColor
from manim.utils.iterables import adjacent_n_tuples, adjacent_pairs
from manim.utils.qhull import QuickHull
from manim.utils.space_ops import angle_between_vectors, normalize, regular_vertices

if TYPE_CHECKING:
    from typing import Any, Literal

    import numpy.typing as npt
    from typing_extensions import Self

    from manim.typing import (
        ManimFloat,
        Point3D,
        Point3D_Array,
        Point3DLike,
        Point3DLike_Array,
    )
    from manim.utils.color import ParsableManimColor


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.121">@max_files_cached.setter
def max_files_cached(self, value: int) -&gt; None:
    self._set_pos_number("max_files_cached", value, True)

</t>
<t tx="ekr.20250122151620.1210">class Polygram(VMobject, metaclass=ConvertToOpenGL):
    """A generalized :class:`Polygon`, allowing for disconnected sets of edges.

    Parameters
    ----------
    vertex_groups
        The groups of vertices making up the :class:`Polygram`.

        The first vertex in each group is repeated to close the shape.
        Each point must be 3-dimensional: ``[x,y,z]``
    color
        The color of the :class:`Polygram`.
    kwargs
        Forwarded to the parent constructor.

    Examples
    --------
    .. manim:: PolygramExample

        import numpy as np

        class PolygramExample(Scene):
            def construct(self):
                hexagram = Polygram(
                    [[0, 2, 0], [-np.sqrt(3), -1, 0], [np.sqrt(3), -1, 0]],
                    [[-np.sqrt(3), 1, 0], [0, -2, 0], [np.sqrt(3), 1, 0]],
                )
                self.add(hexagram)

                dot = Dot()
                self.play(MoveAlongPath(dot, hexagram), run_time=5, rate_func=linear)
                self.remove(dot)
                self.wait()
    """

    @others
</t>
<t tx="ekr.20250122151620.1211">class Polygon(Polygram):
    """A shape consisting of one closed loop of vertices.

    Parameters
    ----------
    vertices
        The vertices of the :class:`Polygon`.
    kwargs
        Forwarded to the parent constructor.

    Examples
    --------
    .. manim:: PolygonExample
        :save_last_frame:

        class PolygonExample(Scene):
            def construct(self):
                isosceles = Polygon([-5, 1.5, 0], [-2, 1.5, 0], [-3.5, -2, 0])
                position_list = [
                    [4, 1, 0],  # middle right
                    [4, -2.5, 0],  # bottom right
                    [0, -2.5, 0],  # bottom left
                    [0, 3, 0],  # top left
                    [2, 1, 0],  # middle
                    [4, 3, 0],  # top right
                ]
                square_and_triangles = Polygon(*position_list, color=PURPLE_B)
                self.add(isosceles, square_and_triangles)
    """

    @others
</t>
<t tx="ekr.20250122151620.1212">class RegularPolygram(Polygram):
    """A :class:`Polygram` with regularly spaced vertices.

    Parameters
    ----------
    num_vertices
        The number of vertices.
    density
        The density of the :class:`RegularPolygram`.

        Can be thought of as how many vertices to hop
        to draw a line between them. Every ``density``-th
        vertex is connected.
    radius
        The radius of the circle that the vertices are placed on.
    start_angle
        The angle the vertices start at; the rotation of
        the :class:`RegularPolygram`.
    kwargs
        Forwarded to the parent constructor.

    Examples
    --------
    .. manim:: RegularPolygramExample
        :save_last_frame:

        class RegularPolygramExample(Scene):
            def construct(self):
                pentagram = RegularPolygram(5, radius=2)
                self.add(pentagram)
    """

    @others
</t>
<t tx="ekr.20250122151620.1213">class RegularPolygon(RegularPolygram):
    """An n-sided regular :class:`Polygon`.

    Parameters
    ----------
    n
        The number of sides of the :class:`RegularPolygon`.
    kwargs
        Forwarded to the parent constructor.

    Examples
    --------
    .. manim:: RegularPolygonExample
        :save_last_frame:

        class RegularPolygonExample(Scene):
            def construct(self):
                poly_1 = RegularPolygon(n=6)
                poly_2 = RegularPolygon(n=6, start_angle=30*DEGREES, color=GREEN)
                poly_3 = RegularPolygon(n=10, color=RED)

                poly_group = Group(poly_1, poly_2, poly_3).scale(1.5).arrange(buff=1)
                self.add(poly_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.1214">class Star(Polygon):
    """A regular polygram without the intersecting lines.

    Parameters
    ----------
    n
        How many points on the :class:`Star`.
    outer_radius
        The radius of the circle that the outer vertices are placed on.
    inner_radius
        The radius of the circle that the inner vertices are placed on.

        If unspecified, the inner radius will be
        calculated such that the edges of the :class:`Star`
        perfectly follow the edges of its :class:`RegularPolygram`
        counterpart.
    density
        The density of the :class:`Star`. Only used if
        ``inner_radius`` is unspecified.

        See :class:`RegularPolygram` for more information.
    start_angle
        The angle the vertices start at; the rotation of
        the :class:`Star`.
    kwargs
        Forwardeds to the parent constructor.

    Raises
    ------
    :exc:`ValueError`
        If ``inner_radius`` is unspecified and ``density``
        is not in the range ``[1, n/2)``.

    Examples
    --------
    .. manim:: StarExample

        class StarExample(Scene):
            def construct(self):
                pentagram = RegularPolygram(5, radius=2)
                star = Star(outer_radius=2, color=RED)

                self.add(pentagram)
                self.play(Create(star), run_time=3)
                self.play(FadeOut(star), run_time=2)

    .. manim:: DifferentDensitiesExample
        :save_last_frame:

        class DifferentDensitiesExample(Scene):
            def construct(self):
                density_2 = Star(7, outer_radius=2, density=2, color=RED)
                density_3 = Star(7, outer_radius=2, density=3, color=PURPLE)

                self.add(VGroup(density_2, density_3).arrange(RIGHT))

    """

    @others
</t>
<t tx="ekr.20250122151620.1215">class Triangle(RegularPolygon):
    """An equilateral triangle.

    Parameters
    ----------
    kwargs
        Additional arguments to be passed to :class:`RegularPolygon`

    Examples
    --------
    .. manim:: TriangleExample
        :save_last_frame:

        class TriangleExample(Scene):
            def construct(self):
                triangle_1 = Triangle()
                triangle_2 = Triangle().scale(2).rotate(60*DEGREES)
                tri_group = Group(triangle_1, triangle_2).arrange(buff=1)
                self.add(tri_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.1216">class Rectangle(Polygon):
    """A quadrilateral with two sets of parallel sides.

    Parameters
    ----------
    color
        The color of the rectangle.
    height
        The vertical height of the rectangle.
    width
        The horizontal width of the rectangle.
    grid_xstep
        Space between vertical grid lines.
    grid_ystep
        Space between horizontal grid lines.
    mark_paths_closed
        No purpose.
    close_new_points
        No purpose.
    kwargs
        Additional arguments to be passed to :class:`Polygon`

    Examples
    ----------
    .. manim:: RectangleExample
        :save_last_frame:

        class RectangleExample(Scene):
            def construct(self):
                rect1 = Rectangle(width=4.0, height=2.0, grid_xstep=1.0, grid_ystep=0.5)
                rect2 = Rectangle(width=1.0, height=4.0)
                rect3 = Rectangle(width=2.0, height=2.0, grid_xstep=1.0, grid_ystep=1.0)
                rect3.grid_lines.set_stroke(width=1)

                rects = Group(rect1, rect2, rect3).arrange(buff=1)
                self.add(rects)
    """

    @others
</t>
<t tx="ekr.20250122151620.1217">class Square(Rectangle):
    """A rectangle with equal side lengths.

    Parameters
    ----------
    side_length
        The length of the sides of the square.
    kwargs
        Additional arguments to be passed to :class:`Rectangle`.

    Examples
    --------
    .. manim:: SquareExample
        :save_last_frame:

        class SquareExample(Scene):
            def construct(self):
                square_1 = Square(side_length=2.0).shift(DOWN)
                square_2 = Square(side_length=1.0).next_to(square_1, direction=UP)
                square_3 = Square(side_length=0.5).next_to(square_2, direction=UP)
                self.add(square_1, square_2, square_3)
    """

    @others
</t>
<t tx="ekr.20250122151620.1218">class RoundedRectangle(Rectangle):
    """A rectangle with rounded corners.

    Parameters
    ----------
    corner_radius
        The curvature of the corners of the rectangle.
    kwargs
        Additional arguments to be passed to :class:`Rectangle`

    Examples
    --------
    .. manim:: RoundedRectangleExample
        :save_last_frame:

        class RoundedRectangleExample(Scene):
            def construct(self):
                rect_1 = RoundedRectangle(corner_radius=0.5)
                rect_2 = RoundedRectangle(corner_radius=1.5, height=4.0, width=4.0)

                rect_group = Group(rect_1, rect_2).arrange(buff=1)
                self.add(rect_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.1219">class Cutout(VMobject, metaclass=ConvertToOpenGL):
    """A shape with smaller cutouts.

    Parameters
    ----------
    main_shape
        The primary shape from which cutouts are made.
    mobjects
        The smaller shapes which are to be cut out of the ``main_shape``.
    kwargs
        Further keyword arguments that are passed to the constructor of
        :class:`~.VMobject`.


    .. warning::
        Technically, this class behaves similar to a symmetric difference: if
        parts of the ``mobjects`` are not located within the ``main_shape``,
        these parts will be added to the resulting :class:`~.VMobject`.

    Examples
    --------
    .. manim:: CutoutExample

        class CutoutExample(Scene):
            def construct(self):
                s1 = Square().scale(2.5)
                s2 = Triangle().shift(DOWN + RIGHT).scale(0.5)
                s3 = Square().shift(UP + RIGHT).scale(0.5)
                s4 = RegularPolygon(5).shift(DOWN + LEFT).scale(0.5)
                s5 = RegularPolygon(6).shift(UP + LEFT).scale(0.5)
                c = Cutout(s1, s2, s3, s4, s5, fill_opacity=1, color=BLUE, stroke_color=RED)
                self.play(Write(c), run_time=4)
                self.wait()
    """

    @others
</t>
<t tx="ekr.20250122151620.122">@property
def window_monitor(self) -&gt; int:
    """The monitor on which the scene will be rendered."""
    return self._d["window_monitor"]

</t>
<t tx="ekr.20250122151620.1220">class ConvexHull(Polygram):
    """Constructs a convex hull for a set of points in no particular order.

    Parameters
    ----------
    points
        The points to consider.
    tolerance
        The tolerance used by quickhull.
    kwargs
        Forwarded to the parent constructor.

    Examples
    --------
    .. manim:: ConvexHullExample
        :save_last_frame:
        :quality: high

        class ConvexHullExample(Scene):
            def construct(self):
                points = [
                    [-2.35, -2.25, 0],
                    [1.65, -2.25, 0],
                    [2.65, -0.25, 0],
                    [1.65, 1.75, 0],
                    [-0.35, 2.75, 0],
                    [-2.35, 0.75, 0],
                    [-0.35, -1.25, 0],
                    [0.65, -0.25, 0],
                    [-1.35, 0.25, 0],
                    [0.15, 0.75, 0]
                ]
                hull = ConvexHull(*points, color=BLUE)
                dots = VGroup(*[Dot(point) for point in points])
                self.add(hull)
                self.add(dots)
    """

    @others
</t>
<t tx="ekr.20250122151620.1221">def __init__(
    self,
    *vertex_groups: Point3DLike_Array,
    color: ParsableManimColor = BLUE,
    **kwargs: Any,
):
    super().__init__(color=color, **kwargs)

    for vertices in vertex_groups:
        # The inferred type for *vertices is Any, but it should be
        # Point3D_Array
        first_vertex, *vertices = vertices
        first_vertex = np.array(first_vertex)

        self.start_new_path(first_vertex)
        self.add_points_as_corners(
            [*(np.array(vertex) for vertex in vertices), first_vertex],
        )

</t>
<t tx="ekr.20250122151620.1222">def get_vertices(self) -&gt; Point3D_Array:
    """Gets the vertices of the :class:`Polygram`.

    Returns
    -------
    :class:`numpy.ndarray`
        The vertices of the :class:`Polygram`.

    Examples
    --------
    ::

        &gt;&gt;&gt; sq = Square()
        &gt;&gt;&gt; sq.get_vertices()
        array([[ 1.,  1.,  0.],
               [-1.,  1.,  0.],
               [-1., -1.,  0.],
               [ 1., -1.,  0.]])
    """
    return self.get_start_anchors()

</t>
<t tx="ekr.20250122151620.1223">def get_vertex_groups(self) -&gt; npt.NDArray[ManimFloat]:
    """Gets the vertex groups of the :class:`Polygram`.

    Returns
    -------
    :class:`numpy.ndarray`
        The vertex groups of the :class:`Polygram`.

    Examples
    --------
    ::

        &gt;&gt;&gt; poly = Polygram([ORIGIN, RIGHT, UP], [LEFT, LEFT + UP, 2 * LEFT])
        &gt;&gt;&gt; poly.get_vertex_groups()
        array([[[ 0.,  0.,  0.],
                [ 1.,  0.,  0.],
                [ 0.,  1.,  0.]],
        &lt;BLANKLINE&gt;
               [[-1.,  0.,  0.],
                [-1.,  1.,  0.],
                [-2.,  0.,  0.]]])
    """
    vertex_groups = []

    group = []
    for start, end in zip(self.get_start_anchors(), self.get_end_anchors()):
        group.append(start)

        if self.consider_points_equals(end, group[0]):
            vertex_groups.append(group)
            group = []

    return np.array(vertex_groups)

</t>
<t tx="ekr.20250122151620.1224">def round_corners(
    self,
    radius: float | list[float] = 0.5,
    evenly_distribute_anchors: bool = False,
    components_per_rounded_corner: int = 2,
) -&gt; Self:
    """Rounds off the corners of the :class:`Polygram`.

    Parameters
    ----------
    radius
        The curvature of the corners of the :class:`Polygram`.
    evenly_distribute_anchors
        Break long line segments into proportionally-sized segments.
    components_per_rounded_corner
        The number of points used to represent the rounded corner curve.


    .. seealso::
        :class:`.~RoundedRectangle`

    .. note::
        If `radius` is supplied as a single value, then the same radius
        will be applied to all corners.  If `radius` is a list, then the
        individual values will be applied sequentially, with the first
        corner receiving `radius[0]`, the second corner receiving
        `radius[1]`, etc.  The radius list will be repeated as necessary.

        The `components_per_rounded_corner` value is provided so that the
        fidelity of the rounded corner may be fine-tuned as needed.  2 is
        an appropriate value for most shapes, however a larger value may be
        need if the rounded corner is particularly large.  2 is the minimum
        number allowed, representing the start and end of the curve.  3 will
        result in a start, middle, and end point, meaning 2 curves will be
        generated.

        The option to `evenly_distribute_anchors` is provided so that the
        line segments (the part part of each line remaining after rounding
        off the corners) can be subdivided to a density similar to that of
        the average density of the rounded corners.  This may be desirable
        in situations in which an even distribution of curves is desired
        for use in later transformation animations.  Be aware, though, that
        enabling this option can result in an an object containing
        significantly more points than the original, especially when the
        rounded corner curves are small.

    Examples
    --------
    .. manim:: PolygramRoundCorners
        :save_last_frame:

        class PolygramRoundCorners(Scene):
            def construct(self):
                star = Star(outer_radius=2)

                shapes = VGroup(star)
                shapes.add(star.copy().round_corners(radius=0.1))
                shapes.add(star.copy().round_corners(radius=0.25))

                shapes.arrange(RIGHT)
                self.add(shapes)
    """
    if radius == 0:
        return self

    new_points: list[Point3D] = []

    for vertices in self.get_vertex_groups():
        arcs = []

        # Repeat the radius list as necessary in order to provide a radius
        # for each vertex.
        if isinstance(radius, (int, float)):
            radius_list = [radius] * len(vertices)
        else:
            radius_list = radius * ceil(len(vertices) / len(radius))

        for currentRadius, (v1, v2, v3) in zip(
            radius_list, adjacent_n_tuples(vertices, 3)
        ):
            vect1 = v2 - v1
            vect2 = v3 - v2
            unit_vect1 = normalize(vect1)
            unit_vect2 = normalize(vect2)

            angle = angle_between_vectors(vect1, vect2)
            # Negative radius gives concave curves
            angle *= np.sign(currentRadius)

            # Distance between vertex and start of the arc
            cut_off_length = currentRadius * np.tan(angle / 2)

            # Determines counterclockwise vs. clockwise
            sign = np.sign(np.cross(vect1, vect2)[2])

            arc = ArcBetweenPoints(
                v2 - unit_vect1 * cut_off_length,
                v2 + unit_vect2 * cut_off_length,
                angle=sign * angle,
                num_components=components_per_rounded_corner,
            )
            arcs.append(arc)

        if evenly_distribute_anchors:
            # Determine the average length of each curve
            nonZeroLengthArcs = [arc for arc in arcs if len(arc.points) &gt; 4]
            if len(nonZeroLengthArcs):
                totalArcLength = sum(
                    [arc.get_arc_length() for arc in nonZeroLengthArcs]
                )
                totalCurveCount = (
                    sum([len(arc.points) for arc in nonZeroLengthArcs]) / 4
                )
                averageLengthPerCurve = totalArcLength / totalCurveCount
            else:
                averageLengthPerCurve = 1

        # To ensure that we loop through starting with last
        arcs = [arcs[-1], *arcs[:-1]]
        from manim.mobject.geometry.line import Line

        for arc1, arc2 in adjacent_pairs(arcs):
            new_points.extend(arc1.points)

            line = Line(arc1.get_end(), arc2.get_start())

            # Make sure anchors are evenly distributed, if necessary
            if evenly_distribute_anchors:
                line.insert_n_curves(
                    ceil(line.get_length() / averageLengthPerCurve)
                )

            new_points.extend(line.points)

    self.set_points(np.array(new_points))

    return self


</t>
<t tx="ekr.20250122151620.1225">def __init__(self, *vertices: Point3DLike, **kwargs: Any) -&gt; None:
    super().__init__(vertices, **kwargs)


</t>
<t tx="ekr.20250122151620.1226">def __init__(
    self,
    num_vertices: int,
    *,
    density: int = 2,
    radius: float = 1,
    start_angle: float | None = None,
    **kwargs: Any,
) -&gt; None:
    # Regular polygrams can be expressed by the number of their vertices
    # and their density. This relation can be expressed as its Schläfli
    # symbol: {num_vertices/density}.
    #
    # For instance, a pentagon can be expressed as {5/1} or just {5}.
    # A pentagram, however, can be expressed as {5/2}.
    # A hexagram *would* be expressed as {6/2}, except that 6 and 2
    # are not coprime, and it can be simplified to 2{3}, which corresponds
    # to the fact that a hexagram is actually made up of 2 triangles.
    #
    # See https://en.wikipedia.org/wiki/Polygram_(geometry)#Generalized_regular_polygons
    # for more information.

    num_gons = np.gcd(num_vertices, density)
    num_vertices //= num_gons
    density //= num_gons

    # Utility function for generating the individual
    # polygon vertices.
    def gen_polygon_vertices(start_angle: float | None) -&gt; tuple[list[Any], float]:
        reg_vertices, start_angle = regular_vertices(
            num_vertices,
            radius=radius,
            start_angle=start_angle,
        )

        vertices = []
        i = 0
        while True:
            vertices.append(reg_vertices[i])

            i += density
            i %= num_vertices
            if i == 0:
                break

        return vertices, start_angle

    first_group, self.start_angle = gen_polygon_vertices(start_angle)
    vertex_groups = [first_group]

    for i in range(1, num_gons):
        start_angle = self.start_angle + (i / num_gons) * TAU / num_vertices
        group, _ = gen_polygon_vertices(start_angle)

        vertex_groups.append(group)

    super().__init__(*vertex_groups, **kwargs)


</t>
<t tx="ekr.20250122151620.1227">def __init__(self, n: int = 6, **kwargs: Any) -&gt; None:
    super().__init__(n, density=1, **kwargs)


</t>
<t tx="ekr.20250122151620.1228">def __init__(
    self,
    n: int = 5,
    *,
    outer_radius: float = 1,
    inner_radius: float | None = None,
    density: int = 2,
    start_angle: float | None = TAU / 4,
    **kwargs: Any,
) -&gt; None:
    inner_angle = TAU / (2 * n)

    if inner_radius is None:
        # See https://math.stackexchange.com/a/2136292 for an
        # overview of how to calculate the inner radius of a
        # perfect star.

        if density &lt;= 0 or density &gt;= n / 2:
            raise ValueError(
                f"Incompatible density {density} for number of points {n}",
            )

        outer_angle = TAU * density / n
        inverse_x = 1 - np.tan(inner_angle) * (
            (np.cos(outer_angle) - 1) / np.sin(outer_angle)
        )

        inner_radius = outer_radius / (np.cos(inner_angle) * inverse_x)

    outer_vertices, self.start_angle = regular_vertices(
        n,
        radius=outer_radius,
        start_angle=start_angle,
    )
    inner_vertices, _ = regular_vertices(
        n,
        radius=inner_radius,
        start_angle=self.start_angle + inner_angle,
    )

    vertices: list[npt.NDArray] = []
    for pair in zip(outer_vertices, inner_vertices):
        vertices.extend(pair)

    super().__init__(*vertices, **kwargs)


</t>
<t tx="ekr.20250122151620.1229">def __init__(self, **kwargs: Any) -&gt; None:
    super().__init__(n=3, **kwargs)


</t>
<t tx="ekr.20250122151620.123">@window_monitor.setter
def window_monitor(self, value: int) -&gt; None:
    self._set_pos_number("window_monitor", value, True)

</t>
<t tx="ekr.20250122151620.1230">def __init__(
    self,
    color: ParsableManimColor = WHITE,
    height: float = 2.0,
    width: float = 4.0,
    grid_xstep: float | None = None,
    grid_ystep: float | None = None,
    mark_paths_closed: bool = True,
    close_new_points: bool = True,
    **kwargs: Any,
):
    super().__init__(UR, UL, DL, DR, color=color, **kwargs)
    self.stretch_to_fit_width(width)
    self.stretch_to_fit_height(height)

    v = self.get_vertices()
    self.grid_lines = VGroup()

    if grid_xstep or grid_ystep:
        from manim.mobject.geometry.line import Line

        v = self.get_vertices()

    if grid_xstep:
        grid_xstep = abs(grid_xstep)
        count = int(width / grid_xstep)
        grid = VGroup(
            *(
                Line(
                    v[1] + i * grid_xstep * RIGHT,
                    v[1] + i * grid_xstep * RIGHT + height * DOWN,
                    color=color,
                )
                for i in range(1, count)
            )
        )
        self.grid_lines.add(grid)

    if grid_ystep:
        grid_ystep = abs(grid_ystep)
        count = int(height / grid_ystep)
        grid = VGroup(
            *(
                Line(
                    v[1] + i * grid_ystep * DOWN,
                    v[1] + i * grid_ystep * DOWN + width * RIGHT,
                    color=color,
                )
                for i in range(1, count)
            )
        )
        self.grid_lines.add(grid)

    if self.grid_lines:
        self.add(self.grid_lines)


</t>
<t tx="ekr.20250122151620.1231">def __init__(self, side_length: float = 2.0, **kwargs: Any) -&gt; None:
    super().__init__(height=side_length, width=side_length, **kwargs)

</t>
<t tx="ekr.20250122151620.1232">@property
def side_length(self) -&gt; float:
    return float(np.linalg.norm(self.get_vertices()[0] - self.get_vertices()[1]))

</t>
<t tx="ekr.20250122151620.1233">@side_length.setter
def side_length(self, value: float) -&gt; None:
    self.scale(value / self.side_length)


</t>
<t tx="ekr.20250122151620.1234">def __init__(self, corner_radius: float | list[float] = 0.5, **kwargs: Any):
    super().__init__(**kwargs)
    self.corner_radius = corner_radius
    self.round_corners(self.corner_radius)


</t>
<t tx="ekr.20250122151620.1235">def __init__(
    self, main_shape: VMobject, *mobjects: VMobject, **kwargs: Any
) -&gt; None:
    super().__init__(**kwargs)
    self.append_points(main_shape.points)
    sub_direction: Literal["CCW", "CW"] = (
        "CCW" if main_shape.get_direction() == "CW" else "CW"
    )
    for mobject in mobjects:
        self.append_points(mobject.force_direction(sub_direction).points)


</t>
<t tx="ekr.20250122151620.1236">def __init__(
    self, *points: Point3DLike, tolerance: float = 1e-5, **kwargs: Any
) -&gt; None:
    # Build Convex Hull
    array = np.array(points)[:, :2]
    hull = QuickHull(tolerance)
    hull.build(array)

    # Extract Vertices
    facets = set(hull.facets) - hull.removed
    facet = facets.pop()
    subfacets = list(facet.subfacets)
    while len(subfacets) &lt;= len(facets):
        sf = subfacets[-1]
        (facet,) = hull.neighbors[sf] - {facet}
        (sf,) = facet.subfacets - {sf}
        subfacets.append(sf)

    # Setup Vertices as Point3D
    coordinates = np.vstack([sf.coordinates for sf in subfacets])
    vertices = np.hstack((coordinates, np.zeros((len(coordinates), 1))))

    # Call Polygram
    super().__init__(vertices, **kwargs)
</t>
<t tx="ekr.20250122151620.1237">"""Mobjects used to mark and annotate other mobjects."""

from __future__ import annotations

__all__ = ["SurroundingRectangle", "BackgroundRectangle", "Cross", "Underline"]

from typing import Any

from typing_extensions import Self

from manim import logger
from manim._config import config
from manim.constants import (
    DOWN,
    LEFT,
    RIGHT,
    SMALL_BUFF,
    UP,
)
from manim.mobject.geometry.line import Line
from manim.mobject.geometry.polygram import RoundedRectangle
from manim.mobject.mobject import Mobject
from manim.mobject.types.vectorized_mobject import VGroup
from manim.utils.color import BLACK, RED, YELLOW, ManimColor, ParsableManimColor


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1238">class SurroundingRectangle(RoundedRectangle):
    @others
</t>
<t tx="ekr.20250122151620.1239">class BackgroundRectangle(SurroundingRectangle):
    """A background rectangle. Its default color is the background color
    of the scene.

    Examples
    --------
    .. manim:: ExampleBackgroundRectangle
        :save_last_frame:

        class ExampleBackgroundRectangle(Scene):
            def construct(self):
                circle = Circle().shift(LEFT)
                circle.set_stroke(color=GREEN, width=20)
                triangle = Triangle().shift(2 * RIGHT)
                triangle.set_fill(PINK, opacity=0.5)
                backgroundRectangle1 = BackgroundRectangle(circle, color=WHITE, fill_opacity=0.15)
                backgroundRectangle2 = BackgroundRectangle(triangle, color=WHITE, fill_opacity=0.15)
                self.add(backgroundRectangle1)
                self.add(backgroundRectangle2)
                self.add(circle)
                self.add(triangle)
                self.play(Rotate(backgroundRectangle1, PI / 4))
                self.play(Rotate(backgroundRectangle2, PI / 2))
    """

    @others
</t>
<t tx="ekr.20250122151620.124">@property
def flush_cache(self) -&gt; bool:
    """Whether to delete all the cached partial movie files."""
    return self._d["flush_cache"]

</t>
<t tx="ekr.20250122151620.1240">class Cross(VGroup):
    """Creates a cross.

    Parameters
    ----------
    mobject
        The mobject linked to this instance. It fits the mobject when specified. Defaults to None.
    stroke_color
        Specifies the color of the cross lines. Defaults to RED.
    stroke_width
        Specifies the width of the cross lines. Defaults to 6.
    scale_factor
        Scales the cross to the provided units. Defaults to 1.

    Examples
    --------
    .. manim:: ExampleCross
        :save_last_frame:

        class ExampleCross(Scene):
            def construct(self):
                cross = Cross()
                self.add(cross)
    """

    @others
</t>
<t tx="ekr.20250122151620.1241">class Underline(Line):
    """Creates an underline.

    Examples
    --------
    .. manim:: UnderLine
        :save_last_frame:

        class UnderLine(Scene):
            def construct(self):
                man = Tex("Manim")  # Full Word
                ul = Underline(man)  # Underlining the word
                self.add(man, ul)
    """

    @others
</t>
<t tx="ekr.20250122151620.1242">r"""A rectangle surrounding a :class:`~.Mobject`

Examples
--------
.. manim:: SurroundingRectExample
    :save_last_frame:

    class SurroundingRectExample(Scene):
        def construct(self):
            title = Title("A Quote from Newton")
            quote = Text(
                "If I have seen further than others, \n"
                "it is by standing upon the shoulders of giants.",
                color=BLUE,
            ).scale(0.75)
            box = SurroundingRectangle(quote, color=YELLOW, buff=MED_LARGE_BUFF)

            t2 = Tex(r"Hello World").scale(1.5)
            box2 = SurroundingRectangle(t2, corner_radius=0.2)
            mobjects = VGroup(VGroup(box, quote), VGroup(t2, box2)).arrange(DOWN)
            self.add(title, mobjects)
"""

def __init__(
    self,
    *mobjects: Mobject,
    color: ParsableManimColor = YELLOW,
    buff: float = SMALL_BUFF,
    corner_radius: float = 0.0,
    **kwargs: Any,
) -&gt; None:
    from manim.mobject.mobject import Group

    if not all(isinstance(mob, Mobject) for mob in mobjects):
        raise TypeError(
            "Expected all inputs for parameter mobjects to be a Mobjects"
        )

    group = Group(*mobjects)
    super().__init__(
        color=color,
        width=group.width + 2 * buff,
        height=group.height + 2 * buff,
        corner_radius=corner_radius,
        **kwargs,
    )
    self.buff = buff
    self.move_to(group)


</t>
<t tx="ekr.20250122151620.1243">def __init__(
    self,
    *mobjects: Mobject,
    color: ParsableManimColor | None = None,
    stroke_width: float = 0,
    stroke_opacity: float = 0,
    fill_opacity: float = 0.75,
    buff: float = 0,
    **kwargs: Any,
) -&gt; None:
    if color is None:
        color = config.background_color

    super().__init__(
        *mobjects,
        color=color,
        stroke_width=stroke_width,
        stroke_opacity=stroke_opacity,
        fill_opacity=fill_opacity,
        buff=buff,
        **kwargs,
    )
    self.original_fill_opacity: float = self.fill_opacity

</t>
<t tx="ekr.20250122151620.1244">def pointwise_become_partial(self, mobject: Mobject, a: Any, b: float) -&gt; Self:
    self.set_fill(opacity=b * self.original_fill_opacity)
    return self

</t>
<t tx="ekr.20250122151620.1245">def set_style(self, fill_opacity: float, **kwargs: Any) -&gt; Self:  # type: ignore[override]
    # Unchangeable style, except for fill_opacity
    # All other style arguments are ignored
    super().set_style(
        stroke_color=BLACK,
        stroke_width=0,
        fill_color=BLACK,
        fill_opacity=fill_opacity,
    )
    if len(kwargs) &gt; 0:
        logger.info(
            "Argument %s is ignored in BackgroundRectangle.set_style.",
            kwargs,
        )
    return self

</t>
<t tx="ekr.20250122151620.1246">def get_fill_color(self) -&gt; ManimColor:
    # The type of the color property is set to Any using the property decorator
    # vectorized_mobject.py#L571
    temp_color: ManimColor = self.color
    return temp_color


</t>
<t tx="ekr.20250122151620.1247">def __init__(
    self,
    mobject: Mobject | None = None,
    stroke_color: ParsableManimColor = RED,
    stroke_width: float = 6.0,
    scale_factor: float = 1.0,
    **kwargs: Any,
) -&gt; None:
    super().__init__(
        Line(UP + LEFT, DOWN + RIGHT), Line(UP + RIGHT, DOWN + LEFT), **kwargs
    )
    if mobject is not None:
        self.replace(mobject, stretch=True)
    self.scale(scale_factor)
    self.set_stroke(color=stroke_color, width=stroke_width)


</t>
<t tx="ekr.20250122151620.1248">def __init__(
    self, mobject: Mobject, buff: float = SMALL_BUFF, **kwargs: Any
) -&gt; None:
    super().__init__(LEFT, RIGHT, buff=buff, **kwargs)
    self.match_width(mobject)
    self.next_to(mobject, DOWN, buff=self.buff)
</t>
<t tx="ekr.20250122151620.1249">r"""A collection of tip mobjects for use with :class:`~.TipableVMobject`."""

from __future__ import annotations

__all__ = [
    "ArrowTip",
    "ArrowCircleFilledTip",
    "ArrowCircleTip",
    "ArrowSquareTip",
    "ArrowSquareFilledTip",
    "ArrowTriangleTip",
    "ArrowTriangleFilledTip",
    "StealthTip",
]

from typing import TYPE_CHECKING

import numpy as np

from manim.constants import *
from manim.mobject.geometry.arc import Circle
from manim.mobject.geometry.polygram import Square, Triangle
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.types.vectorized_mobject import VMobject
from manim.utils.space_ops import angle_of_vector

if TYPE_CHECKING:
    from typing import Any

    from manim.typing import Point3D, Vector3D


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.125">@flush_cache.setter
def flush_cache(self, value: bool) -&gt; None:
    self._set_boolean("flush_cache", value)

</t>
<t tx="ekr.20250122151620.1250">class ArrowTip(VMobject, metaclass=ConvertToOpenGL):
    @others
</t>
<t tx="ekr.20250122151620.1251">class StealthTip(ArrowTip):
    @others
</t>
<t tx="ekr.20250122151620.1252">class ArrowTriangleTip(ArrowTip, Triangle):
    @others
</t>
<t tx="ekr.20250122151620.1253">class ArrowTriangleFilledTip(ArrowTriangleTip):
    @others
</t>
<t tx="ekr.20250122151620.1254">class ArrowCircleTip(ArrowTip, Circle):
    @others
</t>
<t tx="ekr.20250122151620.1255">class ArrowCircleFilledTip(ArrowCircleTip):
    @others
</t>
<t tx="ekr.20250122151620.1256">class ArrowSquareTip(ArrowTip, Square):
    @others
</t>
<t tx="ekr.20250122151620.1257">class ArrowSquareFilledTip(ArrowSquareTip):
    @others
</t>
<t tx="ekr.20250122151620.1258">r"""Base class for arrow tips.

.. seealso::
    :class:`ArrowTriangleTip`
    :class:`ArrowTriangleFilledTip`
    :class:`ArrowCircleTip`
    :class:`ArrowCircleFilledTip`
    :class:`ArrowSquareTip`
    :class:`ArrowSquareFilledTip`
    :class:`StealthTip`

Examples
--------
Cannot be used directly, only intended for inheritance::

    &gt;&gt;&gt; tip = ArrowTip()
    Traceback (most recent call last):
    ...
    NotImplementedError: Has to be implemented in inheriting subclasses.

Instead, use one of the pre-defined ones, or make
a custom one like this:

.. manim:: CustomTipExample

    &gt;&gt;&gt; from manim import RegularPolygon, Arrow
    &gt;&gt;&gt; class MyCustomArrowTip(ArrowTip, RegularPolygon):
    ...     def __init__(self, length=0.35, **kwargs):
    ...         RegularPolygon.__init__(self, n=5, **kwargs)
    ...         self.width = length
    ...         self.stretch_to_fit_height(length)
    &gt;&gt;&gt; arr = Arrow(
    ...     np.array([-2, -2, 0]), np.array([2, 2, 0]), tip_shape=MyCustomArrowTip
    ... )
    &gt;&gt;&gt; isinstance(arr.tip, RegularPolygon)
    True
    &gt;&gt;&gt; from manim import Scene, Create
    &gt;&gt;&gt; class CustomTipExample(Scene):
    ...     def construct(self):
    ...         self.play(Create(arr))

Using a class inherited from :class:`ArrowTip` to get a non-filled
tip is a shorthand to manually specifying the arrow tip style as follows::

    &gt;&gt;&gt; arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]),
    ...               tip_style={'fill_opacity': 0, 'stroke_width': 3})

The following example illustrates the usage of all of the predefined
arrow tips.

.. manim:: ArrowTipsShowcase
    :save_last_frame:

    class ArrowTipsShowcase(Scene):
        def construct(self):
            tip_names = [
                'Default (YELLOW)', 'ArrowTriangleTip', 'Default', 'ArrowSquareTip',
                'ArrowSquareFilledTip', 'ArrowCircleTip', 'ArrowCircleFilledTip', 'StealthTip'
            ]

            big_arrows = [
                Arrow(start=[-4, 3.5, 0], end=[2, 3.5, 0], color=YELLOW),
                Arrow(start=[-4, 2.5, 0], end=[2, 2.5, 0], tip_shape=ArrowTriangleTip),
                Arrow(start=[-4, 1.5, 0], end=[2, 1.5, 0]),
                Arrow(start=[-4, 0.5, 0], end=[2, 0.5, 0], tip_shape=ArrowSquareTip),

                Arrow([-4, -0.5, 0], [2, -0.5, 0], tip_shape=ArrowSquareFilledTip),
                Arrow([-4, -1.5, 0], [2, -1.5, 0], tip_shape=ArrowCircleTip),
                Arrow([-4, -2.5, 0], [2, -2.5, 0], tip_shape=ArrowCircleFilledTip),
                Arrow([-4, -3.5, 0], [2, -3.5, 0], tip_shape=StealthTip)
            ]

            small_arrows = (
                arrow.copy().scale(0.5, scale_tips=True).next_to(arrow, RIGHT) for arrow in big_arrows
            )

            labels = (
                Text(tip_names[i], font='monospace', font_size=20, color=BLUE).next_to(big_arrows[i], LEFT) for i in range(len(big_arrows))
            )

            self.add(*big_arrows, *small_arrows, *labels)
"""

def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
    raise NotImplementedError("Has to be implemented in inheriting subclasses.")

</t>
<t tx="ekr.20250122151620.1259">@property
def base(self) -&gt; Point3D:
    r"""The base point of the arrow tip.

    This is the point connecting to the arrow line.

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import Arrow
        &gt;&gt;&gt; arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)
        &gt;&gt;&gt; arrow.tip.base.round(2) + 0.  # add 0. to avoid negative 0 in output
        array([1.65, 0.  , 0.  ])

    """
    return self.point_from_proportion(0.5)

</t>
<t tx="ekr.20250122151620.126">@property
def disable_caching(self) -&gt; bool:
    """Whether to use scene caching."""
    return self._d["disable_caching"]

</t>
<t tx="ekr.20250122151620.1260">@property
def tip_point(self) -&gt; Point3D:
    r"""The tip point of the arrow tip.

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import Arrow
        &gt;&gt;&gt; arrow = Arrow(np.array([0, 0, 0]), np.array([2, 0, 0]), buff=0)
        &gt;&gt;&gt; arrow.tip.tip_point.round(2) + 0.
        array([2., 0., 0.])

    """
    # Type inference of extracting an element from a list, is not
    # supported by numpy, see this numpy issue
    # https://github.com/numpy/numpy/issues/16544
    tip_point: Point3D = self.points[0]
    return tip_point

</t>
<t tx="ekr.20250122151620.1261">@property
def vector(self) -&gt; Vector3D:
    r"""The vector pointing from the base point to the tip point.

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import Arrow
        &gt;&gt;&gt; arrow = Arrow(np.array([0, 0, 0]), np.array([2, 2, 0]), buff=0)
        &gt;&gt;&gt; arrow.tip.vector.round(2) + 0.
        array([0.25, 0.25, 0.  ])

    """
    return self.tip_point - self.base

</t>
<t tx="ekr.20250122151620.1262">@property
def tip_angle(self) -&gt; float:
    r"""The angle of the arrow tip.

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import Arrow
        &gt;&gt;&gt; arrow = Arrow(np.array([0, 0, 0]), np.array([1, 1, 0]), buff=0)
        &gt;&gt;&gt; bool(round(arrow.tip.tip_angle, 5) == round(PI/4, 5))
        True

    """
    return angle_of_vector(self.vector)

</t>
<t tx="ekr.20250122151620.1263">@property
def length(self) -&gt; float:
    r"""The length of the arrow tip.

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import Arrow
        &gt;&gt;&gt; arrow = Arrow(np.array([0, 0, 0]), np.array([1, 2, 0]))
        &gt;&gt;&gt; round(arrow.tip.length, 3)
        0.35

    """
    return float(np.linalg.norm(self.vector))


</t>
<t tx="ekr.20250122151620.1264">r"""'Stealth' fighter / kite arrow shape.

Naming is inspired by the corresponding
`TikZ arrow shape &lt;https://tikz.dev/tikz-arrows#sec-16.3&gt;`__.
"""

def __init__(
    self,
    fill_opacity: float = 1,
    stroke_width: float = 3,
    length: float = DEFAULT_ARROW_TIP_LENGTH / 2,
    start_angle: float = PI,
    **kwargs: Any,
):
    self.start_angle = start_angle
    VMobject.__init__(
        self, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs
    )
    self.set_points_as_corners(
        np.array(
            [
                [2, 0, 0],  # tip
                [-1.2, 1.6, 0],
                [0, 0, 0],  # base
                [-1.2, -1.6, 0],
                [2, 0, 0],  # close path, back to tip
            ]
        )
    )
    self.scale(length / self.length)

</t>
<t tx="ekr.20250122151620.1265">@property
def length(self) -&gt; float:
    """The length of the arrow tip.

    In this case, the length is computed as the height of
    the triangle encompassing the stealth tip (otherwise,
    the tip is scaled too large).
    """
    return float(np.linalg.norm(self.vector) * 1.6)


</t>
<t tx="ekr.20250122151620.1266">r"""Triangular arrow tip."""

def __init__(
    self,
    fill_opacity: float = 0,
    stroke_width: float = 3,
    length: float = DEFAULT_ARROW_TIP_LENGTH,
    width: float = DEFAULT_ARROW_TIP_LENGTH,
    start_angle: float = PI,
    **kwargs: Any,
) -&gt; None:
    Triangle.__init__(
        self,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        start_angle=start_angle,
        **kwargs,
    )
    self.width = width

    self.stretch_to_fit_width(length)
    self.stretch_to_fit_height(width)


</t>
<t tx="ekr.20250122151620.1267">r"""Triangular arrow tip with filled tip.

This is the default arrow tip shape.
"""

def __init__(
    self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs: Any
) -&gt; None:
    super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)


</t>
<t tx="ekr.20250122151620.1268">r"""Circular arrow tip."""

def __init__(
    self,
    fill_opacity: float = 0,
    stroke_width: float = 3,
    length: float = DEFAULT_ARROW_TIP_LENGTH,
    start_angle: float = PI,
    **kwargs: Any,
) -&gt; None:
    self.start_angle = start_angle
    Circle.__init__(
        self, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs
    )
    self.width = length
    self.stretch_to_fit_height(length)


</t>
<t tx="ekr.20250122151620.1269">r"""Circular arrow tip with filled tip."""

def __init__(
    self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs: Any
) -&gt; None:
    super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)


</t>
<t tx="ekr.20250122151620.127">@disable_caching.setter
def disable_caching(self, value: bool) -&gt; None:
    self._set_boolean("disable_caching", value)

</t>
<t tx="ekr.20250122151620.1270">r"""Square arrow tip."""

def __init__(
    self,
    fill_opacity: float = 0,
    stroke_width: float = 3,
    length: float = DEFAULT_ARROW_TIP_LENGTH,
    start_angle: float = PI,
    **kwargs: Any,
) -&gt; None:
    self.start_angle = start_angle
    Square.__init__(
        self,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        side_length=length,
        **kwargs,
    )
    self.width = length
    self.stretch_to_fit_height(length)


</t>
<t tx="ekr.20250122151620.1271">r"""Square arrow tip with filled tip."""

def __init__(
    self, fill_opacity: float = 1, stroke_width: float = 0, **kwargs: Any
) -&gt; None:
    super().__init__(fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs)
</t>
<t tx="ekr.20250122151620.1272"></t>
<t tx="ekr.20250122151620.1273">"""Coordinate systems and function graphing related mobjects.

Modules
=======

.. autosummary::
    :toctree: ../reference

    ~coordinate_systems
    ~functions
    ~number_line
    ~probability
    ~scale
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1274">"""Mobjects that represent coordinate systems."""

from __future__ import annotations

__all__ = [
    "CoordinateSystem",
    "Axes",
    "ThreeDAxes",
    "NumberPlane",
    "PolarPlane",
    "ComplexPlane",
]

import fractions as fr
import numbers
from collections.abc import Iterable, Sequence
from typing import TYPE_CHECKING, Any, Callable, TypeVar, overload

import numpy as np
from typing_extensions import Self

from manim import config
from manim.constants import *
from manim.mobject.geometry.arc import Circle, Dot
from manim.mobject.geometry.line import Arrow, DashedLine, Line
from manim.mobject.geometry.polygram import Polygon, Rectangle, RegularPolygon
from manim.mobject.graphing.functions import ImplicitFunction, ParametricFunction
from manim.mobject.graphing.number_line import NumberLine
from manim.mobject.graphing.scale import LinearBase
from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.opengl.opengl_surface import OpenGLSurface
from manim.mobject.text.tex_mobject import MathTex
from manim.mobject.three_d.three_dimensions import Surface
from manim.mobject.types.vectorized_mobject import (
    VDict,
    VectorizedPoint,
    VGroup,
    VMobject,
)
from manim.utils.color import (
    BLACK,
    BLUE,
    BLUE_D,
    GREEN,
    WHITE,
    YELLOW,
    ManimColor,
    ParsableManimColor,
    color_gradient,
    interpolate_color,
    invert_color,
)
from manim.utils.config_ops import merge_dicts_recursively, update_dict_recursively
from manim.utils.simple_functions import binary_search
from manim.utils.space_ops import angle_of_vector

if TYPE_CHECKING:
    from manim.mobject.mobject import Mobject
    from manim.typing import (
        ManimFloat,
        Point2D,
        Point2DLike,
        Point3D,
        Point3DLike,
        Vector3D,
    )

    LineType = TypeVar("LineType", bound=Line)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1275">class CoordinateSystem:
    @others
</t>
<t tx="ekr.20250122151620.1276">class Axes(VGroup, CoordinateSystem, metaclass=ConvertToOpenGL):
    """Creates a set of axes.

    Parameters
    ----------
    x_range
        The ``(x_min, x_max, x_step)`` values of the x-axis.
    y_range
        The ``(y_min, y_max, y_step)`` values of the y-axis.
    x_length
        The length of the x-axis.
    y_length
        The length of the y-axis.
    axis_config
        Arguments to be passed to :class:`~.NumberLine` that influences both axes.
    x_axis_config
        Arguments to be passed to :class:`~.NumberLine` that influence the x-axis.
    y_axis_config
        Arguments to be passed to :class:`~.NumberLine` that influence the y-axis.
    tips
        Whether or not to include the tips on both axes.
    kwargs
        Additional arguments to be passed to :class:`CoordinateSystem` and :class:`~.VGroup`.

    Examples
    --------
    .. manim:: LogScalingExample
        :save_last_frame:

        class LogScalingExample(Scene):
            def construct(self):
                ax = Axes(
                    x_range=[0, 10, 1],
                    y_range=[-2, 6, 1],
                    tips=False,
                    axis_config={"include_numbers": True},
                    y_axis_config={"scaling": LogBase(custom_labels=True)},
                )

                # x_min must be &gt; 0 because log is undefined at 0.
                graph = ax.plot(lambda x: x ** 2, x_range=[0.001, 10], use_smoothing=False)
                self.add(ax, graph)

    Styling arguments can be passed to the underlying :class:`.NumberLine`
    mobjects that represent the axes:

    .. manim:: AxesWithDifferentTips
        :save_last_frame:

        class AxesWithDifferentTips(Scene):
            def construct(self):
                ax = Axes(axis_config={'tip_shape': StealthTip})
                self.add(ax)
    """

    @others
</t>
<t tx="ekr.20250122151620.1277">class ThreeDAxes(Axes):
    """A 3-dimensional set of axes.

    Parameters
    ----------
    x_range
        The ``[x_min, x_max, x_step]`` values of the x-axis.
    y_range
        The ``[y_min, y_max, y_step]`` values of the y-axis.
    z_range
        The ``[z_min, z_max, z_step]`` values of the z-axis.
    x_length
        The length of the x-axis.
    y_length
        The length of the y-axis.
    z_length
        The length of the z-axis.
    z_axis_config
        Arguments to be passed to :class:`~.NumberLine` that influence the z-axis.
    z_normal
        The direction of the normal.
    num_axis_pieces
        The number of pieces used to construct the axes.
    light_source
        The direction of the light source.
    depth
        Currently non-functional.
    gloss
        Currently non-functional.
    kwargs
        Additional arguments to be passed to :class:`Axes`.
    """

    @others
</t>
<t tx="ekr.20250122151620.1278">class NumberPlane(Axes):
    """Creates a cartesian plane with background lines.

    Parameters
    ----------
    x_range
        The ``[x_min, x_max, x_step]`` values of the plane in the horizontal direction.
    y_range
        The ``[y_min, y_max, y_step]`` values of the plane in the vertical direction.
    x_length
        The width of the plane.
    y_length
        The height of the plane.
    background_line_style
        Arguments that influence the construction of the background lines of the plane.
    faded_line_style
        Similar to :attr:`background_line_style`, affects the construction of the scene's background lines.
    faded_line_ratio
        Determines the number of boxes within the background lines: :code:`2` = 4 boxes, :code:`3` = 9 boxes.
    make_smooth_after_applying_functions
        Currently non-functional.
    kwargs
        Additional arguments to be passed to :class:`Axes`.


    .. note::
        If :attr:`x_length` or :attr:`y_length` are not defined, they are automatically calculated such that
        one unit on each axis is one Manim unit long.

    Examples
    --------
    .. manim:: NumberPlaneExample
        :save_last_frame:

        class NumberPlaneExample(Scene):
            def construct(self):
                number_plane = NumberPlane(
                    background_line_style={
                        "stroke_color": TEAL,
                        "stroke_width": 4,
                        "stroke_opacity": 0.6
                    }
                )
                self.add(number_plane)

    .. manim:: NumberPlaneScaled
        :save_last_frame:

        class NumberPlaneScaled(Scene):
            def construct(self):
                number_plane = NumberPlane(
                    x_range=(-4, 11, 1),
                    y_range=(-3, 3, 1),
                    x_length=5,
                    y_length=2,
                ).move_to(LEFT*3)

                number_plane_scaled_y = NumberPlane(
                    x_range=(-4, 11, 1),
                    x_length=5,
                    y_length=4,
                ).move_to(RIGHT*3)

                self.add(number_plane)
                self.add(number_plane_scaled_y)
    """

    @others
</t>
<t tx="ekr.20250122151620.1279">class PolarPlane(Axes):
    @others
</t>
<t tx="ekr.20250122151620.128">@property
def disable_caching_warning(self) -&gt; bool:
    """Whether a warning is raised if there are too much submobjects to hash."""
    return self._d["disable_caching_warning"]

</t>
<t tx="ekr.20250122151620.1280">class ComplexPlane(NumberPlane):
    """A :class:`~.NumberPlane` specialized for use with complex numbers.

    Examples
    --------
    .. manim:: ComplexPlaneExample
        :save_last_frame:
        :ref_classes: Dot MathTex

        class ComplexPlaneExample(Scene):
            def construct(self):
                plane = ComplexPlane().add_coordinates()
                self.add(plane)
                d1 = Dot(plane.n2p(2 + 1j), color=YELLOW)
                d2 = Dot(plane.n2p(-3 - 2j), color=YELLOW)
                label1 = MathTex("2+i").next_to(d1, UR, 0.1)
                label2 = MathTex("-3-2i").next_to(d2, UR, 0.1)
                self.add(
                    d1,
                    label1,
                    d2,
                    label2,
                )

    """

    @others
</t>
<t tx="ekr.20250122151620.1281">r"""Abstract base class for Axes and NumberPlane.

Examples
--------
.. manim:: CoordSysExample
    :save_last_frame:

    class CoordSysExample(Scene):
        def construct(self):
            # the location of the ticks depends on the x_range and y_range.
            grid = Axes(
                x_range=[0, 1, 0.05],  # step size determines num_decimal_places.
                y_range=[0, 1, 0.05],
                x_length=9,
                y_length=5.5,
                axis_config={
                    "numbers_to_include": np.arange(0, 1 + 0.1, 0.1),
                    "font_size": 24,
                },
                tips=False,
            )

            # Labels for the x-axis and y-axis.
            y_label = grid.get_y_axis_label("y", edge=LEFT, direction=LEFT, buff=0.4)
            x_label = grid.get_x_axis_label("x")
            grid_labels = VGroup(x_label, y_label)

            graphs = VGroup()
            for n in np.arange(1, 20 + 0.5, 0.5):
                graphs += grid.plot(lambda x: x ** n, color=WHITE)
                graphs += grid.plot(
                    lambda x: x ** (1 / n), color=WHITE, use_smoothing=False
                )

            # Extra lines and labels for point (1,1)
            graphs += grid.get_horizontal_line(grid @ (1, 1, 0), color=BLUE)
            graphs += grid.get_vertical_line(grid @ (1, 1, 0), color=BLUE)
            graphs += Dot(point=grid @ (1, 1, 0), color=YELLOW)
            graphs += Tex("(1,1)").scale(0.75).next_to(grid @ (1, 1, 0))
            title = Title(
                # spaces between braces to prevent SyntaxError
                r"Graphs of $y=x^{ {1}\over{n} }$ and $y=x^n (n=1,2,3,...,20)$",
                include_underline=False,
                font_size=40,
            )

            self.add(title, graphs, grid, grid_labels)
"""

def __init__(
    self,
    x_range: Sequence[float] | None = None,
    y_range: Sequence[float] | None = None,
    x_length: float | None = None,
    y_length: float | None = None,
    dimension: int = 2,
) -&gt; None:
    self.dimension = dimension

    default_step = 1
    if x_range is None:
        x_range = [
            round(-config["frame_x_radius"]),
            round(config["frame_x_radius"]),
            default_step,
        ]
    elif len(x_range) == 2:
        x_range = [*x_range, default_step]

    if y_range is None:
        y_range = [
            round(-config["frame_y_radius"]),
            round(config["frame_y_radius"]),
            default_step,
        ]
    elif len(y_range) == 2:
        y_range = [*y_range, default_step]

    self.x_range = x_range
    self.y_range = y_range
    self.x_length = x_length
    self.y_length = y_length
    self.num_sampled_graph_points_per_tick = 10

</t>
<t tx="ekr.20250122151620.1282">def coords_to_point(self, *coords: ManimFloat):
    raise NotImplementedError()

</t>
<t tx="ekr.20250122151620.1283">def point_to_coords(self, point: Point3DLike):
    raise NotImplementedError()

</t>
<t tx="ekr.20250122151620.1284">def polar_to_point(self, radius: float, azimuth: float) -&gt; Point2D:
    r"""Gets a point from polar coordinates.

    Parameters
    ----------
    radius
        The coordinate radius (:math:`r`).

    azimuth
        The coordinate azimuth (:math:`\theta`).

    Returns
    -------
    numpy.ndarray
        The point.

    Examples
    --------
    .. manim:: PolarToPointExample
        :ref_classes: PolarPlane Vector
        :save_last_frame:

        class PolarToPointExample(Scene):
            def construct(self):
                polarplane_pi = PolarPlane(azimuth_units="PI radians", size=6)
                polartopoint_vector = Vector(polarplane_pi.polar_to_point(3, PI/4))
                self.add(polarplane_pi)
                self.add(polartopoint_vector)
    """
    return self.coords_to_point(radius * np.cos(azimuth), radius * np.sin(azimuth))

</t>
<t tx="ekr.20250122151620.1285">def point_to_polar(self, point: Point2DLike) -&gt; Point2D:
    r"""Gets polar coordinates from a point.

    Parameters
    ----------
    point
        The point.

    Returns
    -------
    Tuple[:class:`float`, :class:`float`]
        The coordinate radius (:math:`r`) and the coordinate azimuth (:math:`\theta`).
    """
    x, y = self.point_to_coords(point)
    return np.sqrt(x**2 + y**2), np.arctan2(y, x)

</t>
<t tx="ekr.20250122151620.1286">def c2p(
    self, *coords: float | Sequence[float] | Sequence[Sequence[float]] | np.ndarray
) -&gt; np.ndarray:
    """Abbreviation for :meth:`coords_to_point`"""
    return self.coords_to_point(*coords)

</t>
<t tx="ekr.20250122151620.1287">def p2c(self, point: Point3DLike):
    """Abbreviation for :meth:`point_to_coords`"""
    return self.point_to_coords(point)

</t>
<t tx="ekr.20250122151620.1288">def pr2pt(self, radius: float, azimuth: float) -&gt; np.ndarray:
    """Abbreviation for :meth:`polar_to_point`"""
    return self.polar_to_point(radius, azimuth)

</t>
<t tx="ekr.20250122151620.1289">def pt2pr(self, point: np.ndarray) -&gt; tuple[float, float]:
    """Abbreviation for :meth:`point_to_polar`"""
    return self.point_to_polar(point)

</t>
<t tx="ekr.20250122151620.129">@disable_caching_warning.setter
def disable_caching_warning(self, value: bool) -&gt; None:
    self._set_boolean("disable_caching_warning", value)

</t>
<t tx="ekr.20250122151620.1290">def get_axes(self):
    raise NotImplementedError()

</t>
<t tx="ekr.20250122151620.1291">def get_axis(self, index: int) -&gt; Mobject:
    return self.get_axes()[index]

</t>
<t tx="ekr.20250122151620.1292">def get_origin(self) -&gt; np.ndarray:
    """Gets the origin of :class:`~.Axes`.

    Returns
    -------
    np.ndarray
        The center point.
    """
    return self.coords_to_point(0, 0)

</t>
<t tx="ekr.20250122151620.1293">def get_x_axis(self) -&gt; Mobject:
    return self.get_axis(0)

</t>
<t tx="ekr.20250122151620.1294">def get_y_axis(self) -&gt; Mobject:
    return self.get_axis(1)

</t>
<t tx="ekr.20250122151620.1295">def get_z_axis(self) -&gt; Mobject:
    return self.get_axis(2)

</t>
<t tx="ekr.20250122151620.1296">def get_x_unit_size(self) -&gt; float:
    return self.get_x_axis().get_unit_size()

</t>
<t tx="ekr.20250122151620.1297">def get_y_unit_size(self) -&gt; float:
    return self.get_y_axis().get_unit_size()

</t>
<t tx="ekr.20250122151620.1298">def get_x_axis_label(
    self,
    label: float | str | Mobject,
    edge: Sequence[float] = UR,
    direction: Sequence[float] = UR,
    buff: float = SMALL_BUFF,
    **kwargs,
) -&gt; Mobject:
    """Generate an x-axis label.

    Parameters
    ----------
    label
        The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    edge
        The edge of the x-axis to which the label will be added, by default ``UR``.
    direction
        Allows for further positioning of the label from an edge, by default ``UR``.
    buff
        The distance of the label from the line.

    Returns
    -------
    :class:`~.Mobject`
        The positioned label.

    Examples
    --------
    .. manim:: GetXAxisLabelExample
        :save_last_frame:

        class GetXAxisLabelExample(Scene):
            def construct(self):
                ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
                x_label = ax.get_x_axis_label(
                    Tex("$x$-values").scale(0.65), edge=DOWN, direction=DOWN, buff=0.5
                )
                self.add(ax, x_label)
    """
    return self._get_axis_label(
        label, self.get_x_axis(), edge, direction, buff=buff, **kwargs
    )

</t>
<t tx="ekr.20250122151620.1299">def get_y_axis_label(
    self,
    label: float | str | Mobject,
    edge: Sequence[float] = UR,
    direction: Sequence[float] = UP * 0.5 + RIGHT,
    buff: float = SMALL_BUFF,
    **kwargs,
) -&gt; Mobject:
    """Generate a y-axis label.

    Parameters
    ----------
    label
        The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    edge
        The edge of the y-axis to which the label will be added, by default ``UR``.
    direction
        Allows for further positioning of the label from an edge, by default ``UR``
    buff
        The distance of the label from the line.

    Returns
    -------
    :class:`~.Mobject`
        The positioned label.

    Examples
    --------
    .. manim:: GetYAxisLabelExample
        :save_last_frame:

        class GetYAxisLabelExample(Scene):
            def construct(self):
                ax = Axes(x_range=(0, 8), y_range=(0, 5), x_length=8, y_length=5)
                y_label = ax.get_y_axis_label(
                    Tex("$y$-values").scale(0.65).rotate(90 * DEGREES),
                    edge=LEFT,
                    direction=LEFT,
                    buff=0.3,
                )
                self.add(ax, y_label)
    """
    return self._get_axis_label(
        label, self.get_y_axis(), edge, direction, buff=buff, **kwargs
    )

</t>
<t tx="ekr.20250122151620.13">"""Custom type definitions used in Manim.

.. admonition:: Note for developers
    :class: important

    Around the source code there are multiple strings which look like this:

    .. code-block::

        '''
        [CATEGORY]
        &lt;category_name&gt;
        '''

    All type aliases defined under those strings will be automatically
    classified under that category.

    If you need to define a new category, respect the format described above.
"""

from __future__ import annotations

from collections.abc import Sequence
from os import PathLike
from typing import Callable, Union

import numpy as np
import numpy.typing as npt
from typing_extensions import TypeAlias

__all__ = [
    "ManimFloat",
    "ManimInt",
    "ManimColorDType",
    "RGB_Array_Float",
    "RGB_Tuple_Float",
    "RGB_Array_Int",
    "RGB_Tuple_Int",
    "RGBA_Array_Float",
    "RGBA_Tuple_Float",
    "RGBA_Array_Int",
    "RGBA_Tuple_Int",
    "HSV_Array_Float",
    "HSV_Tuple_Float",
    "HSL_Array_Float",
    "HSL_Tuple_Float",
    "HSVA_Array_Float",
    "HSVA_Tuple_Float",
    "ManimColorInternal",
    "PointDType",
    "Point2D",
    "Point2DLike",
    "Point2D_Array",
    "Point2DLike_Array",
    "Point3D",
    "Point3DLike",
    "Point3D_Array",
    "Point3DLike_Array",
    "PointND",
    "PointNDLike",
    "PointND_Array",
    "PointNDLike_Array",
    "Vector2D",
    "Vector2D_Array",
    "Vector3D",
    "Vector3D_Array",
    "VectorND",
    "VectorND_Array",
    "RowVector",
    "ColVector",
    "MatrixMN",
    "Zeros",
    "QuadraticBezierPoints",
    "QuadraticBezierPointsLike",
    "QuadraticBezierPoints_Array",
    "QuadraticBezierPointsLike_Array",
    "QuadraticBezierPath",
    "QuadraticBezierPathLike",
    "QuadraticSpline",
    "QuadraticSplineLike",
    "CubicBezierPoints",
    "CubicBezierPointsLike",
    "CubicBezierPoints_Array",
    "CubicBezierPointsLike_Array",
    "CubicBezierPath",
    "CubicBezierPathLike",
    "CubicSpline",
    "CubicSplineLike",
    "BezierPoints",
    "BezierPointsLike",
    "BezierPoints_Array",
    "BezierPointsLike_Array",
    "BezierPath",
    "BezierPathLike",
    "Spline",
    "SplineLike",
    "FlatBezierPoints",
    "FunctionOverride",
    "PathFuncType",
    "MappingFunction",
    "MultiMappingFunction",
    "PixelArray",
    "GrayscalePixelArray",
    "RGBPixelArray",
    "RGBAPixelArray",
    "StrPath",
    "StrOrBytesPath",
]


"""
[CATEGORY]
Primitive data types
"""

ManimFloat: TypeAlias = np.float64
"""A double-precision floating-point value (64 bits, or 8 bytes),
according to the IEEE 754 standard.
"""

ManimInt: TypeAlias = np.int64
r"""A long integer (64 bits, or 8 bytes).

It can take values between :math:`-2^{63}` and :math:`+2^{63} - 1`,
which expressed in base 10 is a range between around
:math:`-9.223 \cdot 10^{18}` and :math:`+9.223 \cdot 10^{18}`.
"""


"""
[CATEGORY]
Color types
"""

ManimColorDType: TypeAlias = ManimFloat
"""Data type used in :class:`~.ManimColorInternal`: a
double-precision float between 0 and 1.
"""

RGB_Array_Float: TypeAlias = npt.NDArray[ManimColorDType]
"""``shape: (3,)``

A :class:`numpy.ndarray` of 3 floats between 0 and 1, representing a
color in RGB format.

Its components describe, in order, the intensity of Red, Green, and
Blue in the represented color.
"""

RGB_Tuple_Float: TypeAlias = tuple[float, float, float]
"""``shape: (3,)``

A tuple of 3 floats between 0 and 1, representing a color in RGB
format.

Its components describe, in order, the intensity of Red, Green, and
Blue in the represented color.
"""

RGB_Array_Int: TypeAlias = npt.NDArray[ManimInt]
"""``shape: (3,)``

A :class:`numpy.ndarray` of 3 integers between 0 and 255,
representing a color in RGB format.

Its components describe, in order, the intensity of Red, Green, and
Blue in the represented color.
"""

RGB_Tuple_Int: TypeAlias = tuple[int, int, int]
"""``shape: (3,)``

A tuple of 3 integers between 0 and 255, representing a color in RGB
format.

Its components describe, in order, the intensity of Red, Green, and
Blue in the represented color.
"""

RGBA_Array_Float: TypeAlias = npt.NDArray[ManimColorDType]
"""``shape: (4,)``

A :class:`numpy.ndarray` of 4 floats between 0 and 1, representing a
color in RGBA format.

Its components describe, in order, the intensity of Red, Green, Blue
and Alpha (opacity) in the represented color.
"""

RGBA_Tuple_Float: TypeAlias = tuple[float, float, float, float]
"""``shape: (4,)``

A tuple of 4 floats between 0 and 1, representing a color in RGBA
format.

Its components describe, in order, the intensity of Red, Green, Blue
and Alpha (opacity) in the represented color.
"""

RGBA_Array_Int: TypeAlias = npt.NDArray[ManimInt]
"""``shape: (4,)``

A :class:`numpy.ndarray` of 4 integers between 0 and 255,
representing a color in RGBA format.

Its components describe, in order, the intensity of Red, Green, Blue
and Alpha (opacity) in the represented color.
"""

RGBA_Tuple_Int: TypeAlias = tuple[int, int, int, int]
"""``shape: (4,)``

A tuple of 4 integers between 0 and 255, representing a color in RGBA
format.

Its components describe, in order, the intensity of Red, Green, Blue
and Alpha (opacity) in the represented color.
"""

HSV_Array_Float: TypeAlias = RGB_Array_Float
"""``shape: (3,)``

A :class:`numpy.ndarray` of 3 floats between 0 and 1, representing a
color in HSV (or HSB) format.

Its components describe, in order, the Hue, Saturation and Value (or
Brightness) in the represented color.
"""

HSV_Tuple_Float: TypeAlias = RGB_Tuple_Float
"""``shape: (3,)``

A tuple of 3 floats between 0 and 1, representing a color in HSV (or
HSB) format.

Its components describe, in order, the Hue, Saturation and Value (or
Brightness) in the represented color.
"""

HSVA_Array_Float: TypeAlias = RGBA_Array_Float
"""``shape: (4,)``

A :class:`numpy.ndarray` of 4 floats between 0 and 1, representing a
color in HSVA (or HSBA) format.

Its components describe, in order, the Hue, Saturation and Value (or
Brightness) in the represented color.
"""

HSVA_Tuple_Float: TypeAlias = RGBA_Tuple_Float
"""``shape: (4,)``

A tuple of 4 floats between 0 and 1, representing a color in HSVA (or
HSBA) format.

Its components describe, in order, the Hue, Saturation and Value (or
Brightness) in the represented color.
"""

HSL_Array_Float: TypeAlias = RGB_Array_Float
"""``shape: (3,)``

A :class:`numpy.ndarray` of 3 floats between 0 and 1, representing a
color in HSL format.

Its components describe, in order, the Hue, Saturation and Lightness
in the represented color.
"""

HSL_Tuple_Float: TypeAlias = RGB_Tuple_Float
"""``shape: (3,)``

A :class:`numpy.ndarray` of 3 floats between 0 and 1, representing a
color in HSL format.

Its components describe, in order, the Hue, Saturation and Lightness
in the represented color.
"""

ManimColorInternal: TypeAlias = RGBA_Array_Float
"""``shape: (4,)``

Internal color representation used by :class:`~.ManimColor`,
following the RGBA format.

It is a :class:`numpy.ndarray` consisting of 4 floats between 0 and
1, describing respectively the intensities of Red, Green, Blue and
Alpha (opacity) in the represented color.
"""


"""
[CATEGORY]
Point types
"""

PointDType: TypeAlias = ManimFloat
"""Default type for arrays representing points: a double-precision
floating point value.
"""

Point2D: TypeAlias = npt.NDArray[PointDType]
"""``shape: (2,)``

A NumPy array representing a 2-dimensional point: ``[float, float]``.
"""

Point2DLike: TypeAlias = Union[Point2D, tuple[float, float]]
"""``shape: (2,)``

A 2-dimensional point: ``[float, float]``.

This represents anything which can be converted to a :class:`Point2D` NumPy
array.

Normally, a function or method which expects a `Point2D` as a
parameter can handle being passed a `Point3D` instead.
"""

Point2D_Array: TypeAlias = npt.NDArray[PointDType]
"""``shape: (M, 2)``

A NumPy array representing a sequence of `Point2D` objects:
``[[float, float], ...]``.
"""

Point2DLike_Array: TypeAlias = Union[Point2D_Array, Sequence[Point2DLike]]
"""``shape: (M, 2)``

An array of `Point2DLike` objects: ``[[float, float], ...]``.

This represents anything which can be converted to a :class:`Point2D_Array`
NumPy array.

Normally, a function or method which expects a `Point2D_Array` as a
parameter can handle being passed a `Point3D_Array` instead.

Please refer to the documentation of the function you are using for
further type information.
"""

Point3D: TypeAlias = npt.NDArray[PointDType]
"""``shape: (3,)``

A NumPy array representing a 3-dimensional point: ``[float, float, float]``.
"""

Point3DLike: TypeAlias = Union[Point3D, tuple[float, float, float]]
"""``shape: (3,)``

A 3-dimensional point: ``[float, float, float]``.

This represents anything which can be converted to a :class:`Point3D` NumPy
array.
"""

Point3D_Array: TypeAlias = npt.NDArray[PointDType]
"""``shape: (M, 3)``

A NumPy array representing a sequence of `Point3D` objects:
``[[float, float, float], ...]``.
"""

Point3DLike_Array: TypeAlias = Union[Point3D_Array, Sequence[Point3DLike]]
"""``shape: (M, 3)``

An array of `Point3D` objects: ``[[float, float, float], ...]``.

This represents anything which can be converted to a :class:`Point3D_Array`
NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""

PointND: TypeAlias = npt.NDArray[PointDType]
"""``shape: (N,)``

A NumPy array representing an N-dimensional point: ``[float, ...]``.
"""

PointNDLike: TypeAlias = Union[PointND, Sequence[float]]
"""``shape: (N,)``

An N-dimensional point: ``[float, ...]``.

This represents anything which can be converted to a :class:`PointND` NumPy
array.
"""

PointND_Array: TypeAlias = npt.NDArray[PointDType]
"""``shape: (M, N)``

A NumPy array representing a sequence of `PointND` objects:
``[[float, ...], ...]``.
"""

PointNDLike_Array: TypeAlias = Union[PointND_Array, Sequence[PointNDLike]]
"""``shape: (M, N)``

An array of `PointND` objects: ``[[float, ...], ...]``.

This represents anything which can be converted to a :class:`PointND_Array`
NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""


"""
[CATEGORY]
Vector types
"""

Vector2D: TypeAlias = npt.NDArray[PointDType]
"""``shape: (2,)``

A 2-dimensional vector: ``[float, float]``.

Normally, a function or method which expects a `Vector2D` as a
parameter can handle being passed a `Vector3D` instead.

.. caution::
    Do not confuse with the :class:`~.Vector` or :class:`~.Arrow`
    VMobjects!
"""

Vector2D_Array: TypeAlias = npt.NDArray[PointDType]
"""``shape: (M, 2)``

An array of `Vector2D` objects: ``[[float, float], ...]``.

Normally, a function or method which expects a `Vector2D_Array` as a
parameter can handle being passed a `Vector3D_Array` instead.
"""

Vector3D: TypeAlias = npt.NDArray[PointDType]
"""``shape: (3,)``

A 3-dimensional vector: ``[float, float, float]``.

.. caution::
    Do not confuse with the :class:`~.Vector` or :class:`~.Arrow3D`
    VMobjects!
"""

Vector3D_Array: TypeAlias = npt.NDArray[PointDType]
"""``shape: (M, 3)``

An array of `Vector3D` objects: ``[[float, float, float], ...]``.
"""

VectorND: TypeAlias = npt.NDArray[PointDType]
"""``shape (N,)``

An :math:`N`-dimensional vector: ``[float, ...]``.

.. caution::
    Do not confuse with the :class:`~.Vector` VMobject! This type alias
    is named "VectorND" instead of "Vector" to avoid potential name
    collisions.
"""

VectorND_Array: TypeAlias = npt.NDArray[PointDType]
"""``shape (M, N)``

An array of `VectorND` objects: ``[[float, ...], ...]``.
"""

RowVector: TypeAlias = npt.NDArray[PointDType]
"""``shape: (1, N)``

A row vector: ``[[float, ...]]``.
"""

ColVector: TypeAlias = npt.NDArray[PointDType]
"""``shape: (N, 1)``

A column vector: ``[[float], [float], ...]``.
"""


"""
[CATEGORY]
Matrix types
"""

MatrixMN: TypeAlias = npt.NDArray[PointDType]
"""``shape: (M, N)``

A matrix: ``[[float, ...], [float, ...], ...]``.
"""

Zeros: TypeAlias = MatrixMN
"""``shape: (M, N)``

A `MatrixMN` filled with zeros, typically created with
``numpy.zeros((M, N))``.
"""


"""
[CATEGORY]
Bézier types
"""

QuadraticBezierPoints: TypeAlias = Point3D_Array
"""``shape: (3, 3)``

A `Point3D_Array` of three 3D control points for a single quadratic Bézier
curve:
``[[float, float, float], [float, float, float], [float, float, float]]``.
"""

QuadraticBezierPointsLike: TypeAlias = Union[
    QuadraticBezierPoints, tuple[Point3DLike, Point3DLike, Point3DLike]
]
"""``shape: (3, 3)``

A `Point3DLike_Array` of three 3D control points for a single quadratic Bézier
curve:
``[[float, float, float], [float, float, float], [float, float, float]]``.

This represents anything which can be converted to a
:class:`QuadraticBezierPoints` NumPy array.
"""

QuadraticBezierPoints_Array: TypeAlias = npt.NDArray[PointDType]
"""``shape: (N, 3, 3)``

A NumPy array containing :math:`N` `QuadraticBezierPoints` objects:
``[[[float, float, float], [float, float, float], [float, float, float]], ...]``.
"""

QuadraticBezierPointsLike_Array: TypeAlias = Union[
    QuadraticBezierPoints_Array, Sequence[QuadraticBezierPointsLike]
]
"""``shape: (N, 3, 3)``

A sequence of :math:`N` `QuadraticBezierPointsLike` objects:
``[[[float, float, float], [float, float, float], [float, float, float]], ...]``.

This represents anything which can be converted to a
:class:`QuadraticBezierPoints_Array` NumPy array.
"""

QuadraticBezierPath: TypeAlias = Point3D_Array
"""``shape: (3*N, 3)``

A `Point3D_Array` of :math:`3N` points, where each one of the
:math:`N` consecutive blocks of 3 points represents a quadratic
Bézier curve:
``[[float, float, float], ...], ...]``.

Please refer to the documentation of the function you are using for
further type information.
"""

QuadraticBezierPathLike: TypeAlias = Point3DLike_Array
"""``shape: (3*N, 3)``

A `Point3DLike_Array` of :math:`3N` points, where each one of the
:math:`N` consecutive blocks of 3 points represents a quadratic
Bézier curve:
``[[float, float, float], ...], ...]``.

This represents anything which can be converted to a
:class:`QuadraticBezierPath` NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""

QuadraticSpline: TypeAlias = QuadraticBezierPath
"""``shape: (3*N, 3)``

A special case of `QuadraticBezierPath` where all the :math:`N`
quadratic Bézier curves are connected, forming a quadratic spline:
``[[float, float, float], ...], ...]``.

Please refer to the documentation of the function you are using for
further type information.
"""

QuadraticSplineLike: TypeAlias = QuadraticBezierPathLike
"""``shape: (3*N, 3)``

A special case of `QuadraticBezierPathLike` where all the :math:`N`
quadratic Bézier curves are connected, forming a quadratic spline:
``[[float, float, float], ...], ...]``.

This represents anything which can be converted to a :class:`QuadraticSpline`
NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""

CubicBezierPoints: TypeAlias = Point3D_Array
"""``shape: (4, 3)``

A `Point3D_Array` of four 3D control points for a single cubic Bézier curve:
``[[float, float, float], [float, float, float], [float, float, float], [float, float, float]]``.
"""

CubicBezierPointsLike: TypeAlias = Union[
    CubicBezierPoints, tuple[Point3DLike, Point3DLike, Point3DLike, Point3DLike]
]
"""``shape: (4, 3)``

A `Point3DLike_Array` of 4 control points for a single cubic Bézier curve:
``[[float, float, float], [float, float, float], [float, float, float], [float, float, float]]``.

This represents anything which can be converted to a :class:`CubicBezierPoints`
NumPy array.
"""

CubicBezierPoints_Array: TypeAlias = npt.NDArray[PointDType]
"""``shape: (N, 4, 3)``

A NumPy array containing :math:`N` `CubicBezierPoints` objects:
``[[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...]``.
"""

CubicBezierPointsLike_Array: TypeAlias = Union[
    CubicBezierPoints_Array, Sequence[CubicBezierPointsLike]
]
"""``shape: (N, 4, 3)``

A sequence of :math:`N` `CubicBezierPointsLike` objects:
``[[[float, float, float], [float, float, float], [float, float, float], [float, float, float]], ...]``.

This represents anything which can be converted to a
:class:`CubicBezierPoints_Array` NumPy array.
"""

CubicBezierPath: TypeAlias = Point3D_Array
"""``shape: (4*N, 3)``

A `Point3D_Array` of :math:`4N` points, where each one of the
:math:`N` consecutive blocks of 4 points represents a cubic Bézier
curve:
``[[float, float, float], ...], ...]``.

Please refer to the documentation of the function you are using for
further type information.
"""

CubicBezierPathLike: TypeAlias = Point3DLike_Array
"""``shape: (4*N, 3)``

A `Point3DLike_Array` of :math:`4N` points, where each one of the
:math:`N` consecutive blocks of 4 points represents a cubic Bézier
curve:
``[[float, float, float], ...], ...]``.

This represents anything which can be converted to a
:class:`CubicBezierPath` NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""

CubicSpline: TypeAlias = CubicBezierPath
"""``shape: (4*N, 3)``

A special case of `CubicBezierPath` where all the :math:`N` cubic
Bézier curves are connected, forming a quadratic spline:
``[[float, float, float], ...], ...]``.

Please refer to the documentation of the function you are using for
further type information.
"""

CubicSplineLike: TypeAlias = CubicBezierPathLike
"""``shape: (4*N, 3)``

A special case of `CubicBezierPath` where all the :math:`N` cubic
Bézier curves are connected, forming a quadratic spline:
``[[float, float, float], ...], ...]``.

This represents anything which can be converted to a
:class:`CubicSpline` NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""

BezierPoints: TypeAlias = Point3D_Array
r"""``shape: (PPC, 3)``

A `Point3D_Array` of :math:`\text{PPC}` control points
(:math:`\text{PPC: Points Per Curve} = n + 1`) for a single
:math:`n`-th degree Bézier curve:
``[[float, float, float], ...]``.

Please refer to the documentation of the function you are using for
further type information.
"""

BezierPointsLike: TypeAlias = Point3DLike_Array
r"""``shape: (PPC, 3)``

A `Point3DLike_Array` of :math:`\text{PPC}` control points
(:math:`\text{PPC: Points Per Curve} = n + 1`) for a single
:math:`n`-th degree Bézier curve:
``[[float, float, float], ...]``.

This represents anything which can be converted to a
:class:`BezierPoints` NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""

BezierPoints_Array: TypeAlias = npt.NDArray[PointDType]
r"""``shape: (N, PPC, 3)``

A NumPy array of :math:`N` `BezierPoints` objects containing
:math:`\text{PPC}` `Point3D` objects each
(:math:`\text{PPC: Points Per Curve} = n + 1`):
``[[[float, float, float], ...], ...]``.

Please refer to the documentation of the function you are using for
further type information.
"""

BezierPointsLike_Array: TypeAlias = Union[
    BezierPoints_Array, Sequence[BezierPointsLike]
]
r"""``shape: (N, PPC, 3)``

A sequence of :math:`N` `BezierPointsLike` objects containing
:math:`\text{PPC}` `Point3DLike` objects each
(:math:`\text{PPC: Points Per Curve} = n + 1`):
``[[[float, float, float], ...], ...]``.

This represents anything which can be converted to a
:class:`BezierPoints_Array` NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""

BezierPath: TypeAlias = Point3D_Array
r"""``shape: (PPC*N, 3)``

A `Point3D_Array` of :math:`\text{PPC} \cdot N` points, where each
one of the :math:`N` consecutive blocks of :math:`\text{PPC}` control
points (:math:`\text{PPC: Points Per Curve} = n + 1`) represents a
Bézier curve of :math:`n`-th degree:
``[[float, float, float], ...], ...]``.

Please refer to the documentation of the function you are using for
further type information.
"""

BezierPathLike: TypeAlias = Point3DLike_Array
r"""``shape: (PPC*N, 3)``

A `Point3DLike_Array` of :math:`\text{PPC} \cdot N` points, where each
one of the :math:`N` consecutive blocks of :math:`\text{PPC}` control
points (:math:`\text{PPC: Points Per Curve} = n + 1`) represents a
Bézier curve of :math:`n`-th degree:
``[[float, float, float], ...], ...]``.

This represents anything which can be converted to a
:class:`BezierPath` NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""

Spline: TypeAlias = BezierPath
r"""``shape: (PPC*N, 3)``

A special case of `BezierPath` where all the :math:`N` Bézier curves
consisting of :math:`\text{PPC}` `Point3D` objects
(:math:`\text{PPC: Points Per Curve} = n + 1`) are connected, forming
an :math:`n`-th degree spline:
``[[float, float, float], ...], ...]``.

Please refer to the documentation of the function you are using for
further type information.
"""

SplineLike: TypeAlias = BezierPathLike
r"""``shape: (PPC*N, 3)``

A special case of `BezierPathLike` where all the :math:`N` Bézier curves
consisting of :math:`\text{PPC}` `Point3D` objects
(:math:`\text{PPC: Points Per Curve} = n + 1`) are connected, forming
an :math:`n`-th degree spline:
``[[float, float, float], ...], ...]``.

This represents anything which can be converted to a
:class:`Spline` NumPy array.

Please refer to the documentation of the function you are using for
further type information.
"""

FlatBezierPoints: TypeAlias = Union[npt.NDArray[PointDType], tuple[float, ...]]
"""``shape: (3*PPC*N,)``

A flattened array of Bézier control points:
``[float, ...]``.
"""


"""
[CATEGORY]
Function types
"""

# Due to current limitations
# (see https://github.com/python/mypy/issues/14656 / 8263),
# we don't specify the first argument type (Mobject).
# Nor are we able to specify the return type (Animation) since we cannot import
# that here.
FunctionOverride: TypeAlias = Callable
"""Function type returning an :class:`~.Animation` for the specified
:class:`~.Mobject`.
"""

PathFuncType: TypeAlias = Callable[[Point3DLike, Point3DLike, float], Point3DLike]
"""Function mapping two :class:`Point3D` objects and an alpha value to a new
:class:`Point3D`.
"""

MappingFunction: TypeAlias = Callable[[Point3D], Point3D]
"""A function mapping a :class:`Point3D` to another :class:`Point3D`."""

MultiMappingFunction: TypeAlias = Callable[[Point3D_Array], Point3D_Array]
"""A function mapping a :class:`Point3D_Array` to another
:class:`Point3D_Array`.
"""

"""
[CATEGORY]
Image types
"""

PixelArray: TypeAlias = npt.NDArray[ManimInt]
"""``shape: (height, width) | (height, width, 3) | (height, width, 4)``

A rasterized image with a height of ``height`` pixels and a width of
``width`` pixels.

Every value in the array is an integer from 0 to 255.

Every pixel is represented either by a single integer indicating its
lightness (for greyscale images), an `RGB_Array_Int` or an
`RGBA_Array_Int`.
"""

GrayscalePixelArray: TypeAlias = PixelArray
"""``shape: (height, width)``

A 100% opaque grayscale `PixelArray`, where every pixel value is a
`ManimInt` indicating its lightness (black -&gt; gray -&gt; white).
"""

RGBPixelArray: TypeAlias = PixelArray
"""``shape: (height, width, 3)``

A 100% opaque `PixelArray` in color, where every pixel value is an
`RGB_Array_Int` object.
"""

RGBAPixelArray: TypeAlias = PixelArray
"""``shape: (height, width, 4)``

A `PixelArray` in color where pixels can be transparent. Every pixel
value is an `RGBA_Array_Int` object.
"""


"""
[CATEGORY]
Path types
"""

StrPath: TypeAlias = Union[str, PathLike[str]]
"""A string or :class:`os.PathLike` representing a path to a
directory or file.
"""

StrOrBytesPath: TypeAlias = Union[str, bytes, PathLike[str], PathLike[bytes]]
"""A string, bytes or :class:`os.PathLike` object representing a path
to a directory or file.
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.130">@property
def movie_file_extension(self) -&gt; str:
    """Either .mp4, .webm or .mov."""
    return self._d["movie_file_extension"]

</t>
<t tx="ekr.20250122151620.1300">def _get_axis_label(
    self,
    label: float | str | Mobject,
    axis: Mobject,
    edge: Sequence[float],
    direction: Sequence[float],
    buff: float = SMALL_BUFF,
) -&gt; Mobject:
    """Gets the label for an axis.

    Parameters
    ----------
    label
        The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    axis
        The axis to which the label will be added.
    edge
        The edge of the axes to which the label will be added. ``RIGHT`` adds to the right side of the axis
    direction
        Allows for further positioning of the label.
    buff
        The distance of the label from the line.

    Returns
    -------
    :class:`~.Mobject`
        The positioned label along the given axis.
    """
    label = self.x_axis._create_label_tex(label)
    label.next_to(axis.get_edge_center(edge), direction=direction, buff=buff)
    label.shift_onto_screen(buff=MED_SMALL_BUFF)
    return label

</t>
<t tx="ekr.20250122151620.1301">def get_axis_labels(self):
    raise NotImplementedError()

</t>
<t tx="ekr.20250122151620.1302">def add_coordinates(
    self,
    *axes_numbers: Iterable[float] | None | dict[float, str | float | Mobject],
    **kwargs: Any,
) -&gt; Self:
    """Adds labels to the axes. Use ``Axes.coordinate_labels`` to
    access the coordinates after creation.

    Parameters
    ----------
    axes_numbers
        The numbers to be added to the axes. Use ``None`` to represent an axis with default labels.

    Examples
    --------
    .. code-block:: python

        ax = ThreeDAxes()
        x_labels = range(-4, 5)
        z_labels = range(-4, 4, 2)
        ax.add_coordinates(
            x_labels, None, z_labels
        )  # default y labels, custom x &amp; z labels
        ax.add_coordinates(x_labels)  # only x labels

    You can also specifically control the position and value of the labels using a dict.

    .. code-block:: python

        ax = Axes(x_range=[0, 7])
        x_pos = [x for x in range(1, 8)]

        # strings are automatically converted into a Tex mobject.
        x_vals = [
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
            "Sunday",
        ]
        x_dict = dict(zip(x_pos, x_vals))
        ax.add_coordinates(x_dict)
    """
    self.coordinate_labels = VGroup()
    # if nothing is passed to axes_numbers, produce axes with default labelling
    if not axes_numbers:
        axes_numbers = [None for _ in range(self.dimension)]

    for axis, values in zip(self.axes, axes_numbers):
        if isinstance(values, dict):
            axis.add_labels(values, **kwargs)
            labels = axis.labels
        elif values is None and axis.scaling.custom_labels:
            tick_range = axis.get_tick_range()
            axis.add_labels(
                dict(zip(tick_range, axis.scaling.get_custom_labels(tick_range)))
            )
            labels = axis.labels
        else:
            axis.add_numbers(values, **kwargs)
            labels = axis.numbers
        self.coordinate_labels.add(labels)

    return self

</t>
<t tx="ekr.20250122151620.1303"># overload necessary until https://github.com/python/mypy/issues/3737 is supported
@overload
def get_line_from_axis_to_point(
    self,
    index: int,
    point: Sequence[float],
    line_config: dict | None = ...,
    color: ParsableManimColor | None = ...,
    stroke_width: float = ...,
) -&gt; DashedLine: ...

</t>
<t tx="ekr.20250122151620.1304">@overload
def get_line_from_axis_to_point(
    self,
    index: int,
    point: Sequence[float],
    line_func: type[LineType],
    line_config: dict | None = ...,
    color: ParsableManimColor | None = ...,
    stroke_width: float = ...,
) -&gt; LineType: ...

</t>
<t tx="ekr.20250122151620.1305">def get_line_from_axis_to_point(  # type: ignore[no-untyped-def]
    self,
    index,
    point,
    line_func=DashedLine,
    line_config=None,
    color=None,
    stroke_width=2,
):
    """Returns a straight line from a given axis to a point in the scene.

    Parameters
    ----------
    index
        Specifies the axis from which to draw the line. `0 = x_axis`, `1 = y_axis`
    point
        The point to which the line will be drawn.
    line_func
        The function of the :class:`~.Line` mobject used to construct the line.
    line_config
        Optional arguments to passed to :attr:`line_func`.
    color
        The color of the line.
    stroke_width
        The stroke width of the line.

    Returns
    -------
    :class:`~.Line`
        The line from an axis to a point.


    .. seealso::
        :meth:`~.CoordinateSystem.get_vertical_line`
        :meth:`~.CoordinateSystem.get_horizontal_line`
    """
    line_config = line_config if line_config is not None else {}

    if color is None:
        color = VMobject().color

    line_config["color"] = ManimColor.parse(color)
    line_config["stroke_width"] = stroke_width

    axis = self.get_axis(index)
    line = line_func(axis.get_projection(point), point, **line_config)
    return line

</t>
<t tx="ekr.20250122151620.1306">def get_vertical_line(self, point: Sequence[float], **kwargs: Any) -&gt; Line:
    """A vertical line from the x-axis to a given point in the scene.

    Parameters
    ----------
    point
        The point to which the vertical line will be drawn.
    kwargs
        Additional parameters to be passed to :class:`get_line_from_axis_to_point`.

    Returns
    -------
    :class:`Line`
        A vertical line from the x-axis to the point.

    Examples
    --------
    .. manim:: GetVerticalLineExample
        :save_last_frame:

        class GetVerticalLineExample(Scene):
            def construct(self):
                ax = Axes().add_coordinates()
                point = ax.coords_to_point(-3.5, 2)

                dot = Dot(point)
                line = ax.get_vertical_line(point, line_config={"dashed_ratio": 0.85})

                self.add(ax, line, dot)


    """
    return self.get_line_from_axis_to_point(0, point, **kwargs)

</t>
<t tx="ekr.20250122151620.1307">def get_horizontal_line(self, point: Sequence[float], **kwargs) -&gt; Line:
    """A horizontal line from the y-axis to a given point in the scene.

    Parameters
    ----------
    point
        The point to which the horizontal line will be drawn.
    kwargs
        Additional parameters to be passed to :class:`get_line_from_axis_to_point`.

    Returns
    -------
    :class:`Line`
        A horizontal line from the y-axis to the point.

    Examples
    --------
    .. manim:: GetHorizontalLineExample
        :save_last_frame:

        class GetHorizontalLineExample(Scene):
            def construct(self):
                ax = Axes().add_coordinates()
                point = ax @ (-4, 1.5)

                dot = Dot(point)
                line = ax.get_horizontal_line(point, line_func=Line)

                self.add(ax, line, dot)
    """
    return self.get_line_from_axis_to_point(1, point, **kwargs)

</t>
<t tx="ekr.20250122151620.1308">def get_lines_to_point(self, point: Sequence[float], **kwargs) -&gt; VGroup:
    """Generate both horizontal and vertical lines from the axis to a point.

    Parameters
    ----------
    point
        A point on the scene.
    kwargs
        Additional parameters to be passed to :meth:`get_line_from_axis_to_point`

    Returns
    -------
    :class:`~.VGroup`
        A :class:`~.VGroup` of the horizontal and vertical lines.


    .. seealso::
        :meth:`~.CoordinateSystem.get_vertical_line`
        :meth:`~.CoordinateSystem.get_horizontal_line`

    Examples
    --------
    .. manim:: GetLinesToPointExample
        :save_last_frame:

        class GetLinesToPointExample(Scene):
            def construct(self):
                ax = Axes()
                circ = Circle(radius=0.5).move_to([-4, -1.5, 0])

                lines_1 = ax.get_lines_to_point(circ.get_right(), color=GREEN_B)
                lines_2 = ax.get_lines_to_point(circ.get_corner(DL), color=BLUE_B)
                self.add(ax, lines_1, lines_2, circ)
    """
    return VGroup(
        self.get_horizontal_line(point, **kwargs),
        self.get_vertical_line(point, **kwargs),
    )

</t>
<t tx="ekr.20250122151620.1309"># graphing

def plot(
    self,
    function: Callable[[float], float],
    x_range: Sequence[float] | None = None,
    use_vectorized: bool = False,
    colorscale: Union[Iterable[Color], Iterable[Color, float]] | None = None,
    colorscale_axis: int = 1,
    **kwargs: Any,
) -&gt; ParametricFunction:
    """Generates a curve based on a function.

    Parameters
    ----------
    function
        The function used to construct the :class:`~.ParametricFunction`.
    x_range
        The range of the curve along the axes. ``x_range = [x_min, x_max, x_step]``.
    use_vectorized
        Whether to pass in the generated t value array to the function. Only use this if your function supports it.
        Output should be a numpy array of shape ``[y_0, y_1, ...]``
    colorscale
        Colors of the function. Optional parameter used when coloring a function by values. Passing a list of colors
        and a colorscale_axis will color the function by y-value. Passing a list of tuples in the form ``(color, pivot)``
        allows user-defined pivots where the color transitions.
    colorscale_axis
        Defines the axis on which the colorscale is applied (0 = x, 1 = y), default is y-axis (1).
    kwargs
        Additional parameters to be passed to :class:`~.ParametricFunction`.

    Returns
    -------
    :class:`~.ParametricFunction`
        The plotted curve.


    .. warning::
        This method may not produce accurate graphs since Manim currently relies on interpolation between
        evenly-spaced samples of the curve, instead of intelligent plotting.
        See the example below for some solutions to this problem.

    Examples
    --------
    .. manim:: PlotExample
        :save_last_frame:

        class PlotExample(Scene):
            def construct(self):
                # construct the axes
                ax_1 = Axes(
                    x_range=[0.001, 6],
                    y_range=[-8, 2],
                    x_length=5,
                    y_length=3,
                    tips=False,
                )
                ax_2 = ax_1.copy()
                ax_3 = ax_1.copy()

                # position the axes
                ax_1.to_corner(UL)
                ax_2.to_corner(UR)
                ax_3.to_edge(DOWN)
                axes = VGroup(ax_1, ax_2, ax_3)

                # create the logarithmic curves
                def log_func(x):
                    return np.log(x)

                # a curve without adjustments; poor interpolation.
                curve_1 = ax_1.plot(log_func, color=PURE_RED)

                # disabling interpolation makes the graph look choppy as not enough
                # inputs are available
                curve_2 = ax_2.plot(log_func, use_smoothing=False, color=ORANGE)

                # taking more inputs of the curve by specifying a step for the
                # x_range yields expected results, but increases rendering time.
                curve_3 = ax_3.plot(
                    log_func, x_range=(0.001, 6, 0.001), color=PURE_GREEN
                )

                curves = VGroup(curve_1, curve_2, curve_3)

                self.add(axes, curves)
    """
    t_range = np.array(self.x_range, dtype=float)
    if x_range is not None:
        t_range[: len(x_range)] = x_range

    if x_range is None or len(x_range) &lt; 3:
        # if t_range has a defined step size, increase the number of sample points per tick
        t_range[2] /= self.num_sampled_graph_points_per_tick
    # For axes, the third coordinate of x_range indicates
    # tick frequency.  But for functions, it indicates a
    # sample frequency

    graph = ParametricFunction(
        lambda t: self.coords_to_point(t, function(t)),
        t_range=t_range,
        scaling=self.x_axis.scaling,
        use_vectorized=use_vectorized,
        **kwargs,
    )

    graph.underlying_function = function

    if colorscale:
        if type(colorscale[0]) in (list, tuple):
            new_colors, pivots = [
                [i for i, j in colorscale],
                [j for i, j in colorscale],
            ]
        else:
            new_colors = colorscale

            ranges = [self.x_range, self.y_range]
            pivot_min = ranges[colorscale_axis][0]
            pivot_max = ranges[colorscale_axis][1]
            pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)
            pivots = np.arange(
                start=pivot_min,
                stop=pivot_max + pivot_frequency,
                step=pivot_frequency,
            )

        resolution = 0.01 if len(x_range) == 2 else x_range[2]
        sample_points = np.arange(x_range[0], x_range[1] + resolution, resolution)
        color_list = []
        for samp_x in sample_points:
            axis_value = (samp_x, function(samp_x))[colorscale_axis]
            if axis_value &lt;= pivots[0]:
                color_list.append(new_colors[0])
            elif axis_value &gt;= pivots[-1]:
                color_list.append(new_colors[-1])
            else:
                for i, pivot in enumerate(pivots):
                    if pivot &gt; axis_value:
                        color_index = (axis_value - pivots[i - 1]) / (
                            pivots[i] - pivots[i - 1]
                        )
                        color_index = min(color_index, 1)
                        mob_color = interpolate_color(
                            new_colors[i - 1],
                            new_colors[i],
                            color_index,
                        )
                        color_list.append(mob_color)
                        break
        if config.renderer == RendererType.OPENGL:
            graph.set_color(color_list)
        else:
            graph.set_stroke(color_list)
            graph.set_sheen_direction(RIGHT)

    return graph

</t>
<t tx="ekr.20250122151620.131">@movie_file_extension.setter
def movie_file_extension(self, value: str) -&gt; None:
    self._set_from_list("movie_file_extension", value, [".mp4", ".mov", ".webm"])

</t>
<t tx="ekr.20250122151620.1310">def plot_implicit_curve(
    self,
    func: Callable[[float, float], float],
    min_depth: int = 5,
    max_quads: int = 1500,
    **kwargs: Any,
) -&gt; ImplicitFunction:
    """Creates the curves of an implicit function.

    Parameters
    ----------
    func
        The function to graph, in the form of f(x, y) = 0.
    min_depth
        The minimum depth of the function to calculate.
    max_quads
        The maximum number of quads to use.
    kwargs
        Additional parameters to pass into :class:`ImplicitFunction`.

    Examples
    --------
    .. manim:: ImplicitExample
        :save_last_frame:

        class ImplicitExample(Scene):
            def construct(self):
                ax = Axes()
                a = ax.plot_implicit_curve(
                    lambda x, y: y * (x - y) ** 2 - 4 * x - 8, color=BLUE
                )
                self.add(ax, a)
    """
    x_scale = self.get_x_axis().scaling
    y_scale = self.get_y_axis().scaling
    graph = ImplicitFunction(
        func=(lambda x, y: func(x_scale.function(x), y_scale.function(y))),
        x_range=self.x_range[:2],
        y_range=self.y_range[:2],
        min_depth=min_depth,
        max_quads=max_quads,
        **kwargs,
    )
    (
        graph.stretch(self.get_x_unit_size(), 0, about_point=ORIGIN)
        .stretch(self.get_y_unit_size(), 1, about_point=ORIGIN)
        .shift(self.get_origin())
    )
    return graph

</t>
<t tx="ekr.20250122151620.1311">def plot_parametric_curve(
    self,
    function: Callable[[float], np.ndarray],
    use_vectorized: bool = False,
    **kwargs: Any,
) -&gt; ParametricFunction:
    """A parametric curve.

    Parameters
    ----------
    function
        A parametric function mapping a number to a point in the
        coordinate system.
    use_vectorized
        Whether to pass in the generated t value array to the function. Only use this if your function supports it.
    kwargs
        Any further keyword arguments are passed to :class:`.ParametricFunction`.

    Example
    -------
    .. manim:: ParametricCurveExample
        :save_last_frame:

        class ParametricCurveExample(Scene):
            def construct(self):
                ax = Axes()
                cardioid = ax.plot_parametric_curve(
                    lambda t: np.array(
                        [
                            np.exp(1) * np.cos(t) * (1 - np.cos(t)),
                            np.exp(1) * np.sin(t) * (1 - np.cos(t)),
                            0,
                        ]
                    ),
                    t_range=[0, 2 * PI],
                    color="#0FF1CE",
                )
                self.add(ax, cardioid)
    """
    dim = self.dimension
    graph = ParametricFunction(
        lambda t: self.coords_to_point(*function(t)[:dim]),
        use_vectorized=use_vectorized,
        **kwargs,
    )
    graph.underlying_function = function
    return graph

</t>
<t tx="ekr.20250122151620.1312">def plot_polar_graph(
    self,
    r_func: Callable[[float], float],
    theta_range: Sequence[float] | None = None,
    **kwargs: Any,
) -&gt; ParametricFunction:
    """A polar graph.

    Parameters
    ----------
    r_func
        The function r of theta.
    theta_range
        The range of theta as ``theta_range = [theta_min, theta_max, theta_step]``.
    kwargs
        Additional parameters passed to :class:`~.ParametricFunction`.

    Examples
    --------
    .. manim:: PolarGraphExample
        :ref_classes: PolarPlane
        :save_last_frame:

        class PolarGraphExample(Scene):
            def construct(self):
                plane = PolarPlane()
                r = lambda theta: 2 * np.sin(theta * 5)
                graph = plane.plot_polar_graph(r, [0, 2 * PI], color=ORANGE)
                self.add(plane, graph)
    """
    theta_range = theta_range if theta_range is not None else [0, 2 * PI]
    graph = ParametricFunction(
        function=lambda th: self.pr2pt(r_func(th), th),
        t_range=theta_range,
        **kwargs,
    )
    graph.underlying_function = r_func
    return graph

</t>
<t tx="ekr.20250122151620.1313">def plot_surface(
    self,
    function: Callable[[float], float],
    u_range: Sequence[float] | None = None,
    v_range: Sequence[float] | None = None,
    colorscale: (
        Sequence[ParsableManimColor]
        | Sequence[tuple[ParsableManimColor, float]]
        | None
    ) = None,
    colorscale_axis: int = 2,
    **kwargs: Any,
</t>
<t tx="ekr.20250122151620.1314">) -&gt; Surface | OpenGLSurface:
    """Generates a surface based on a function.

    Parameters
    ----------
    function
        The function used to construct the :class:`~.Surface`.
    u_range
        The range of the ``u`` variable: ``(u_min, u_max)``.
    v_range
        The range of the ``v`` variable: ``(v_min, v_max)``.
    colorscale
        Colors of the surface. Passing a list of colors will color the surface by z-value.
        Passing a list of tuples in the form ``(color, pivot)`` allows user-defined pivots
        where the color transitions.
    colorscale_axis
        Defines the axis on which the colorscale is applied (0 = x, 1 = y, 2 = z), default
        is z-axis (2).
    kwargs
        Additional parameters to be passed to :class:`~.Surface`.

    Returns
    -------
    :class:`~.Surface`
        The plotted surface.

    Examples
    --------
    .. manim:: PlotSurfaceExample
        :save_last_frame:

        class PlotSurfaceExample(ThreeDScene):
            def construct(self):
                resolution_fa = 16
                self.set_camera_orientation(phi=75 * DEGREES, theta=-60 * DEGREES)
                axes = ThreeDAxes(x_range=(-3, 3, 1), y_range=(-3, 3, 1), z_range=(-5, 5, 1))
                def param_trig(u, v):
                    x = u
                    y = v
                    z = 2 * np.sin(x) + 2 * np.cos(y)
                    return z
                trig_plane = axes.plot_surface(
                    param_trig,
                    resolution=(resolution_fa, resolution_fa),
                    u_range = (-3, 3),
                    v_range = (-3, 3),
                    colorscale = [BLUE, GREEN, YELLOW, ORANGE, RED],
                    )
                self.add(axes, trig_plane)
    """
    if config.renderer == RendererType.CAIRO:
        surface = Surface(
            lambda u, v: self.c2p(u, v, function(u, v)),
            u_range=u_range,
            v_range=v_range,
            **kwargs,
        )
        if colorscale:
            surface.set_fill_by_value(
                axes=self.copy(),
                colorscale=colorscale,
                axis=colorscale_axis,
            )
    elif config.renderer == RendererType.OPENGL:
        surface = OpenGLSurface(
            lambda u, v: self.c2p(u, v, function(u, v)),
            u_range=u_range,
            v_range=v_range,
            axes=self.copy(),
            colorscale=colorscale,
            colorscale_axis=colorscale_axis,
            **kwargs,
        )

    return surface

def input_to_graph_point(
    self,
    x: float,
    graph: ParametricFunction | VMobject,
) -&gt; Point3D:
    """Returns the coordinates of the point on a ``graph`` corresponding to an ``x`` value.

    Parameters
    ----------
    x
        The x-value of a point on the ``graph``.
    graph
        The :class:`~.ParametricFunction` on which the point lies.

    Returns
    -------
    :class:`np.ndarray`
        The coordinates of the point on the :attr:`graph` corresponding to the :attr:`x` value.

    Raises
    ------
    :exc:`ValueError`
        When the target x is not in the range of the line graph.

    Examples
    --------
    .. manim:: InputToGraphPointExample
        :save_last_frame:

        class InputToGraphPointExample(Scene):
            def construct(self):
                ax = Axes()
                curve = ax.plot(lambda x : np.cos(x))

                # move a square to PI on the cosine curve.
                position = ax.input_to_graph_point(x=PI, graph=curve)
                sq = Square(side_length=1, color=YELLOW).move_to(position)

                self.add(ax, curve, sq)
    """
    if hasattr(graph, "underlying_function"):
        return graph.function(x)
    else:
        alpha = binary_search(
            function=lambda a: self.point_to_coords(graph.point_from_proportion(a))[
                0
            ],
            target=x,
            lower_bound=0,
            upper_bound=1,
        )
        if alpha is not None:
            return graph.point_from_proportion(alpha)
        else:
            raise ValueError(
                f"x={x} not located in the range of the graph ([{self.p2c(graph.get_start())[0]}, {self.p2c(graph.get_end())[0]}])",
            )

</t>
<t tx="ekr.20250122151620.1315">def input_to_graph_coords(
    self, x: float, graph: ParametricFunction
) -&gt; tuple[float, float]:
    """Returns a tuple of the axis relative coordinates of the point
    on the graph based on the x-value given.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; from manim import Axes
        &gt;&gt;&gt; ax = Axes()
        &gt;&gt;&gt; parabola = ax.plot(lambda x: x**2)
        &gt;&gt;&gt; ax.input_to_graph_coords(x=3, graph=parabola)
        (3, 9)
    """
    return x, graph.underlying_function(x)

</t>
<t tx="ekr.20250122151620.1316">def i2gc(self, x: float, graph: ParametricFunction) -&gt; tuple[float, float]:
    """Alias for :meth:`input_to_graph_coords`."""
    return self.input_to_graph_coords(x, graph)

</t>
<t tx="ekr.20250122151620.1317">def i2gp(self, x: float, graph: ParametricFunction) -&gt; np.ndarray:
    """Alias for :meth:`input_to_graph_point`."""
    return self.input_to_graph_point(x, graph)

</t>
<t tx="ekr.20250122151620.1318">def get_graph_label(
    self,
    graph: ParametricFunction,
    label: float | str | Mobject = "f(x)",
    x_val: float | None = None,
    direction: Sequence[float] = RIGHT,
    buff: float = MED_SMALL_BUFF,
    color: ParsableManimColor | None = None,
    dot: bool = False,
    dot_config: dict[str, Any] | None = None,
) -&gt; Mobject:
    r"""Creates a properly positioned label for the passed graph, with an optional dot.

    Parameters
    ----------
    graph
        The curve.
    label
        The label for the function's curve. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    x_val
        The x_value along the curve that positions the label.
    direction
        The cartesian position, relative to the curve that the label will be at --&gt; ``LEFT``, ``RIGHT``.
    buff
        The distance between the curve and the label.
    color
        The color of the label. Defaults to the color of the curve.
    dot
        Whether to add a dot at the point on the graph.
    dot_config
        Additional parameters to be passed to :class:`~.Dot`.

    Returns
    -------
    :class:`Mobject`
        The positioned label and :class:`~.Dot`, if applicable.

    Examples
    --------
    .. manim:: GetGraphLabelExample
        :save_last_frame:

        class GetGraphLabelExample(Scene):
            def construct(self):
                ax = Axes()
                sin = ax.plot(lambda x: np.sin(x), color=PURPLE_B)
                label = ax.get_graph_label(
                    graph=sin,
                    label= MathTex(r"\frac{\pi}{2}"),
                    x_val=PI / 2,
                    dot=True,
                    direction=UR,
                )

                self.add(ax, sin, label)
    """
    if dot_config is None:
        dot_config = {}
    if color is None:
        color = graph.get_color()
    label = self.x_axis._create_label_tex(label).set_color(color)

    if x_val is None:
        # Search from right to left
        for x in np.linspace(self.x_range[1], self.x_range[0], 100):
            point = self.input_to_graph_point(x, graph)
            if point[1] &lt; config["frame_y_radius"]:
                break
    else:
        point = self.input_to_graph_point(x_val, graph)

    label.next_to(point, direction, buff=buff)
    label.shift_onto_screen()

    if dot:
        dot = Dot(point=point, **dot_config)
        label.add(dot)
        label.dot = dot
    return label

</t>
<t tx="ekr.20250122151620.1319"># calculus

def get_riemann_rectangles(
    self,
    graph: ParametricFunction,
    x_range: Sequence[float] | None = None,
    dx: float | None = 0.1,
    input_sample_type: str = "left",
    stroke_width: float = 1,
    stroke_color: ParsableManimColor = BLACK,
    fill_opacity: float = 1,
    color: Iterable[ParsableManimColor] | ParsableManimColor = (BLUE, GREEN),
    show_signed_area: bool = True,
    bounded_graph: ParametricFunction = None,
    blend: bool = False,
    width_scale_factor: float = 1.001,
</t>
<t tx="ekr.20250122151620.132">@property
def background_opacity(self) -&gt; float:
    """A number between 0.0 (fully transparent) and 1.0 (fully opaque)."""
    return self._d["background_opacity"]

</t>
<t tx="ekr.20250122151620.1320">) -&gt; VGroup:
    """Generates a :class:`~.VGroup` of the Riemann Rectangles for a given curve.

    Parameters
    ----------
    graph
        The graph whose area will be approximated by Riemann rectangles.
    x_range
        The minimum and maximum x-values of the rectangles. ``x_range = [x_min, x_max]``.
    dx
        The change in x-value that separates each rectangle.
    input_sample_type
        Can be any of ``"left"``, ``"right"`` or ``"center"``. Refers to where
        the sample point for the height of each Riemann Rectangle
        will be inside the segments of the partition.
    stroke_width
        The stroke_width of the border of the rectangles.
    stroke_color
        The color of the border of the rectangle.
    fill_opacity
        The opacity of the rectangles.
    color
        The colors of the rectangles. Creates a balanced gradient if multiple colors are passed.
    show_signed_area
        Indicates negative area when the curve dips below the x-axis by inverting its color.
    blend
        Sets the :attr:`stroke_color` to :attr:`fill_color`, blending the rectangles without clear separation.
    bounded_graph
        If a secondary graph is specified, encloses the area between the two curves.
    width_scale_factor
        The factor by which the width of the rectangles is scaled.

    Returns
    -------
    :class:`~.VGroup`
        A :class:`~.VGroup` containing the Riemann Rectangles.

    Examples
    --------
    .. manim:: GetRiemannRectanglesExample
        :save_last_frame:

        class GetRiemannRectanglesExample(Scene):
            def construct(self):
                ax = Axes(y_range=[-2, 10])
                quadratic = ax.plot(lambda x: 0.5 * x ** 2 - 0.5)

                # the rectangles are constructed from their top right corner.
                # passing an iterable to `color` produces a gradient
                rects_right = ax.get_riemann_rectangles(
                    quadratic,
                    x_range=[-4, -3],
                    dx=0.25,
                    color=(TEAL, BLUE_B, DARK_BLUE),
                    input_sample_type="right",
                )

                # the colour of rectangles below the x-axis is inverted
                # due to show_signed_area
                rects_left = ax.get_riemann_rectangles(
                    quadratic, x_range=[-1.5, 1.5], dx=0.15, color=YELLOW
                )

                bounding_line = ax.plot(
                    lambda x: 1.5 * x, color=BLUE_B, x_range=[3.3, 6]
                )
                bounded_rects = ax.get_riemann_rectangles(
                    bounding_line,
                    bounded_graph=quadratic,
                    dx=0.15,
                    x_range=[4, 5],
                    show_signed_area=False,
                    color=(MAROON_A, RED_B, PURPLE_D),
                )

                self.add(
                    ax, bounding_line, quadratic, rects_right, rects_left, bounded_rects
                )
    """
    # setting up x_range, overwrite user's third input
    if x_range is None:
        if bounded_graph is None:
            x_range = [graph.t_min, graph.t_max]
        else:
            x_min = max(graph.t_min, bounded_graph.t_min)
            x_max = min(graph.t_max, bounded_graph.t_max)
            x_range = [x_min, x_max]

    x_range = [*x_range[:2], dx]

    rectangles = VGroup()
    x_range = np.arange(*x_range)

    if isinstance(color, (list, tuple)):
        color = [ManimColor(c) for c in color]
    else:
        color = [ManimColor(color)]

    colors = color_gradient(color, len(x_range))

    for x, color in zip(x_range, colors):
        if input_sample_type == "left":
            sample_input = x
        elif input_sample_type == "right":
            sample_input = x + dx
        elif input_sample_type == "center":
            sample_input = x + 0.5 * dx
        else:
            raise ValueError("Invalid input sample type")
        graph_point = self.input_to_graph_point(sample_input, graph)

        if bounded_graph is None:
            y_point = self._origin_shift(self.y_range)
        else:
            y_point = bounded_graph.underlying_function(x)

        points = VGroup(
            *list(
                map(
                    VectorizedPoint,
                    [
                        self.coords_to_point(x, y_point),
                        self.coords_to_point(x + width_scale_factor * dx, y_point),
                        graph_point,
                    ],
                ),
            )
        )

        rect = Rectangle().replace(points, stretch=True)
        rectangles.add(rect)

        # checks if the rectangle is under the x-axis
        if self.p2c(graph_point)[1] &lt; y_point and show_signed_area:
            color = invert_color(color)

        # blends rectangles smoothly
        if blend:
            stroke_color = color

        rect.set_style(
            fill_color=color,
            fill_opacity=fill_opacity,
            stroke_color=stroke_color,
            stroke_width=stroke_width,
        )

    return rectangles

def get_area(
    self,
    graph: ParametricFunction,
    x_range: tuple[float, float] | None = None,
    color: ParsableManimColor | Iterable[ParsableManimColor] = (BLUE, GREEN),
    opacity: float = 0.3,
    bounded_graph: ParametricFunction = None,
    **kwargs: Any,
</t>
<t tx="ekr.20250122151620.1321">) -&gt; Polygon:
    """Returns a :class:`~.Polygon` representing the area under the graph passed.

    Parameters
    ----------
    graph
        The graph/curve for which the area needs to be gotten.
    x_range
        The range of the minimum and maximum x-values of the area. ``x_range = [x_min, x_max]``.
    color
        The color of the area. Creates a gradient if a list of colors is provided.
    opacity
        The opacity of the area.
    bounded_graph
        If a secondary :attr:`graph` is specified, encloses the area between the two curves.
    kwargs
        Additional parameters passed to :class:`~.Polygon`.

    Returns
    -------
    :class:`~.Polygon`
        The :class:`~.Polygon` representing the area.

    Raises
    ------
    :exc:`ValueError`
        When x_ranges do not match (either area x_range, graph's x_range or bounded_graph's x_range).

    Examples
    --------
    .. manim:: GetAreaExample
        :save_last_frame:

        class GetAreaExample(Scene):
            def construct(self):
                ax = Axes().add_coordinates()
                curve = ax.plot(lambda x: 2 * np.sin(x), color=DARK_BLUE)
                area = ax.get_area(
                    curve,
                    x_range=(PI / 2, 3 * PI / 2),
                    color=(GREEN_B, GREEN_D),
                    opacity=1,
                )

                self.add(ax, curve, area)
    """
    if x_range is None:
        a = graph.t_min
        b = graph.t_max
    else:
        a, b = x_range
    if bounded_graph is not None:
        if bounded_graph.t_min &gt; b:
            raise ValueError(
                f"Ranges not matching: {bounded_graph.t_min} &lt; {b}",
            )
        if bounded_graph.t_max &lt; a:
            raise ValueError(
                f"Ranges not matching: {bounded_graph.t_max} &gt; {a}",
            )
        a = max(a, bounded_graph.t_min)
        b = min(b, bounded_graph.t_max)

    if bounded_graph is None:
        points = (
            [self.c2p(a), graph.function(a)]
            + [p for p in graph.points if a &lt;= self.p2c(p)[0] &lt;= b]
            + [graph.function(b), self.c2p(b)]
        )
    else:
        graph_points, bounded_graph_points = (
            [g.function(a)]
            + [p for p in g.points if a &lt;= self.p2c(p)[0] &lt;= b]
            + [g.function(b)]
            for g in (graph, bounded_graph)
        )
        points = graph_points + bounded_graph_points[::-1]
    return Polygon(*points, **kwargs).set_opacity(opacity).set_color(color)

def angle_of_tangent(
    self,
    x: float,
    graph: ParametricFunction,
    dx: float = 1e-8,
) -&gt; float:
    """Returns the angle to the x-axis of the tangent
    to the plotted curve at a particular x-value.

    Parameters
    ----------
    x
        The x-value at which the tangent must touch the curve.
    graph
        The :class:`~.ParametricFunction` for which to calculate the tangent.
    dx
        The change in `x` used to determine the angle of the tangent to the curve.

    Returns
    -------
    :class:`float`
        The angle of the tangent to the curve.

    Examples
    --------
    .. code-block:: python

        ax = Axes()
        curve = ax.plot(lambda x: x**2)
        ax.angle_of_tangent(x=3, graph=curve)
        # 1.4056476493802699
    """
    p0 = np.array([*self.input_to_graph_coords(x, graph)])
    p1 = np.array([*self.input_to_graph_coords(x + dx, graph)])
    return angle_of_vector(p1 - p0)

</t>
<t tx="ekr.20250122151620.1322">def slope_of_tangent(
    self, x: float, graph: ParametricFunction, **kwargs: Any
) -&gt; float:
    """Returns the slope of the tangent to the plotted curve
    at a particular x-value.

    Parameters
    ----------
    x
        The x-value at which the tangent must touch the curve.
    graph
        The :class:`~.ParametricFunction` for which to calculate the tangent.

    Returns
    -------
    :class:`float`
        The slope of the tangent with the x axis.

    Examples
    --------
    .. code-block:: python

        ax = Axes()
        curve = ax.plot(lambda x: x**2)
        ax.slope_of_tangent(x=-2, graph=curve)
        # -3.5000000259052038
    """
    return np.tan(self.angle_of_tangent(x, graph, **kwargs))

</t>
<t tx="ekr.20250122151620.1323">def plot_derivative_graph(
    self, graph: ParametricFunction, color: ParsableManimColor = GREEN, **kwargs
) -&gt; ParametricFunction:
    """Returns the curve of the derivative of the passed graph.

    Parameters
    ----------
    graph
        The graph for which the derivative will be found.
    color
        The color of the derivative curve.
    kwargs
        Any valid keyword argument of :class:`~.ParametricFunction`.

    Returns
    -------
    :class:`~.ParametricFunction`
        The curve of the derivative.

    Examples
    --------
    .. manim:: DerivativeGraphExample
        :save_last_frame:

        class DerivativeGraphExample(Scene):
            def construct(self):
                ax = NumberPlane(y_range=[-1, 7], background_line_style={"stroke_opacity": 0.4})

                curve_1 = ax.plot(lambda x: x ** 2, color=PURPLE_B)
                curve_2 = ax.plot_derivative_graph(curve_1)
                curves = VGroup(curve_1, curve_2)

                label_1 = ax.get_graph_label(curve_1, "x^2", x_val=-2, direction=DL)
                label_2 = ax.get_graph_label(curve_2, "2x", x_val=3, direction=RIGHT)
                labels = VGroup(label_1, label_2)

                self.add(ax, curves, labels)
    """

    def deriv(x):
        return self.slope_of_tangent(x, graph)

    return self.plot(deriv, color=color, **kwargs)

</t>
<t tx="ekr.20250122151620.1324">def plot_antiderivative_graph(
    self,
    graph: ParametricFunction,
    y_intercept: float = 0,
    samples: int = 50,
    use_vectorized: bool = False,
    **kwargs: Any,
) -&gt; ParametricFunction:
    """Plots an antiderivative graph.

    Parameters
    ----------
    graph
        The graph for which the antiderivative will be found.
    y_intercept
        The y-value at which the graph intercepts the y-axis.
    samples
        The number of points to take the area under the graph.
    use_vectorized
        Whether to use the vectorized version of the antiderivative. This means
        to pass in the generated t value array to the function. Only use this if your function supports it.
        Output should be a numpy array of shape ``[y_0, y_1, ...]``
    kwargs
        Any valid keyword argument of :class:`~.ParametricFunction`.

    Returns
    -------
    :class:`~.ParametricFunction`
        The curve of the antiderivative.


    .. note::
        This graph is plotted from the values of area under the reference graph.
        The result might not be ideal if the reference graph contains uncalculatable
        areas from x=0.

    Examples
    --------
    .. manim:: AntiderivativeExample
        :save_last_frame:

        class AntiderivativeExample(Scene):
            def construct(self):
                ax = Axes()
                graph1 = ax.plot(
                    lambda x: (x ** 2 - 2) / 3,
                    color=RED,
                )
                graph2 = ax.plot_antiderivative_graph(graph1, color=BLUE)
                self.add(ax, graph1, graph2)
    """

    def antideriv(x):
        x_vals = np.linspace(0, x, samples, axis=1 if use_vectorized else 0)
        f_vec = np.vectorize(graph.underlying_function)
        y_vals = f_vec(x_vals)
        return np.trapz(y_vals, x_vals) + y_intercept

    return self.plot(antideriv, use_vectorized=use_vectorized, **kwargs)

</t>
<t tx="ekr.20250122151620.1325">def get_secant_slope_group(
    self,
    x: float,
    graph: ParametricFunction,
    dx: float | None = None,
    dx_line_color: ParsableManimColor = YELLOW,
    dy_line_color: ParsableManimColor | None = None,
    dx_label: float | str | None = None,
    dy_label: float | str | None = None,
    include_secant_line: bool = True,
    secant_line_color: ParsableManimColor = GREEN,
    secant_line_length: float = 10,
) -&gt; VGroup:
    """Creates two lines representing `dx` and `df`, the labels for `dx` and `df`, and
     the secant to the curve at a particular x-value.

    Parameters
    ----------
    x
        The x-value at which the secant intersects the graph for the first time.
    graph
        The curve for which the secant will be found.
    dx
        The change in `x` after which the secant exits.
    dx_line_color
        The color of the line that indicates the change in `x`.
    dy_line_color
        The color of the line that indicates the change in `y`. Defaults to the color of :attr:`graph`.
    dx_label
        The label for the `dx` line. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    dy_label
        The label for the `dy` line. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    include_secant_line
        Whether to include the secant line in the graph,
        or just the df/dx lines and labels.
    secant_line_color
        The color of the secant line.
    secant_line_length
        The length of the secant line.

    Returns
    -------
    :class:`~.VGroup`
        A group containing the elements: `dx_line`, `df_line`, and
        if applicable also :attr:`dx_label`, :attr:`df_label`, `secant_line`.

    Examples
    --------
     .. manim:: GetSecantSlopeGroupExample
        :save_last_frame:

        class GetSecantSlopeGroupExample(Scene):
            def construct(self):
                ax = Axes(y_range=[-1, 7])
                graph = ax.plot(lambda x: 1 / 4 * x ** 2, color=BLUE)
                slopes = ax.get_secant_slope_group(
                    x=2.0,
                    graph=graph,
                    dx=1.0,
                    dx_label=Tex("dx = 1.0"),
                    dy_label="dy",
                    dx_line_color=GREEN_B,
                    secant_line_length=4,
                    secant_line_color=RED_D,
                )

                self.add(ax, graph, slopes)
    """
    group = VGroup()

    dx = dx or float(self.x_range[1] - self.x_range[0]) / 10
    dy_line_color = dy_line_color or graph.get_color()

    p1 = self.input_to_graph_point(x, graph)
    p2 = self.input_to_graph_point(x + dx, graph)
    interim_point = p2[0] * RIGHT + p1[1] * UP

    group.dx_line = Line(p1, interim_point, color=dx_line_color)
    group.df_line = Line(interim_point, p2, color=dy_line_color)
    group.add(group.dx_line, group.df_line)

    labels = VGroup()
    if dx_label is not None:
        group.dx_label = self.x_axis._create_label_tex(dx_label)
        labels.add(group.dx_label)
        group.add(group.dx_label)
    if dy_label is not None:
        group.df_label = self.x_axis._create_label_tex(dy_label)
        labels.add(group.df_label)
        group.add(group.df_label)

    if len(labels) &gt; 0:
        max_width = 0.8 * group.dx_line.width
        max_height = 0.8 * group.df_line.height
        if labels.width &gt; max_width:
            labels.width = max_width
        if labels.height &gt; max_height:
            labels.height = max_height

    if dx_label is not None:
        group.dx_label.next_to(
            group.dx_line,
            np.sign(dx) * DOWN,
            buff=group.dx_label.height / 2,
        )
        group.dx_label.set_color(group.dx_line.get_color())

    if dy_label is not None:
        group.df_label.next_to(
            group.df_line,
            np.sign(dx) * RIGHT,
            buff=group.df_label.height / 2,
        )
        group.df_label.set_color(group.df_line.get_color())

    if include_secant_line:
        group.secant_line = Line(p1, p2, color=secant_line_color)
        group.secant_line.scale(
            secant_line_length / group.secant_line.get_length(),
        )
        group.add(group.secant_line)
    return group

</t>
<t tx="ekr.20250122151620.1326">def get_vertical_lines_to_graph(
    self,
    graph: ParametricFunction,
    x_range: Sequence[float] | None = None,
    num_lines: int = 20,
    **kwargs: Any,
) -&gt; VGroup:
    """Obtains multiple lines from the x-axis to the curve.

    Parameters
    ----------
    graph
        The graph along which the lines are placed.
    x_range
        A list containing the lower and and upper bounds of the lines: ``x_range = [x_min, x_max]``.
    num_lines
        The number of evenly spaced lines.
    kwargs
        Additional arguments to be passed to :meth:`~.CoordinateSystem.get_vertical_line`.

    Returns
    -------
    :class:`~.VGroup`
        The :class:`~.VGroup` of the evenly spaced lines.

    Examples
    --------
    .. manim:: GetVerticalLinesToGraph
        :save_last_frame:

        class GetVerticalLinesToGraph(Scene):
            def construct(self):
                ax = Axes(
                    x_range=[0, 8.0, 1],
                    y_range=[-1, 1, 0.2],
                    axis_config={"font_size": 24},
                ).add_coordinates()

                curve = ax.plot(lambda x: np.sin(x) / np.e ** 2 * x)

                lines = ax.get_vertical_lines_to_graph(
                    curve, x_range=[0, 4], num_lines=30, color=BLUE
                )

                self.add(ax, curve, lines)
    """
    x_range = x_range if x_range is not None else self.x_range

    return VGroup(
        *(
            self.get_vertical_line(self.i2gp(x, graph), **kwargs)
            for x in np.linspace(x_range[0], x_range[1], num_lines)
        )
    )

</t>
<t tx="ekr.20250122151620.1327">def get_T_label(
    self,
    x_val: float,
    graph: ParametricFunction,
    label: float | str | Mobject | None = None,
    label_color: ParsableManimColor | None = None,
    triangle_size: float = MED_SMALL_BUFF,
    triangle_color: ParsableManimColor | None = WHITE,
    line_func: type[Line] = Line,
    line_color: ParsableManimColor = YELLOW,
) -&gt; VGroup:
    """Creates a labelled triangle marker with a vertical line from the x-axis
    to a curve at a given x-value.

    Parameters
    ----------
    x_val
        The position along the curve at which the label, line and triangle will be constructed.
    graph
        The :class:`~.ParametricFunction` for which to construct the label.
    label
        The label of the vertical line and triangle.
    label_color
        The color of the label.
    triangle_size
        The size of the triangle.
    triangle_color
        The color of the triangle.
    line_func
        The function used to construct the vertical line.
    line_color
        The color of the vertical line.

    Returns
    -------
    :class:`~.VGroup`
        A :class:`~.VGroup` of the label, triangle and vertical line mobjects.

    Examples
    --------
    .. manim:: TLabelExample
        :save_last_frame:

        class TLabelExample(Scene):
            def construct(self):
                # defines the axes and linear function
                axes = Axes(x_range=[-1, 10], y_range=[-1, 10], x_length=9, y_length=6)
                func = axes.plot(lambda x: x, color=BLUE)
                # creates the T_label
                t_label = axes.get_T_label(x_val=4, graph=func, label=Tex("x-value"))
                self.add(axes, func, t_label)
    """
    T_label_group = VGroup()
    triangle = RegularPolygon(n=3, start_angle=np.pi / 2, stroke_width=0).set_fill(
        color=triangle_color,
        opacity=1,
    )
    triangle.height = triangle_size
    triangle.move_to(self.coords_to_point(x_val, 0), UP)
    if label is not None:
        t_label = self.x_axis._create_label_tex(label, color=label_color)
        t_label.next_to(triangle, DOWN)
        T_label_group.add(t_label)

    v_line = self.get_vertical_line(
        self.i2gp(x_val, graph),
        color=line_color,
        line_func=line_func,
    )

    T_label_group.add(triangle, v_line)

    return T_label_group

</t>
<t tx="ekr.20250122151620.1328">def __matmul__(self, coord: Point3DLike | Mobject):
    if isinstance(coord, Mobject):
        coord = coord.get_center()
    return self.coords_to_point(*coord)

</t>
<t tx="ekr.20250122151620.1329">def __rmatmul__(self, point: Point3DLike):
    return self.point_to_coords(point)


</t>
<t tx="ekr.20250122151620.133">@background_opacity.setter
def background_opacity(self, value: float) -&gt; None:
    self._set_between("background_opacity", value, 0, 1)
    if self.background_opacity &lt; 1:
        self.resolve_movie_file_extension(is_transparent=True)

</t>
<t tx="ekr.20250122151620.1330">def __init__(
    self,
    x_range: Sequence[float] | None = None,
    y_range: Sequence[float] | None = None,
    x_length: float | None = round(config.frame_width) - 2,
    y_length: float | None = round(config.frame_height) - 2,
    axis_config: dict | None = None,
    x_axis_config: dict | None = None,
    y_axis_config: dict | None = None,
    tips: bool = True,
    **kwargs: Any,
</t>
<t tx="ekr.20250122151620.1331">) -&gt; None:
    VGroup.__init__(self, **kwargs)
    CoordinateSystem.__init__(self, x_range, y_range, x_length, y_length)

    self.axis_config = {
        "include_tip": tips,
        "numbers_to_exclude": [0],
    }
    self.x_axis_config = {}
    self.y_axis_config = {"rotation": 90 * DEGREES, "label_direction": LEFT}

    self._update_default_configs(
        (self.axis_config, self.x_axis_config, self.y_axis_config),
        (axis_config, x_axis_config, y_axis_config),
    )

    self.x_axis_config = merge_dicts_recursively(
        self.axis_config,
        self.x_axis_config,
    )
    self.y_axis_config = merge_dicts_recursively(
        self.axis_config,
        self.y_axis_config,
    )

    # excluding the origin tick removes a tick at the 0-point of the axis
    # This is desired for LinearBase because the 0 point is always the x-axis
    # For non-LinearBase, the "0-point" does not have this quality, so it must be included.

    # i.e. with LogBase range [-2, 4]:
    # it would remove the "0" tick, which is actually 10^0,
    # not the lowest tick on the graph (which is 10^-2).

    if self.x_axis_config.get("scaling") is None or isinstance(
        self.x_axis_config.get("scaling"), LinearBase
    ):
        self.x_axis_config["exclude_origin_tick"] = True
    else:
        self.x_axis_config["exclude_origin_tick"] = False

    if self.y_axis_config.get("scaling") is None or isinstance(
        self.y_axis_config.get("scaling"), LinearBase
    ):
        self.y_axis_config["exclude_origin_tick"] = True
    else:
        self.y_axis_config["exclude_origin_tick"] = False

    self.x_axis = self._create_axis(self.x_range, self.x_axis_config, self.x_length)
    self.y_axis = self._create_axis(self.y_range, self.y_axis_config, self.y_length)

    # Add as a separate group in case various other
    # mobjects are added to self, as for example in
    # NumberPlane below
    self.axes = VGroup(self.x_axis, self.y_axis)
    self.add(*self.axes)

    # finds the middle-point on each axis
    lines_center_point = [
        axis.scaling.function((axis.x_range[1] + axis.x_range[0]) / 2)
        for axis in self.axes
    ]

    self.shift(-self.coords_to_point(*lines_center_point))

@staticmethod
def _update_default_configs(
    default_configs: tuple[dict[Any, Any]], passed_configs: tuple[dict[Any, Any]]
) -&gt; None:
    """Takes in two tuples of dicts and return modifies the first such that values from
    ``passed_configs`` overwrite values in ``default_configs``. If a key does not exist
    in default_configs, it is added to the dict.

    This method is useful for having defaults in a class and being able to overwrite
    them with user-defined input.

    Parameters
    ----------
    default_configs
        The dict that will be updated.
    passed_configs
        The dict that will be used to update.

    Examples
    --------
    To create a tuple with one dictionary, add a comma after the element:

    .. code-block:: python

        self._update_default_configs(
            (dict_1,)(
                dict_2,
            )
        )
    """
    for default_config, passed_config in zip(default_configs, passed_configs):
        if passed_config is not None:
            update_dict_recursively(default_config, passed_config)

</t>
<t tx="ekr.20250122151620.1332">def _create_axis(
    self,
    range_terms: Sequence[float],
    axis_config: dict[str, Any],
    length: float,
) -&gt; NumberLine:
    """Creates an axis and dynamically adjusts its position depending on where 0 is located on the line.

    Parameters
    ----------
    range_terms
        The range of the the axis : ``(x_min, x_max, x_step)``.
    axis_config
        Additional parameters that are passed to :class:`~.NumberLine`.
    length
        The length of the axis.

    Returns
    -------
    :class:`NumberLine`
        Returns a number line based on ``range_terms``.
    """
    axis_config["length"] = length
    axis = NumberLine(range_terms, **axis_config)

    # without the call to _origin_shift, graph does not exist when min &gt; 0 or max &lt; 0
    # shifts the axis so that 0 is centered
    axis.shift(-axis.number_to_point(self._origin_shift([axis.x_min, axis.x_max])))
    return axis

</t>
<t tx="ekr.20250122151620.1333">def coords_to_point(
    self, *coords: float | Sequence[float] | Sequence[Sequence[float]] | np.ndarray
) -&gt; np.ndarray:
    """Accepts coordinates from the axes and returns a point with respect to the scene.
    Equivalent to `ax @ (coord1)`

    Parameters
    ----------
    coords
        The coordinates. Each coord is passed as a separate argument: ``ax.coords_to_point(1, 2, 3)``.

        Also accepts a list of coordinates

        ``ax.coords_to_point( [x_0, x_1, ...], [y_0, y_1, ...], ... )``

        ``ax.coords_to_point( [[x_0, y_0, z_0], [x_1, y_1, z_1]] )``

    Returns
    -------
    np.ndarray
        A point with respect to the scene's coordinate system.
        The shape of the array will be similar to the shape of the input.

    Examples
    --------

    .. code-block:: pycon

        &gt;&gt;&gt; from manim import Axes
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; ax = Axes()
        &gt;&gt;&gt; np.around(ax.coords_to_point(1, 0, 0), 2)
        array([0.86, 0.  , 0.  ])
        &gt;&gt;&gt; np.around(ax @ (1, 0, 0), 2)
        array([0.86, 0.  , 0.  ])
        &gt;&gt;&gt; np.around(ax.coords_to_point([[0, 1], [1, 1], [1, 0]]), 2)
        array([[0.  , 0.75, 0.  ],
               [0.86, 0.75, 0.  ],
               [0.86, 0.  , 0.  ]])
        &gt;&gt;&gt; np.around(
        ...     ax.coords_to_point([0, 1, 1], [1, 1, 0]), 2
        ... )  # Transposed version of the above
        array([[0.  , 0.86, 0.86],
               [0.75, 0.75, 0.  ],
               [0.  , 0.  , 0.  ]])

    .. manim:: CoordsToPointExample
        :save_last_frame:

        class CoordsToPointExample(Scene):
            def construct(self):
                ax = Axes().add_coordinates()

                # a dot with respect to the axes
                dot_axes = Dot(ax.coords_to_point(2, 2), color=GREEN)
                lines = ax.get_lines_to_point(ax.c2p(2,2))

                # a dot with respect to the scene
                # the default plane corresponds to the coordinates of the scene.
                plane = NumberPlane()
                dot_scene = Dot((2,2,0), color=RED)

                self.add(plane, dot_scene, ax, dot_axes, lines)
    """
    coords = np.asarray(coords)
    origin = self.x_axis.number_to_point(
        self._origin_shift([self.x_axis.x_min, self.x_axis.x_max]),
    )

    # Is coords in the format ([[x1 y1 z1] [x2 y2 z2] ...])? (True)
    # Or is coords in the format (x, y, z) or ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...])? (False)
    # The latter is preferred.
    are_coordinates_transposed = False

    # If coords is in the format ([[x1 y1 z1] [x2 y2 z2] ...]):
    if coords.ndim == 3:
        # Extract from original tuple: now coords looks like [[x y z]] or [[x1 y1 z1] [x2 y2 z2] ...].
        coords = coords[0]
        # If there's a single coord (coords = [[x y z]]), extract it so that
        # coords = [x y z] and coords_to_point returns a single point.
        if coords.shape[0] == 1:
            coords = coords[0]
        # Else, if coords looks more like [[x1 y1 z1] [x2 y2 z2] ...], transform them (by
        # transposing) into the format [[x1 x2 ...] [y1 y2 ...] [z1 z2 ...]] for later processing.
        else:
            coords = coords.T
            are_coordinates_transposed = True
    # Otherwise, coords already looked like (x, y, z) or ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...]),
    # so no further processing is needed.

    # Now coords should either look like [x y z] or [[x1 x2 ...] [y1 y2 ...] [z1 z2 ...]],
    # so it can be iterated directly. Each element is either a float representing a single
    # coordinate, or a float ndarray of coordinates corresponding to a single axis.
    # Although "points" and "nums" are in plural, there might be a single point or number.
    points = self.x_axis.number_to_point(coords[0])
    other_axes = self.axes.submobjects[1:]
    for axis, nums in zip(other_axes, coords[1:]):
        points += axis.number_to_point(nums) - origin

    # Return points as is, except if coords originally looked like
    # ([x1 x2 ...], [y1 y2 ...], [z1 z2 ...]), which is determined by the conditions below. In
    # that case, the current implementation requires that the results have to be transposed.
    if are_coordinates_transposed or points.ndim == 1:
        return points
    return points.T

</t>
<t tx="ekr.20250122151620.1334">def point_to_coords(self, point: Sequence[float]) -&gt; np.ndarray:
    """Accepts a point from the scene and returns its coordinates with respect to the axes.

    Parameters
    ----------
    point
        The point, i.e. ``RIGHT`` or ``[0, 1, 0]``.
        Also accepts a list of points as ``[RIGHT, [0, 1, 0]]``.

    Returns
    -------
    np.ndarray[float]
        The coordinates on the axes, i.e. ``[4.0, 7.0]``.
        Or a list of coordinates if `point` is a list of points.

    Examples
    --------

    .. code-block:: pycon

        &gt;&gt;&gt; from manim import Axes, RIGHT
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; ax = Axes(x_range=[0, 10, 2])
        &gt;&gt;&gt; np.around(ax.point_to_coords(RIGHT), 2)
        array([5.83, 0.  ])
        &gt;&gt;&gt; np.around(ax.point_to_coords([[0, 0, 1], [1, 0, 0]]), 2)
        array([[5.  , 0.  ],
               [5.83, 0.  ]])


    .. manim:: PointToCoordsExample
        :save_last_frame:

        class PointToCoordsExample(Scene):
            def construct(self):
                ax = Axes(x_range=[0, 10, 2]).add_coordinates()
                circ = Circle(radius=0.5).shift(UR * 2)

                # get the coordinates of the circle with respect to the axes
                coords = np.around(ax.point_to_coords(circ.get_right()), decimals=2)

                label = (
                    Matrix([[coords[0]], [coords[1]]]).scale(0.75).next_to(circ, RIGHT)
                )

                self.add(ax, circ, label, Dot(circ.get_right()))
    """
    point = np.asarray(point)
    result = np.asarray([axis.point_to_number(point) for axis in self.get_axes()])
    if point.ndim == 2:
        return result.T
    return result

</t>
<t tx="ekr.20250122151620.1335">def get_axes(self) -&gt; VGroup:
    """Gets the axes.

    Returns
    -------
    :class:`~.VGroup`
        A pair of axes.
    """
    return self.axes

</t>
<t tx="ekr.20250122151620.1336">def get_axis_labels(
    self,
    x_label: float | str | Mobject = "x",
    y_label: float | str | Mobject = "y",
) -&gt; VGroup:
    """Defines labels for the x-axis and y-axis of the graph.

    For increased control over the position of the labels,
    use :meth:`~.CoordinateSystem.get_x_axis_label` and
    :meth:`~.CoordinateSystem.get_y_axis_label`.

    Parameters
    ----------
    x_label
        The label for the x_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    y_label
        The label for the y_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.

    Returns
    -------
    :class:`~.VGroup`
        A :class:`~.VGroup` of the labels for the x_axis and y_axis.


    .. seealso::
        :meth:`~.CoordinateSystem.get_x_axis_label`
        :meth:`~.CoordinateSystem.get_y_axis_label`

    Examples
    --------
    .. manim:: GetAxisLabelsExample
        :save_last_frame:

        class GetAxisLabelsExample(Scene):
            def construct(self):
                ax = Axes()
                labels = ax.get_axis_labels(
                    Tex("x-axis").scale(0.7), Text("y-axis").scale(0.45)
                )
                self.add(ax, labels)
    """
    self.axis_labels = VGroup(
        self.get_x_axis_label(x_label),
        self.get_y_axis_label(y_label),
    )
    return self.axis_labels

</t>
<t tx="ekr.20250122151620.1337">def plot_line_graph(
    self,
    x_values: Iterable[float],
    y_values: Iterable[float],
    z_values: Iterable[float] | None = None,
    line_color: ParsableManimColor = YELLOW,
    add_vertex_dots: bool = True,
    vertex_dot_radius: float = DEFAULT_DOT_RADIUS,
    vertex_dot_style: dict[str, Any] | None = None,
    **kwargs: Any,
) -&gt; VDict:
    """Draws a line graph.

    The graph connects the vertices formed from zipping
    ``x_values``, ``y_values`` and ``z_values``. Also adds :class:`Dots &lt;.Dot&gt;` at the
    vertices if ``add_vertex_dots`` is set to ``True``.

    Parameters
    ----------
    x_values
        Iterable of values along the x-axis.
    y_values
        Iterable of values along the y-axis.
    z_values
        Iterable of values (zeros if z_values is None) along the z-axis.
    line_color
        Color for the line graph.
    add_vertex_dots
        Whether or not to add :class:`~.Dot` at each vertex.
    vertex_dot_radius
        Radius for the :class:`~.Dot` at each vertex.
    vertex_dot_style
        Style arguments to be passed into :class:`~.Dot` at each vertex.
    kwargs
        Additional arguments to be passed into :class:`~.VMobject`.

    Returns
    -------
    :class:`~.VDict`
        A VDict containing both the line and dots (if specified). The line can be accessed with: ``line_graph["line_graph"]``.
        The dots can be accessed with: ``line_graph["vertex_dots"]``.

    Examples
    --------
    .. manim:: LineGraphExample
        :save_last_frame:

        class LineGraphExample(Scene):
            def construct(self):
                plane = NumberPlane(
                    x_range = (0, 7),
                    y_range = (0, 5),
                    x_length = 7,
                    axis_config={"include_numbers": True},
                )
                plane.center()
                line_graph = plane.plot_line_graph(
                    x_values = [0, 1.5, 2, 2.8, 4, 6.25],
                    y_values = [1, 3, 2.25, 4, 2.5, 1.75],
                    line_color=GOLD_E,
                    vertex_dot_style=dict(stroke_width=3,  fill_color=PURPLE),
                    stroke_width = 4,
                )
                self.add(plane, line_graph)
    """
    x_values, y_values = map(np.array, (x_values, y_values))
    if z_values is None:
        z_values = np.zeros(x_values.shape)

    line_graph = VDict()
    graph = VGroup(color=line_color, **kwargs)

    vertices = [
        self.coords_to_point(x, y, z)
        for x, y, z in zip(x_values, y_values, z_values)
    ]
    graph.set_points_as_corners(vertices)
    line_graph["line_graph"] = graph

    if add_vertex_dots:
        vertex_dot_style = vertex_dot_style or {}
        vertex_dots = VGroup(
            *(
                Dot(point=vertex, radius=vertex_dot_radius, **vertex_dot_style)
                for vertex in vertices
            )
        )
        line_graph["vertex_dots"] = vertex_dots

    return line_graph

</t>
<t tx="ekr.20250122151620.1338">@staticmethod
def _origin_shift(axis_range: Sequence[float]) -&gt; float:
    """Determines how to shift graph mobjects to compensate when 0 is not on the axis.

    Parameters
    ----------
    axis_range
        The range of the axis : ``(x_min, x_max, x_step)``.
    """
    if axis_range[0] &gt; 0:
        # min greater than 0
        return axis_range[0]
    if axis_range[1] &lt; 0:
        # max less than 0
        return axis_range[1]
    else:
        return 0


</t>
<t tx="ekr.20250122151620.1339">def __init__(
    self,
    x_range: Sequence[float] | None = (-6, 6, 1),
    y_range: Sequence[float] | None = (-5, 5, 1),
    z_range: Sequence[float] | None = (-4, 4, 1),
    x_length: float | None = config.frame_height + 2.5,
    y_length: float | None = config.frame_height + 2.5,
    z_length: float | None = config.frame_height - 1.5,
    z_axis_config: dict[str, Any] | None = None,
    z_normal: Vector3D = DOWN,
    num_axis_pieces: int = 20,
    light_source: Sequence[float] = 9 * DOWN + 7 * LEFT + 10 * OUT,
    # opengl stuff (?)
    depth=None,
    gloss=0.5,
    **kwargs: dict[str, Any],
</t>
<t tx="ekr.20250122151620.134">@property
def frame_size(self) -&gt; tuple[int, int]:
    """Tuple with (pixel width, pixel height) (no flag)."""
    return (self._d["pixel_width"], self._d["pixel_height"])

</t>
<t tx="ekr.20250122151620.1340">) -&gt; None:
    super().__init__(
        x_range=x_range,
        x_length=x_length,
        y_range=y_range,
        y_length=y_length,
        **kwargs,
    )

    self.z_range = z_range
    self.z_length = z_length

    self.z_axis_config = {}
    self._update_default_configs((self.z_axis_config,), (z_axis_config,))
    self.z_axis_config = merge_dicts_recursively(
        self.axis_config,
        self.z_axis_config,
    )

    self.z_normal = z_normal
    self.num_axis_pieces = num_axis_pieces

    self.light_source = light_source

    self.dimension = 3

    if self.z_axis_config.get("scaling") is None or isinstance(
        self.z_axis_config.get("scaling"), LinearBase
    ):
        self.z_axis_config["exclude_origin_tick"] = True
    else:
        self.z_axis_config["exclude_origin_tick"] = False

    z_axis = self._create_axis(self.z_range, self.z_axis_config, self.z_length)

    # [ax.x_min, ax.x_max] used to account for LogBase() scaling
    # where ax.x_range[0] != ax.x_min
    z_origin = self._origin_shift([z_axis.x_min, z_axis.x_max])

    z_axis.rotate_about_number(z_origin, -PI / 2, UP)
    z_axis.rotate_about_number(z_origin, angle_of_vector(self.z_normal))
    z_axis.shift(-z_axis.number_to_point(z_origin))
    z_axis.shift(
        self.x_axis.number_to_point(
            self._origin_shift([self.x_axis.x_min, self.x_axis.x_max]),
        ),
    )

    self.axes.add(z_axis)
    self.add(z_axis)
    self.z_axis = z_axis

    if config.renderer == RendererType.CAIRO:
        self._add_3d_pieces()
        self._set_axis_shading()

def _add_3d_pieces(self) -&gt; None:
    for axis in self.axes:
        axis.pieces = VGroup(*axis.get_pieces(self.num_axis_pieces))
        axis.add(axis.pieces)
        axis.set_stroke(width=0, family=False)
        axis.set_shade_in_3d(True)

</t>
<t tx="ekr.20250122151620.1341">def _set_axis_shading(self) -&gt; None:
    def make_func(axis):
        vect = self.light_source
        return lambda: (
            axis.get_edge_center(-vect),
            axis.get_edge_center(vect),
        )

    for axis in self:
        for submob in axis.family_members_with_points():
            submob.get_gradient_start_and_end_points = make_func(axis)
            submob.get_unit_normal = lambda a: np.ones(3)
            submob.set_sheen(0.2)

</t>
<t tx="ekr.20250122151620.1342">def get_y_axis_label(
    self,
    label: float | str | Mobject,
    edge: Sequence[float] = UR,
    direction: Sequence[float] = UR,
    buff: float = SMALL_BUFF,
    rotation: float = PI / 2,
    rotation_axis: Vector3D = OUT,
    **kwargs,
) -&gt; Mobject:
    """Generate a y-axis label.

    Parameters
    ----------
    label
        The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    edge
        The edge of the y-axis to which the label will be added, by default ``UR``.
    direction
        Allows for further positioning of the label from an edge, by default ``UR``.
    buff
        The distance of the label from the line, by default ``SMALL_BUFF``.
    rotation
        The angle at which to rotate the label, by default ``PI/2``.
    rotation_axis
        The axis about which to rotate the label, by default ``OUT``.

    Returns
    -------
    :class:`~.Mobject`
        The positioned label.

    Examples
    --------
    .. manim:: GetYAxisLabelExample
        :save_last_frame:

        class GetYAxisLabelExample(ThreeDScene):
            def construct(self):
                ax = ThreeDAxes()
                lab = ax.get_y_axis_label(Tex("$y$-label"))
                self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
                self.add(ax, lab)
    """
    positioned_label = self._get_axis_label(
        label, self.get_y_axis(), edge, direction, buff=buff, **kwargs
    )
    positioned_label.rotate(rotation, axis=rotation_axis)
    return positioned_label

</t>
<t tx="ekr.20250122151620.1343">def get_z_axis_label(
    self,
    label: float | str | Mobject,
    edge: Vector3D = OUT,
    direction: Vector3D = RIGHT,
    buff: float = SMALL_BUFF,
    rotation: float = PI / 2,
    rotation_axis: Vector3D = RIGHT,
    **kwargs: Any,
) -&gt; Mobject:
    """Generate a z-axis label.

    Parameters
    ----------
    label
        The label. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    edge
        The edge of the z-axis to which the label will be added, by default ``OUT``.
    direction
        Allows for further positioning of the label from an edge, by default ``RIGHT``.
    buff
        The distance of the label from the line, by default ``SMALL_BUFF``.
    rotation
        The angle at which to rotate the label, by default ``PI/2``.
    rotation_axis
        The axis about which to rotate the label, by default ``RIGHT``.

    Returns
    -------
    :class:`~.Mobject`
        The positioned label.

    Examples
    --------
    .. manim:: GetZAxisLabelExample
        :save_last_frame:

        class GetZAxisLabelExample(ThreeDScene):
            def construct(self):
                ax = ThreeDAxes()
                lab = ax.get_z_axis_label(Tex("$z$-label"))
                self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
                self.add(ax, lab)
    """
    positioned_label = self._get_axis_label(
        label, self.get_z_axis(), edge, direction, buff=buff, **kwargs
    )
    positioned_label.rotate(rotation, axis=rotation_axis)
    return positioned_label

</t>
<t tx="ekr.20250122151620.1344">def get_axis_labels(
    self,
    x_label: float | str | Mobject = "x",
    y_label: float | str | Mobject = "y",
    z_label: float | str | Mobject = "z",
) -&gt; VGroup:
    """Defines labels for the x_axis and y_axis of the graph.

    For increased control over the position of the labels,
    use :meth:`~.CoordinateSystem.get_x_axis_label`,
    :meth:`~.ThreeDAxes.get_y_axis_label`, and
    :meth:`~.ThreeDAxes.get_z_axis_label`.

    Parameters
    ----------
    x_label
        The label for the x_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    y_label
        The label for the y_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.
    z_label
        The label for the z_axis. Defaults to :class:`~.MathTex` for ``str`` and ``float`` inputs.

    Returns
    -------
    :class:`~.VGroup`
        A :class:`~.VGroup` of the labels for the x_axis, y_axis, and z_axis.


    .. seealso::
        :meth:`~.CoordinateSystem.get_x_axis_label`
        :meth:`~.ThreeDAxes.get_y_axis_label`
        :meth:`~.ThreeDAxes.get_z_axis_label`

    Examples
    --------
    .. manim:: GetAxisLabelsExample
        :save_last_frame:

        class GetAxisLabelsExample(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=2*PI/5, theta=PI/5)
                axes = ThreeDAxes()
                labels = axes.get_axis_labels(
                    Text("x-axis").scale(0.7), Text("y-axis").scale(0.45), Text("z-axis").scale(0.45)
                )
                self.add(axes, labels)
    """
    self.axis_labels = VGroup(
        self.get_x_axis_label(x_label),
        self.get_y_axis_label(y_label),
        self.get_z_axis_label(z_label),
    )
    return self.axis_labels


</t>
<t tx="ekr.20250122151620.1345">def __init__(
    self,
    x_range: Sequence[float] | None = (
        -config["frame_x_radius"],
        config["frame_x_radius"],
        1,
    ),
    y_range: Sequence[float] | None = (
        -config["frame_y_radius"],
        config["frame_y_radius"],
        1,
    ),
    x_length: float | None = None,
    y_length: float | None = None,
    background_line_style: dict[str, Any] | None = None,
    faded_line_style: dict[str, Any] | None = None,
    faded_line_ratio: int = 1,
    make_smooth_after_applying_functions: bool = True,
    **kwargs: dict[str, Any],
</t>
<t tx="ekr.20250122151620.1346">):
    # configs
    self.axis_config = {
        "stroke_width": 2,
        "include_ticks": False,
        "include_tip": False,
        "line_to_number_buff": SMALL_BUFF,
        "label_direction": DR,
        "font_size": 24,
    }
    self.y_axis_config = {"label_direction": DR}
    self.background_line_style = {
        "stroke_color": BLUE_D,
        "stroke_width": 2,
        "stroke_opacity": 1,
    }

    self._update_default_configs(
        (self.axis_config, self.y_axis_config, self.background_line_style),
        (
            kwargs.pop("axis_config", None),
            kwargs.pop("y_axis_config", None),
            background_line_style,
        ),
    )

    # Defaults to a faded version of line_config
    self.faded_line_style = faded_line_style
    self.faded_line_ratio = faded_line_ratio
    self.make_smooth_after_applying_functions = make_smooth_after_applying_functions

    # init
    super().__init__(
        x_range=x_range,
        y_range=y_range,
        x_length=x_length,
        y_length=y_length,
        axis_config=self.axis_config,
        y_axis_config=self.y_axis_config,
        **kwargs,
    )

    self._init_background_lines()

def _init_background_lines(self) -&gt; None:
    """Will init all the lines of NumberPlanes (faded or not)"""
    if self.faded_line_style is None:
        style = dict(self.background_line_style)
        # For anything numerical, like stroke_width
        # and stroke_opacity, chop it in half
        for key in style:
            if isinstance(style[key], numbers.Number):
                style[key] *= 0.5
        self.faded_line_style = style

    self.background_lines, self.faded_lines = self._get_lines()

    self.background_lines.set_style(
        **self.background_line_style,
    )
    self.faded_lines.set_style(
        **self.faded_line_style,
    )
    self.add_to_back(
        self.faded_lines,
        self.background_lines,
    )

</t>
<t tx="ekr.20250122151620.1347">def _get_lines(self) -&gt; tuple[VGroup, VGroup]:
    """Generate all the lines, faded and not faded.
     Two sets of lines are generated: one parallel to the X-axis, and parallel to the Y-axis.

    Returns
    -------
    Tuple[:class:`~.VGroup`, :class:`~.VGroup`]
        The first (i.e the non faded lines) and second (i.e the faded lines) sets of lines, respectively.
    """
    x_axis = self.get_x_axis()
    y_axis = self.get_y_axis()

    x_lines1, x_lines2 = self._get_lines_parallel_to_axis(
        x_axis,
        y_axis,
        self.y_axis.x_range[2],
        self.faded_line_ratio,
    )

    y_lines1, y_lines2 = self._get_lines_parallel_to_axis(
        y_axis,
        x_axis,
        self.x_axis.x_range[2],
        self.faded_line_ratio,
    )

    # TODO this was added so that we can run tests on NumberPlane
    # In the future these attributes will be tacked onto self.background_lines
    self.x_lines = x_lines1
    self.y_lines = y_lines1
    lines1 = VGroup(*x_lines1, *y_lines1)
    lines2 = VGroup(*x_lines2, *y_lines2)

    return lines1, lines2

</t>
<t tx="ekr.20250122151620.1348">def _get_lines_parallel_to_axis(
    self,
    axis_parallel_to: NumberLine,
    axis_perpendicular_to: NumberLine,
    freq: float,
    ratio_faded_lines: int,
) -&gt; tuple[VGroup, VGroup]:
    """Generate a set of lines parallel to an axis.

    Parameters
    ----------
    axis_parallel_to
        The axis with which the lines will be parallel.
    axis_perpendicular_to
        The axis with which the lines will be perpendicular.
    ratio_faded_lines
        The ratio between the space between faded lines and the space between non-faded lines.
    freq
        Frequency of non-faded lines (number of non-faded lines per graph unit).

    Returns
    -------
    Tuple[:class:`~.VGroup`, :class:`~.VGroup`]
        The first (i.e the non-faded lines parallel to `axis_parallel_to`) and second
         (i.e the faded lines parallel to `axis_parallel_to`) sets of lines, respectively.
    """
    line = Line(axis_parallel_to.get_start(), axis_parallel_to.get_end())
    if ratio_faded_lines == 0:  # don't show faded lines
        ratio_faded_lines = 1  # i.e. set ratio to 1
    step = (1 / ratio_faded_lines) * freq
    lines1 = VGroup()
    lines2 = VGroup()
    unit_vector_axis_perp_to = axis_perpendicular_to.get_unit_vector()

    # need to unpack all three values
    x_min, x_max, _ = axis_perpendicular_to.x_range

    # account for different axis scalings (logarithmic), where
    # negative values do not exist and [-2 , 4] should output lines
    # similar to [0, 6]
    if axis_perpendicular_to.x_min &gt; 0 and x_min &lt; 0:
        x_min, x_max = (0, np.abs(x_min) + np.abs(x_max))

    # min/max used in case range does not include 0. i.e. if (2,6):
    # the range becomes (0,4), not (0,6).
    ranges = (
        [0],
        np.arange(step, min(x_max - x_min, x_max), step),
        np.arange(-step, max(x_min - x_max, x_min), -step),
    )

    for inputs in ranges:
        for k, x in enumerate(inputs):
            new_line = line.copy()
            new_line.shift(unit_vector_axis_perp_to * x)
            if (k + 1) % ratio_faded_lines == 0:
                lines1.add(new_line)
            else:
                lines2.add(new_line)
    return lines1, lines2

</t>
<t tx="ekr.20250122151620.1349">def get_vector(self, coords: Sequence[ManimFloat], **kwargs: Any) -&gt; Arrow:
    kwargs["buff"] = 0
    return Arrow(
        self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs
    )

</t>
<t tx="ekr.20250122151620.135">@frame_size.setter
def frame_size(self, value: tuple[int, int]) -&gt; None:
    self._d.__setitem__("pixel_width", value[0]) or self._d.__setitem__(
        "pixel_height", value[1]
    )

</t>
<t tx="ekr.20250122151620.1350">def prepare_for_nonlinear_transform(self, num_inserted_curves: int = 50) -&gt; Self:
    for mob in self.family_members_with_points():
        num_curves = mob.get_num_curves()
        if num_inserted_curves &gt; num_curves:
            mob.insert_n_curves(num_inserted_curves - num_curves)
    return self


</t>
<t tx="ekr.20250122151620.1351">r"""Creates a polar plane with background lines.

Parameters
----------
azimuth_step
    The number of divisions in the azimuth (also known as the `angular coordinate` or `polar angle`). If ``None`` is specified then it will use the default
    specified by ``azimuth_units``:

    - ``"PI radians"`` or ``"TAU radians"``: 20
    - ``"degrees"``: 36
    - ``"gradians"``: 40
    - ``None``: 1

    A non-integer value will result in a partial division at the end of the circle.

size
    The diameter of the plane.

radius_step
    The distance between faded radius lines.

radius_max
    The maximum value of the radius.

azimuth_units
    Specifies a default labelling system for the azimuth. Choices are:

    - ``"PI radians"``: Fractional labels in the interval :math:`\left[0, 2\pi\right]` with :math:`\pi` as a constant.
    - ``"TAU radians"``: Fractional labels in the interval :math:`\left[0, \tau\right]` (where :math:`\tau = 2\pi`) with :math:`\tau` as a constant.
    - ``"degrees"``: Decimal labels in the interval :math:`\left[0, 360\right]` with a degree (:math:`^{\circ}`) symbol.
    - ``"gradians"``: Decimal labels in the interval :math:`\left[0, 400\right]` with a superscript "g" (:math:`^{g}`).
    - ``None``: Decimal labels in the interval :math:`\left[0, 1\right]`.

azimuth_compact_fraction
    If the ``azimuth_units`` choice has fractional labels, choose whether to
    combine the constant in a compact form :math:`\tfrac{xu}{y}` as opposed to
    :math:`\tfrac{x}{y}u`, where :math:`u` is the constant.

azimuth_offset
    The angle offset of the azimuth, expressed in radians.

azimuth_direction
    The direction of the azimuth.

    - ``"CW"``: Clockwise.
    - ``"CCW"``: Anti-clockwise.

azimuth_label_buff
    The buffer for the azimuth labels.

azimuth_label_font_size
    The font size of the azimuth labels.

radius_config
    The axis config for the radius.

Examples
--------
.. manim:: PolarPlaneExample
    :ref_classes: PolarPlane
    :save_last_frame:

    class PolarPlaneExample(Scene):
        def construct(self):
            polarplane_pi = PolarPlane(
                azimuth_units="PI radians",
                size=6,
                azimuth_label_font_size=33.6,
                radius_config={"font_size": 33.6},
            ).add_coordinates()
            self.add(polarplane_pi)
"""

def __init__(
    self,
    radius_max: float = config["frame_y_radius"],
    size: float | None = None,
    radius_step: float = 1,
    azimuth_step: float | None = None,
    azimuth_units: str | None = "PI radians",
    azimuth_compact_fraction: bool = True,
    azimuth_offset: float = 0,
    azimuth_direction: str = "CCW",
    azimuth_label_buff: float = SMALL_BUFF,
    azimuth_label_font_size: float = 24,
    radius_config: dict[str, Any] | None = None,
    background_line_style: dict[str, Any] | None = None,
    faded_line_style: dict[str, Any] | None = None,
    faded_line_ratio: int = 1,
    make_smooth_after_applying_functions: bool = True,
    **kwargs: Any,
) -&gt; None:
    # error catching
    if azimuth_units in ["PI radians", "TAU radians", "degrees", "gradians", None]:
        self.azimuth_units = azimuth_units
    else:
        raise ValueError(
            "Invalid azimuth units. Expected one of: PI radians, TAU radians, degrees, gradians or None.",
        )

    if azimuth_direction in ["CW", "CCW"]:
        self.azimuth_direction = azimuth_direction
    else:
        raise ValueError("Invalid azimuth units. Expected one of: CW, CCW.")

    # configs
    self.radius_config = {
        "stroke_width": 2,
        "include_ticks": False,
        "include_tip": False,
        "line_to_number_buff": SMALL_BUFF,
        "label_direction": DL,
        "font_size": 24,
    }

    self.background_line_style = {
        "stroke_color": BLUE_D,
        "stroke_width": 2,
        "stroke_opacity": 1,
    }

    self.azimuth_step = (
        (
            {
                "PI radians": 20,
                "TAU radians": 20,
                "degrees": 36,
                "gradians": 40,
                None: 1,
            }[azimuth_units]
        )
        if azimuth_step is None
        else azimuth_step
    )

    self._update_default_configs(
        (self.radius_config, self.background_line_style),
        (radius_config, background_line_style),
    )

    # Defaults to a faded version of line_config
    self.faded_line_style = faded_line_style
    self.faded_line_ratio = faded_line_ratio
    self.make_smooth_after_applying_functions = make_smooth_after_applying_functions
    self.azimuth_offset = azimuth_offset
    self.azimuth_label_buff = azimuth_label_buff
    self.azimuth_label_font_size = azimuth_label_font_size
    self.azimuth_compact_fraction = azimuth_compact_fraction

    # init

    super().__init__(
        x_range=np.array((-radius_max, radius_max, radius_step)),
        y_range=np.array((-radius_max, radius_max, radius_step)),
        x_length=size,
        y_length=size,
        axis_config=self.radius_config,
        **kwargs,
    )

    self._init_background_lines()

</t>
<t tx="ekr.20250122151620.1352">def _init_background_lines(self) -&gt; None:
    """Will init all the lines of NumberPlanes (faded or not)"""
    if self.faded_line_style is None:
        style = dict(self.background_line_style)
        # For anything numerical, like stroke_width
        # and stroke_opacity, chop it in half
        for key in style:
            if isinstance(style[key], numbers.Number):
                style[key] *= 0.5
        self.faded_line_style = style

    self.background_lines, self.faded_lines = self._get_lines()
    self.background_lines.set_style(
        **self.background_line_style,
    )
    self.faded_lines.set_style(
        **self.faded_line_style,
    )
    self.add_to_back(
        self.faded_lines,
        self.background_lines,
    )

</t>
<t tx="ekr.20250122151620.1353">def _get_lines(self) -&gt; tuple[VGroup, VGroup]:
    """Generate all the lines and circles, faded and not faded.

    Returns
    -------
    Tuple[:class:`~.VGroup`, :class:`~.VGroup`]
        The first (i.e the non faded lines and circles) and second (i.e the faded lines and circles) sets of lines and circles, respectively.
    """
    center = self.get_origin()
    ratio_faded_lines = self.faded_line_ratio
    offset = self.azimuth_offset

    if ratio_faded_lines == 0:  # don't show faded lines
        ratio_faded_lines = 1  # i.e. set ratio to 1
    rstep = (1 / ratio_faded_lines) * self.x_axis.x_range[2]
    astep = (1 / ratio_faded_lines) * (TAU * (1 / self.azimuth_step))
    rlines1 = VGroup()
    rlines2 = VGroup()
    alines1 = VGroup()
    alines2 = VGroup()

    rinput = np.arange(0, self.x_axis.x_range[1] + rstep, rstep)
    ainput = np.arange(0, TAU, astep)

    unit_vector = self.x_axis.get_unit_vector()[0]

    for k, x in enumerate(rinput):
        new_line = Circle(radius=x * unit_vector)
        if k % ratio_faded_lines == 0:
            alines1.add(new_line)
        else:
            alines2.add(new_line)

    line = Line(center, self.get_x_axis().get_end())

    for k, x in enumerate(ainput):
        new_line = line.copy()
        new_line.rotate(x + offset, about_point=center)
        if k % ratio_faded_lines == 0:
            rlines1.add(new_line)
        else:
            rlines2.add(new_line)

    lines1 = VGroup(*rlines1, *alines1)
    lines2 = VGroup(*rlines2, *alines2)
    return lines1, lines2

</t>
<t tx="ekr.20250122151620.1354">def get_axes(self) -&gt; VGroup:
    """Gets the axes.

    Returns
    -------
    :class:`~.VGroup`
        A pair of axes.
    """
    return self.axes

</t>
<t tx="ekr.20250122151620.1355">def get_vector(self, coords: Sequence[ManimFloat], **kwargs: Any) -&gt; Arrow:
    kwargs["buff"] = 0
    return Arrow(
        self.coords_to_point(0, 0), self.coords_to_point(*coords), **kwargs
    )

</t>
<t tx="ekr.20250122151620.1356">def prepare_for_nonlinear_transform(self, num_inserted_curves: int = 50) -&gt; Self:
    for mob in self.family_members_with_points():
        num_curves = mob.get_num_curves()
        if num_inserted_curves &gt; num_curves:
            mob.insert_n_curves(num_inserted_curves - num_curves)
    return self

</t>
<t tx="ekr.20250122151620.1357">def get_coordinate_labels(
    self,
    r_values: Iterable[float] | None = None,
    a_values: Iterable[float] | None = None,
    **kwargs: Any,
) -&gt; VDict:
    """Gets labels for the coordinates

    Parameters
    ----------
    r_values
        Iterable of values along the radius, by default None.
    a_values
        Iterable of values along the azimuth, by default None.

    Returns
    -------
    VDict
        Labels for the radius and azimuth values.
    """
    if r_values is None:
        r_values = [r for r in self.get_x_axis().get_tick_range() if r &gt;= 0]
    if a_values is None:
        a_values = np.arange(0, 1, 1 / self.azimuth_step)
    r_mobs = self.get_x_axis().add_numbers(r_values)
    if self.azimuth_direction == "CCW":
        d = 1
    elif self.azimuth_direction == "CW":
        d = -1
    else:
        raise ValueError("Invalid azimuth direction. Expected one of: CW, CCW")
    a_points = [
        {
            "label": i,
            "point": np.array(
                [
                    self.get_right()[0]
                    * np.cos(d * (i * TAU) + self.azimuth_offset),
                    self.get_right()[0]
                    * np.sin(d * (i * TAU) + self.azimuth_offset),
                    0,
                ],
            ),
        }
        for i in a_values
    ]
    if self.azimuth_units == "PI radians" or self.azimuth_units == "TAU radians":
        a_tex = [
            self.get_radian_label(
                i["label"],
                font_size=self.azimuth_label_font_size,
            ).next_to(
                i["point"],
                direction=i["point"],
                aligned_edge=i["point"],
                buff=self.azimuth_label_buff,
            )
            for i in a_points
        ]
    elif self.azimuth_units == "degrees":
        a_tex = [
            MathTex(
                f"{360 * i['label']:g}" + r"^{\circ}",
                font_size=self.azimuth_label_font_size,
            ).next_to(
                i["point"],
                direction=i["point"],
                aligned_edge=i["point"],
                buff=self.azimuth_label_buff,
            )
            for i in a_points
        ]
    elif self.azimuth_units == "gradians":
        a_tex = [
            MathTex(
                f"{400 * i['label']:g}" + r"^{g}",
                font_size=self.azimuth_label_font_size,
            ).next_to(
                i["point"],
                direction=i["point"],
                aligned_edge=i["point"],
                buff=self.azimuth_label_buff,
            )
            for i in a_points
        ]
    elif self.azimuth_units is None:
        a_tex = [
            MathTex(
                f"{i['label']:g}",
                font_size=self.azimuth_label_font_size,
            ).next_to(
                i["point"],
                direction=i["point"],
                aligned_edge=i["point"],
                buff=self.azimuth_label_buff,
            )
            for i in a_points
        ]
    a_mobs = VGroup(*a_tex)
    self.coordinate_labels = VGroup(r_mobs, a_mobs)
    return self.coordinate_labels

</t>
<t tx="ekr.20250122151620.1358">def add_coordinates(
    self,
    r_values: Iterable[float] | None = None,
    a_values: Iterable[float] | None = None,
) -&gt; Self:
    """Adds the coordinates.

    Parameters
    ----------
    r_values
        Iterable of values along the radius, by default None.
    a_values
        Iterable of values along the azimuth, by default None.
    """
    self.add(self.get_coordinate_labels(r_values, a_values))
    return self

</t>
<t tx="ekr.20250122151620.1359">def get_radian_label(self, number, font_size: float = 24, **kwargs: Any) -&gt; MathTex:
    constant_label = {"PI radians": r"\pi", "TAU radians": r"\tau"}[
        self.azimuth_units
    ]
    division = number * {"PI radians": 2, "TAU radians": 1}[self.azimuth_units]
    frac = fr.Fraction(division).limit_denominator(max_denominator=100)
    if frac.numerator == 0 &amp; frac.denominator == 0:
        string = r"0"
    elif frac.numerator == 1 and frac.denominator == 1:
        string = constant_label
    elif frac.numerator == 1:
        if self.azimuth_compact_fraction:
            string = (
                r"\tfrac{" + constant_label + r"}{" + str(frac.denominator) + "}"
            )
        else:
            string = r"\tfrac{1}{" + str(frac.denominator) + "}" + constant_label
    elif frac.denominator == 1:
        string = str(frac.numerator) + constant_label

    else:
        if self.azimuth_compact_fraction:
            string = (
                r"\tfrac{"
                + str(frac.numerator)
                + constant_label
                + r"}{"
                + str(frac.denominator)
                + r"}"
            )
        else:
            string = (
                r"\tfrac{"
                + str(frac.numerator)
                + r"}{"
                + str(frac.denominator)
                + r"}"
                + constant_label
            )

    return MathTex(string, font_size=font_size, **kwargs)


</t>
<t tx="ekr.20250122151620.136">@property
def quality(self) -&gt; str | None:
    """Video quality (-q)."""
    keys = ["pixel_width", "pixel_height", "frame_rate"]
    q = {k: self[k] for k in keys}
    for qual in constants.QUALITIES:
        if all(q[k] == constants.QUALITIES[qual][k] for k in keys):
            return qual
    return None

</t>
<t tx="ekr.20250122151620.1360">def __init__(self, **kwargs: Any) -&gt; None:
    super().__init__(
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.1361">def number_to_point(self, number: float | complex) -&gt; np.ndarray:
    """Accepts a float/complex number and returns the equivalent point on the plane.

    Parameters
    ----------
    number
        The number. Can be a float or a complex number.

    Returns
    -------
    np.ndarray
        The point on the plane.
    """
    number = complex(number)
    return self.coords_to_point(number.real, number.imag)

</t>
<t tx="ekr.20250122151620.1362">def n2p(self, number: float | complex) -&gt; np.ndarray:
    """Abbreviation for :meth:`number_to_point`."""
    return self.number_to_point(number)

</t>
<t tx="ekr.20250122151620.1363">def point_to_number(self, point: Point3DLike) -&gt; complex:
    """Accepts a point and returns a complex number equivalent to that point on the plane.

    Parameters
    ----------
    point
        The point in manim's coordinate-system

    Returns
    -------
    complex
        A complex number consisting of real and imaginary components.
    """
    x, y = self.point_to_coords(point)
    return complex(x, y)

</t>
<t tx="ekr.20250122151620.1364">def p2n(self, point: Point3DLike) -&gt; complex:
    """Abbreviation for :meth:`point_to_number`."""
    return self.point_to_number(point)

</t>
<t tx="ekr.20250122151620.1365">def _get_default_coordinate_values(self) -&gt; list[float | complex]:
    """Generate a list containing the numerical values of the plane's labels.

    Returns
    -------
    List[float | complex]
        A list of floats representing the x-axis and complex numbers representing the y-axis.
    """
    x_numbers = self.get_x_axis().get_tick_range()
    y_numbers = self.get_y_axis().get_tick_range()
    y_numbers = [complex(0, y) for y in y_numbers if y != 0]
    return [*x_numbers, *y_numbers]

</t>
<t tx="ekr.20250122151620.1366">def get_coordinate_labels(
    self, *numbers: Iterable[float | complex], **kwargs: Any
) -&gt; VGroup:
    """Generates the :class:`~.DecimalNumber` mobjects for the coordinates of the plane.

    Parameters
    ----------
    numbers
        An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.
    kwargs
        Additional arguments to be passed to :meth:`~.NumberLine.get_number_mobject`, i.e. :class:`~.DecimalNumber`.

    Returns
    -------
    :class:`~.VGroup`
        A :class:`~.VGroup` containing the positioned label mobjects.
    """
    # TODO: Make this work the same as coord_sys.add_coordinates()
    if len(numbers) == 0:
        numbers = self._get_default_coordinate_values()

    self.coordinate_labels = VGroup()
    for number in numbers:
        z = complex(number)
        if abs(z.imag) &gt; abs(z.real):
            axis = self.get_y_axis()
            value = z.imag
            kwargs["unit"] = "i"
        else:
            axis = self.get_x_axis()
            value = z.real
        number_mob = axis.get_number_mobject(value, **kwargs)
        self.coordinate_labels.add(number_mob)
    return self.coordinate_labels

</t>
<t tx="ekr.20250122151620.1367">def add_coordinates(
    self, *numbers: Iterable[float | complex], **kwargs: Any
) -&gt; Self:
    """Adds the labels produced from :meth:`~.NumberPlane.get_coordinate_labels` to the plane.

    Parameters
    ----------
    numbers
        An iterable of floats/complex numbers. Floats are positioned along the x-axis, complex numbers along the y-axis.
    kwargs
        Additional arguments to be passed to :meth:`~.NumberLine.get_number_mobject`, i.e. :class:`~.DecimalNumber`.
    """
    self.add(self.get_coordinate_labels(*numbers, **kwargs))
    return self
</t>
<t tx="ekr.20250122151620.1368">"""Mobjects representing function graphs."""

from __future__ import annotations

__all__ = ["ParametricFunction", "FunctionGraph", "ImplicitFunction"]


from collections.abc import Iterable, Sequence
from typing import TYPE_CHECKING, Callable

import numpy as np
from isosurfaces import plot_isoline

from manim import config
from manim.mobject.graphing.scale import LinearBase, _ScaleBase
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.types.vectorized_mobject import VMobject

if TYPE_CHECKING:
    from typing_extensions import Self

    from manim.typing import Point3D, Point3DLike

from manim.utils.color import YELLOW


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1369">class ParametricFunction(VMobject, metaclass=ConvertToOpenGL):
    """A parametric curve.

    Parameters
    ----------
    function
        The function to be plotted in the form of ``(lambda t: (x(t), y(t), z(t)))``
    t_range
        Determines the length that the function spans in the form of (t_min, t_max, step=0.01). By default ``[0, 1]``
    scaling
        Scaling class applied to the points of the function. Default of :class:`~.LinearBase`.
    use_smoothing
        Whether to interpolate between the points of the function after they have been created.
        (Will have odd behaviour with a low number of points)
    use_vectorized
        Whether to pass in the generated t value array to the function as ``[t_0, t_1, ...]``.
        Only use this if your function supports it. Output should be a numpy array
        of shape ``[[x_0, x_1, ...], [y_0, y_1, ...], [z_0, z_1, ...]]`` but ``z`` can
        also be 0 if the Axes is 2D
    discontinuities
        Values of t at which the function experiences discontinuity.
    dt
        The left and right tolerance for the discontinuities.


    Examples
    --------
    .. manim:: PlotParametricFunction
        :save_last_frame:

        class PlotParametricFunction(Scene):
            def func(self, t):
                return (np.sin(2 * t), np.sin(3 * t), 0)

            def construct(self):
                func = ParametricFunction(self.func, t_range = (0, TAU), fill_opacity=0).set_color(RED)
                self.add(func.scale(3))

    .. manim:: ThreeDParametricSpring
        :save_last_frame:

        class ThreeDParametricSpring(ThreeDScene):
            def construct(self):
                curve1 = ParametricFunction(
                    lambda u: (
                        1.2 * np.cos(u),
                        1.2 * np.sin(u),
                        u * 0.05
                    ), color=RED, t_range = (-3*TAU, 5*TAU, 0.01)
                ).set_shade_in_3d(True)
                axes = ThreeDAxes()
                self.add(axes, curve1)
                self.set_camera_orientation(phi=80 * DEGREES, theta=-60 * DEGREES)
                self.wait()

    .. attention::
        If your function has discontinuities, you'll have to specify the location
        of the discontinuities manually. See the following example for guidance.

    .. manim:: DiscontinuousExample
        :save_last_frame:

        class DiscontinuousExample(Scene):
            def construct(self):
                ax1 = NumberPlane((-3, 3), (-4, 4))
                ax2 = NumberPlane((-3, 3), (-4, 4))
                VGroup(ax1, ax2).arrange()
                discontinuous_function = lambda x: (x ** 2 - 2) / (x ** 2 - 4)
                incorrect = ax1.plot(discontinuous_function, color=RED)
                correct = ax2.plot(
                    discontinuous_function,
                    discontinuities=[-2, 2],  # discontinuous points
                    dt=0.1,  # left and right tolerance of discontinuity
                    color=GREEN,
                )
                self.add(ax1, ax2, incorrect, correct)
    """

    @others
    init_points = generate_points


</t>
<t tx="ekr.20250122151620.137">@quality.setter
def quality(self, value: str | None) -&gt; None:
    if value is None:
        return
    if value not in constants.QUALITIES:
        raise KeyError(f"quality must be one of {list(constants.QUALITIES.keys())}")
    q = constants.QUALITIES[value]
    self.frame_size = q["pixel_width"], q["pixel_height"]
    self.frame_rate = q["frame_rate"]

</t>
<t tx="ekr.20250122151620.1370">class FunctionGraph(ParametricFunction):
    """A :class:`ParametricFunction` that spans the length of the scene by default.

    Examples
    --------
    .. manim:: ExampleFunctionGraph
        :save_last_frame:

        class ExampleFunctionGraph(Scene):
            def construct(self):
                cos_func = FunctionGraph(
                    lambda t: np.cos(t) + 0.5 * np.cos(7 * t) + (1 / 7) * np.cos(14 * t),
                    color=RED,
                )

                sin_func_1 = FunctionGraph(
                    lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
                    color=BLUE,
                )

                sin_func_2 = FunctionGraph(
                    lambda t: np.sin(t) + 0.5 * np.sin(7 * t) + (1 / 7) * np.sin(14 * t),
                    x_range=[-4, 4],
                    color=GREEN,
                ).move_to([0, 1, 0])

                self.add(cos_func, sin_func_1, sin_func_2)
    """

    @others
</t>
<t tx="ekr.20250122151620.1371">class ImplicitFunction(VMobject, metaclass=ConvertToOpenGL):
    @others
    init_points = generate_points
</t>
<t tx="ekr.20250122151620.1372">def __init__(
    self,
    function: Callable[[float], Point3DLike],
    t_range: tuple[float, float] | tuple[float, float, float] = (0, 1),
    scaling: _ScaleBase = LinearBase(),
    dt: float = 1e-8,
    discontinuities: Iterable[float] | None = None,
    use_smoothing: bool = True,
    use_vectorized: bool = False,
    **kwargs,
</t>
<t tx="ekr.20250122151620.1373">):
    def internal_parametric_function(t: float) -&gt; Point3D:
        """Wrap ``function``'s output inside a NumPy array."""
        return np.asarray(function(t))

</t>
<t tx="ekr.20250122151620.1374">    self.function = internal_parametric_function
    if len(t_range) == 2:
        t_range = (*t_range, 0.01)

    self.scaling = scaling

    self.dt = dt
    self.discontinuities = discontinuities
    self.use_smoothing = use_smoothing
    self.use_vectorized = use_vectorized
    self.t_min, self.t_max, self.t_step = t_range

    super().__init__(**kwargs)

def get_function(self) -&gt; Callable[[float], Point3D]:
    return self.function

</t>
<t tx="ekr.20250122151620.1375">def get_point_from_function(self, t: float) -&gt; Point3D:
    return self.function(t)

</t>
<t tx="ekr.20250122151620.1376">def generate_points(self) -&gt; Self:
    if self.discontinuities is not None:
        discontinuities = filter(
            lambda t: self.t_min &lt;= t &lt;= self.t_max,
            self.discontinuities,
        )
        discontinuities = np.array(list(discontinuities))
        boundary_times = np.array(
            [
                self.t_min,
                self.t_max,
                *(discontinuities - self.dt),
                *(discontinuities + self.dt),
            ],
        )
        boundary_times.sort()
    else:
        boundary_times = [self.t_min, self.t_max]

    for t1, t2 in zip(boundary_times[0::2], boundary_times[1::2]):
        t_range = np.array(
            [
                *self.scaling.function(np.arange(t1, t2, self.t_step)),
                self.scaling.function(t2),
            ],
        )

        if self.use_vectorized:
            x, y, z = self.function(t_range)
            if not isinstance(z, np.ndarray):
                z = np.zeros_like(x)
            points = np.stack([x, y, z], axis=1)
        else:
            points = np.array([self.function(t) for t in t_range])

        self.start_new_path(points[0])
        self.add_points_as_corners(points[1:])
    if self.use_smoothing:
        # TODO: not in line with upstream, approx_smooth does not exist
        self.make_smooth()
    return self

</t>
<t tx="ekr.20250122151620.1377">def __init__(self, function, x_range=None, color=YELLOW, **kwargs):
    if x_range is None:
        x_range = np.array([-config["frame_x_radius"], config["frame_x_radius"]])

    self.x_range = x_range
    self.parametric_function = lambda t: np.array([t, function(t), 0])
    self.function = function
    super().__init__(self.parametric_function, self.x_range, color=color, **kwargs)

</t>
<t tx="ekr.20250122151620.1378">def get_function(self):
    return self.function

</t>
<t tx="ekr.20250122151620.1379">def get_point_from_function(self, x):
    return self.parametric_function(x)


</t>
<t tx="ekr.20250122151620.138">@property
def transparent(self) -&gt; bool:
    """Whether the background opacity is less than 1.0 (-t)."""
    return self._d["background_opacity"] &lt; 1.0

</t>
<t tx="ekr.20250122151620.1380">def __init__(
    self,
    func: Callable[[float, float], float],
    x_range: Sequence[float] | None = None,
    y_range: Sequence[float] | None = None,
    min_depth: int = 5,
    max_quads: int = 1500,
    use_smoothing: bool = True,
    **kwargs,
):
    """An implicit function.

    Parameters
    ----------
    func
        The implicit function in the form ``f(x, y) = 0``.
    x_range
        The x min and max of the function.
    y_range
        The y min and max of the function.
    min_depth
        The minimum depth of the function to calculate.
    max_quads
        The maximum number of quads to use.
    use_smoothing
        Whether or not to smoothen the curves.
    kwargs
        Additional parameters to pass into :class:`VMobject`


    .. note::
        A small ``min_depth`` :math:`d` means that some small details might
        be ignored if they don't cross an edge of one of the
        :math:`4^d` uniform quads.

        The value of ``max_quads`` strongly corresponds to the
        quality of the curve, but a higher number of quads
        may take longer to render.

    Examples
    --------
    .. manim:: ImplicitFunctionExample
        :save_last_frame:

        class ImplicitFunctionExample(Scene):
            def construct(self):
                graph = ImplicitFunction(
                    lambda x, y: x * y ** 2 - x ** 2 * y - 2,
                    color=YELLOW
                )
                self.add(NumberPlane(), graph)
    """
    self.function = func
    self.min_depth = min_depth
    self.max_quads = max_quads
    self.use_smoothing = use_smoothing
    self.x_range = x_range or [
        -config.frame_width / 2,
        config.frame_width / 2,
    ]
    self.y_range = y_range or [
        -config.frame_height / 2,
        config.frame_height / 2,
    ]

    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.1381">def generate_points(self):
    p_min, p_max = (
        np.array([self.x_range[0], self.y_range[0]]),
        np.array([self.x_range[1], self.y_range[1]]),
    )
    curves = plot_isoline(
        fn=lambda u: self.function(u[0], u[1]),
        pmin=p_min,
        pmax=p_max,
        min_depth=self.min_depth,
        max_quads=self.max_quads,
    )  # returns a list of lists of 2D points
    curves = [
        np.pad(curve, [(0, 0), (0, 1)]) for curve in curves if curve != []
    ]  # add z coord as 0
    for curve in curves:
        self.start_new_path(curve[0])
        self.add_points_as_corners(curve[1:])
    if self.use_smoothing:
        self.make_smooth()
    return self

</t>
<t tx="ekr.20250122151620.1382">"""Mobject representing a number line."""

from __future__ import annotations

from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject

__all__ = ["NumberLine", "UnitInterval"]


from collections.abc import Iterable, Sequence
from typing import TYPE_CHECKING, Callable

if TYPE_CHECKING:
    from manim.mobject.geometry.tips import ArrowTip
    from manim.typing import Point3DLike

import numpy as np

from manim import config
from manim.constants import *
from manim.mobject.geometry.line import Line
from manim.mobject.graphing.scale import LinearBase, _ScaleBase
from manim.mobject.text.numbers import DecimalNumber
from manim.mobject.text.tex_mobject import MathTex, Tex
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from manim.utils.bezier import interpolate
from manim.utils.config_ops import merge_dicts_recursively
from manim.utils.space_ops import normalize


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1383">class NumberLine(Line):
    """Creates a number line with tick marks.

    Parameters
    ----------
    x_range
        The ``[x_min, x_max, x_step]`` values to create the line.
    length
        The length of the number line.
    unit_size
        The distance between each tick of the line. Overwritten by :attr:`length`, if specified.
    include_ticks
        Whether to include ticks on the number line.
    tick_size
        The length of each tick mark.
    numbers_with_elongated_ticks
        An iterable of specific values with elongated ticks.
    longer_tick_multiple
        Influences how many times larger elongated ticks are than regular ticks (2 = 2x).
    rotation
        The angle (in radians) at which the line is rotated.
    stroke_width
        The thickness of the line.
    include_tip
        Whether to add a tip to the end of the line.
    tip_width
        The width of the tip.
    tip_height
        The height of the tip.
    tip_shape
        The mobject class used to construct the tip, or ``None`` (the
        default) for the default arrow tip. Passed classes have to inherit
        from :class:`.ArrowTip`.
    include_numbers
        Whether to add numbers to the tick marks. The number of decimal places is determined
        by the step size, this default can be overridden by ``decimal_number_config``.
    scaling
        The way the ``x_range`` is value is scaled, i.e. :class:`~.LogBase` for a logarithmic numberline. Defaults to :class:`~.LinearBase`.
    font_size
        The size of the label mobjects. Defaults to 36.
    label_direction
        The specific position to which label mobjects are added on the line.
    label_constructor
        Determines the mobject class that will be used to construct the labels of the number line.
    line_to_number_buff
        The distance between the line and the label mobject.
    decimal_number_config
        Arguments that can be passed to :class:`~.numbers.DecimalNumber` to influence number mobjects.
    numbers_to_exclude
        An explicit iterable of numbers to not be added to the number line.
    numbers_to_include
        An explicit iterable of numbers to add to the number line
    kwargs
        Additional arguments to be passed to :class:`~.Line`.


    .. note::

        Number ranges that include both negative and positive values will be generated
        from the 0 point, and may not include a tick at the min / max
        values as the tick locations are dependent on the step size.

    Examples
    --------
    .. manim:: NumberLineExample
        :save_last_frame:

        class NumberLineExample(Scene):
            def construct(self):
                l0 = NumberLine(
                    x_range=[-10, 10, 2],
                    length=10,
                    color=BLUE,
                    include_numbers=True,
                    label_direction=UP,
                )

                l1 = NumberLine(
                    x_range=[-10, 10, 2],
                    unit_size=0.5,
                    numbers_with_elongated_ticks=[-2, 4],
                    include_numbers=True,
                    font_size=24,
                )
                num6 = l1.numbers[8]
                num6.set_color(RED)

                l2 = NumberLine(
                    x_range=[-2.5, 2.5 + 0.5, 0.5],
                    length=12,
                    decimal_number_config={"num_decimal_places": 2},
                    include_numbers=True,
                )

                l3 = NumberLine(
                    x_range=[-5, 5 + 1, 1],
                    length=6,
                    include_tip=True,
                    include_numbers=True,
                    rotation=10 * DEGREES,
                )

                line_group = VGroup(l0, l1, l2, l3).arrange(DOWN, buff=1)
                self.add(line_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.1384">class UnitInterval(NumberLine):
    @others
</t>
<t tx="ekr.20250122151620.1385">def __init__(
    self,
    x_range: Sequence[float] | None = None,  # must be first
    length: float | None = None,
    unit_size: float = 1,
    # ticks
    include_ticks: bool = True,
    tick_size: float = 0.1,
    numbers_with_elongated_ticks: Iterable[float] | None = None,
    longer_tick_multiple: int = 2,
    exclude_origin_tick: bool = False,
    # visuals
    rotation: float = 0,
    stroke_width: float = 2.0,
    # tip
    include_tip: bool = False,
    tip_width: float = DEFAULT_ARROW_TIP_LENGTH,
    tip_height: float = DEFAULT_ARROW_TIP_LENGTH,
    tip_shape: type[ArrowTip] | None = None,
    # numbers/labels
    include_numbers: bool = False,
    font_size: float = 36,
    label_direction: Sequence[float] = DOWN,
    label_constructor: VMobject = MathTex,
    scaling: _ScaleBase = LinearBase(),
    line_to_number_buff: float = MED_SMALL_BUFF,
    decimal_number_config: dict | None = None,
    numbers_to_exclude: Iterable[float] | None = None,
    numbers_to_include: Iterable[float] | None = None,
    **kwargs,
</t>
<t tx="ekr.20250122151620.1386">):
    # avoid mutable arguments in defaults
    if numbers_to_exclude is None:
        numbers_to_exclude = []
    if numbers_with_elongated_ticks is None:
        numbers_with_elongated_ticks = []

    if x_range is None:
        x_range = [
            round(-config["frame_x_radius"]),
            round(config["frame_x_radius"]),
            1,
        ]
    elif len(x_range) == 2:
        # adds x_step if not specified. not sure how to feel about this. a user can't know default without peeking at source code
        x_range = [*x_range, 1]

    if decimal_number_config is None:
        decimal_number_config = {
            "num_decimal_places": self._decimal_places_from_step(x_range[2]),
        }

    # turn into a NumPy array to scale by just applying the function
    self.x_range = np.array(x_range, dtype=float)
    self.x_min, self.x_max, self.x_step = scaling.function(self.x_range)
    self.length = length
    self.unit_size = unit_size
    # ticks
    self.include_ticks = include_ticks
    self.tick_size = tick_size
    self.numbers_with_elongated_ticks = numbers_with_elongated_ticks
    self.longer_tick_multiple = longer_tick_multiple
    self.exclude_origin_tick = exclude_origin_tick
    # visuals
    self.rotation = rotation
    # tip
    self.include_tip = include_tip
    self.tip_width = tip_width
    self.tip_height = tip_height
    # numbers
    self.font_size = font_size
    self.include_numbers = include_numbers
    self.label_direction = label_direction
    self.label_constructor = label_constructor
    self.line_to_number_buff = line_to_number_buff
    self.decimal_number_config = decimal_number_config
    self.numbers_to_exclude = numbers_to_exclude
    self.numbers_to_include = numbers_to_include

    self.scaling = scaling
    super().__init__(
        self.x_range[0] * RIGHT,
        self.x_range[1] * RIGHT,
        stroke_width=stroke_width,
        **kwargs,
    )

    if self.length:
        self.set_length(self.length)
        self.unit_size = self.get_unit_size()
    else:
        self.scale(self.unit_size)

    self.center()

    if self.include_tip:
        self.add_tip(
            tip_length=self.tip_height,
            tip_width=self.tip_width,
            tip_shape=tip_shape,
        )
        self.tip.set_stroke(self.stroke_color, self.stroke_width)

    if self.include_ticks:
        self.add_ticks()

    self.rotate(self.rotation)
    if self.include_numbers or self.numbers_to_include is not None:
        if self.scaling.custom_labels:
            tick_range = self.get_tick_range()

            self.add_labels(
                dict(
                    zip(
                        tick_range,
                        self.scaling.get_custom_labels(
                            tick_range,
                            unit_decimal_places=decimal_number_config[
                                "num_decimal_places"
                            ],
                        ),
                    )
                ),
            )

        else:
            self.add_numbers(
                x_values=self.numbers_to_include,
                excluding=self.numbers_to_exclude,
                font_size=self.font_size,
            )

def rotate_about_zero(self, angle: float, axis: Sequence[float] = OUT, **kwargs):
    return self.rotate_about_number(0, angle, axis, **kwargs)

</t>
<t tx="ekr.20250122151620.1387">def rotate_about_number(
    self, number: float, angle: float, axis: Sequence[float] = OUT, **kwargs
):
    return self.rotate(angle, axis, about_point=self.n2p(number), **kwargs)

</t>
<t tx="ekr.20250122151620.1388">def add_ticks(self):
    """Adds ticks to the number line. Ticks can be accessed after creation
    via ``self.ticks``.
    """
    ticks = VGroup()
    elongated_tick_size = self.tick_size * self.longer_tick_multiple
    elongated_tick_offsets = self.numbers_with_elongated_ticks - self.x_min
    for x in self.get_tick_range():
        size = self.tick_size
        if np.any(np.isclose(x - self.x_min, elongated_tick_offsets)):
            size = elongated_tick_size
        ticks.add(self.get_tick(x, size))
    self.add(ticks)
    self.ticks = ticks

</t>
<t tx="ekr.20250122151620.1389">def get_tick(self, x: float, size: float | None = None) -&gt; Line:
    """Generates a tick and positions it along the number line.

    Parameters
    ----------
    x
        The position of the tick.
    size
        The factor by which the tick is scaled.

    Returns
    -------
    :class:`~.Line`
        A positioned tick.
    """
    if size is None:
        size = self.tick_size
    result = Line(size * DOWN, size * UP)
    result.rotate(self.get_angle())
    result.move_to(self.number_to_point(x))
    result.match_style(self)
    return result

</t>
<t tx="ekr.20250122151620.139">@transparent.setter
def transparent(self, value: bool) -&gt; None:
    self._d["background_opacity"] = float(not value)
    self.resolve_movie_file_extension(value)

</t>
<t tx="ekr.20250122151620.1390">def get_tick_marks(self) -&gt; VGroup:
    return self.ticks

</t>
<t tx="ekr.20250122151620.1391">def get_tick_range(self) -&gt; np.ndarray:
    """Generates the range of values on which labels are plotted based on the
    ``x_range`` attribute of the number line.

    Returns
    -------
    np.ndarray
        A numpy array of floats represnting values along the number line.
    """
    x_min, x_max, x_step = self.x_range
    if not self.include_tip:
        x_max += 1e-6

    # Handle cases where min and max are both positive or both negative
    if x_min &lt; x_max &lt; 0 or x_max &gt; x_min &gt; 0:
        tick_range = np.arange(x_min, x_max, x_step)
    else:
        start_point = 0
        if self.exclude_origin_tick:
            start_point += x_step

        x_min_segment = np.arange(start_point, np.abs(x_min) + 1e-6, x_step) * -1
        x_max_segment = np.arange(start_point, x_max, x_step)

        tick_range = np.unique(np.concatenate((x_min_segment, x_max_segment)))

    return self.scaling.function(tick_range)

</t>
<t tx="ekr.20250122151620.1392">def number_to_point(self, number: float | np.ndarray) -&gt; np.ndarray:
    """Accepts a value along the number line and returns a point with
    respect to the scene.
    Equivalent to `NumberLine @ number`

    Parameters
    ----------
    number
        The value to be transformed into a coordinate. Or a list of values.

    Returns
    -------
    np.ndarray
        A point with respect to the scene's coordinate system. Or a list of points.

    Examples
    --------

        &gt;&gt;&gt; from manim import NumberLine
        &gt;&gt;&gt; number_line = NumberLine()
        &gt;&gt;&gt; number_line.number_to_point(0)
        array([0., 0., 0.])
        &gt;&gt;&gt; number_line.number_to_point(1)
        array([1., 0., 0.])
        &gt;&gt;&gt; number_line @ 1
        array([1., 0., 0.])
        &gt;&gt;&gt; number_line.number_to_point([1, 2, 3])
        array([[1., 0., 0.],
               [2., 0., 0.],
               [3., 0., 0.]])
    """
    number = np.asarray(number)
    scalar = number.ndim == 0
    number = self.scaling.inverse_function(number)
    alphas = (number - self.x_range[0]) / (self.x_range[1] - self.x_range[0])
    alphas = float(alphas) if scalar else np.vstack(alphas)
    val = interpolate(self.get_start(), self.get_end(), alphas)
    return val

</t>
<t tx="ekr.20250122151620.1393">def point_to_number(self, point: Sequence[float]) -&gt; float:
    """Accepts a point with respect to the scene and returns
    a float along the number line.

    Parameters
    ----------
    point
        A sequence of values consisting of ``(x_coord, y_coord, z_coord)``.

    Returns
    -------
    float
        A float representing a value along the number line.

    Examples
    --------

        &gt;&gt;&gt; from manim import NumberLine
        &gt;&gt;&gt; number_line = NumberLine()
        &gt;&gt;&gt; number_line.point_to_number((0, 0, 0))
        np.float64(0.0)
        &gt;&gt;&gt; number_line.point_to_number((1, 0, 0))
        np.float64(1.0)
        &gt;&gt;&gt; number_line.point_to_number([[0.5, 0, 0], [1, 0, 0], [1.5, 0, 0]])
        array([0.5, 1. , 1.5])

    """
    point = np.asarray(point)
    start, end = self.get_start_and_end()
    unit_vect = normalize(end - start)
    proportion = np.dot(point - start, unit_vect) / np.dot(end - start, unit_vect)
    return interpolate(self.x_min, self.x_max, proportion)

</t>
<t tx="ekr.20250122151620.1394">def n2p(self, number: float | np.ndarray) -&gt; np.ndarray:
    """Abbreviation for :meth:`~.NumberLine.number_to_point`."""
    return self.number_to_point(number)

</t>
<t tx="ekr.20250122151620.1395">def p2n(self, point: Sequence[float]) -&gt; float:
    """Abbreviation for :meth:`~.NumberLine.point_to_number`."""
    return self.point_to_number(point)

</t>
<t tx="ekr.20250122151620.1396">def get_unit_size(self) -&gt; float:
    return self.get_length() / (self.x_range[1] - self.x_range[0])

</t>
<t tx="ekr.20250122151620.1397">def get_unit_vector(self) -&gt; np.ndarray:
    return super().get_unit_vector() * self.unit_size

</t>
<t tx="ekr.20250122151620.1398">def get_number_mobject(
    self,
    x: float,
    direction: Sequence[float] | None = None,
    buff: float | None = None,
    font_size: float | None = None,
    label_constructor: VMobject | None = None,
    **number_config,
) -&gt; VMobject:
    """Generates a positioned :class:`~.DecimalNumber` mobject
    generated according to ``label_constructor``.

    Parameters
    ----------
    x
        The x-value at which the mobject should be positioned.
    direction
        Determines the direction at which the label is positioned next to the line.
    buff
        The distance of the label from the line.
    font_size
        The font size of the label mobject.
    label_constructor
        The :class:`~.VMobject` class that will be used to construct the label.
        Defaults to the ``label_constructor`` attribute of the number line
        if not specified.

    Returns
    -------
    :class:`~.DecimalNumber`
        The positioned mobject.
    """
    number_config = merge_dicts_recursively(
        self.decimal_number_config,
        number_config,
    )
    if direction is None:
        direction = self.label_direction
    if buff is None:
        buff = self.line_to_number_buff
    if font_size is None:
        font_size = self.font_size
    if label_constructor is None:
        label_constructor = self.label_constructor

    num_mob = DecimalNumber(
        x, font_size=font_size, mob_class=label_constructor, **number_config
    )

    num_mob.next_to(self.number_to_point(x), direction=direction, buff=buff)
    if x &lt; 0 and self.label_direction[0] == 0:
        # Align without the minus sign
        num_mob.shift(num_mob[0].width * LEFT / 2)
    return num_mob

</t>
<t tx="ekr.20250122151620.1399">def get_number_mobjects(self, *numbers, **kwargs) -&gt; VGroup:
    if len(numbers) == 0:
        numbers = self.default_numbers_to_display()
    return VGroup([self.get_number_mobject(number, **kwargs) for number in numbers])

</t>
<t tx="ekr.20250122151620.14"></t>
<t tx="ekr.20250122151620.140">@property
def dry_run(self) -&gt; bool:
    """Whether dry run is enabled."""
    return self._d["dry_run"]

</t>
<t tx="ekr.20250122151620.1400">def get_labels(self) -&gt; VGroup:
    return self.get_number_mobjects()

</t>
<t tx="ekr.20250122151620.1401">def add_numbers(
    self,
    x_values: Iterable[float] | None = None,
    excluding: Iterable[float] | None = None,
    font_size: float | None = None,
    label_constructor: VMobject | None = None,
    **kwargs,
):
    """Adds :class:`~.DecimalNumber` mobjects representing their position
    at each tick of the number line. The numbers can be accessed after creation
    via ``self.numbers``.

    Parameters
    ----------
    x_values
        An iterable of the values used to position and create the labels.
        Defaults to the output produced by :meth:`~.NumberLine.get_tick_range`
    excluding
        A list of values to exclude from :attr:`x_values`.
    font_size
        The font size of the labels. Defaults to the ``font_size`` attribute
        of the number line.
    label_constructor
        The :class:`~.VMobject` class that will be used to construct the label.
        Defaults to the ``label_constructor`` attribute of the number line
        if not specified.
    """
    if x_values is None:
        x_values = self.get_tick_range()

    if excluding is None:
        excluding = self.numbers_to_exclude

    if font_size is None:
        font_size = self.font_size

    if label_constructor is None:
        label_constructor = self.label_constructor

    numbers = VGroup()
    for x in x_values:
        if x in excluding:
            continue
        numbers.add(
            self.get_number_mobject(
                x,
                font_size=font_size,
                label_constructor=label_constructor,
                **kwargs,
            )
        )
    self.add(numbers)
    self.numbers = numbers
    return self

</t>
<t tx="ekr.20250122151620.1402">def add_labels(
    self,
    dict_values: dict[float, str | float | VMobject],
    direction: Sequence[float] = None,
    buff: float | None = None,
    font_size: float | None = None,
    label_constructor: VMobject | None = None,
):
    """Adds specifically positioned labels to the :class:`~.NumberLine` using a ``dict``.
    The labels can be accessed after creation via ``self.labels``.

    Parameters
    ----------
    dict_values
        A dictionary consisting of the position along the number line and the mobject to be added:
        ``{1: Tex("Monday"), 3: Tex("Tuesday")}``. :attr:`label_constructor` will be used
        to construct the labels if the value is not a mobject (``str`` or ``float``).
    direction
        Determines the direction at which the label is positioned next to the line.
    buff
        The distance of the label from the line.
    font_size
        The font size of the mobject to be positioned.
    label_constructor
        The :class:`~.VMobject` class that will be used to construct the label.
        Defaults to the ``label_constructor`` attribute of the number line
        if not specified.

    Raises
    ------
    AttributeError
        If the label does not have a ``font_size`` attribute, an ``AttributeError`` is raised.
    """
    direction = self.label_direction if direction is None else direction
    buff = self.line_to_number_buff if buff is None else buff
    font_size = self.font_size if font_size is None else font_size
    if label_constructor is None:
        label_constructor = self.label_constructor

    labels = VGroup()
    for x, label in dict_values.items():
        # TODO: remove this check and ability to call
        # this method via CoordinateSystem.add_coordinates()
        # must be explicitly called
        if isinstance(label, str) and label_constructor is MathTex:
            label = Tex(label)
        else:
            label = self._create_label_tex(label, label_constructor)

        if hasattr(label, "font_size"):
            label.font_size = font_size
        else:
            raise AttributeError(f"{label} is not compatible with add_labels.")
        label.next_to(self.number_to_point(x), direction=direction, buff=buff)
        labels.add(label)

    self.labels = labels
    self.add(labels)
    return self

</t>
<t tx="ekr.20250122151620.1403">def _create_label_tex(
    self,
    label_tex: str | float | VMobject,
    label_constructor: Callable | None = None,
    **kwargs,
) -&gt; VMobject:
    """Checks if the label is a :class:`~.VMobject`, otherwise, creates a
    label by passing ``label_tex`` to ``label_constructor``.

    Parameters
    ----------
    label_tex
        The label for which a mobject should be created. If the label already
        is a mobject, no new mobject is created.
    label_constructor
        Optional. A class or function returning a mobject when
        passing ``label_tex`` as an argument. If ``None`` is passed
        (the default), the label constructor from the :attr:`.label_constructor`
        attribute is used.

    Returns
    -------
    :class:`~.VMobject`
        The label.
    """
    if label_constructor is None:
        label_constructor = self.label_constructor
    if isinstance(label_tex, (VMobject, OpenGLVMobject)):
        return label_tex
    else:
        return label_constructor(label_tex, **kwargs)

</t>
<t tx="ekr.20250122151620.1404">@staticmethod
def _decimal_places_from_step(step) -&gt; int:
    step = str(step)
    if "." not in step:
        return 0
    return len(step.split(".")[-1])

</t>
<t tx="ekr.20250122151620.1405">def __matmul__(self, other: float):
    return self.n2p(other)

</t>
<t tx="ekr.20250122151620.1406">def __rmatmul__(self, other: Point3DLike | Mobject):
    if isinstance(other, Mobject):
        other = other.get_center()
    return self.p2n(other)


</t>
<t tx="ekr.20250122151620.1407">def __init__(
    self,
    unit_size=10,
    numbers_with_elongated_ticks=None,
    decimal_number_config=None,
    **kwargs,
):
    numbers_with_elongated_ticks = (
        [0, 1]
        if numbers_with_elongated_ticks is None
        else numbers_with_elongated_ticks
    )

    decimal_number_config = (
        {
            "num_decimal_places": 1,
        }
        if decimal_number_config is None
        else decimal_number_config
    )

    super().__init__(
        x_range=(0, 1, 0.1),
        unit_size=unit_size,
        numbers_with_elongated_ticks=numbers_with_elongated_ticks,
        decimal_number_config=decimal_number_config,
        **kwargs,
    )
</t>
<t tx="ekr.20250122151620.1408">"""Mobjects representing objects from probability theory and statistics."""

from __future__ import annotations

__all__ = ["SampleSpace", "BarChart"]


from collections.abc import Iterable, MutableSequence, Sequence

import numpy as np

from manim import config, logger
from manim.constants import *
from manim.mobject.geometry.polygram import Rectangle
from manim.mobject.graphing.coordinate_systems import Axes
from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.mobject.svg.brace import Brace
from manim.mobject.text.tex_mobject import MathTex, Tex
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from manim.utils.color import (
    BLUE_E,
    DARK_GREY,
    GREEN_E,
    LIGHT_GREY,
    MAROON_B,
    YELLOW,
    ParsableManimColor,
    color_gradient,
)
from manim.utils.iterables import tuplify

EPSILON = 0.0001


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1409">class SampleSpace(Rectangle):
    """A mobject representing a twodimensional rectangular
    sampling space.

    Examples
    --------
    .. manim:: ExampleSampleSpace
        :save_last_frame:

        class ExampleSampleSpace(Scene):
            def construct(self):
                poly1 = SampleSpace(stroke_width=15, fill_opacity=1)
                poly2 = SampleSpace(width=5, height=3, stroke_width=5, fill_opacity=0.5)
                poly3 = SampleSpace(width=2, height=2, stroke_width=5, fill_opacity=0.1)
                poly3.divide_vertically(p_list=np.array([0.37, 0.13, 0.5]), colors=[BLACK, WHITE, GRAY], vect=RIGHT)
                poly_group = VGroup(poly1, poly2, poly3).arrange()
                self.add(poly_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.141">@dry_run.setter
def dry_run(self, val: bool) -&gt; None:
    self._d["dry_run"] = val
    if val:
        self.write_to_movie = False
        self.write_all = False
        self.save_last_frame = False
        self.format = None

</t>
<t tx="ekr.20250122151620.1410">class BarChart(Axes):
    """Creates a bar chart. Inherits from :class:`~.Axes`, so it shares its methods
    and attributes. Each axis inherits from :class:`~.NumberLine`, so pass in ``x_axis_config``/``y_axis_config``
    to control their attributes.

    Parameters
    ----------
    values
        A sequence of values that determines the height of each bar. Accepts negative values.
    bar_names
        A sequence of names for each bar. Does not have to match the length of ``values``.
    y_range
        The y_axis range of values. If ``None``, the range will be calculated based on the
        min/max of ``values`` and the step will be calculated based on ``y_length``.
    x_length
        The length of the x-axis. If ``None``, it is automatically calculated based on
        the number of values and the width of the screen.
    y_length
        The length of the y-axis.
    bar_colors
        The color for the bars. Accepts a sequence of colors (can contain just one item).
        If the length of``bar_colors`` does not match that of ``values``,
        intermediate colors will be automatically determined.
    bar_width
        The length of a bar. Must be between 0 and 1.
    bar_fill_opacity
        The fill opacity of the bars.
    bar_stroke_width
        The stroke width of the bars.

    Examples
    --------
    .. manim:: BarChartExample
        :save_last_frame:

        class BarChartExample(Scene):
            def construct(self):
                chart = BarChart(
                    values=[-5, 40, -10, 20, -3],
                    bar_names=["one", "two", "three", "four", "five"],
                    y_range=[-20, 50, 10],
                    y_length=6,
                    x_length=10,
                    x_axis_config={"font_size": 36},
                )

                c_bar_lbls = chart.get_bar_labels(font_size=48)

                self.add(chart, c_bar_lbls)
    """

    @others
</t>
<t tx="ekr.20250122151620.1411">def __init__(
    self,
    height=3,
    width=3,
    fill_color=DARK_GREY,
    fill_opacity=1,
    stroke_width=0.5,
    stroke_color=LIGHT_GREY,
    default_label_scale_val=1,
):
    super().__init__(
        height=height,
        width=width,
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        stroke_color=stroke_color,
    )
    self.default_label_scale_val = default_label_scale_val

</t>
<t tx="ekr.20250122151620.1412">def add_title(self, title="Sample space", buff=MED_SMALL_BUFF):
    # TODO, should this really exist in SampleSpaceScene
    title_mob = Tex(title)
    if title_mob.width &gt; self.width:
        title_mob.width = self.width
    title_mob.next_to(self, UP, buff=buff)
    self.title = title_mob
    self.add(title_mob)

</t>
<t tx="ekr.20250122151620.1413">def add_label(self, label):
    self.label = label

</t>
<t tx="ekr.20250122151620.1414">def complete_p_list(self, p_list):
    new_p_list = list(tuplify(p_list))
    remainder = 1.0 - sum(new_p_list)
    if abs(remainder) &gt; EPSILON:
        new_p_list.append(remainder)
    return new_p_list

</t>
<t tx="ekr.20250122151620.1415">def get_division_along_dimension(self, p_list, dim, colors, vect):
    p_list = self.complete_p_list(p_list)
    colors = color_gradient(colors, len(p_list))

    last_point = self.get_edge_center(-vect)
    parts = VGroup()
    for factor, color in zip(p_list, colors):
        part = SampleSpace()
        part.set_fill(color, 1)
        part.replace(self, stretch=True)
        part.stretch(factor, dim)
        part.move_to(last_point, -vect)
        last_point = part.get_edge_center(vect)
        parts.add(part)
    return parts

</t>
<t tx="ekr.20250122151620.1416">def get_horizontal_division(self, p_list, colors=[GREEN_E, BLUE_E], vect=DOWN):
    return self.get_division_along_dimension(p_list, 1, colors, vect)

</t>
<t tx="ekr.20250122151620.1417">def get_vertical_division(self, p_list, colors=[MAROON_B, YELLOW], vect=RIGHT):
    return self.get_division_along_dimension(p_list, 0, colors, vect)

</t>
<t tx="ekr.20250122151620.1418">def divide_horizontally(self, *args, **kwargs):
    self.horizontal_parts = self.get_horizontal_division(*args, **kwargs)
    self.add(self.horizontal_parts)

</t>
<t tx="ekr.20250122151620.1419">def divide_vertically(self, *args, **kwargs):
    self.vertical_parts = self.get_vertical_division(*args, **kwargs)
    self.add(self.vertical_parts)

</t>
<t tx="ekr.20250122151620.142">@property
def renderer(self) -&gt; RendererType:
    """The currently active renderer.

    Populated with one of the available renderers in :class:`.RendererType`.

    Tests::

        &gt;&gt;&gt; test_config = ManimConfig()
        &gt;&gt;&gt; test_config.renderer is None  # a new ManimConfig is unpopulated
        True
        &gt;&gt;&gt; test_config.renderer = 'opengl'
        &gt;&gt;&gt; test_config.renderer
        &lt;RendererType.OPENGL: 'opengl'&gt;
        &gt;&gt;&gt; test_config.renderer = 42
        Traceback (most recent call last):
        ...
        ValueError: 42 is not a valid RendererType

    Check that capitalization of renderer types is irrelevant::

        &gt;&gt;&gt; test_config.renderer = 'OpenGL'
        &gt;&gt;&gt; test_config.renderer = 'cAirO'
    """
    return self._d["renderer"]

</t>
<t tx="ekr.20250122151620.1420">def get_subdivision_braces_and_labels(
    self,
    parts,
    labels,
    direction,
    buff=SMALL_BUFF,
    min_num_quads=1,
):
    label_mobs = VGroup()
    braces = VGroup()
    for label, part in zip(labels, parts):
        brace = Brace(part, direction, min_num_quads=min_num_quads, buff=buff)
        if isinstance(label, (Mobject, OpenGLMobject)):
            label_mob = label
        else:
            label_mob = MathTex(label)
            label_mob.scale(self.default_label_scale_val)
        label_mob.next_to(brace, direction, buff)

        braces.add(brace)
        label_mobs.add(label_mob)
    parts.braces = braces
    parts.labels = label_mobs
    parts.label_kwargs = {
        "labels": label_mobs.copy(),
        "direction": direction,
        "buff": buff,
    }
    return VGroup(parts.braces, parts.labels)

</t>
<t tx="ekr.20250122151620.1421">def get_side_braces_and_labels(self, labels, direction=LEFT, **kwargs):
    assert hasattr(self, "horizontal_parts")
    parts = self.horizontal_parts
    return self.get_subdivision_braces_and_labels(
        parts, labels, direction, **kwargs
    )

</t>
<t tx="ekr.20250122151620.1422">def get_top_braces_and_labels(self, labels, **kwargs):
    assert hasattr(self, "vertical_parts")
    parts = self.vertical_parts
    return self.get_subdivision_braces_and_labels(parts, labels, UP, **kwargs)

</t>
<t tx="ekr.20250122151620.1423">def get_bottom_braces_and_labels(self, labels, **kwargs):
    assert hasattr(self, "vertical_parts")
    parts = self.vertical_parts
    return self.get_subdivision_braces_and_labels(parts, labels, DOWN, **kwargs)

</t>
<t tx="ekr.20250122151620.1424">def add_braces_and_labels(self):
    for attr in "horizontal_parts", "vertical_parts":
        if not hasattr(self, attr):
            continue
        parts = getattr(self, attr)
        for subattr in "braces", "labels":
            if hasattr(parts, subattr):
                self.add(getattr(parts, subattr))

</t>
<t tx="ekr.20250122151620.1425">def __getitem__(self, index):
    if hasattr(self, "horizontal_parts"):
        return self.horizontal_parts[index]
    elif hasattr(self, "vertical_parts"):
        return self.vertical_parts[index]
    return self.split()[index]


</t>
<t tx="ekr.20250122151620.1426">def __init__(
    self,
    values: MutableSequence[float],
    bar_names: Sequence[str] | None = None,
    y_range: Sequence[float] | None = None,
    x_length: float | None = None,
    y_length: float | None = None,
    bar_colors: Iterable[str] = [
        "#003f5c",
        "#58508d",
        "#bc5090",
        "#ff6361",
        "#ffa600",
    ],
    bar_width: float = 0.6,
    bar_fill_opacity: float = 0.7,
    bar_stroke_width: float = 3,
    **kwargs,
):
    if isinstance(bar_colors, str):
        logger.warning(
            "Passing a string to `bar_colors` has been deprecated since v0.15.2 and will be removed after v0.17.0, the parameter must be a list.  "
        )
        bar_colors = list(bar_colors)

    y_length = y_length if y_length is not None else config.frame_height - 4

    self.values = values
    self.bar_names = bar_names
    self.bar_colors = bar_colors
    self.bar_width = bar_width
    self.bar_fill_opacity = bar_fill_opacity
    self.bar_stroke_width = bar_stroke_width

    x_range = [0, len(self.values), 1]

    if y_range is None:
        y_range = [
            min(0, min(self.values)),
            max(0, max(self.values)),
            round(max(self.values) / y_length, 2),
        ]

    elif len(y_range) == 2:
        y_range = [*y_range, round(max(self.values) / y_length, 2)]

    if x_length is None:
        x_length = min(len(self.values), config.frame_width - 2)

    x_axis_config = {"font_size": 24, "label_constructor": Tex}
    self._update_default_configs(
        (x_axis_config,), (kwargs.pop("x_axis_config", None),)
    )

    self.bars: VGroup = VGroup()
    self.x_labels: VGroup | None = None
    self.bar_labels: VGroup | None = None

    super().__init__(
        x_range=x_range,
        y_range=y_range,
        x_length=x_length,
        y_length=y_length,
        x_axis_config=x_axis_config,
        tips=kwargs.pop("tips", False),
        **kwargs,
    )

    self._add_bars()

    if self.bar_names is not None:
        self._add_x_axis_labels()

    self.y_axis.add_numbers()

</t>
<t tx="ekr.20250122151620.1427">def _update_colors(self):
    """Initialize the colors of the bars of the chart.

    Sets the color of ``self.bars`` via ``self.bar_colors``.

    Primarily used when the bars are initialized with ``self._add_bars``
    or updated via ``self.change_bar_values``.
    """
    self.bars.set_color_by_gradient(*self.bar_colors)

</t>
<t tx="ekr.20250122151620.1428">def _add_x_axis_labels(self):
    """Essentially :meth`:~.NumberLine.add_labels`, but differs in that
    the direction of the label with respect to the x_axis changes to UP or DOWN
    depending on the value.

    UP for negative values and DOWN for positive values.
    """
    val_range = np.arange(
        0.5, len(self.bar_names), 1
    )  # 0.5 shifted so that labels are centered, not on ticks

    labels = VGroup()

    for i, (value, bar_name) in enumerate(zip(val_range, self.bar_names)):
        # to accommodate negative bars, the label may need to be
        # below or above the x_axis depending on the value of the bar
        direction = UP if self.values[i] &lt; 0 else DOWN
        bar_name_label = self.x_axis.label_constructor(bar_name)

        bar_name_label.font_size = self.x_axis.font_size
        bar_name_label.next_to(
            self.x_axis.number_to_point(value),
            direction=direction,
            buff=self.x_axis.line_to_number_buff,
        )

        labels.add(bar_name_label)

    self.x_axis.labels = labels
    self.x_axis.add(labels)

</t>
<t tx="ekr.20250122151620.1429">def _create_bar(self, bar_number: int, value: float) -&gt; Rectangle:
    """Creates a positioned bar on the chart.

    Parameters
    ----------
    bar_number
        Determines the x-position of the bar.
    value
        The value that determines the height of the bar.

    Returns
    -------
    Rectangle
        A positioned rectangle representing a bar on the chart.
    """
    # bar measurements relative to the axis

    # distance from between the y-axis and the top of the bar
    bar_h = abs(self.c2p(0, value)[1] - self.c2p(0, 0)[1])
    # width of the bar
    bar_w = self.c2p(self.bar_width, 0)[0] - self.c2p(0, 0)[0]

    bar = Rectangle(
        height=bar_h,
        width=bar_w,
        stroke_width=self.bar_stroke_width,
        fill_opacity=self.bar_fill_opacity,
    )

    pos = UP if (value &gt;= 0) else DOWN
    bar.next_to(self.c2p(bar_number + 0.5, 0), pos, buff=0)
    return bar

</t>
<t tx="ekr.20250122151620.143">@renderer.setter
def renderer(self, value: str | RendererType) -&gt; None:
    """The setter of the renderer property.

    Takes care of switching inheritance bases using the
    :class:`.ConvertToOpenGL` metaclass.
    """
    if isinstance(value, str):
        value = value.lower()
    renderer = RendererType(value)
    try:
        from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
        from manim.mobject.opengl.opengl_mobject import OpenGLMobject
        from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject

        from ..mobject.mobject import Mobject
        from ..mobject.types.vectorized_mobject import VMobject

        for cls in ConvertToOpenGL._converted_classes:
            if renderer == RendererType.OPENGL:
                conversion_dict = {
                    Mobject: OpenGLMobject,
                    VMobject: OpenGLVMobject,
                }
            else:
                conversion_dict = {
                    OpenGLMobject: Mobject,
                    OpenGLVMobject: VMobject,
                }

            cls.__bases__ = tuple(
                conversion_dict.get(base, base) for base in cls.__bases__
            )
    except ImportError:
        # The renderer is set during the initial import of the
        # library for the first time. The imports above cause an
        # ImportError due to circular imports. However, the
        # metaclass sets stuff up correctly in this case, so we
        # can just do nothing.
        pass

    self._set_from_enum("renderer", renderer, RendererType)

</t>
<t tx="ekr.20250122151620.1430">def _add_bars(self) -&gt; None:
    for i, value in enumerate(self.values):
        tmp_bar = self._create_bar(bar_number=i, value=value)
        self.bars.add(tmp_bar)

    self._update_colors()
    self.add_to_back(self.bars)

</t>
<t tx="ekr.20250122151620.1431">def get_bar_labels(
    self,
    color: ParsableManimColor | None = None,
    font_size: float = 24,
    buff: float = MED_SMALL_BUFF,
    label_constructor: type[VMobject] = Tex,
):
    """Annotates each bar with its corresponding value. Use ``self.bar_labels`` to access the
    labels after creation.

    Parameters
    ----------
    color
        The color of each label. By default ``None`` and is based on the parent's bar color.
    font_size
        The font size of each label.
    buff
        The distance from each label to its bar. By default 0.4.
    label_constructor
        The Mobject class to construct the labels, by default :class:`~.Tex`.

    Examples
    --------
    .. manim:: GetBarLabelsExample
        :save_last_frame:

        class GetBarLabelsExample(Scene):
            def construct(self):
                chart = BarChart(values=[10, 9, 8, 7, 6, 5, 4, 3, 2, 1], y_range=[0, 10, 1])

                c_bar_lbls = chart.get_bar_labels(
                    color=WHITE, label_constructor=MathTex, font_size=36
                )

                self.add(chart, c_bar_lbls)
    """
    bar_labels = VGroup()
    for bar, value in zip(self.bars, self.values):
        bar_lbl = label_constructor(str(value))

        if color is None:
            bar_lbl.set_color(bar.get_fill_color())
        else:
            bar_lbl.set_color(color)

        bar_lbl.font_size = font_size

        pos = UP if (value &gt;= 0) else DOWN
        bar_lbl.next_to(bar, pos, buff=buff)
        bar_labels.add(bar_lbl)

    return bar_labels

</t>
<t tx="ekr.20250122151620.1432">def change_bar_values(self, values: Iterable[float], update_colors: bool = True):
    """Updates the height of the bars of the chart.

    Parameters
    ----------
    values
        The values that will be used to update the height of the bars.
        Does not have to match the number of bars.
    update_colors
        Whether to re-initalize the colors of the bars based on ``self.bar_colors``.

    Examples
    --------
    .. manim:: ChangeBarValuesExample
        :save_last_frame:

        class ChangeBarValuesExample(Scene):
            def construct(self):
                values=[-10, -8, -6, -4, -2, 0, 2, 4, 6, 8, 10]

                chart = BarChart(
                    values,
                    y_range=[-10, 10, 2],
                    y_axis_config={"font_size": 24},
                )
                self.add(chart)

                chart.change_bar_values(list(reversed(values)))
                self.add(chart.get_bar_labels(font_size=24))
    """
    for i, (bar, value) in enumerate(zip(self.bars, values)):
        chart_val = self.values[i]

        if chart_val &gt; 0:
            bar_lim = bar.get_bottom()
            aligned_edge = DOWN
        else:
            bar_lim = bar.get_top()
            aligned_edge = UP

        # check if the bar has height
        if chart_val != 0:
            quotient = value / chart_val
            if quotient &lt; 0:
                aligned_edge = UP if chart_val &gt; 0 else DOWN

                # if the bar is already positive, then we now want to move it
                # so that it is negative. So, we move the top edge of the bar
                # to the location of the previous bottom

                # if already negative, then we move the bottom edge of the bar
                # to the location of the previous top

            bar.stretch_to_fit_height(abs(quotient) * bar.height)

        else:
            # create a new bar since the current one has a height of zero (doesn't exist)
            temp_bar = self._create_bar(i, value)
            self.bars.remove(bar)
            self.bars.insert(i, temp_bar)

        bar.move_to(bar_lim, aligned_edge)

    if update_colors:
        self._update_colors()

    self.values[: len(values)] = values
</t>
<t tx="ekr.20250122151620.1433">from __future__ import annotations

import math
from collections.abc import Iterable
from typing import TYPE_CHECKING, Any

import numpy as np

__all__ = ["LogBase", "LinearBase"]

from manim.mobject.text.numbers import Integer

if TYPE_CHECKING:
    from manim.mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1434">class _ScaleBase:
    """Scale baseclass for graphing/functions.

    Parameters
    ----------
    custom_labels
        Whether to create custom labels when plotted on a :class:`~.NumberLine`.
    """

    @others
</t>
<t tx="ekr.20250122151620.1435">class LinearBase(_ScaleBase):
    @others
</t>
<t tx="ekr.20250122151620.1436">class LogBase(_ScaleBase):
    @others
</t>
<t tx="ekr.20250122151620.1437">def __init__(self, custom_labels: bool = False):
    self.custom_labels = custom_labels

</t>
<t tx="ekr.20250122151620.1438">def function(self, value: float) -&gt; float:
    """The function that will be used to scale the values.

    Parameters
    ----------
    value
        The number/``np.ndarray`` to be scaled.

    Returns
    -------
    float
        The value after it has undergone the scaling.

    Raises
    ------
    NotImplementedError
        Must be subclassed.
    """
    raise NotImplementedError

</t>
<t tx="ekr.20250122151620.1439">def inverse_function(self, value: float) -&gt; float:
    """The inverse of ``function``. Used for plotting on a particular axis.

    Raises
    ------
    NotImplementedError
        Must be subclassed.
    """
    raise NotImplementedError

</t>
<t tx="ekr.20250122151620.144">@property
def media_dir(self) -&gt; str:
    """Main output directory.  See :meth:`ManimConfig.get_dir`."""
    return self._d["media_dir"]

</t>
<t tx="ekr.20250122151620.1440">def get_custom_labels(
    self,
    val_range: Iterable[float],
) -&gt; Iterable[Mobject]:
    """Custom instructions for generating labels along an axis.

    Parameters
    ----------
    val_range
        The position of labels. Also used for defining the content of the labels.

    Returns
    -------
    Dict
        A list consisting of the labels.
        Can be passed to :meth:`~.NumberLine.add_labels() along with ``val_range``.

    Raises
    ------
    NotImplementedError
        Can be subclassed, optional.
    """
    raise NotImplementedError


</t>
<t tx="ekr.20250122151620.1441">def __init__(self, scale_factor: float = 1.0):
    """The default scaling class.

    Parameters
    ----------
    scale_factor
        The slope of the linear function, by default 1.0
    """
    super().__init__()
    self.scale_factor = scale_factor

</t>
<t tx="ekr.20250122151620.1442">def function(self, value: float) -&gt; float:
    """Multiplies the value by the scale factor.

    Parameters
    ----------
    value
        Value to be multiplied by the scale factor.
    """
    return self.scale_factor * value

</t>
<t tx="ekr.20250122151620.1443">def inverse_function(self, value: float) -&gt; float:
    """Inverse of function. Divides the value by the scale factor.

    Parameters
    ----------
    value
        value to be divided by the scale factor.
    """
    return value / self.scale_factor


</t>
<t tx="ekr.20250122151620.1444">def __init__(self, base: float = 10, custom_labels: bool = True):
    """Scale for logarithmic graphs/functions.

    Parameters
    ----------
    base
        The base of the log, by default 10.
    custom_labels
        For use with :class:`~.Axes`:
        Whether or not to include ``LaTeX`` axis labels, by default True.

    Examples
    --------
    .. code-block:: python

        func = ParametricFunction(lambda x: x, scaling=LogBase(base=2))

    """
    super().__init__()
    self.base = base
    self.custom_labels = custom_labels

</t>
<t tx="ekr.20250122151620.1445">def function(self, value: float) -&gt; float:
    """Scales the value to fit it to a logarithmic scale.``self.function(5)==10**5``"""
    return self.base**value

</t>
<t tx="ekr.20250122151620.1446">def inverse_function(self, value: float) -&gt; float:
    """Inverse of ``function``. The value must be greater than 0"""
    if isinstance(value, np.ndarray):
        condition = value.any() &lt;= 0

        def func(value, base):
            return np.log(value) / np.log(base)
    else:
        condition = value &lt;= 0
        func = math.log

    if condition:
        raise ValueError(
            "log(0) is undefined. Make sure the value is in the domain of the function"
        )
    value = func(value, self.base)
    return value

</t>
<t tx="ekr.20250122151620.1447">def get_custom_labels(
    self,
    val_range: Iterable[float],
    unit_decimal_places: int = 0,
    **base_config: dict[str, Any],
) -&gt; list[Mobject]:
    """Produces custom :class:`~.Integer` labels in the form of ``10^2``.

    Parameters
    ----------
    val_range
        The iterable of values used to create the labels. Determines the exponent.
    unit_decimal_places
        The number of decimal places to include in the exponent
    base_config
        Additional arguments to be passed to :class:`~.Integer`.
    """
    # uses `format` syntax to control the number of decimal places.
    tex_labels = [
        Integer(
            self.base,
            unit="^{%s}" % (f"{self.inverse_function(i):.{unit_decimal_places}f}"),  # noqa: UP031
            **base_config,
        )
        for i in val_range
    ]
    return tex_labels
</t>
<t tx="ekr.20250122151620.1448"></t>
<t tx="ekr.20250122151620.1449"></t>
<t tx="ekr.20250122151620.145">@media_dir.setter
def media_dir(self, value: str | Path) -&gt; None:
    self._set_dir("media_dir", value)

</t>
<t tx="ekr.20250122151620.1450">from __future__ import annotations

__all__ = ["TrueDot", "DotCloud"]

import numpy as np

from manim.constants import ORIGIN, RIGHT, UP
from manim.mobject.opengl.opengl_point_cloud_mobject import OpenGLPMobject
from manim.utils.color import YELLOW


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1451">class DotCloud(OpenGLPMobject):
    @others
</t>
<t tx="ekr.20250122151620.1452">class TrueDot(DotCloud):
    @others
</t>
<t tx="ekr.20250122151620.1453">def __init__(
    self, color=YELLOW, stroke_width=2.0, radius=2.0, density=10, **kwargs
):
    self.radius = radius
    self.epsilon = 1.0 / density
    super().__init__(
        stroke_width=stroke_width, density=density, color=color, **kwargs
    )

</t>
<t tx="ekr.20250122151620.1454">def init_points(self):
    self.points = np.array(
        [
            r * (np.cos(theta) * RIGHT + np.sin(theta) * UP)
            for r in np.arange(self.epsilon, self.radius, self.epsilon)
            # Num is equal to int(stop - start)/ (step + 1) reformulated.
            for theta in np.linspace(
                0,
                2 * np.pi,
                num=int(2 * np.pi * (r + self.epsilon) / self.epsilon),
            )
        ],
        dtype=np.float32,
    )

</t>
<t tx="ekr.20250122151620.1455">def make_3d(self, gloss=0.5, shadow=0.2):
    self.set_gloss(gloss)
    self.set_shadow(shadow)
    self.apply_depth_test()
    return self


</t>
<t tx="ekr.20250122151620.1456">def __init__(self, center=ORIGIN, stroke_width=2.0, **kwargs):
    self.radius = stroke_width
    super().__init__(points=[center], stroke_width=stroke_width, **kwargs)
</t>
<t tx="ekr.20250122151620.1457">from __future__ import annotations

from abc import ABCMeta

from manim import config
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.mobject.opengl.opengl_point_cloud_mobject import OpenGLPMobject
from manim.mobject.opengl.opengl_three_dimensions import OpenGLSurface
from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject

from ...constants import RendererType

__all__ = ["ConvertToOpenGL"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1458">class ConvertToOpenGL(ABCMeta):
    """Metaclass for swapping (V)Mobject with its OpenGL counterpart at runtime
    depending on config.renderer. This metaclass should only need to be inherited
    on the lowest order inheritance classes such as Mobject and VMobject.
    """

    @others
</t>
<t tx="ekr.20250122151620.1459">_converted_classes = []

def __new__(mcls, name, bases, namespace):  # noqa: B902
    if config.renderer == RendererType.OPENGL:
        # Must check class names to prevent
        # cyclic importing.
        base_names_to_opengl = {
            "Mobject": OpenGLMobject,
            "VMobject": OpenGLVMobject,
            "PMobject": OpenGLPMobject,
            "Mobject1D": OpenGLPMobject,
            "Mobject2D": OpenGLPMobject,
            "Surface": OpenGLSurface,
        }

        bases = tuple(
            base_names_to_opengl.get(base.__name__, base) for base in bases
        )

    return super().__new__(mcls, name, bases, namespace)

</t>
<t tx="ekr.20250122151620.146">@property
def window_position(self) -&gt; str:
    """Set the position of preview window. You can use directions, e.g. UL/DR/ORIGIN/LEFT...or the position(pixel) of the upper left corner of the window, e.g. '960,540'."""
    return self._d["window_position"]

</t>
<t tx="ekr.20250122151620.1460">def __init__(cls, name, bases, namespace):  # noqa: B902
    super().__init__(name, bases, namespace)
    cls._converted_classes.append(cls)
</t>
<t tx="ekr.20250122151620.1461">from __future__ import annotations

import numpy as np

from manim.constants import *
from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_vectorized_mobject import (
    OpenGLDashedVMobject,
    OpenGLVGroup,
    OpenGLVMobject,
)
from manim.utils.color import *
from manim.utils.iterables import adjacent_n_tuples, adjacent_pairs
from manim.utils.simple_functions import clip
from manim.utils.space_ops import (
    angle_between_vectors,
    angle_of_vector,
    compass_directions,
    find_intersection,
    normalize,
    rotate_vector,
    rotation_matrix_transpose,
)

DEFAULT_DOT_RADIUS = 0.08
DEFAULT_DASH_LENGTH = 0.05
DEFAULT_ARROW_TIP_LENGTH = 0.35
DEFAULT_ARROW_TIP_WIDTH = 0.35

__all__ = [
    "OpenGLTipableVMobject",
    "OpenGLArc",
    "OpenGLArcBetweenPoints",
    "OpenGLCurvedArrow",
    "OpenGLCurvedDoubleArrow",
    "OpenGLCircle",
    "OpenGLDot",
    "OpenGLEllipse",
    "OpenGLAnnularSector",
    "OpenGLSector",
    "OpenGLAnnulus",
    "OpenGLLine",
    "OpenGLDashedLine",
    "OpenGLTangentLine",
    "OpenGLElbow",
    "OpenGLArrow",
    "OpenGLVector",
    "OpenGLDoubleArrow",
    "OpenGLCubicBezier",
    "OpenGLPolygon",
    "OpenGLRegularPolygon",
    "OpenGLTriangle",
    "OpenGLArrowTip",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1462">class OpenGLTipableVMobject(OpenGLVMobject):
    """
    Meant for shared functionality between Arc and Line.
    Functionality can be classified broadly into these groups:

        * Adding, Creating, Modifying tips
            - add_tip calls create_tip, before pushing the new tip
                into the TipableVMobject's list of submobjects
            - stylistic and positional configuration

        * Checking for tips
            - Boolean checks for whether the TipableVMobject has a tip
                and a starting tip

        * Getters
            - Straightforward accessors, returning information pertaining
                to the TipableVMobject instance's tip(s), its length etc
    """

    @others
</t>
<t tx="ekr.20250122151620.1463">class OpenGLArc(OpenGLTipableVMobject):
    @others
</t>
<t tx="ekr.20250122151620.1464">class OpenGLArcBetweenPoints(OpenGLArc):
    @others
</t>
<t tx="ekr.20250122151620.1465">class OpenGLCurvedArrow(OpenGLArcBetweenPoints):
    @others
</t>
<t tx="ekr.20250122151620.1466">class OpenGLCurvedDoubleArrow(OpenGLCurvedArrow):
    @others
</t>
<t tx="ekr.20250122151620.1467">class OpenGLCircle(OpenGLArc):
    @others
</t>
<t tx="ekr.20250122151620.1468">class OpenGLDot(OpenGLCircle):
    @others
</t>
<t tx="ekr.20250122151620.1469">class OpenGLEllipse(OpenGLCircle):
    @others
</t>
<t tx="ekr.20250122151620.147">@window_position.setter
def window_position(self, value: str) -&gt; None:
    self._d.__setitem__("window_position", value)

</t>
<t tx="ekr.20250122151620.1470">class OpenGLAnnularSector(OpenGLArc):
    @others
</t>
<t tx="ekr.20250122151620.1471">class OpenGLSector(OpenGLAnnularSector):
    @others
</t>
<t tx="ekr.20250122151620.1472">class OpenGLAnnulus(OpenGLCircle):
    @others
</t>
<t tx="ekr.20250122151620.1473">class OpenGLLine(OpenGLTipableVMobject):
    @others
</t>
<t tx="ekr.20250122151620.1474">class OpenGLDashedLine(OpenGLLine):
    @others
</t>
<t tx="ekr.20250122151620.1475">class OpenGLTangentLine(OpenGLLine):
    @others
</t>
<t tx="ekr.20250122151620.1476">class OpenGLElbow(OpenGLVMobject):
    @others
</t>
<t tx="ekr.20250122151620.1477">class OpenGLArrow(OpenGLLine):
    @others
</t>
<t tx="ekr.20250122151620.1478">class OpenGLVector(OpenGLArrow):
    @others
</t>
<t tx="ekr.20250122151620.1479">class OpenGLDoubleArrow(OpenGLArrow):
    @others
</t>
<t tx="ekr.20250122151620.148">@property
def window_size(self) -&gt; str:
    """The size of the opengl window. 'default' to automatically scale the window based on the display monitor."""
    return self._d["window_size"]

</t>
<t tx="ekr.20250122151620.1480">class OpenGLCubicBezier(OpenGLVMobject):
    @others
</t>
<t tx="ekr.20250122151620.1481">class OpenGLPolygon(OpenGLVMobject):
    @others
</t>
<t tx="ekr.20250122151620.1482">class OpenGLRegularPolygon(OpenGLPolygon):
    @others
</t>
<t tx="ekr.20250122151620.1483">class OpenGLTriangle(OpenGLRegularPolygon):
    @others
</t>
<t tx="ekr.20250122151620.1484">class OpenGLArrowTip(OpenGLTriangle):
    @others
</t>
<t tx="ekr.20250122151620.1485">class OpenGLRectangle(OpenGLPolygon):
    @others
</t>
<t tx="ekr.20250122151620.1486">class OpenGLSquare(OpenGLRectangle):
    @others
</t>
<t tx="ekr.20250122151620.1487">class OpenGLRoundedRectangle(OpenGLRectangle):
    @others
</t>
<t tx="ekr.20250122151620.1488"># Adding, Creating, Modifying tips

def __init__(
    self,
    tip_length=DEFAULT_ARROW_TIP_LENGTH,
    normal_vector=OUT,
    tip_config={},
    **kwargs,
):
    self.tip_length = tip_length
    self.normal_vector = normal_vector
    self.tip_config = tip_config
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.1489">def add_tip(self, at_start=False, **kwargs):
    """
    Adds a tip to the TipableVMobject instance, recognising
    that the endpoints might need to be switched if it's
    a 'starting tip' or not.
    """
    tip = self.create_tip(at_start, **kwargs)
    self.reset_endpoints_based_on_tip(tip, at_start)
    self.asign_tip_attr(tip, at_start)
    self.add(tip)
    return self

</t>
<t tx="ekr.20250122151620.149">@window_size.setter
def window_size(self, value: str) -&gt; None:
    self._d.__setitem__("window_size", value)

</t>
<t tx="ekr.20250122151620.1490">def create_tip(self, at_start=False, **kwargs):
    """
    Stylises the tip, positions it spacially, and returns
    the newly instantiated tip to the caller.
    """
    tip = self.get_unpositioned_tip(**kwargs)
    self.position_tip(tip, at_start)
    return tip

</t>
<t tx="ekr.20250122151620.1491">def get_unpositioned_tip(self, **kwargs):
    """
    Returns a tip that has been stylistically configured,
    but has not yet been given a position in space.
    """
    config = {}
    config.update(self.tip_config)
    config.update(kwargs)
    return OpenGLArrowTip(**config)

</t>
<t tx="ekr.20250122151620.1492">def position_tip(self, tip, at_start=False):
    # Last two control points, defining both
    # the end, and the tangency direction
    if at_start:
        anchor = self.get_start()
        handle = self.get_first_handle()
    else:
        handle = self.get_last_handle()
        anchor = self.get_end()
    tip.rotate(angle_of_vector(handle - anchor) - PI - tip.get_angle())
    tip.shift(anchor - tip.get_tip_point())
    return tip

</t>
<t tx="ekr.20250122151620.1493">def reset_endpoints_based_on_tip(self, tip, at_start):
    if self.get_length() == 0:
        # Zero length, put_start_and_end_on wouldn't
        # work
        return self

    if at_start:
        start = tip.get_base()
        end = self.get_end()
    else:
        start = self.get_start()
        end = tip.get_base()
    self.put_start_and_end_on(start, end)
    return self

</t>
<t tx="ekr.20250122151620.1494">def asign_tip_attr(self, tip, at_start):
    if at_start:
        self.start_tip = tip
    else:
        self.tip = tip
    return self

</t>
<t tx="ekr.20250122151620.1495"># Checking for tips
def has_tip(self):
    return hasattr(self, "tip") and self.tip in self

</t>
<t tx="ekr.20250122151620.1496">def has_start_tip(self):
    return hasattr(self, "start_tip") and self.start_tip in self

</t>
<t tx="ekr.20250122151620.1497"># Getters
def pop_tips(self):
    start, end = self.get_start_and_end()
    result = OpenGLVGroup()
    if self.has_tip():
        result.add(self.tip)
        self.remove(self.tip)
    if self.has_start_tip():
        result.add(self.start_tip)
        self.remove(self.start_tip)
    self.put_start_and_end_on(start, end)
    return result

</t>
<t tx="ekr.20250122151620.1498">def get_tips(self):
    """
    Returns a VGroup (collection of VMobjects) containing
    the TipableVMObject instance's tips.
    """
    result = OpenGLVGroup()
    if hasattr(self, "tip"):
        result.add(self.tip)
    if hasattr(self, "start_tip"):
        result.add(self.start_tip)
    return result

</t>
<t tx="ekr.20250122151620.1499">def get_tip(self):
    """Returns the TipableVMobject instance's (first) tip,
    otherwise throws an exception.
    """
    tips = self.get_tips()
    if len(tips) == 0:
        raise Exception("tip not found")
    else:
        return tips[0]

</t>
<t tx="ekr.20250122151620.15">"""Set the global config and logger."""

from __future__ import annotations

import logging
from collections.abc import Generator
from contextlib import contextmanager
from typing import Any

from .cli_colors import parse_cli_ctx
from .logger_utils import make_logger
from .utils import ManimConfig, ManimFrame, make_config_parser

__all__ = [
    "logger",
    "console",
    "error_console",
    "config",
    "frame",
    "tempconfig",
    "cli_ctx_settings",
]

parser = make_config_parser()

# The logger can be accessed from anywhere as manim.logger, or as
# logging.getLogger("manim").  The console must be accessed as manim.console.
# Throughout the codebase, use manim.console.print() instead of print().
# Use error_console to print errors so that it outputs to stderr.
logger, console, error_console = make_logger(
    parser["logger"],
    parser["CLI"]["verbosity"],
)
cli_ctx_settings = parse_cli_ctx(parser["CLI_CTX"])
# TODO: temporary to have a clean terminal output when working with PIL or matplotlib
logging.getLogger("PIL").setLevel(logging.INFO)
logging.getLogger("matplotlib").setLevel(logging.INFO)

config = ManimConfig().digest_parser(parser)
# TODO: to be used in the future - see PR #620
# https://github.com/ManimCommunity/manim/pull/620
frame = ManimFrame(config)


# This has to go here because it needs access to this module's config
@contextmanager
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.150">def resolve_movie_file_extension(self, is_transparent: bool) -&gt; None:
    prev_file_extension = self.movie_file_extension
    if is_transparent:
        self.movie_file_extension = ".webm" if self.format == "webm" else ".mov"
    elif self.format == "webm":
        self.movie_file_extension = ".webm"
    elif self.format == "mov":
        self.movie_file_extension = ".mov"
    else:
        self.movie_file_extension = ".mp4"
    if self.movie_file_extension != prev_file_extension:
        logger.warning(
            f"Output format changed to '{self.movie_file_extension}' "
            "to support transparency",
        )

</t>
<t tx="ekr.20250122151620.1500">def get_default_tip_length(self):
    return self.tip_length

</t>
<t tx="ekr.20250122151620.1501">def get_first_handle(self):
    return self.points[1]

</t>
<t tx="ekr.20250122151620.1502">def get_last_handle(self):
    return self.points[-2]

</t>
<t tx="ekr.20250122151620.1503">def get_end(self):
    if self.has_tip():
        return self.tip.get_start()
    else:
        return super().get_end()

</t>
<t tx="ekr.20250122151620.1504">def get_start(self):
    if self.has_start_tip():
        return self.start_tip.get_start()
    else:
        return super().get_start()

</t>
<t tx="ekr.20250122151620.1505">def get_length(self):
    start, end = self.get_start_and_end()
    return np.linalg.norm(start - end)


</t>
<t tx="ekr.20250122151620.1506">def __init__(
    self,
    start_angle=0,
    angle=TAU / 4,
    radius=1.0,
    n_components=8,
    arc_center=ORIGIN,
    **kwargs,
):
    self.start_angle = start_angle
    self.angle = angle
    self.radius = radius
    self.n_components = n_components
    self.arc_center = arc_center
    super().__init__(self, **kwargs)
    self.orientation = -1

</t>
<t tx="ekr.20250122151620.1507">def init_points(self):
    self.set_points(
        OpenGLArc.create_quadratic_bezier_points(
            angle=self.angle,
            start_angle=self.start_angle,
            n_components=self.n_components,
        ),
    )
    # To maintain proper orientation for fill shaders.
    self.scale(self.radius, about_point=ORIGIN)
    self.shift(self.arc_center)

</t>
<t tx="ekr.20250122151620.1508">@staticmethod
def create_quadratic_bezier_points(angle, start_angle=0, n_components=8):
    samples = np.array(
        [
            [np.cos(a), np.sin(a), 0]
            for a in np.linspace(
                start_angle,
                start_angle + angle,
                2 * n_components + 1,
            )
        ],
    )
    theta = angle / n_components
    samples[1::2] /= np.cos(theta / 2)

    points = np.zeros((3 * n_components, 3))
    points[0::3] = samples[0:-1:2]
    points[1::3] = samples[1::2]
    points[2::3] = samples[2::2]
    return points

</t>
<t tx="ekr.20250122151620.1509">def get_arc_center(self):
    """
    Looks at the normals to the first two
    anchors, and finds their intersection points
    """
    # First two anchors and handles
    a1, h, a2 = self.points[:3]
    # Tangent vectors
    t1 = h - a1
    t2 = h - a2
    # Normals
    n1 = rotate_vector(t1, TAU / 4)
    n2 = rotate_vector(t2, TAU / 4)
    return find_intersection(a1, n1, a2, n2)

</t>
<t tx="ekr.20250122151620.151">@property
def enable_gui(self) -&gt; bool:
    """Enable GUI interaction."""
    return self._d["enable_gui"]

</t>
<t tx="ekr.20250122151620.1510">def get_start_angle(self):
    angle = angle_of_vector(self.get_start() - self.get_arc_center())
    return angle % TAU

</t>
<t tx="ekr.20250122151620.1511">def get_stop_angle(self):
    angle = angle_of_vector(self.get_end() - self.get_arc_center())
    return angle % TAU

</t>
<t tx="ekr.20250122151620.1512">def move_arc_center_to(self, point):
    self.shift(point - self.get_arc_center())
    return self


</t>
<t tx="ekr.20250122151620.1513">def __init__(self, start, end, angle=TAU / 4, **kwargs):
    super().__init__(angle=angle, **kwargs)
    if angle == 0:
        self.set_points_as_corners([LEFT, RIGHT])
    self.put_start_and_end_on(start, end)


</t>
<t tx="ekr.20250122151620.1514">def __init__(self, start_point, end_point, **kwargs):
    super().__init__(start_point, end_point, **kwargs)
    self.add_tip()


</t>
<t tx="ekr.20250122151620.1515">def __init__(self, start_point, end_point, **kwargs):
    super().__init__(start_point, end_point, **kwargs)
    self.add_tip(at_start=True)


</t>
<t tx="ekr.20250122151620.1516">def __init__(self, color=RED, **kwargs):
    super().__init__(0, TAU, color=color, **kwargs)

</t>
<t tx="ekr.20250122151620.1517">def surround(self, mobject, dim_to_match=0, stretch=False, buff=MED_SMALL_BUFF):
    # Ignores dim_to_match and stretch; result will always be a circle
    # TODO: Perhaps create an ellipse class to handle singele-dimension stretching

    self.replace(mobject, dim_to_match, stretch)
    self.stretch((self.get_width() + 2 * buff) / self.get_width(), 0)
    self.stretch((self.get_height() + 2 * buff) / self.get_height(), 1)

</t>
<t tx="ekr.20250122151620.1518">def point_at_angle(self, angle):
    start_angle = self.get_start_angle()
    return self.point_from_proportion((angle - start_angle) / TAU)


</t>
<t tx="ekr.20250122151620.1519">def __init__(
    self,
    point=ORIGIN,
    radius=DEFAULT_DOT_RADIUS,
    stroke_width=0,
    fill_opacity=1.0,
    color=WHITE,
    **kwargs,
):
    super().__init__(
        arc_center=point,
        radius=radius,
        stroke_width=stroke_width,
        fill_opacity=fill_opacity,
        color=color,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.152">@enable_gui.setter
def enable_gui(self, value: bool) -&gt; None:
    self._set_boolean("enable_gui", value)

</t>
<t tx="ekr.20250122151620.1520">def __init__(self, width=2, height=1, **kwargs):
    super().__init__(**kwargs)
    self.set_width(width, stretch=True)
    self.set_height(height, stretch=True)


</t>
<t tx="ekr.20250122151620.1521">def __init__(
    self,
    inner_radius=1,
    outer_radius=2,
    angle=TAU / 4,
    start_angle=0,
    fill_opacity=1,
    stroke_width=0,
    color=WHITE,
    **kwargs,
):
    self.inner_radius = inner_radius
    self.outer_radius = outer_radius
    super().__init__(
        start_angle=start_angle,
        angle=angle,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        color=color,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.1522">def init_points(self):
    inner_arc, outer_arc = (
        OpenGLArc(
            start_angle=self.start_angle,
            angle=self.angle,
            radius=radius,
            arc_center=self.arc_center,
        )
        for radius in (self.inner_radius, self.outer_radius)
    )
    outer_arc.reverse_points()
    self.append_points(inner_arc.points)
    self.add_line_to(outer_arc.points[0])
    self.append_points(outer_arc.points)
    self.add_line_to(inner_arc.points[0])


</t>
<t tx="ekr.20250122151620.1523">def __init__(self, outer_radius=1, inner_radius=0, **kwargs):
    super().__init__(inner_radius=inner_radius, outer_radius=outer_radius, **kwargs)


</t>
<t tx="ekr.20250122151620.1524">def __init__(
    self,
    inner_radius=1,
    outer_radius=2,
    fill_opacity=1,
    stroke_width=0,
    color=WHITE,
    mark_paths_closed=False,
    **kwargs,
):
    self.mark_paths_closed = mark_paths_closed  # is this even used?
    self.inner_radius = inner_radius
    self.outer_radius = outer_radius
    super().__init__(
        fill_opacity=fill_opacity, stroke_width=stroke_width, color=color, **kwargs
    )

</t>
<t tx="ekr.20250122151620.1525">def init_points(self):
    self.radius = self.outer_radius
    outer_circle = OpenGLCircle(radius=self.outer_radius)
    inner_circle = OpenGLCircle(radius=self.inner_radius)
    inner_circle.reverse_points()
    self.append_points(outer_circle.points)
    self.append_points(inner_circle.points)
    self.shift(self.arc_center)


</t>
<t tx="ekr.20250122151620.1526">def __init__(self, start=LEFT, end=RIGHT, buff=0, path_arc=0, **kwargs):
    self.dim = 3
    self.buff = buff
    self.path_arc = path_arc
    self.set_start_and_end_attrs(start, end)
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.1527">def init_points(self):
    self.set_points_by_ends(self.start, self.end, self.buff, self.path_arc)

</t>
<t tx="ekr.20250122151620.1528">def set_points_by_ends(self, start, end, buff=0, path_arc=0):
    if path_arc:
        self.set_points(OpenGLArc.create_quadratic_bezier_points(path_arc))
        self.put_start_and_end_on(start, end)
    else:
        self.set_points_as_corners([start, end])
    self.account_for_buff(self.buff)

</t>
<t tx="ekr.20250122151620.1529">def set_path_arc(self, new_value):
    self.path_arc = new_value
    self.init_points()

</t>
<t tx="ekr.20250122151620.153">@property
def gui_location(self) -&gt; tuple[Any]:
    """Enable GUI interaction."""
    return self._d["gui_location"]

</t>
<t tx="ekr.20250122151620.1530">def account_for_buff(self, buff):
    if buff == 0:
        return
    #
    length = self.get_length() if self.path_arc == 0 else self.get_arc_length()
    #
    if length &lt; 2 * buff:
        return
    buff_prop = buff / length
    self.pointwise_become_partial(self, buff_prop, 1 - buff_prop)
    return self

</t>
<t tx="ekr.20250122151620.1531">def set_start_and_end_attrs(self, start, end):
    # If either start or end are Mobjects, this
    # gives their centers
    rough_start = self.pointify(start)
    rough_end = self.pointify(end)
    vect = normalize(rough_end - rough_start)
    # Now that we know the direction between them,
    # we can find the appropriate boundary point from
    # start and end, if they're mobjects
    self.start = self.pointify(start, vect) + self.buff * vect
    self.end = self.pointify(end, -vect) - self.buff * vect

</t>
<t tx="ekr.20250122151620.1532">def pointify(self, mob_or_point, direction=None):
    """
    Take an argument passed into Line (or subclass) and turn
    it into a 3d point.
    """
    if isinstance(mob_or_point, Mobject):
        mob = mob_or_point
        if direction is None:
            return mob.get_center()
        else:
            return mob.get_continuous_bounding_box_point(direction)
    else:
        point = mob_or_point
        result = np.zeros(self.dim)
        result[: len(point)] = point
        return result

</t>
<t tx="ekr.20250122151620.1533">def put_start_and_end_on(self, start, end):
    curr_start, curr_end = self.get_start_and_end()
    if (curr_start == curr_end).all():
        self.set_points_by_ends(start, end, self.path_arc)
    return super().put_start_and_end_on(start, end)

</t>
<t tx="ekr.20250122151620.1534">def get_vector(self):
    return self.get_end() - self.get_start()

</t>
<t tx="ekr.20250122151620.1535">def get_unit_vector(self):
    return normalize(self.get_vector())

</t>
<t tx="ekr.20250122151620.1536">def get_angle(self):
    return angle_of_vector(self.get_vector())

</t>
<t tx="ekr.20250122151620.1537">def get_projection(self, point):
    """Return projection of a point onto the line"""
    unit_vect = self.get_unit_vector()
    start = self.get_start()
    return start + np.dot(point - start, unit_vect) * unit_vect

</t>
<t tx="ekr.20250122151620.1538">def get_slope(self):
    return np.tan(self.get_angle())

</t>
<t tx="ekr.20250122151620.1539">def set_angle(self, angle, about_point=None):
    if about_point is None:
        about_point = self.get_start()
    self.rotate(
        angle - self.get_angle(),
        about_point=about_point,
    )
    return self

</t>
<t tx="ekr.20250122151620.154">@gui_location.setter
def gui_location(self, value: tuple[Any]) -&gt; None:
    self._set_tuple("gui_location", value)

</t>
<t tx="ekr.20250122151620.1540">def set_length(self, length):
    self.scale(length / self.get_length())


</t>
<t tx="ekr.20250122151620.1541">def __init__(
    self, *args, dash_length=DEFAULT_DASH_LENGTH, dashed_ratio=0.5, **kwargs
):
    self.dashed_ratio = dashed_ratio
    self.dash_length = dash_length
    super().__init__(*args, **kwargs)
    dashed_ratio = self.dashed_ratio
    num_dashes = self.calculate_num_dashes(dashed_ratio)
    dashes = OpenGLDashedVMobject(
        self,
        num_dashes=num_dashes,
        dashed_ratio=dashed_ratio,
    )
    self.clear_points()
    self.add(*dashes)

</t>
<t tx="ekr.20250122151620.1542">def calculate_num_dashes(self, dashed_ratio):
    return max(
        2,
        int(np.ceil((self.get_length() / self.dash_length) * dashed_ratio)),
    )

</t>
<t tx="ekr.20250122151620.1543">def get_start(self):
    if len(self.submobjects) &gt; 0:
        return self.submobjects[0].get_start()
    else:
        return super().get_start()

</t>
<t tx="ekr.20250122151620.1544">def get_end(self):
    if len(self.submobjects) &gt; 0:
        return self.submobjects[-1].get_end()
    else:
        return super().get_end()

</t>
<t tx="ekr.20250122151620.1545">def get_first_handle(self):
    return self.submobjects[0].points[1]

</t>
<t tx="ekr.20250122151620.1546">def get_last_handle(self):
    return self.submobjects[-1].points[-2]


</t>
<t tx="ekr.20250122151620.1547">def __init__(self, vmob, alpha, length=1, d_alpha=1e-6, **kwargs):
    self.length = length
    self.d_alpha = d_alpha
    da = self.d_alpha
    a1 = clip(alpha - da, 0, 1)
    a2 = clip(alpha + da, 0, 1)
    super().__init__(vmob.pfp(a1), vmob.pfp(a2), **kwargs)
    self.scale(self.length / self.get_length())


</t>
<t tx="ekr.20250122151620.1548">def __init__(self, width=0.2, angle=0, **kwargs):
    self.angle = angle
    super().__init__(self, **kwargs)
    self.set_points_as_corners([UP, UP + RIGHT, RIGHT])
    self.set_width(width, about_point=ORIGIN)
    self.rotate(self.angle, about_point=ORIGIN)


</t>
<t tx="ekr.20250122151620.1549">def __init__(
    self,
    start=LEFT,
    end=RIGHT,
    path_arc=0,
    fill_color=GREY_A,
    fill_opacity=1,
    stroke_width=0,
    buff=MED_SMALL_BUFF,
    thickness=0.05,
    tip_width_ratio=5,
    tip_angle=PI / 3,
    max_tip_length_to_length_ratio=0.5,
    max_width_to_length_ratio=0.1,
    **kwargs,
):
    self.thickness = thickness
    self.tip_width_ratio = tip_width_ratio
    self.tip_angle = tip_angle
    self.max_tip_length_to_length_ratio = max_tip_length_to_length_ratio
    self.max_width_to_length_ratio = max_width_to_length_ratio
    super().__init__(
        start=start,
        end=end,
        buff=buff,
        path_arc=path_arc,
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.155">@property
def fullscreen(self) -&gt; bool:
    """Expand the window to its maximum possible size."""
    return self._d["fullscreen"]

</t>
<t tx="ekr.20250122151620.1550">def set_points_by_ends(self, start, end, buff=0, path_arc=0):
    # Find the right tip length and thickness
    vect = end - start
    length = max(np.linalg.norm(vect), 1e-8)
    thickness = self.thickness
    w_ratio = self.max_width_to_length_ratio / (thickness / length)
    if w_ratio &lt; 1:
        thickness *= w_ratio

    tip_width = self.tip_width_ratio * thickness
    tip_length = tip_width / (2 * np.tan(self.tip_angle / 2))
    t_ratio = self.max_tip_length_to_length_ratio / (tip_length / length)
    if t_ratio &lt; 1:
        tip_length *= t_ratio
        tip_width *= t_ratio

    # Find points for the stem
    if path_arc == 0:
        points1 = (length - tip_length) * np.array([RIGHT, 0.5 * RIGHT, ORIGIN])
        points1 += thickness * UP / 2
        points2 = points1[::-1] + thickness * DOWN
    else:
        # Solve for radius so that the tip-to-tail length matches |end - start|
        a = 2 * (1 - np.cos(path_arc))
        b = -2 * tip_length * np.sin(path_arc)
        c = tip_length**2 - length**2
        R = (-b + np.sqrt(b**2 - 4 * a * c)) / (2 * a)

        # Find arc points
        points1 = OpenGLArc.create_quadratic_bezier_points(path_arc)
        points2 = np.array(points1[::-1])
        points1 *= R + thickness / 2
        points2 *= R - thickness / 2
        if path_arc &lt; 0:
            tip_length *= -1
        rot_T = rotation_matrix_transpose(PI / 2 - path_arc, OUT)
        for points in points1, points2:
            points[:] = np.dot(points, rot_T)
            points += R * DOWN

    self.set_points(points1)
    # Tip
    self.add_line_to(tip_width * UP / 2)
    self.add_line_to(tip_length * LEFT)
    self.tip_index = len(self.points) - 1
    self.add_line_to(tip_width * DOWN / 2)
    self.add_line_to(points2[0])
    # Close it out
    self.append_points(points2)
    self.add_line_to(points1[0])

    if length &gt; 0:
        # Final correction
        super().scale(length / self.get_length())

    self.rotate(angle_of_vector(vect) - self.get_angle())
    self.rotate(
        PI / 2 - np.arccos(normalize(vect)[2]),
        axis=rotate_vector(self.get_unit_vector(), -PI / 2),
    )
    self.shift(start - self.get_start())
    self.refresh_triangulation()

</t>
<t tx="ekr.20250122151620.1551">def reset_points_around_ends(self):
    self.set_points_by_ends(
        self.get_start(),
        self.get_end(),
        path_arc=self.path_arc,
    )
    return self

</t>
<t tx="ekr.20250122151620.1552">def get_start(self):
    nppc = self.n_points_per_curve
    points = self.points
    return (points[0] + points[-nppc]) / 2

</t>
<t tx="ekr.20250122151620.1553">def get_end(self):
    return self.points[self.tip_index]

</t>
<t tx="ekr.20250122151620.1554">def put_start_and_end_on(self, start, end):
    self.set_points_by_ends(start, end, buff=0, path_arc=self.path_arc)
    return self

</t>
<t tx="ekr.20250122151620.1555">def scale(self, *args, **kwargs):
    super().scale(*args, **kwargs)
    self.reset_points_around_ends()
    return self

</t>
<t tx="ekr.20250122151620.1556">def set_thickness(self, thickness):
    self.thickness = thickness
    self.reset_points_around_ends()
    return self

</t>
<t tx="ekr.20250122151620.1557">def set_path_arc(self, path_arc):
    self.path_arc = path_arc
    self.reset_points_around_ends()
    return self


</t>
<t tx="ekr.20250122151620.1558">def __init__(self, direction=RIGHT, buff=0, **kwargs):
    self.buff = buff
    if len(direction) == 2:
        direction = np.hstack([direction, 0])
    super().__init__(ORIGIN, direction, buff=buff, **kwargs)


</t>
<t tx="ekr.20250122151620.1559">def __init__(self, *args, **kwargs):
    super().__init__(*args, **kwargs)
    self.add_tip(at_start=True)


</t>
<t tx="ekr.20250122151620.156">@fullscreen.setter
def fullscreen(self, value: bool) -&gt; None:
    self._set_boolean("fullscreen", value)

</t>
<t tx="ekr.20250122151620.1560">def __init__(self, a0, h0, h1, a1, **kwargs):
    super().__init__(**kwargs)
    self.add_cubic_bezier_curve(a0, h0, h1, a1)


</t>
<t tx="ekr.20250122151620.1561">def __init__(self, *vertices, **kwargs):
    self.vertices = vertices
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.1562">def init_points(self):
    verts = self.vertices
    self.set_points_as_corners([*verts, verts[0]])

</t>
<t tx="ekr.20250122151620.1563">def get_vertices(self):
    return self.get_start_anchors()

</t>
<t tx="ekr.20250122151620.1564">def round_corners(self, radius=0.5):
    vertices = self.get_vertices()
    arcs = []
    for v1, v2, v3 in adjacent_n_tuples(vertices, 3):
        vect1 = v2 - v1
        vect2 = v3 - v2
        unit_vect1 = normalize(vect1)
        unit_vect2 = normalize(vect2)
        angle = angle_between_vectors(vect1, vect2)
        # Negative radius gives concave curves
        angle *= np.sign(radius)
        # Distance between vertex and start of the arc
        cut_off_length = radius * np.tan(angle / 2)
        # Determines counterclockwise vs. clockwise
        sign = np.sign(np.cross(vect1, vect2)[2])
        arc = OpenGLArcBetweenPoints(
            v2 - unit_vect1 * cut_off_length,
            v2 + unit_vect2 * cut_off_length,
            angle=sign * angle,
            n_components=2,
        )
        arcs.append(arc)

    self.clear_points()
    # To ensure that we loop through starting with last
    arcs = [arcs[-1], *arcs[:-1]]
    for arc1, arc2 in adjacent_pairs(arcs):
        self.append_points(arc1.points)
        line = OpenGLLine(arc1.get_end(), arc2.get_start())
        # Make sure anchors are evenly distributed
        len_ratio = line.get_length() / arc1.get_arc_length()
        line.insert_n_curves(int(arc1.get_num_curves() * len_ratio))
        self.append_points(line.points)
    return self


</t>
<t tx="ekr.20250122151620.1565">def __init__(self, n=6, start_angle=None, **kwargs):
    self.start_angle = start_angle
    if self.start_angle is None:
        if n % 2 == 0:
            self.start_angle = 0
        else:
            self.start_angle = 90 * DEGREES
    start_vect = rotate_vector(RIGHT, self.start_angle)
    vertices = compass_directions(n, start_vect)
    super().__init__(*vertices, **kwargs)


</t>
<t tx="ekr.20250122151620.1566">def __init__(self, **kwargs):
    super().__init__(n=3, **kwargs)


</t>
<t tx="ekr.20250122151620.1567">def __init__(
    self,
    fill_opacity=1,
    fill_color=WHITE,
    stroke_width=0,
    width=DEFAULT_ARROW_TIP_WIDTH,
    length=DEFAULT_ARROW_TIP_LENGTH,
    angle=0,
    **kwargs,
):
    super().__init__(
        start_angle=0,
        fill_opacity=fill_opacity,
        fill_color=fill_color,
        stroke_width=stroke_width,
        **kwargs,
    )
    self.set_width(width, stretch=True)
    self.set_height(length, stretch=True)

</t>
<t tx="ekr.20250122151620.1568">def get_base(self):
    return self.point_from_proportion(0.5)

</t>
<t tx="ekr.20250122151620.1569">def get_tip_point(self):
    return self.points[0]

</t>
<t tx="ekr.20250122151620.157">@property
def use_projection_fill_shaders(self) -&gt; bool:
    """Use shaders for OpenGLVMobject fill which are compatible with transformation matrices."""
    return self._d["use_projection_fill_shaders"]

</t>
<t tx="ekr.20250122151620.1570">def get_vector(self):
    return self.get_tip_point() - self.get_base()

</t>
<t tx="ekr.20250122151620.1571">def get_angle(self):
    return angle_of_vector(self.get_vector())

</t>
<t tx="ekr.20250122151620.1572">def get_length(self):
    return np.linalg.norm(self.get_vector())


</t>
<t tx="ekr.20250122151620.1573">def __init__(self, color=WHITE, width=4.0, height=2.0, **kwargs):
    super().__init__(UR, UL, DL, DR, color=color, **kwargs)

    self.set_width(width, stretch=True)
    self.set_height(height, stretch=True)


</t>
<t tx="ekr.20250122151620.1574">def __init__(self, side_length=2.0, **kwargs):
    self.side_length = side_length

    super().__init__(height=side_length, width=side_length, **kwargs)


</t>
<t tx="ekr.20250122151620.1575">def __init__(self, corner_radius=0.5, **kwargs):
    self.corner_radius = corner_radius
    super().__init__(**kwargs)
    self.round_corners(self.corner_radius)
</t>
<t tx="ekr.20250122151620.1576">from __future__ import annotations

__all__ = [
    "OpenGLImageMobject",
]

from pathlib import Path

import numpy as np
from PIL import Image
from PIL.Image import Resampling

from manim.mobject.opengl.opengl_surface import OpenGLSurface, OpenGLTexturedSurface
from manim.utils.images import get_full_raster_image_path

__all__ = ["OpenGLImageMobject"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1577">class OpenGLImageMobject(OpenGLTexturedSurface):
    @others
</t>
<t tx="ekr.20250122151620.1578">def __init__(
    self,
    filename_or_array: str | Path | np.ndarray,
    width: float = None,
    height: float = None,
    image_mode: str = "RGBA",
    resampling_algorithm: int = Resampling.BICUBIC,
    opacity: float = 1,
    gloss: float = 0,
    shadow: float = 0,
    **kwargs,
):
    self.image = filename_or_array
    self.resampling_algorithm = resampling_algorithm
    if isinstance(filename_or_array, np.ndarray):
        self.size = self.image.shape[1::-1]
    elif isinstance(filename_or_array, (str, Path)):
        path = get_full_raster_image_path(filename_or_array)
        self.size = Image.open(path).size

    if width is None and height is None:
        width = 4 * self.size[0] / self.size[1]
        height = 4
    if height is None:
        height = width * self.size[1] / self.size[0]
    if width is None:
        width = height * self.size[0] / self.size[1]

    surface = OpenGLSurface(
        lambda u, v: np.array([u, v, 0]),
        [-width / 2, width / 2],
        [-height / 2, height / 2],
        opacity=opacity,
        gloss=gloss,
        shadow=shadow,
    )

    super().__init__(
        surface,
        self.image,
        image_mode=image_mode,
        opacity=opacity,
        gloss=gloss,
        shadow=shadow,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.1579">def get_image_from_file(
    self,
    image_file: str | Path | np.ndarray,
    image_mode: str,
):
    if isinstance(image_file, (str, Path)):
        return super().get_image_from_file(image_file, image_mode)
    else:
        return (
            Image.fromarray(image_file.astype("uint8"))
            .convert(image_mode)
            .resize(
                np.array(image_file.shape[:2])
                * 200,  # assumption of 200 ppmu (pixels per manim unit) would suffice
                resample=self.resampling_algorithm,
            )
        )
</t>
<t tx="ekr.20250122151620.158">@use_projection_fill_shaders.setter
def use_projection_fill_shaders(self, value: bool) -&gt; None:
    self._set_boolean("use_projection_fill_shaders", value)

</t>
<t tx="ekr.20250122151620.1580">from __future__ import annotations

import copy
import inspect
import itertools as it
import random
import sys
import types
from collections.abc import Iterable, Iterator, Sequence
from functools import partialmethod, wraps
from math import ceil
from typing import TYPE_CHECKING, Any, Callable, TypeVar

import moderngl
import numpy as np

from manim import config, logger
from manim.constants import *
from manim.renderer.shader_wrapper import get_colormap_code
from manim.utils.bezier import integer_interpolate, interpolate
from manim.utils.color import (
    WHITE,
    ManimColor,
    ParsableManimColor,
    color_gradient,
    color_to_rgb,
    rgb_to_hex,
)
from manim.utils.config_ops import _Data, _Uniforms

# from ..utils.iterables import batch_by_property
from manim.utils.iterables import (
    batch_by_property,
    list_update,
    listify,
    make_even,
    resize_array,
    resize_preserving_order,
    resize_with_interpolation,
    uniq_chain,
)
from manim.utils.paths import straight_path
from manim.utils.space_ops import (
    angle_between_vectors,
    normalize,
    rotation_matrix_transpose,
)

if TYPE_CHECKING:
    import numpy.typing as npt
    from typing_extensions import Self, TypeAlias

    from manim.renderer.shader_wrapper import ShaderWrapper
    from manim.typing import (
        ManimFloat,
        MappingFunction,
        MatrixMN,
        MultiMappingFunction,
        PathFuncType,
        Point3D,
        Point3D_Array,
        Point3DLike,
        Point3DLike_Array,
        Vector3D,
    )

    TimeBasedUpdater: TypeAlias = Callable[["Mobject", float], object]
    NonTimeBasedUpdater: TypeAlias = Callable[["Mobject"], object]
    Updater: TypeAlias = NonTimeBasedUpdater | TimeBasedUpdater

    T = TypeVar("T")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1581">def affects_shader_info_id(
    func: Callable[[OpenGLMobject], OpenGLMobject],
) -&gt; Callable[[OpenGLMobject], OpenGLMobject]:
    @wraps(func)
    def wrapper(self: OpenGLMobject) -&gt; OpenGLMobject:
        for mob in self.get_family():
            func(mob)
            mob.refresh_shader_wrapper_id()
        return self

    return wrapper


</t>
<t tx="ekr.20250122151620.1582">__all__ = ["OpenGLMobject", "OpenGLGroup", "OpenGLPoint", "_AnimationBuilder"]


class OpenGLMobject:
    """Mathematical Object: base class for objects that can be displayed on screen.

    Attributes
    ----------
    submobjects : List[:class:`OpenGLMobject`]
        The contained objects.
    points : :class:`numpy.ndarray`
        The points of the objects.

        .. seealso::

            :class:`~.OpenGLVMobject`

    """

    @others
</t>
<t tx="ekr.20250122151620.1583">class OpenGLGroup(OpenGLMobject):
    @others
</t>
<t tx="ekr.20250122151620.1584">class OpenGLPoint(OpenGLMobject):
    @others
</t>
<t tx="ekr.20250122151620.1585">class _AnimationBuilder:
    @others
</t>
<t tx="ekr.20250122151620.1586">def override_animate(method: types.FunctionType) -&gt; types.FunctionType:
    r"""Decorator for overriding method animations.

    This allows to specify a method (returning an :class:`~.Animation`)
    which is called when the decorated method is used with the ``.animate`` syntax
    for animating the application of a method.

    .. seealso::

        :attr:`OpenGLMobject.animate`

    .. note::

        Overridden methods cannot be combined with normal or other overridden
        methods using method chaining with the ``.animate`` syntax.


    Examples
    --------

    .. manim:: AnimationOverrideExample

        class CircleWithContent(VGroup):
            def __init__(self, content):
                super().__init__()
                self.circle = Circle()
                self.content = content
                self.add(self.circle, content)
                content.move_to(self.circle.get_center())

            def clear_content(self):
                self.remove(self.content)
                self.content = None

            @override_animate(clear_content)
            def _clear_content_animation(self, anim_args=None):
                if anim_args is None:
                    anim_args = {}
                anim = Uncreate(self.content, **anim_args)
                self.clear_content()
                return anim

        class AnimationOverrideExample(Scene):
            def construct(self):
                t = Text("hello!")
                my_mobject = CircleWithContent(t)
                self.play(Create(my_mobject))
                self.play(my_mobject.animate.clear_content())
                self.wait()

    """

    def decorator(animation_method):
        method._override_animate = animation_method
        return animation_method

    return decorator
</t>
<t tx="ekr.20250122151620.1587">shader_dtype = [
    ("point", np.float32, (3,)),
]
shader_folder = ""

# _Data and _Uniforms are set as class variables to tell manim how to handle setting/getting these attributes later.
points = _Data()
bounding_box = _Data()
rgbas = _Data()

is_fixed_in_frame = _Uniforms()
is_fixed_orientation = _Uniforms()
fixed_orientation_center = _Uniforms()  # for fixed orientation reference
gloss = _Uniforms()
shadow = _Uniforms()

def __init__(
    self,
    color: ParsableManimColor | Iterable[ParsableManimColor] = WHITE,
    opacity: float = 1,
    dim: int = 3,  # TODO, get rid of this
    # Lighting parameters
    # Positive gloss up to 1 makes it reflect the light.
    gloss: float = 0.0,
    # Positive shadow up to 1 makes a side opposite the light darker
    shadow: float = 0.0,
    # For shaders
    render_primitive: int = moderngl.TRIANGLES,
    texture_paths: dict[str, str] | None = None,
    depth_test: bool = False,
    # If true, the mobject will not get rotated according to camera position
    is_fixed_in_frame: bool = False,
    is_fixed_orientation: bool = False,
    # Must match in attributes of vert shader
    # Event listener
    listen_to_events: bool = False,
    model_matrix: MatrixMN | None = None,
    should_render: bool = True,
    name: str | None = None,
    **kwargs,
):
    self.name = self.__class__.__name__ if name is None else name
    # getattr in case data/uniforms are already defined in parent classes.
    self.data = getattr(self, "data", {})
    self.uniforms = getattr(self, "uniforms", {})

    self.opacity = opacity
    self.dim = dim  # TODO, get rid of this
    # Lighting parameters
    # Positive gloss up to 1 makes it reflect the light.
    self.gloss = gloss
    # Positive shadow up to 1 makes a side opposite the light darker
    self.shadow = shadow
    # For shaders
    self.render_primitive = render_primitive
    self.texture_paths = texture_paths
    self.depth_test = depth_test
    # If true, the mobject will not get rotated according to camera position
    self.is_fixed_in_frame = float(is_fixed_in_frame)
    self.is_fixed_orientation = float(is_fixed_orientation)
    self.fixed_orientation_center = (0, 0, 0)
    # Must match in attributes of vert shader
    # Event listener
    self.listen_to_events = listen_to_events

    self._submobjects = []
    self.parents = []
    self.parent = None
    self.family = [self]
    self.locked_data_keys = set()
    self.needs_new_bounding_box = True
    if model_matrix is None:
        self.model_matrix = np.eye(4)
    else:
        self.model_matrix = model_matrix

    self.init_data()
    self.init_updaters()
    # self.init_event_listners()
    self.init_points()
    self.color = ManimColor.parse(color)
    self.init_colors()

    self.shader_indices = None

    if self.depth_test:
        self.apply_depth_test()

    self.should_render = should_render

</t>
<t tx="ekr.20250122151620.1588">def _assert_valid_submobjects(self, submobjects: Iterable[OpenGLMobject]) -&gt; Self:
    """Check that all submobjects are actually instances of
    :class:`OpenGLMobject`, and that none of them is
    ``self`` (an :class:`OpenGLMobject` cannot contain itself).

    This is an auxiliary function called when adding OpenGLMobjects to the
    :attr:`submobjects` list.

    This function is intended to be overridden by subclasses such as
    :class:`OpenGLVMobject`, which should assert that only other
    OpenGLVMobjects may be added into it.

    Parameters
    ----------
    submobjects
        The list containing values to validate.

    Returns
    -------
    :class:`OpenGLMobject`
        The OpenGLMobject itself.

    Raises
    ------
    TypeError
        If any of the values in `submobjects` is not an
        :class:`OpenGLMobject`.
    ValueError
        If there was an attempt to add an :class:`OpenGLMobject` as its own
        submobject.
    """
    return self._assert_valid_submobjects_internal(submobjects, OpenGLMobject)

</t>
<t tx="ekr.20250122151620.1589">def _assert_valid_submobjects_internal(
    self, submobjects: Iterable[OpenGLMobject], mob_class: type[OpenGLMobject]
) -&gt; Self:
    for i, submob in enumerate(submobjects):
        if not isinstance(submob, mob_class):
            error_message = (
                f"Only values of type {mob_class.__name__} can be added "
                f"as submobjects of {type(self).__name__}, but the value "
                f"{submob} (at index {i}) is of type "
                f"{type(submob).__name__}."
            )
            # Intended for subclasses such as OpenGLVMobject, which
            # cannot have regular OpenGLMobjects as submobjects
            if isinstance(submob, OpenGLMobject):
                error_message += (
                    " You can try adding this value into a Group instead."
                )
            raise TypeError(error_message)
        if submob is self:
            raise ValueError(
                f"Cannot add {type(self).__name__} as a submobject of "
                f"itself (at index {i})."
            )
    return self

</t>
<t tx="ekr.20250122151620.159">@property
def use_projection_stroke_shaders(self) -&gt; bool:
    """Use shaders for OpenGLVMobject stroke which are compatible with transformation matrices."""
    return self._d["use_projection_stroke_shaders"]

</t>
<t tx="ekr.20250122151620.1590">@classmethod
def __init_subclass__(cls, **kwargs) -&gt; None:
    super().__init_subclass__(**kwargs)
    cls._original__init__ = cls.__init__

</t>
<t tx="ekr.20250122151620.1591">def __str__(self) -&gt; str:
    return self.__class__.__name__

</t>
<t tx="ekr.20250122151620.1592">def __repr__(self) -&gt; str:
    return str(self.name)

</t>
<t tx="ekr.20250122151620.1593">def __sub__(self, other):
    return NotImplemented

</t>
<t tx="ekr.20250122151620.1594">def __isub__(self, other):
    return NotImplemented

</t>
<t tx="ekr.20250122151620.1595">def __add__(self, mobject):
    return NotImplemented

</t>
<t tx="ekr.20250122151620.1596">def __iadd__(self, mobject):
    return NotImplemented

</t>
<t tx="ekr.20250122151620.1597">@classmethod
def set_default(cls, **kwargs) -&gt; None:
    """Sets the default values of keyword arguments.

    If this method is called without any additional keyword
    arguments, the original default values of the initialization
    method of this class are restored.

    Parameters
    ----------

    kwargs
        Passing any keyword argument will update the default
        values of the keyword arguments of the initialization
        function of this class.

    Examples
    --------

    ::

        &gt;&gt;&gt; from manim import Square, GREEN
        &gt;&gt;&gt; Square.set_default(color=GREEN, fill_opacity=0.25)
        &gt;&gt;&gt; s = Square(); s.color, s.fill_opacity
        (ManimColor('#83C167'), 0.25)
        &gt;&gt;&gt; Square.set_default()
        &gt;&gt;&gt; s = Square(); s.color, s.fill_opacity
        (ManimColor('#FFFFFF'), 0.0)

    .. manim:: ChangedDefaultTextcolor
        :save_last_frame:

        config.background_color = WHITE

        class ChangedDefaultTextcolor(Scene):
            def construct(self):
                Text.set_default(color=BLACK)
                self.add(Text("Changing default values is easy!"))

                # we revert the colour back to the default to prevent a bug in the docs.
                Text.set_default(color=WHITE)

    """
    if kwargs:
        cls.__init__ = partialmethod(cls.__init__, **kwargs)
    else:
        cls.__init__ = cls._original__init__

</t>
<t tx="ekr.20250122151620.1598">def init_data(self) -&gt; None:
    """Initializes the ``points``, ``bounding_box`` and ``rgbas`` attributes and groups them into self.data.
    Subclasses can inherit and overwrite this method to extend `self.data`.
    """
    self.points = np.zeros((0, 3))
    self.bounding_box = np.zeros((3, 3))
    self.rgbas = np.zeros((1, 4))

</t>
<t tx="ekr.20250122151620.1599">def init_colors(self) -&gt; object:
    """Initializes the colors.

    Gets called upon creation
    """
    self.set_color(self.color, self.opacity)

</t>
<t tx="ekr.20250122151620.16">def tempconfig(temp: ManimConfig | dict[str, Any]) -&gt; Generator[None, None, None]:
    """Context manager that temporarily modifies the global ``config`` object.

    Inside the ``with`` statement, the modified config will be used.  After
    context manager exits, the config will be restored to its original state.

    Parameters
    ----------
    temp
        Object whose keys will be used to temporarily update the global
        ``config``.

    Examples
    --------

    Use ``with tempconfig({...})`` to temporarily change the default values of
    certain config options.

    .. code-block:: pycon

       &gt;&gt;&gt; config["frame_height"]
       8.0
       &gt;&gt;&gt; with tempconfig({"frame_height": 100.0}):
       ...     print(config["frame_height"])
       100.0
       &gt;&gt;&gt; config["frame_height"]
       8.0

    """
    global config
    original = config.copy()

    temp = {k: v for k, v in temp.items() if k in original}

    # In order to change the config that every module has access to, use
    # update(), DO NOT use assignment.  Assigning config = some_dict will just
    # make the local variable named config point to a new dictionary, it will
    # NOT change the dictionary that every module has a reference to.
    config.update(temp)
    try:
        yield
    finally:
        config.update(original)  # update, not assignment!
</t>
<t tx="ekr.20250122151620.160">@use_projection_stroke_shaders.setter
def use_projection_stroke_shaders(self, value: bool) -&gt; None:
    self._set_boolean("use_projection_stroke_shaders", value)

</t>
<t tx="ekr.20250122151620.1600">def init_points(self) -&gt; object:
    """Initializes :attr:`points` and therefore the shape.

    Gets called upon creation. This is an empty method that can be implemented by
    subclasses.
    """
    # Typically implemented in subclass, unless purposefully left blank
    pass

</t>
<t tx="ekr.20250122151620.1601">def set(self, **kwargs) -&gt; Self:
    """Sets attributes.

    Mainly to be used along with :attr:`animate` to
    animate setting attributes.

    Examples
    --------
    ::

        &gt;&gt;&gt; mob = OpenGLMobject()
        &gt;&gt;&gt; mob.set(foo=0)
        OpenGLMobject
        &gt;&gt;&gt; mob.foo
        0

    Parameters
    ----------
    **kwargs
        The attributes and corresponding values to set.

    Returns
    -------
    :class:`OpenGLMobject`
        ``self``


    """
    for attr, value in kwargs.items():
        setattr(self, attr, value)

    return self

</t>
<t tx="ekr.20250122151620.1602">def set_data(self, data: dict[str, Any]) -&gt; Self:
    for key in data:
        self.data[key] = data[key].copy()
    return self

</t>
<t tx="ekr.20250122151620.1603">def set_uniforms(self, uniforms: dict[str, Any]) -&gt; Self:
    for key in uniforms:
        self.uniforms[key] = uniforms[key]  # Copy?
    return self

</t>
<t tx="ekr.20250122151620.1604">@property
def animate(self) -&gt; _AnimationBuilder | Self:
    """Used to animate the application of a method.

    .. warning::

        Passing multiple animations for the same :class:`OpenGLMobject` in one
        call to :meth:`~.Scene.play` is discouraged and will most likely
        not work properly. Instead of writing an animation like

        ::

            self.play(
                my_mobject.animate.shift(RIGHT), my_mobject.animate.rotate(PI)
            )

        make use of method chaining for ``animate``, meaning::

            self.play(my_mobject.animate.shift(RIGHT).rotate(PI))

    Keyword arguments that can be passed to :meth:`.Scene.play` can be passed
    directly after accessing ``.animate``, like so::

        self.play(my_mobject.animate(rate_func=linear).shift(RIGHT))

    This is especially useful when animating simultaneous ``.animate`` calls that
    you want to behave differently::

        self.play(
            mobject1.animate(run_time=2).rotate(PI),
            mobject2.animate(rate_func=there_and_back).shift(RIGHT),
        )

    .. seealso::

        :func:`override_animate`


    Examples
    --------

    .. manim:: AnimateExample

        class AnimateExample(Scene):
            def construct(self):
                s = Square()
                self.play(Create(s))
                self.play(s.animate.shift(RIGHT))
                self.play(s.animate.scale(2))
                self.play(s.animate.rotate(PI / 2))
                self.play(Uncreate(s))


    .. manim:: AnimateChainExample

        class AnimateChainExample(Scene):
            def construct(self):
                s = Square()
                self.play(Create(s))
                self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))
                self.play(Uncreate(s))

    .. manim:: AnimateWithArgsExample

        class AnimateWithArgsExample(Scene):
            def construct(self):
                s = Square()
                c = Circle()

                VGroup(s, c).arrange(RIGHT, buff=2)
                self.add(s, c)

                self.play(
                    s.animate(run_time=2).rotate(PI / 2),
                    c.animate(rate_func=there_and_back).shift(RIGHT),
                )

    .. warning::

        ``.animate``
         will interpolate the :class:`~.OpenGLMobject` between its points prior to
         ``.animate`` and its points after applying ``.animate`` to it. This may
         result in unexpected behavior when attempting to interpolate along paths,
         or rotations.
         If you want animations to consider the points between, consider using
         :class:`~.ValueTracker` with updaters instead.

    """
    return _AnimationBuilder(self)

</t>
<t tx="ekr.20250122151620.1605">@property
def width(self) -&gt; float:
    """The width of the mobject.

    Returns
    -------
    :class:`float`

    Examples
    --------
    .. manim:: WidthExample

        class WidthExample(Scene):
            def construct(self):
                decimal = DecimalNumber().to_edge(UP)
                rect = Rectangle(color=BLUE)
                rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

                decimal.add_updater(lambda d: d.set_value(rect.width))

                self.add(rect_copy, rect, decimal)
                self.play(rect.animate.set(width=7))
                self.wait()

    See also
    --------
    :meth:`length_over_dim`

    """
    # Get the length across the X dimension
    return self.length_over_dim(0)

</t>
<t tx="ekr.20250122151620.1606"># Only these methods should directly affect points
@width.setter
def width(self, value: float) -&gt; None:
    self.rescale_to_fit(value, 0, stretch=False)

</t>
<t tx="ekr.20250122151620.1607">@property
def height(self) -&gt; float:
    """The height of the mobject.

    Returns
    -------
    :class:`float`

    Examples
    --------
    .. manim:: HeightExample

        class HeightExample(Scene):
            def construct(self):
                decimal = DecimalNumber().to_edge(UP)
                rect = Rectangle(color=BLUE)
                rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

                decimal.add_updater(lambda d: d.set_value(rect.height))

                self.add(rect_copy, rect, decimal)
                self.play(rect.animate.set(height=5))
                self.wait()

    See also
    --------
    :meth:`length_over_dim`

    """
    # Get the length across the Y dimension
    return self.length_over_dim(1)

</t>
<t tx="ekr.20250122151620.1608">@height.setter
def height(self, value: float) -&gt; None:
    self.rescale_to_fit(value, 1, stretch=False)

</t>
<t tx="ekr.20250122151620.1609">@property
def depth(self) -&gt; float:
    """The depth of the mobject.

    Returns
    -------
    :class:`float`

    See also
    --------
    :meth:`length_over_dim`

    """
    # Get the length across the Z dimension
    return self.length_over_dim(2)

</t>
<t tx="ekr.20250122151620.161">@property
def zero_pad(self) -&gt; int:
    """PNG zero padding. A number between 0 (no zero padding) and 9 (9 columns minimum)."""
    return self._d["zero_pad"]

</t>
<t tx="ekr.20250122151620.1610">@depth.setter
def depth(self, value: float) -&gt; None:
    self.rescale_to_fit(value, 2, stretch=False)

</t>
<t tx="ekr.20250122151620.1611">def resize_points(self, new_length, resize_func=resize_array):
    if new_length != len(self.points):
        self.points = resize_func(self.points, new_length)
    self.refresh_bounding_box()
    return self

</t>
<t tx="ekr.20250122151620.1612">def set_points(self, points: Point3DLike_Array) -&gt; Self:
    if len(points) == len(self.points):
        self.points[:] = points
    elif isinstance(points, np.ndarray):
        self.points = points.copy()
    else:
        self.points = np.array(points)
    self.refresh_bounding_box()
    return self

</t>
<t tx="ekr.20250122151620.1613">def apply_over_attr_arrays(
    self, func: Callable[[npt.NDArray[T]], npt.NDArray[T]]
) -&gt; Self:
    # TODO: OpenGLMobject.get_array_attrs() doesn't even exist!
    for attr in self.get_array_attrs():
        setattr(self, attr, func(getattr(self, attr)))
    return self

</t>
<t tx="ekr.20250122151620.1614">def append_points(self, new_points: Point3DLike_Array) -&gt; Self:
    self.points = np.vstack([self.points, new_points])
    self.refresh_bounding_box()
    return self

</t>
<t tx="ekr.20250122151620.1615">def reverse_points(self) -&gt; Self:
    for mob in self.get_family():
        for key in mob.data:
            mob.data[key] = mob.data[key][::-1]
    return self

</t>
<t tx="ekr.20250122151620.1616">def get_midpoint(self) -&gt; Point3D:
    """Get coordinates of the middle of the path that forms the  :class:`~.OpenGLMobject`.

    Examples
    --------

    .. manim:: AngleMidPoint
        :save_last_frame:

        class AngleMidPoint(Scene):
            def construct(self):
                line1 = Line(ORIGIN, 2*RIGHT)
                line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)

                a = Angle(line1, line2, radius=1.5, other_angle=False)
                d = Dot(a.get_midpoint()).set_color(RED)

                self.add(line1, line2, a, d)
                self.wait()

    """
    return self.point_from_proportion(0.5)

</t>
<t tx="ekr.20250122151620.1617"># TODO: name is inconsistent with Mobject.apply_points_function_about_point()
def apply_points_function(
    self,
    func: MultiMappingFunction,
    about_point: Point3DLike | None = None,
    about_edge: Vector3D | None = ORIGIN,
    works_on_bounding_box: bool = False,
) -&gt; Self:
    if about_point is None and about_edge is not None:
        about_point = self.get_bounding_box_point(about_edge)

    for mob in self.get_family():
        arrs = []
        if mob.has_points():
            arrs.append(mob.points)
        if works_on_bounding_box:
            arrs.append(mob.get_bounding_box())

        for arr in arrs:
            if about_point is None:
                arr[:] = func(arr)
            else:
                arr[:] = func(arr - about_point) + about_point

    if not works_on_bounding_box:
        self.refresh_bounding_box(recurse_down=True)
    else:
        for parent in self.parents:
            parent.refresh_bounding_box()
    return self

</t>
<t tx="ekr.20250122151620.1618"># Others related to points

def match_points(self, mobject: OpenGLMobject) -&gt; Self:
    """Edit points, positions, and submobjects to be identical
    to another :class:`~.OpenGLMobject`, while keeping the style unchanged.

    Examples
    --------
    .. manim:: MatchPointsScene

        class MatchPointsScene(Scene):
            def construct(self):
                circ = Circle(fill_color=RED, fill_opacity=0.8)
                square = Square(fill_color=BLUE, fill_opacity=0.2)
                self.add(circ)
                self.wait(0.5)
                self.play(circ.animate.match_points(square))
                self.wait(0.5)
    """
    self.set_points(mobject.points)
    return self

</t>
<t tx="ekr.20250122151620.1619">def clear_points(self) -&gt; Self:
    self.points = np.empty((0, 3))
    return self

</t>
<t tx="ekr.20250122151620.162">@zero_pad.setter
def zero_pad(self, value: int) -&gt; None:
    self._set_int_between("zero_pad", value, 0, 9)

</t>
<t tx="ekr.20250122151620.1620">def get_num_points(self) -&gt; int:
    return len(self.points)

</t>
<t tx="ekr.20250122151620.1621">def get_all_points(self) -&gt; Point3D_Array:
    if self.submobjects:
        return np.vstack([sm.points for sm in self.get_family()])
    else:
        return self.points

</t>
<t tx="ekr.20250122151620.1622">def has_points(self) -&gt; bool:
    return self.get_num_points() &gt; 0

</t>
<t tx="ekr.20250122151620.1623">def get_bounding_box(self) -&gt; npt.NDArray[float]:
    if self.needs_new_bounding_box:
        self.bounding_box = self.compute_bounding_box()
        self.needs_new_bounding_box = False
    return self.bounding_box

</t>
<t tx="ekr.20250122151620.1624">def compute_bounding_box(self) -&gt; npt.NDArray[float]:
    all_points = np.vstack(
        [
            self.points,
            *(
                mob.get_bounding_box()
                for mob in self.get_family()[1:]
                if mob.has_points()
            ),
        ],
    )
    if len(all_points) == 0:
        return np.zeros((3, self.dim))
    else:
        # Lower left and upper right corners
        mins = all_points.min(0)
        maxs = all_points.max(0)
        mids = (mins + maxs) / 2
        return np.array([mins, mids, maxs])

</t>
<t tx="ekr.20250122151620.1625">def refresh_bounding_box(
    self, recurse_down: bool = False, recurse_up: bool = True
) -&gt; Self:
    for mob in self.get_family(recurse_down):
        mob.needs_new_bounding_box = True
    if recurse_up:
        for parent in self.parents:
            parent.refresh_bounding_box()
    return self

</t>
<t tx="ekr.20250122151620.1626">def is_point_touching(
    self, point: Point3DLike, buff: float = MED_SMALL_BUFF
) -&gt; bool:
    bb = self.get_bounding_box()
    mins = bb[0] - buff
    maxs = bb[2] + buff
    return (point &gt;= mins).all() and (point &lt;= maxs).all()

</t>
<t tx="ekr.20250122151620.1627"># Family matters

def __getitem__(self, value: int | slice) -&gt; OpenGLMobject:
    if isinstance(value, slice):
        GroupClass = self.get_group_class()
        return GroupClass(*self.split().__getitem__(value))
    return self.split().__getitem__(value)

</t>
<t tx="ekr.20250122151620.1628">def __iter__(self) -&gt; Iterator[OpenGLMobject]:
    return iter(self.split())

</t>
<t tx="ekr.20250122151620.1629">def __len__(self) -&gt; int:
    return len(self.split())

</t>
<t tx="ekr.20250122151620.163">def get_dir(self, key: str, **kwargs: Any) -&gt; Path:
    """Resolve a config option that stores a directory.

    Config options that store directories may depend on one another.  This
    method is used to provide the actual directory to the end user.

    Parameters
    ----------
    key
        The config option to be resolved.  Must be an option ending in
        ``'_dir'``, for example ``'media_dir'`` or ``'video_dir'``.

    kwargs
        Any strings to be used when resolving the directory.

    Returns
    -------
    :class:`pathlib.Path`
        Path to the requested directory.  If the path resolves to the empty
        string, return ``None`` instead.

    Raises
    ------
    :class:`KeyError`
        When ``key`` is not a config option that stores a directory and
        thus :meth:`~ManimConfig.get_dir` is not appropriate; or when
        ``key`` is appropriate but there is not enough information to
        resolve the directory.

    Notes
    -----
    Standard :meth:`str.format` syntax is used to resolve the paths so the
    paths may contain arbitrary placeholders using f-string notation.
    However, these will require ``kwargs`` to contain the required values.

    Examples
    --------

    The value of ``config.tex_dir`` is ``'{media_dir}/Tex'`` by default,
    i.e. it is a subfolder of wherever ``config.media_dir`` is located.  In
    order to get the *actual* directory, use :meth:`~ManimConfig.get_dir`.

    .. code-block:: pycon

        &gt;&gt;&gt; from manim import config as globalconfig
        &gt;&gt;&gt; config = globalconfig.copy()
        &gt;&gt;&gt; config.tex_dir
        '{media_dir}/Tex'
        &gt;&gt;&gt; config.media_dir
        './media'
        &gt;&gt;&gt; config.get_dir("tex_dir").as_posix()
        'media/Tex'

    Resolving directories is done in a lazy way, at the last possible
    moment, to reflect any changes in other config options:

    .. code-block:: pycon

        &gt;&gt;&gt; config.media_dir = "my_media_dir"
        &gt;&gt;&gt; config.get_dir("tex_dir").as_posix()
        'my_media_dir/Tex'

    Some directories depend on information that is not available to
    :class:`ManimConfig`. For example, the default value of `video_dir`
    includes the name of the input file and the video quality
    (e.g. 480p15). This informamtion has to be supplied via ``kwargs``:

    .. code-block:: pycon

        &gt;&gt;&gt; config.video_dir
        '{media_dir}/videos/{module_name}/{quality}'
        &gt;&gt;&gt; config.get_dir("video_dir")
        Traceback (most recent call last):
        KeyError: 'video_dir {media_dir}/videos/{module_name}/{quality} requires the following keyword arguments: module_name'
        &gt;&gt;&gt; config.get_dir("video_dir", module_name="myfile").as_posix()
        'my_media_dir/videos/myfile/1080p60'

    Note the quality does not need to be passed as keyword argument since
    :class:`ManimConfig` does store information about quality.

    Directories may be recursively defined.  For example, the config option
    ``partial_movie_dir`` depends on ``video_dir``, which in turn depends
    on ``media_dir``:

    .. code-block:: pycon

        &gt;&gt;&gt; config.partial_movie_dir
        '{video_dir}/partial_movie_files/{scene_name}'
        &gt;&gt;&gt; config.get_dir("partial_movie_dir")
        Traceback (most recent call last):
        KeyError: 'partial_movie_dir {video_dir}/partial_movie_files/{scene_name} requires the following keyword arguments: scene_name'
        &gt;&gt;&gt; config.get_dir(
        ...     "partial_movie_dir", module_name="myfile", scene_name="myscene"
        ... ).as_posix()
        'my_media_dir/videos/myfile/1080p60/partial_movie_files/myscene'

    Standard f-string syntax is used.  Arbitrary names can be used when
    defining directories, as long as the corresponding values are passed to
    :meth:`ManimConfig.get_dir` via ``kwargs``.

    .. code-block:: pycon

        &gt;&gt;&gt; config.media_dir = "{dir1}/{dir2}"
        &gt;&gt;&gt; config.get_dir("media_dir")
        Traceback (most recent call last):
        KeyError: 'media_dir {dir1}/{dir2} requires the following keyword arguments: dir1'
        &gt;&gt;&gt; config.get_dir("media_dir", dir1="foo", dir2="bar").as_posix()
        'foo/bar'
        &gt;&gt;&gt; config.media_dir = "./media"
        &gt;&gt;&gt; config.get_dir("media_dir").as_posix()
        'media'

    """
    dirs = [
        "assets_dir",
        "media_dir",
        "video_dir",
        "sections_dir",
        "images_dir",
        "text_dir",
        "tex_dir",
        "log_dir",
        "input_file",
        "output_file",
        "partial_movie_dir",
    ]
    if key not in dirs:
        raise KeyError(
            "must pass one of "
            "{media,video,images,text,tex,log}_dir "
            "or {input,output}_file",
        )

    dirs.remove(key)  # a path cannot contain itself

    all_args = {k: self._d[k] for k in dirs}
    all_args.update(kwargs)
    all_args["quality"] = f"{self.pixel_height}p{self.frame_rate:g}"

    path = self._d[key]
    while "{" in path:
        try:
            path = path.format(**all_args)
        except KeyError as exc:
            raise KeyError(
                f"{key} {self._d[key]} requires the following "
                + "keyword arguments: "
                + " ".join(exc.args),
            ) from exc
    return Path(path) if path else None

</t>
<t tx="ekr.20250122151620.1630">def split(self) -&gt; Sequence[OpenGLMobject]:
    return self.submobjects

</t>
<t tx="ekr.20250122151620.1631">def assemble_family(self) -&gt; Self:
    sub_families = (sm.get_family() for sm in self.submobjects)
    self.family = [self, *uniq_chain(*sub_families)]
    self.refresh_has_updater_status()
    self.refresh_bounding_box()
    for parent in self.parents:
        parent.assemble_family()
    return self

</t>
<t tx="ekr.20250122151620.1632">def get_family(self, recurse: bool = True) -&gt; Sequence[OpenGLMobject]:
    if recurse and hasattr(self, "family"):
        return self.family
    else:
        return [self]

</t>
<t tx="ekr.20250122151620.1633">def family_members_with_points(self) -&gt; Sequence[OpenGLMobject]:
    return [m for m in self.get_family() if m.has_points()]

</t>
<t tx="ekr.20250122151620.1634">def add(self, *mobjects: OpenGLMobject, update_parent: bool = False) -&gt; Self:
    """Add mobjects as submobjects.

    The mobjects are added to :attr:`submobjects`.

    Subclasses of mobject may implement ``+`` and ``+=`` dunder methods.

    Parameters
    ----------
    mobjects
        The mobjects to add.

    Returns
    -------
    :class:`OpenGLMobject`
        ``self``

    Raises
    ------
    :class:`ValueError`
        When a mobject tries to add itself.
    :class:`TypeError`
        When trying to add an object that is not an instance of :class:`OpenGLMobject`.


    Notes
    -----
    A mobject cannot contain itself, and it cannot contain a submobject
    more than once.  If the parent mobject is displayed, the newly-added
    submobjects will also be displayed (i.e. they are automatically added
    to the parent Scene).

    See Also
    --------
    :meth:`remove`
    :meth:`add_to_back`

    Examples
    --------
    ::

        &gt;&gt;&gt; outer = OpenGLMobject()
        &gt;&gt;&gt; inner = OpenGLMobject()
        &gt;&gt;&gt; outer = outer.add(inner)

    Duplicates are not added again::

        &gt;&gt;&gt; outer = outer.add(inner)
        &gt;&gt;&gt; len(outer.submobjects)
        1

    Only OpenGLMobjects can be added::

        &gt;&gt;&gt; outer.add(3)
        Traceback (most recent call last):
        ...
        TypeError: Only values of type OpenGLMobject can be added as submobjects of OpenGLMobject, but the value 3 (at index 0) is of type int.

    Adding an object to itself raises an error::

        &gt;&gt;&gt; outer.add(outer)
        Traceback (most recent call last):
        ...
        ValueError: Cannot add OpenGLMobject as a submobject of itself (at index 0).

    """
    if update_parent:
        assert len(mobjects) == 1, "Can't set multiple parents."
        mobjects[0].parent = self

    self._assert_valid_submobjects(mobjects)

    if any(mobjects.count(elem) &gt; 1 for elem in mobjects):
        logger.warning(
            "Attempted adding some Mobject as a child more than once, "
            "this is not possible. Repetitions are ignored.",
        )
    for mobject in mobjects:
        if mobject not in self.submobjects:
            self.submobjects.append(mobject)
        if self not in mobject.parents:
            mobject.parents.append(self)
    self.assemble_family()
    return self

</t>
<t tx="ekr.20250122151620.1635">def insert(
    self, index: int, mobject: OpenGLMobject, update_parent: bool = False
) -&gt; Self:
    """Inserts a mobject at a specific position into self.submobjects

    Effectively just calls  ``self.submobjects.insert(index, mobject)``,
    where ``self.submobjects`` is a list.

    Highly adapted from ``OpenGLMobject.add``.

    Parameters
    ----------
    index
        The index at which
    mobject
        The mobject to be inserted.
    update_parent
        Whether or not to set ``mobject.parent`` to ``self``.
    """
    if update_parent:
        mobject.parent = self

    self._assert_valid_submobjects([mobject])

    if mobject not in self.submobjects:
        self.submobjects.insert(index, mobject)

    if self not in mobject.parents:
        mobject.parents.append(self)

    self.assemble_family()
    return self

</t>
<t tx="ekr.20250122151620.1636">def remove(self, *mobjects: OpenGLMobject, update_parent: bool = False) -&gt; Self:
    """Remove :attr:`submobjects`.

    The mobjects are removed from :attr:`submobjects`, if they exist.

    Subclasses of mobject may implement ``-`` and ``-=`` dunder methods.

    Parameters
    ----------
    mobjects
        The mobjects to remove.

    Returns
    -------
    :class:`OpenGLMobject`
        ``self``

    See Also
    --------
    :meth:`add`

    """
    if update_parent:
        assert len(mobjects) == 1, "Can't remove multiple parents."
        mobjects[0].parent = None

    for mobject in mobjects:
        if mobject in self.submobjects:
            self.submobjects.remove(mobject)
        if self in mobject.parents:
            mobject.parents.remove(self)
    self.assemble_family()
    return self

</t>
<t tx="ekr.20250122151620.1637">def add_to_back(self, *mobjects: OpenGLMobject) -&gt; Self:
    # NOTE: is the note true OpenGLMobjects?
    """Add all passed mobjects to the back of the submobjects.

    If :attr:`submobjects` already contains the given mobjects, they just get moved
    to the back instead.

    Parameters
    ----------
    mobjects
        The mobjects to add.

    Returns
    -------
    :class:`OpenGLMobject`
        ``self``


    .. note::

        Technically, this is done by adding (or moving) the mobjects to
        the head of :attr:`submobjects`. The head of this list is rendered
        first, which places the corresponding mobjects behind the
        subsequent list members.

    Raises
    ------
    :class:`ValueError`
        When a mobject tries to add itself.
    :class:`TypeError`
        When trying to add an object that is not an instance of :class:`OpenGLMobject`.

    Notes
    -----
    A mobject cannot contain itself, and it cannot contain a submobject
    more than once.  If the parent mobject is displayed, the newly-added
    submobjects will also be displayed (i.e. they are automatically added
    to the parent Scene).

    See Also
    --------
    :meth:`remove`
    :meth:`add`

    """
    self._assert_valid_submobjects(mobjects)
    self.submobjects = list_update(mobjects, self.submobjects)
    return self

</t>
<t tx="ekr.20250122151620.1638">def replace_submobject(self, index: int, new_submob: OpenGLMobject) -&gt; Self:
    self._assert_valid_submobjects([new_submob])
    old_submob = self.submobjects[index]
    if self in old_submob.parents:
        old_submob.parents.remove(self)
    self.submobjects[index] = new_submob
    self.assemble_family()
    return self

</t>
<t tx="ekr.20250122151620.1639"># Submobject organization

def arrange(
    self, direction: Vector3D = RIGHT, center: bool = True, **kwargs
) -&gt; Self:
    """Sorts :class:`~.OpenGLMobject` next to each other on screen.

    Examples
    --------

    .. manim:: Example
        :save_last_frame:

        class Example(Scene):
            def construct(self):
                s1 = Square()
                s2 = Square()
                s3 = Square()
                s4 = Square()
                x = OpenGLVGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)
                self.add(x)
    """
    for m1, m2 in zip(self.submobjects, self.submobjects[1:]):
        m2.next_to(m1, direction, **kwargs)
    if center:
        self.center()
    return self

</t>
<t tx="ekr.20250122151620.164">def _set_dir(self, key: str, val: str | Path) -&gt; None:
    if isinstance(val, Path):
        self._d.__setitem__(key, str(val))
    else:
        self._d.__setitem__(key, val)

</t>
<t tx="ekr.20250122151620.1640">def arrange_in_grid(
    self,
    rows: int | None = None,
    cols: int | None = None,
    buff: float | tuple[float, float] = MED_SMALL_BUFF,
    cell_alignment: Vector3D = ORIGIN,
    row_alignments: str | None = None,  # "ucd"
    col_alignments: str | None = None,  # "lcr"
    row_heights: Sequence[float | None] | None = None,
    col_widths: Sequence[float | None] | None = None,
    flow_order: str = "rd",
    **kwargs,
) -&gt; Self:
    """Arrange submobjects in a grid.

    Parameters
    ----------
    rows
        The number of rows in the grid.
    cols
        The number of columns in the grid.
    buff
        The gap between grid cells. To specify a different buffer in the horizontal and
        vertical directions, a tuple of two values can be given - ``(row, col)``.
    cell_alignment
        The way each submobject is aligned in its grid cell.
    row_alignments
        The vertical alignment for each row (top to bottom). Accepts the following characters: ``"u"`` -
        up, ``"c"`` - center, ``"d"`` - down.
    col_alignments
        The horizontal alignment for each column (left to right). Accepts the following characters ``"l"`` - left,
        ``"c"`` - center, ``"r"`` - right.
    row_heights
        Defines a list of heights for certain rows (top to bottom). If the list contains
        ``None``, the corresponding row will fit its height automatically based
        on the highest element in that row.
    col_widths
        Defines a list of widths for certain columns (left to right). If the list contains ``None``, the
        corresponding column will fit its width automatically based on the widest element in that column.
    flow_order
        The order in which submobjects fill the grid. Can be one of the following values:
        "rd", "dr", "ld", "dl", "ru", "ur", "lu", "ul". ("rd" -&gt; fill rightwards then downwards)

    Returns
    -------
    OpenGLMobject
        The mobject.

    NOTES
    -----

    If only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big
    enough to fit all submobjects. If neither is set, they will be chosen to be about the same,
    tending towards ``cols`` &gt; ``rows`` (simply because videos are wider than they are high).

    If both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are
    defined, the latter has higher priority.


    Raises
    ------
    ValueError
        If ``rows`` and ``cols`` are too small to fit all submobjects.
    ValueError
        If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,
        :code:`row_alignments` and :code:`row_heights` have mismatching sizes.

    Examples
    --------
    .. manim:: ExampleBoxes
        :save_last_frame:

        class ExampleBoxes(Scene):
            def construct(self):
                boxes=VGroup(*[Square() for s in range(0,6)])
                boxes.arrange_in_grid(rows=2, buff=0.1)
                self.add(boxes)


    .. manim:: ArrangeInGrid
        :save_last_frame:

        class ArrangeInGrid(Scene):
            def construct(self):
                #Add some numbered boxes:
                np.random.seed(3)
                boxes = VGroup(*[
                    Rectangle(WHITE, np.random.random()+.5, np.random.random()+.5).add(Text(str(i+1)).scale(0.5))
                    for i in range(22)
                ])
                self.add(boxes)

                boxes.arrange_in_grid(
                    buff=(0.25,0.5),
                    col_alignments="lccccr",
                    row_alignments="uccd",
                    col_widths=[2, *[None]*4, 2],
                    flow_order="dr"
                )


    """
    from manim.mobject.geometry.line import Line

    mobs = self.submobjects.copy()
    start_pos = self.get_center()

    # get cols / rows values if given (implicitly)
    def init_size(
        num: int | None,
        alignments: str | None,
        sizes: Sequence[float | None] | None,
        name: str,
    ) -&gt; int:
        if num is not None:
            return num
        if alignments is not None:
            return len(alignments)
        if sizes is not None:
            return len(sizes)
        raise ValueError(
            f"At least one of the following parameters: '{name}s', "
            f"'{name}_alignments' or "
            f"'{name}_{'widths' if name == 'col' else 'heights'}', "
            "must not be None"
        )

    cols = init_size(cols, col_alignments, col_widths, "col")
    rows = init_size(rows, row_alignments, row_heights, "row")

    # calculate rows cols
    if rows is None and cols is None:
        cols = ceil(np.sqrt(len(mobs)))
        # make the grid as close to quadratic as possible.
        # choosing cols first can results in cols&gt;rows.
        # This is favored over rows&gt;cols since in general
        # the sceene is wider than high.
    if rows is None:
        rows = ceil(len(mobs) / cols)
    if cols is None:
        cols = ceil(len(mobs) / rows)
    if rows * cols &lt; len(mobs):
        raise ValueError("Too few rows and columns to fit all submobjetcs.")
    # rows and cols are now finally valid.

    if isinstance(buff, tuple):
        buff_x = buff[0]
        buff_y = buff[1]
    else:
        buff_x = buff_y = buff

    # Initialize alignments correctly
    def init_alignments(
        str_alignments: str | None,
        num: int,
        mapping: dict[str, Vector3D],
        name: str,
        direction: Vector3D,
    ) -&gt; Sequence[Vector3D]:
        if str_alignments is None:
            # Use cell_alignment as fallback
            return [cell_alignment * direction] * num
        if len(str_alignments) != num:
            raise ValueError(f"{name}_alignments has a mismatching size.")
        return [mapping[letter] for letter in str_alignments]

    row_alignments = init_alignments(
        row_alignments,
        rows,
        {"u": UP, "c": ORIGIN, "d": DOWN},
        "row",
        RIGHT,
    )
    col_alignments = init_alignments(
        col_alignments,
        cols,
        {"l": LEFT, "c": ORIGIN, "r": RIGHT},
        "col",
        UP,
    )
    # Now row_alignment[r] + col_alignment[c] is the alignment in cell [r][c]

    mapper = {
        "dr": lambda r, c: (rows - r - 1) + c * rows,
        "dl": lambda r, c: (rows - r - 1) + (cols - c - 1) * rows,
        "ur": lambda r, c: r + c * rows,
        "ul": lambda r, c: r + (cols - c - 1) * rows,
        "rd": lambda r, c: (rows - r - 1) * cols + c,
        "ld": lambda r, c: (rows - r - 1) * cols + (cols - c - 1),
        "ru": lambda r, c: r * cols + c,
        "lu": lambda r, c: r * cols + (cols - c - 1),
    }
    if flow_order not in mapper:
        raise ValueError(
            'flow_order must be one of the following values: "dr", "rd", "ld" "dl", "ru", "ur", "lu", "ul".',
        )
    flow_order = mapper[flow_order]

    # Reverse row_alignments and row_heights. Necessary since the
    # grid filling is handled bottom up for simplicity reasons.
    def reverse(maybe_list: Sequence[Any] | None) -&gt; Sequence[Any] | None:
        if maybe_list is not None:
            maybe_list = list(maybe_list)
            maybe_list.reverse()
            return maybe_list
        return None

    row_alignments = reverse(row_alignments)
    row_heights = reverse(row_heights)

    placeholder = OpenGLMobject()
    # Used to fill up the grid temporarily, doesn't get added to the scene.
    # In this case a Mobject is better than None since it has width and height
    # properties of 0.

    mobs.extend([placeholder] * (rows * cols - len(mobs)))
    grid = [[mobs[flow_order(r, c)] for c in range(cols)] for r in range(rows)]

    measured_heigths = [
        max(grid[r][c].height for c in range(cols)) for r in range(rows)
    ]
    measured_widths = [
        max(grid[r][c].width for r in range(rows)) for c in range(cols)
    ]

    # Initialize row_heights / col_widths correctly using measurements as fallback
    def init_sizes(
        sizes: Sequence[float | None] | None,
        num: int,
        measures: Sequence[float],
        name: str,
    ) -&gt; Sequence[float]:
        if sizes is None:
            sizes = [None] * num
        if len(sizes) != num:
            raise ValueError(f"{name} has a mismatching size.")
        return [
            sizes[i] if sizes[i] is not None else measures[i] for i in range(num)
        ]

    heights = init_sizes(row_heights, rows, measured_heigths, "row_heights")
    widths = init_sizes(col_widths, cols, measured_widths, "col_widths")

    x, y = 0, 0
    for r in range(rows):
        x = 0
        for c in range(cols):
            if grid[r][c] is not placeholder:
                alignment = row_alignments[r] + col_alignments[c]
                line = Line(
                    x * RIGHT + y * UP,
                    (x + widths[c]) * RIGHT + (y + heights[r]) * UP,
                )
                # Use a mobject to avoid rewriting align inside
                # box code that Mobject.move_to(Mobject) already
                # includes.

                grid[r][c].move_to(line, alignment)
            x += widths[c] + buff_x
        y += heights[r] + buff_y

    self.move_to(start_pos)
    return self

</t>
<t tx="ekr.20250122151620.1641">def get_grid(
    self, n_rows: int, n_cols: int, height: float | None = None, **kwargs
) -&gt; OpenGLGroup:
    """
    Returns a new mobject containing multiple copies of this one
    arranged in a grid
    """
    grid = self.duplicate(n_rows * n_cols)
    grid.arrange_in_grid(n_rows, n_cols, **kwargs)
    if height is not None:
        grid.set_height(height)
    return grid

</t>
<t tx="ekr.20250122151620.1642">def duplicate(self, n: int) -&gt; OpenGLGroup:
    """Returns an :class:`~.OpenGLGroup` containing ``n`` copies of the mobject."""
    return self.get_group_class()(*[self.copy() for _ in range(n)])

</t>
<t tx="ekr.20250122151620.1643">def sort(
    self,
    point_to_num_func: Callable[[Point3DLike], float] = lambda p: p[0],
    submob_func: Callable[[OpenGLMobject], Any] | None = None,
) -&gt; Self:
    """Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``."""
    if submob_func is not None:
        self.submobjects.sort(key=submob_func)
    else:
        self.submobjects.sort(key=lambda m: point_to_num_func(m.get_center()))
    return self

</t>
<t tx="ekr.20250122151620.1644">def shuffle(self, recurse: bool = False) -&gt; Self:
    """Shuffles the order of :attr:`submobjects`

    Examples
    --------

    .. manim:: ShuffleSubmobjectsExample

        class ShuffleSubmobjectsExample(Scene):
            def construct(self):
                s= OpenGLVGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
                s2= s.copy()
                s2.shuffle()
                s2.shift(DOWN)
                self.play(Write(s), Write(s2))
    """
    if recurse:
        for submob in self.submobjects:
            submob.shuffle(recurse=True)
    random.shuffle(self.submobjects)
    self.assemble_family()
    return self

</t>
<t tx="ekr.20250122151620.1645">def invert(self, recursive: bool = False) -&gt; Self:
    """Inverts the list of :attr:`submobjects`.

    Parameters
    ----------
    recursive
        If ``True``, all submobject lists of this mobject's family are inverted.

    Examples
    --------

    .. manim:: InvertSumobjectsExample

        class InvertSumobjectsExample(Scene):
            def construct(self):
                s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
                s2 = s.copy()
                s2.invert()
                s2.shift(DOWN)
                self.play(Write(s), Write(s2))
    """
    if recursive:
        for submob in self.submobjects:
            submob.invert(recursive=True)
    self.submobjects.reverse()
    self.assemble_family()
    return self

</t>
<t tx="ekr.20250122151620.1646"># Copying

def copy(self, shallow: bool = False) -&gt; OpenGLMobject:
    """Create and return an identical copy of the :class:`OpenGLMobject` including all
    :attr:`submobjects`.

    Returns
    -------
    :class:`OpenGLMobject`
        The copy.

    Parameters
    ----------
    shallow
        Controls whether a shallow copy is returned.

    Note
    ----
    The clone is initially not visible in the Scene, even if the original was.
    """
    if not shallow:
        return self.deepcopy()

    # TODO, either justify reason for shallow copy, or
    # remove this redundancy everywhere
    # return self.deepcopy()

    parents = self.parents
    self.parents = []
    copy_mobject = copy.copy(self)
    self.parents = parents

    copy_mobject.data = dict(self.data)
    for key in self.data:
        copy_mobject.data[key] = self.data[key].copy()

    # TODO, are uniforms ever numpy arrays?
    copy_mobject.uniforms = dict(self.uniforms)

    copy_mobject.submobjects = []
    copy_mobject.add(*(sm.copy() for sm in self.submobjects))
    copy_mobject.match_updaters(self)

    copy_mobject.needs_new_bounding_box = self.needs_new_bounding_box

    # Make sure any mobject or numpy array attributes are copied
    family = self.get_family()
    for attr, value in list(self.__dict__.items()):
        if (
            isinstance(value, OpenGLMobject)
            and value in family
            and value is not self
        ):
            setattr(copy_mobject, attr, value.copy())
        if isinstance(value, np.ndarray):
            setattr(copy_mobject, attr, value.copy())
        # if isinstance(value, ShaderWrapper):
        #     setattr(copy_mobject, attr, value.copy())
    return copy_mobject

</t>
<t tx="ekr.20250122151620.1647">def deepcopy(self) -&gt; OpenGLMobject:
    parents = self.parents
    self.parents = []
    result = copy.deepcopy(self)
    self.parents = parents
    return result

</t>
<t tx="ekr.20250122151620.1648">def generate_target(self, use_deepcopy: bool = False) -&gt; OpenGLMobject:
    self.target = None  # Prevent exponential explosion
    if use_deepcopy:
        self.target = self.deepcopy()
    else:
        self.target = self.copy()
    return self.target

</t>
<t tx="ekr.20250122151620.1649">def save_state(self, use_deepcopy: bool = False) -&gt; Self:
    """Save the current state (position, color &amp; size). Can be restored with :meth:`~.OpenGLMobject.restore`."""
    if hasattr(self, "saved_state"):
        # Prevent exponential growth of data
        self.saved_state = None
    if use_deepcopy:
        self.saved_state = self.deepcopy()
    else:
        self.saved_state = self.copy()
    return self

</t>
<t tx="ekr.20250122151620.165">@property
def assets_dir(self) -&gt; str:
    """Directory to locate video assets (no flag)."""
    return self._d["assets_dir"]

</t>
<t tx="ekr.20250122151620.1650">def restore(self) -&gt; Self:
    """Restores the state that was previously saved with :meth:`~.OpenGLMobject.save_state`."""
    if not hasattr(self, "saved_state") or self.save_state is None:
        raise Exception("Trying to restore without having saved")
    self.become(self.saved_state)
    return self

</t>
<t tx="ekr.20250122151620.1651"># Updating

def init_updaters(self) -&gt; None:
    self.time_based_updaters = []
    self.non_time_updaters = []
    self.has_updaters = False
    self.updating_suspended = False

</t>
<t tx="ekr.20250122151620.1652">def update(self, dt: float = 0, recurse: bool = True) -&gt; Self:
    if not self.has_updaters or self.updating_suspended:
        return self
    for updater in self.time_based_updaters:
        updater(self, dt)
    for updater in self.non_time_updaters:
        updater(self)
    if recurse:
        for submob in self.submobjects:
            submob.update(dt, recurse)
    return self

</t>
<t tx="ekr.20250122151620.1653">def get_time_based_updaters(self) -&gt; Sequence[TimeBasedUpdater]:
    return self.time_based_updaters

</t>
<t tx="ekr.20250122151620.1654">def has_time_based_updater(self) -&gt; bool:
    return len(self.time_based_updaters) &gt; 0

</t>
<t tx="ekr.20250122151620.1655">def get_updaters(self) -&gt; Sequence[Updater]:
    return self.time_based_updaters + self.non_time_updaters

</t>
<t tx="ekr.20250122151620.1656">def get_family_updaters(self) -&gt; Sequence[Updater]:
    return list(it.chain(*(sm.get_updaters() for sm in self.get_family())))

</t>
<t tx="ekr.20250122151620.1657">def add_updater(
    self,
    update_function: Updater,
    index: int | None = None,
    call_updater: bool = False,
) -&gt; Self:
    if "dt" in inspect.signature(update_function).parameters:
        updater_list = self.time_based_updaters
    else:
        updater_list = self.non_time_updaters

    if index is None:
        updater_list.append(update_function)
    else:
        updater_list.insert(index, update_function)

    self.refresh_has_updater_status()
    if call_updater:
        self.update()
    return self

</t>
<t tx="ekr.20250122151620.1658">def remove_updater(self, update_function: Updater) -&gt; Self:
    for updater_list in [self.time_based_updaters, self.non_time_updaters]:
        while update_function in updater_list:
            updater_list.remove(update_function)
    self.refresh_has_updater_status()
    return self

</t>
<t tx="ekr.20250122151620.1659">def clear_updaters(self, recurse: bool = True) -&gt; Self:
    self.time_based_updaters = []
    self.non_time_updaters = []
    self.refresh_has_updater_status()
    if recurse:
        for submob in self.submobjects:
            submob.clear_updaters()
    return self

</t>
<t tx="ekr.20250122151620.166">@assets_dir.setter
def assets_dir(self, value: str | Path) -&gt; None:
    self._set_dir("assets_dir", value)

</t>
<t tx="ekr.20250122151620.1660">def match_updaters(self, mobject: OpenGLMobject) -&gt; Self:
    self.clear_updaters()
    for updater in mobject.get_updaters():
        self.add_updater(updater)
    return self

</t>
<t tx="ekr.20250122151620.1661">def suspend_updating(self, recurse: bool = True) -&gt; Self:
    self.updating_suspended = True
    if recurse:
        for submob in self.submobjects:
            submob.suspend_updating(recurse)
    return self

</t>
<t tx="ekr.20250122151620.1662">def resume_updating(self, recurse: bool = True, call_updater: bool = True) -&gt; Self:
    self.updating_suspended = False
    if recurse:
        for submob in self.submobjects:
            submob.resume_updating(recurse)
    for parent in self.parents:
        parent.resume_updating(recurse=False, call_updater=False)
    if call_updater:
        self.update(dt=0, recurse=recurse)
    return self

</t>
<t tx="ekr.20250122151620.1663">def refresh_has_updater_status(self) -&gt; Self:
    self.has_updaters = any(mob.get_updaters() for mob in self.get_family())
    return self

</t>
<t tx="ekr.20250122151620.1664"># Transforming operations

def shift(self, vector: Vector3D) -&gt; Self:
    self.apply_points_function(
        lambda points: points + vector,
        about_edge=None,
        works_on_bounding_box=True,
    )
    return self

</t>
<t tx="ekr.20250122151620.1665">def scale(
    self,
    scale_factor: float,
    about_point: Sequence[float] | None = None,
    about_edge: Sequence[float] = ORIGIN,
    **kwargs,
) -&gt; Self:
    r"""Scale the size by a factor.

    Default behavior is to scale about the center of the mobject.
    The argument about_edge can be a vector, indicating which side of
    the mobject to scale about, e.g., mob.scale(about_edge = RIGHT)
    scales about mob.get_right().

    Otherwise, if about_point is given a value, scaling is done with
    respect to that point.

    Parameters
    ----------
    scale_factor
        The scaling factor :math:`\alpha`. If :math:`0 &lt; |\alpha| &lt; 1`, the mobject
        will shrink, and for :math:`|\alpha| &gt; 1` it will grow. Furthermore,
        if :math:`\alpha &lt; 0`, the mobject is also flipped.
    kwargs
        Additional keyword arguments passed to
        :meth:`apply_points_function`.

    Returns
    -------
    OpenGLMobject
        The scaled mobject.

    Examples
    --------

    .. manim:: MobjectScaleExample
        :save_last_frame:

        class MobjectScaleExample(Scene):
            def construct(self):
                f1 = Text("F")
                f2 = Text("F").scale(2)
                f3 = Text("F").scale(0.5)
                f4 = Text("F").scale(-1)

                vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)
                self.add(vgroup)

    See also
    --------
    :meth:`move_to`

    """
    self.apply_points_function(
        lambda points: scale_factor * points,
        about_point=about_point,
        about_edge=about_edge,
        works_on_bounding_box=True,
        **kwargs,
    )
    return self

</t>
<t tx="ekr.20250122151620.1666">def stretch(self, factor: float, dim: int, **kwargs) -&gt; Self:
    def func(points: Point3D_Array) -&gt; Point3D_Array:
        points[:, dim] *= factor
        return points

    self.apply_points_function(func, works_on_bounding_box=True, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.1667">def rotate_about_origin(self, angle: float, axis: Vector3D = OUT) -&gt; Self:
    return self.rotate(angle, axis, about_point=ORIGIN)

</t>
<t tx="ekr.20250122151620.1668">def rotate(
    self,
    angle: float,
    axis: Vector3D = OUT,
    about_point: Sequence[float] | None = None,
    **kwargs,
) -&gt; Self:
    """Rotates the :class:`~.OpenGLMobject` about a certain point."""
    rot_matrix_T = rotation_matrix_transpose(angle, axis)
    self.apply_points_function(
        lambda points: np.dot(points, rot_matrix_T),
        about_point=about_point,
        **kwargs,
    )
    return self

</t>
<t tx="ekr.20250122151620.1669">def flip(self, axis: Vector3D = UP, **kwargs) -&gt; Self:
    """Flips/Mirrors an mobject about its center.

    Examples
    --------

    .. manim:: FlipExample
        :save_last_frame:

        class FlipExample(Scene):
            def construct(self):
                s= Line(LEFT, RIGHT+UP).shift(4*LEFT)
                self.add(s)
                s2= s.copy().flip()
                self.add(s2)

    """
    return self.rotate(TAU / 2, axis, **kwargs)

</t>
<t tx="ekr.20250122151620.167">@property
def log_dir(self) -&gt; str:
    """Directory to place logs. See :meth:`ManimConfig.get_dir`."""
    return self._d["log_dir"]

</t>
<t tx="ekr.20250122151620.1670">def apply_function(self, function: MappingFunction, **kwargs) -&gt; Self:
    # Default to applying matrix about the origin, not mobjects center
    if len(kwargs) == 0:
        kwargs["about_point"] = ORIGIN

    def multi_mapping_function(points: Point3D_Array) -&gt; Point3D_Array:
        result: Point3D_Array = np.apply_along_axis(function, 1, points)
        return result

    self.apply_points_function(multi_mapping_function, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.1671">def apply_function_to_position(self, function: MappingFunction) -&gt; Self:
    self.move_to(function(self.get_center()))
    return self

</t>
<t tx="ekr.20250122151620.1672">def apply_function_to_submobject_positions(self, function: MappingFunction) -&gt; Self:
    for submob in self.submobjects:
        submob.apply_function_to_position(function)
    return self

</t>
<t tx="ekr.20250122151620.1673">def apply_matrix(self, matrix: MatrixMN, **kwargs) -&gt; Self:
    # Default to applying matrix about the origin, not mobjects center
    if ("about_point" not in kwargs) and ("about_edge" not in kwargs):
        kwargs["about_point"] = ORIGIN
    full_matrix = np.identity(self.dim)
    matrix = np.array(matrix)
    full_matrix[: matrix.shape[0], : matrix.shape[1]] = matrix
    self.apply_points_function(
        lambda points: np.dot(points, full_matrix.T), **kwargs
    )
    return self

</t>
<t tx="ekr.20250122151620.1674">def apply_complex_function(
    self, function: Callable[[complex], complex], **kwargs
) -&gt; Self:
    """Applies a complex function to a :class:`OpenGLMobject`.
    The x and y coordinates correspond to the real and imaginary parts respectively.

    Example
    -------

    .. manim:: ApplyFuncExample

        class ApplyFuncExample(Scene):
            def construct(self):
                circ = Circle().scale(1.5)
                circ_ref = circ.copy()
                circ.apply_complex_function(
                    lambda x: np.exp(x*1j)
                )
                t = ValueTracker(0)
                circ.add_updater(
                    lambda x: x.become(circ_ref.copy().apply_complex_function(
                        lambda x: np.exp(x+t.get_value()*1j)
                    )).set_color(BLUE)
                )
                self.add(circ_ref)
                self.play(TransformFromCopy(circ_ref, circ))
                self.play(t.animate.set_value(TAU), run_time=3)
    """

    def R3_func(point):
        x, y, z = point
        xy_complex = function(complex(x, y))
        return [xy_complex.real, xy_complex.imag, z]

    return self.apply_function(R3_func)

</t>
<t tx="ekr.20250122151620.1675">def hierarchical_model_matrix(self) -&gt; MatrixMN:
    if self.parent is None:
        return self.model_matrix

    model_matrices = [self.model_matrix]
    current_object = self
    while current_object.parent is not None:
        model_matrices.append(current_object.parent.model_matrix)
        current_object = current_object.parent
    return np.linalg.multi_dot(list(reversed(model_matrices)))

</t>
<t tx="ekr.20250122151620.1676">def wag(
    self,
    direction: Vector3D = RIGHT,
    axis: Vector3D = DOWN,
    wag_factor: float = 1.0,
) -&gt; Self:
    for mob in self.family_members_with_points():
        alphas = np.dot(mob.points, np.transpose(axis))
        alphas -= min(alphas)
        alphas /= max(alphas)
        alphas = alphas**wag_factor
        mob.set_points(
            mob.points
            + np.dot(
                alphas.reshape((len(alphas), 1)),
                np.array(direction).reshape((1, mob.dim)),
            ),
        )
    return self

</t>
<t tx="ekr.20250122151620.1677"># Positioning methods

def center(self) -&gt; Self:
    """Moves the mobject to the center of the Scene."""
    self.shift(-self.get_center())
    return self

</t>
<t tx="ekr.20250122151620.1678">def align_on_border(
    self,
    direction: Vector3D,
    buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER,
) -&gt; Self:
    """
    Direction just needs to be a vector pointing towards side or
    corner in the 2d plane.
    """
    target_point = np.sign(direction) * (
        config["frame_x_radius"],
        config["frame_y_radius"],
        0,
    )
    point_to_align = self.get_bounding_box_point(direction)
    shift_val = target_point - point_to_align - buff * np.array(direction)
    shift_val = shift_val * abs(np.sign(direction))
    self.shift(shift_val)
    return self

</t>
<t tx="ekr.20250122151620.1679">def to_corner(
    self,
    corner: Vector3D = LEFT + DOWN,
    buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER,
) -&gt; Self:
    return self.align_on_border(corner, buff)

</t>
<t tx="ekr.20250122151620.168">@log_dir.setter
def log_dir(self, value: str | Path) -&gt; None:
    self._set_dir("log_dir", value)

</t>
<t tx="ekr.20250122151620.1680">def to_edge(
    self,
    edge: Vector3D = LEFT,
    buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER,
) -&gt; Self:
    return self.align_on_border(edge, buff)

</t>
<t tx="ekr.20250122151620.1681">def next_to(
    self,
    mobject_or_point: OpenGLMobject | Point3DLike,
    direction: Vector3D = RIGHT,
    buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,
    aligned_edge: Vector3D = ORIGIN,
    submobject_to_align: OpenGLMobject | None = None,
    index_of_submobject_to_align: int | None = None,
    coor_mask: Point3DLike = np.array([1, 1, 1]),
</t>
<t tx="ekr.20250122151620.1682">) -&gt; Self:
    """Move this :class:`~.OpenGLMobject` next to another's :class:`~.OpenGLMobject` or coordinate.

    Examples
    --------

    .. manim:: GeometricShapes
        :save_last_frame:

        class GeometricShapes(Scene):
            def construct(self):
                d = Dot()
                c = Circle()
                s = Square()
                t = Triangle()
                d.next_to(c, RIGHT)
                s.next_to(c, LEFT)
                t.next_to(c, DOWN)
                self.add(d, c, s, t)

    """
    if isinstance(mobject_or_point, OpenGLMobject):
        mob = mobject_or_point
        if index_of_submobject_to_align is not None:
            target_aligner = mob[index_of_submobject_to_align]
        else:
            target_aligner = mob
        target_point = target_aligner.get_bounding_box_point(
            aligned_edge + direction,
        )
    else:
        target_point = mobject_or_point
    if submobject_to_align is not None:
        aligner = submobject_to_align
    elif index_of_submobject_to_align is not None:
        aligner = self[index_of_submobject_to_align]
    else:
        aligner = self
    point_to_align = aligner.get_bounding_box_point(aligned_edge - direction)
    self.shift((target_point - point_to_align + buff * direction) * coor_mask)
    return self

def shift_onto_screen(self, **kwargs) -&gt; Self:
    space_lengths = [config["frame_x_radius"], config["frame_y_radius"]]
    for vect in UP, DOWN, LEFT, RIGHT:
        dim = np.argmax(np.abs(vect))
        buff = kwargs.get("buff", DEFAULT_MOBJECT_TO_EDGE_BUFFER)
        max_val = space_lengths[dim] - buff
        edge_center = self.get_edge_center(vect)
        if np.dot(edge_center, vect) &gt; max_val:
            self.to_edge(vect, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.1683">def is_off_screen(self) -&gt; bool:
    if self.get_left()[0] &gt; config.frame_x_radius:
        return True
    if self.get_right()[0] &lt; config.frame_x_radius:
        return True
    if self.get_bottom()[1] &gt; config.frame_y_radius:
        return True
    return self.get_top()[1] &lt; -config.frame_y_radius

</t>
<t tx="ekr.20250122151620.1684">def stretch_about_point(self, factor: float, dim: int, point: Point3DLike) -&gt; Self:
    return self.stretch(factor, dim, about_point=point)

</t>
<t tx="ekr.20250122151620.1685">def rescale_to_fit(
    self, length: float, dim: int, stretch: bool = False, **kwargs
) -&gt; Self:
    old_length = self.length_over_dim(dim)
    if old_length == 0:
        return self
    if stretch:
        self.stretch(length / old_length, dim, **kwargs)
    else:
        self.scale(length / old_length, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.1686">def stretch_to_fit_width(self, width: float, **kwargs) -&gt; Self:
    """Stretches the :class:`~.OpenGLMobject` to fit a width, not keeping height/depth proportional.

    Returns
    -------
    :class:`OpenGLMobject`
        ``self``

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import *
        &gt;&gt;&gt; sq = Square()
        &gt;&gt;&gt; sq.height
        2.0
        &gt;&gt;&gt; sq.stretch_to_fit_width(5)
        Square
        &gt;&gt;&gt; sq.width
        5.0
        &gt;&gt;&gt; sq.height
        2.0
    """
    return self.rescale_to_fit(width, 0, stretch=True, **kwargs)

</t>
<t tx="ekr.20250122151620.1687">def stretch_to_fit_height(self, height: float, **kwargs) -&gt; Self:
    """Stretches the :class:`~.OpenGLMobject` to fit a height, not keeping width/height proportional."""
    return self.rescale_to_fit(height, 1, stretch=True, **kwargs)

</t>
<t tx="ekr.20250122151620.1688">def stretch_to_fit_depth(self, depth: float, **kwargs) -&gt; Self:
    """Stretches the :class:`~.OpenGLMobject` to fit a depth, not keeping width/height proportional."""
    return self.rescale_to_fit(depth, 1, stretch=True, **kwargs)

</t>
<t tx="ekr.20250122151620.1689">def set_width(self, width: float, stretch: bool = False, **kwargs) -&gt; Self:
    """Scales the :class:`~.OpenGLMobject` to fit a width while keeping height/depth proportional.

    Returns
    -------
    :class:`OpenGLMobject`
        ``self``

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import *
        &gt;&gt;&gt; sq = Square()
        &gt;&gt;&gt; sq.height
        2.0
        &gt;&gt;&gt; sq.scale_to_fit_width(5)
        Square
        &gt;&gt;&gt; sq.width
        5.0
        &gt;&gt;&gt; sq.height
        5.0
    """
    return self.rescale_to_fit(width, 0, stretch=stretch, **kwargs)

</t>
<t tx="ekr.20250122151620.169">@property
def video_dir(self) -&gt; str:
    """Directory to place videos (no flag). See :meth:`ManimConfig.get_dir`."""
    return self._d["video_dir"]

</t>
<t tx="ekr.20250122151620.1690">scale_to_fit_width = set_width

def set_height(self, height: float, stretch: bool = False, **kwargs) -&gt; Self:
    """Scales the :class:`~.OpenGLMobject` to fit a height while keeping width/depth proportional."""
    return self.rescale_to_fit(height, 1, stretch=stretch, **kwargs)

</t>
<t tx="ekr.20250122151620.1691">scale_to_fit_height = set_height

def set_depth(self, depth: float, stretch: bool = False, **kwargs):
    """Scales the :class:`~.OpenGLMobject` to fit a depth while keeping width/height proportional."""
    return self.rescale_to_fit(depth, 2, stretch=stretch, **kwargs)

</t>
<t tx="ekr.20250122151620.1692">scale_to_fit_depth = set_depth

def set_coord(self, value: float, dim: int, direction: Vector3D = ORIGIN) -&gt; Self:
    curr = self.get_coord(dim, direction)
    shift_vect = np.zeros(self.dim)
    shift_vect[dim] = value - curr
    self.shift(shift_vect)
    return self

</t>
<t tx="ekr.20250122151620.1693">def set_x(self, x: float, direction: Vector3D = ORIGIN) -&gt; Self:
    """Set x value of the center of the :class:`~.OpenGLMobject` (``int`` or ``float``)"""
    return self.set_coord(x, 0, direction)

</t>
<t tx="ekr.20250122151620.1694">def set_y(self, y: float, direction: Vector3D = ORIGIN) -&gt; Self:
    """Set y value of the center of the :class:`~.OpenGLMobject` (``int`` or ``float``)"""
    return self.set_coord(y, 1, direction)

</t>
<t tx="ekr.20250122151620.1695">def set_z(self, z: float, direction: Vector3D = ORIGIN) -&gt; Self:
    """Set z value of the center of the :class:`~.OpenGLMobject` (``int`` or ``float``)"""
    return self.set_coord(z, 2, direction)

</t>
<t tx="ekr.20250122151620.1696">def space_out_submobjects(self, factor: float = 1.5, **kwargs) -&gt; Self:
    self.scale(factor, **kwargs)
    for submob in self.submobjects:
        submob.scale(1.0 / factor)
    return self

</t>
<t tx="ekr.20250122151620.1697">def move_to(
    self,
    point_or_mobject: Point3DLike | OpenGLMobject,
    aligned_edge: Vector3D = ORIGIN,
    coor_mask: Point3DLike = np.array([1, 1, 1]),
</t>
<t tx="ekr.20250122151620.1698">) -&gt; Self:
    """Move center of the :class:`~.OpenGLMobject` to certain coordinate."""
    if isinstance(point_or_mobject, OpenGLMobject):
        target = point_or_mobject.get_bounding_box_point(aligned_edge)
    else:
        target = point_or_mobject
    point_to_align = self.get_bounding_box_point(aligned_edge)
    self.shift((target - point_to_align) * coor_mask)
    return self

def replace(
    self,
    mobject: OpenGLMobject,
    dim_to_match: int = 0,
    stretch: bool = False,
) -&gt; Self:
    if not mobject.get_num_points() and not mobject.submobjects:
        self.scale(0)
        return self
    if stretch:
        for i in range(self.dim):
            self.rescale_to_fit(mobject.length_over_dim(i), i, stretch=True)
    else:
        self.rescale_to_fit(
            mobject.length_over_dim(dim_to_match),
            dim_to_match,
            stretch=False,
        )
    self.shift(mobject.get_center() - self.get_center())
    return self

</t>
<t tx="ekr.20250122151620.1699">def surround(
    self,
    mobject: OpenGLMobject,
    dim_to_match: int = 0,
    stretch: bool = False,
    buff: float = MED_SMALL_BUFF,
) -&gt; Self:
    self.replace(mobject, dim_to_match, stretch)
    length = mobject.length_over_dim(dim_to_match)
    self.scale((length + buff) / length)
    return self

</t>
<t tx="ekr.20250122151620.17">from __future__ import annotations

import configparser
from typing import Any

from cloup import Context, HelpFormatter, HelpTheme, Style

__all__ = ["parse_cli_ctx"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.170">@video_dir.setter
def video_dir(self, value: str | Path) -&gt; None:
    self._set_dir("video_dir", value)

</t>
<t tx="ekr.20250122151620.1700">def put_start_and_end_on(self, start: Point3DLike, end: Point3DLike) -&gt; Self:
    curr_start, curr_end = self.get_start_and_end()
    curr_vect = curr_end - curr_start
    if np.all(curr_vect == 0):
        raise Exception("Cannot position endpoints of closed loop")
    target_vect = np.array(end) - np.array(start)
    axis = (
        normalize(np.cross(curr_vect, target_vect))
        if np.linalg.norm(np.cross(curr_vect, target_vect)) != 0
        else OUT
    )
    self.scale(
        np.linalg.norm(target_vect) / np.linalg.norm(curr_vect),
        about_point=curr_start,
    )
    self.rotate(
        angle_between_vectors(curr_vect, target_vect),
        about_point=curr_start,
        axis=axis,
    )
    self.shift(start - curr_start)
    return self

</t>
<t tx="ekr.20250122151620.1701"># Color functions

def set_rgba_array(
    self,
    color: ParsableManimColor | Iterable[ParsableManimColor] | None = None,
    opacity: float | Iterable[float] | None = None,
    name: str = "rgbas",
    recurse: bool = True,
) -&gt; Self:
    if color is not None:
        rgbs = np.array([color_to_rgb(c) for c in listify(color)])
    if opacity is not None:
        opacities = listify(opacity)

    # Color only
    if color is not None and opacity is None:
        for mob in self.get_family(recurse):
            mob.data[name] = resize_array(
                mob.data[name] if name in mob.data else np.empty((1, 3)), len(rgbs)
            )
            mob.data[name][:, :3] = rgbs

    # Opacity only
    if color is None and opacity is not None:
        for mob in self.get_family(recurse):
            mob.data[name] = resize_array(
                mob.data[name] if name in mob.data else np.empty((1, 3)),
                len(opacities),
            )
            mob.data[name][:, 3] = opacities

    # Color and opacity
    if color is not None and opacity is not None:
        rgbas = np.array([[*rgb, o] for rgb, o in zip(*make_even(rgbs, opacities))])
        for mob in self.get_family(recurse):
            mob.data[name] = rgbas.copy()
    return self

</t>
<t tx="ekr.20250122151620.1702">def set_rgba_array_direct(
    self,
    rgbas: npt.NDArray[RGBA_Array_Float],
    name: str = "rgbas",
    recurse: bool = True,
) -&gt; Self:
    """Directly set rgba data from `rgbas` and optionally do the same recursively
    with submobjects. This can be used if the `rgbas` have already been generated
    with the correct shape and simply need to be set.

    Parameters
    ----------
    rgbas
        the rgba to be set as data
    name
        the name of the data attribute to be set
    recurse
        set to true to recursively apply this method to submobjects
    """
    for mob in self.get_family(recurse):
        mob.data[name] = rgbas.copy()

</t>
<t tx="ekr.20250122151620.1703">def set_color(
    self,
    color: ParsableManimColor | Iterable[ParsableManimColor] | None,
    opacity: float | Iterable[float] | None = None,
    recurse: bool = True,
) -&gt; Self:
    self.set_rgba_array(color, opacity, recurse=False)
    # Recurse to submobjects differently from how set_rgba_array
    # in case they implement set_color differently
    if color is not None:
        self.color: ManimColor = ManimColor.parse(color)
    if opacity is not None:
        self.opacity = opacity
    if recurse:
        for submob in self.submobjects:
            submob.set_color(color, recurse=True)
    return self

</t>
<t tx="ekr.20250122151620.1704">def set_opacity(
    self, opacity: float | Iterable[float] | None, recurse: bool = True
) -&gt; Self:
    self.set_rgba_array(color=None, opacity=opacity, recurse=False)
    if recurse:
        for submob in self.submobjects:
            submob.set_opacity(opacity, recurse=True)
    return self

</t>
<t tx="ekr.20250122151620.1705">def get_color(self) -&gt; str:
    return rgb_to_hex(self.rgbas[0, :3])

</t>
<t tx="ekr.20250122151620.1706">def get_opacity(self) -&gt; float:
    return self.rgbas[0, 3]

</t>
<t tx="ekr.20250122151620.1707">def set_color_by_gradient(self, *colors: ParsableManimColor) -&gt; Self:
    return self.set_submobject_colors_by_gradient(*colors)

</t>
<t tx="ekr.20250122151620.1708">def set_submobject_colors_by_gradient(self, *colors: ParsableManimColor) -&gt; Self:
    if len(colors) == 0:
        raise Exception("Need at least one color")
    elif len(colors) == 1:
        return self.set_color(*colors)

    # mobs = self.family_members_with_points()
    mobs = self.submobjects
    new_colors = color_gradient(colors, len(mobs))

    for mob, color in zip(mobs, new_colors):
        mob.set_color(color)
    return self

</t>
<t tx="ekr.20250122151620.1709">def fade(self, darkness: float = 0.5, recurse: bool = True) -&gt; Self:
    return self.set_opacity(1.0 - darkness, recurse=recurse)

</t>
<t tx="ekr.20250122151620.171">@property
def sections_dir(self) -&gt; str:
    """Directory to place section videos (no flag). See :meth:`ManimConfig.get_dir`."""
    return self._d["sections_dir"]

</t>
<t tx="ekr.20250122151620.1710">def get_gloss(self) -&gt; float:
    return self.gloss

</t>
<t tx="ekr.20250122151620.1711">def set_gloss(self, gloss: float, recurse: bool = True) -&gt; Self:
    for mob in self.get_family(recurse):
        mob.gloss = gloss
    return self

</t>
<t tx="ekr.20250122151620.1712">def get_shadow(self) -&gt; float:
    return self.shadow

</t>
<t tx="ekr.20250122151620.1713">def set_shadow(self, shadow: float, recurse: bool = True) -&gt; Self:
    for mob in self.get_family(recurse):
        mob.shadow = shadow
    return self

</t>
<t tx="ekr.20250122151620.1714"># Background rectangle

def add_background_rectangle(
    self,
    color: ParsableManimColor | None = None,
    opacity: float = 0.75,
    **kwargs,
) -&gt; Self:
    # TODO, this does not behave well when the mobject has points,
    # since it gets displayed on top
    """Add a BackgroundRectangle as submobject.

    The BackgroundRectangle is added behind other submobjects.

    This can be used to increase the mobjects visibility in front of a noisy background.

    Parameters
    ----------
    color
        The color of the BackgroundRectangle
    opacity
        The opacity of the BackgroundRectangle
    kwargs
        Additional keyword arguments passed to the BackgroundRectangle constructor


    Returns
    -------
    :class:`OpenGLMobject`
        ``self``

    See Also
    --------
    :meth:`add_to_back`
    :class:`~.BackgroundRectangle`

    """
    from manim.mobject.geometry.shape_matchers import BackgroundRectangle

    self.background_rectangle = BackgroundRectangle(
        self, color=color, fill_opacity=opacity, **kwargs
    )
    self.add_to_back(self.background_rectangle)
    return self

</t>
<t tx="ekr.20250122151620.1715">def add_background_rectangle_to_submobjects(self, **kwargs) -&gt; Self:
    for submobject in self.submobjects:
        submobject.add_background_rectangle(**kwargs)
    return self

</t>
<t tx="ekr.20250122151620.1716">def add_background_rectangle_to_family_members_with_points(self, **kwargs) -&gt; Self:
    for mob in self.family_members_with_points():
        mob.add_background_rectangle(**kwargs)
    return self

</t>
<t tx="ekr.20250122151620.1717"># Getters

def get_bounding_box_point(self, direction: Vector3D) -&gt; Point3D:
    bb = self.get_bounding_box()
    indices = (np.sign(direction) + 1).astype(int)
    return np.array([bb[indices[i]][i] for i in range(3)])

</t>
<t tx="ekr.20250122151620.1718">def get_edge_center(self, direction: Vector3D) -&gt; Point3D:
    """Get edge coordinates for certain direction."""
    return self.get_bounding_box_point(direction)

</t>
<t tx="ekr.20250122151620.1719">def get_corner(self, direction: Vector3D) -&gt; Point3D:
    """Get corner coordinates for certain direction."""
    return self.get_bounding_box_point(direction)

</t>
<t tx="ekr.20250122151620.172">@sections_dir.setter
def sections_dir(self, value: str | Path) -&gt; None:
    self._set_dir("sections_dir", value)

</t>
<t tx="ekr.20250122151620.1720">def get_center(self) -&gt; Point3D:
    """Get center coordinates."""
    return self.get_bounding_box()[1]

</t>
<t tx="ekr.20250122151620.1721">def get_center_of_mass(self) -&gt; Point3D:
    return self.get_all_points().mean(0)

</t>
<t tx="ekr.20250122151620.1722">def get_boundary_point(self, direction: Vector3D) -&gt; Point3D:
    all_points = self.get_all_points()
    boundary_directions = all_points - self.get_center()
    norms = np.linalg.norm(boundary_directions, axis=1)
    boundary_directions /= np.repeat(norms, 3).reshape((len(norms), 3))
    index = np.argmax(np.dot(boundary_directions, np.array(direction).T))
    return all_points[index]

</t>
<t tx="ekr.20250122151620.1723">def get_continuous_bounding_box_point(self, direction: Vector3D) -&gt; Point3D:
    dl, center, ur = self.get_bounding_box()
    corner_vect = ur - center
    return center + direction / np.max(
        np.abs(
            np.true_divide(
                direction,
                corner_vect,
                out=np.zeros(len(direction)),
                where=((corner_vect) != 0),
            ),
        ),
    )

</t>
<t tx="ekr.20250122151620.1724">def get_top(self) -&gt; Point3D:
    """Get top coordinates of a box bounding the :class:`~.OpenGLMobject`"""
    return self.get_edge_center(UP)

</t>
<t tx="ekr.20250122151620.1725">def get_bottom(self) -&gt; Point3D:
    """Get bottom coordinates of a box bounding the :class:`~.OpenGLMobject`"""
    return self.get_edge_center(DOWN)

</t>
<t tx="ekr.20250122151620.1726">def get_right(self) -&gt; Point3D:
    """Get right coordinates of a box bounding the :class:`~.OpenGLMobject`"""
    return self.get_edge_center(RIGHT)

</t>
<t tx="ekr.20250122151620.1727">def get_left(self) -&gt; Point3D:
    """Get left coordinates of a box bounding the :class:`~.OpenGLMobject`"""
    return self.get_edge_center(LEFT)

</t>
<t tx="ekr.20250122151620.1728">def get_zenith(self) -&gt; Point3D:
    """Get zenith coordinates of a box bounding a 3D :class:`~.OpenGLMobject`."""
    return self.get_edge_center(OUT)

</t>
<t tx="ekr.20250122151620.1729">def get_nadir(self) -&gt; Point3D:
    """Get nadir (opposite the zenith) coordinates of a box bounding a 3D :class:`~.OpenGLMobject`."""
    return self.get_edge_center(IN)

</t>
<t tx="ekr.20250122151620.173">@property
def images_dir(self) -&gt; str:
    """Directory to place images (no flag).  See :meth:`ManimConfig.get_dir`."""
    return self._d["images_dir"]

</t>
<t tx="ekr.20250122151620.1730">def length_over_dim(self, dim: int) -&gt; float:
    bb = self.get_bounding_box()
    return abs((bb[2] - bb[0])[dim])

</t>
<t tx="ekr.20250122151620.1731">def get_width(self) -&gt; float:
    """Returns the width of the mobject."""
    return self.length_over_dim(0)

</t>
<t tx="ekr.20250122151620.1732">def get_height(self) -&gt; float:
    """Returns the height of the mobject."""
    return self.length_over_dim(1)

</t>
<t tx="ekr.20250122151620.1733">def get_depth(self) -&gt; float:
    """Returns the depth of the mobject."""
    return self.length_over_dim(2)

</t>
<t tx="ekr.20250122151620.1734">def get_coord(self, dim: int, direction: Vector3D = ORIGIN) -&gt; ManimFloat:
    """Meant to generalize ``get_x``, ``get_y`` and ``get_z``"""
    return self.get_bounding_box_point(direction)[dim]

</t>
<t tx="ekr.20250122151620.1735">def get_x(self, direction: Vector3D = ORIGIN) -&gt; ManimFloat:
    """Returns x coordinate of the center of the :class:`~.OpenGLMobject` as ``float``"""
    return self.get_coord(0, direction)

</t>
<t tx="ekr.20250122151620.1736">def get_y(self, direction: Vector3D = ORIGIN) -&gt; ManimFloat:
    """Returns y coordinate of the center of the :class:`~.OpenGLMobject` as ``float``"""
    return self.get_coord(1, direction)

</t>
<t tx="ekr.20250122151620.1737">def get_z(self, direction: Vector3D = ORIGIN) -&gt; ManimFloat:
    """Returns z coordinate of the center of the :class:`~.OpenGLMobject` as ``float``"""
    return self.get_coord(2, direction)

</t>
<t tx="ekr.20250122151620.1738">def get_start(self) -&gt; Point3D:
    """Returns the point, where the stroke that surrounds the :class:`~.OpenGLMobject` starts."""
    self.throw_error_if_no_points()
    return np.array(self.points[0])

</t>
<t tx="ekr.20250122151620.1739">def get_end(self) -&gt; Point3D:
    """Returns the point, where the stroke that surrounds the :class:`~.OpenGLMobject` ends."""
    self.throw_error_if_no_points()
    return np.array(self.points[-1])

</t>
<t tx="ekr.20250122151620.174">@images_dir.setter
def images_dir(self, value: str | Path) -&gt; None:
    self._set_dir("images_dir", value)

</t>
<t tx="ekr.20250122151620.1740">def get_start_and_end(self) -&gt; tuple[Point3D, Point3D]:
    """Returns starting and ending point of a stroke as a ``tuple``."""
    return self.get_start(), self.get_end()

</t>
<t tx="ekr.20250122151620.1741">def point_from_proportion(self, alpha: float) -&gt; Point3D:
    points = self.points
    i, subalpha = integer_interpolate(0, len(points) - 1, alpha)
    return interpolate(points[i], points[i + 1], subalpha)

</t>
<t tx="ekr.20250122151620.1742">def pfp(self, alpha: float) -&gt; Point3D:
    """Abbreviation for point_from_proportion"""
    return self.point_from_proportion(alpha)

</t>
<t tx="ekr.20250122151620.1743">def get_pieces(self, n_pieces: int) -&gt; OpenGLMobject:
    template = self.copy()
    template.submobjects = []
    alphas = np.linspace(0, 1, n_pieces + 1)
    return OpenGLGroup(
        *(
            template.copy().pointwise_become_partial(self, a1, a2)
            for a1, a2 in zip(alphas[:-1], alphas[1:])
        )
    )

</t>
<t tx="ekr.20250122151620.1744">def get_z_index_reference_point(self) -&gt; Point3D:
    # TODO, better place to define default z_index_group?
    z_index_group = getattr(self, "z_index_group", self)
    return z_index_group.get_center()

</t>
<t tx="ekr.20250122151620.1745"># Match other mobject properties

def match_color(self, mobject: OpenGLMobject) -&gt; Self:
    """Match the color with the color of another :class:`~.OpenGLMobject`."""
    return self.set_color(mobject.get_color())

</t>
<t tx="ekr.20250122151620.1746">def match_dim_size(self, mobject: OpenGLMobject, dim: int, **kwargs) -&gt; Self:
    """Match the specified dimension with the dimension of another :class:`~.OpenGLMobject`."""
    return self.rescale_to_fit(mobject.length_over_dim(dim), dim, **kwargs)

</t>
<t tx="ekr.20250122151620.1747">def match_width(self, mobject: OpenGLMobject, **kwargs) -&gt; Self:
    """Match the width with the width of another :class:`~.OpenGLMobject`."""
    return self.match_dim_size(mobject, 0, **kwargs)

</t>
<t tx="ekr.20250122151620.1748">def match_height(self, mobject: OpenGLMobject, **kwargs) -&gt; Self:
    """Match the height with the height of another :class:`~.OpenGLMobject`."""
    return self.match_dim_size(mobject, 1, **kwargs)

</t>
<t tx="ekr.20250122151620.1749">def match_depth(self, mobject: OpenGLMobject, **kwargs) -&gt; Self:
    """Match the depth with the depth of another :class:`~.OpenGLMobject`."""
    return self.match_dim_size(mobject, 2, **kwargs)

</t>
<t tx="ekr.20250122151620.175">@property
def text_dir(self) -&gt; str:
    """Directory to place text (no flag).  See :meth:`ManimConfig.get_dir`."""
    return self._d["text_dir"]

</t>
<t tx="ekr.20250122151620.1750">def match_coord(
    self, mobject: OpenGLMobject, dim: int, direction: Vector3D = ORIGIN
) -&gt; Self:
    """Match the coordinates with the coordinates of another :class:`~.OpenGLMobject`."""
    return self.set_coord(
        mobject.get_coord(dim, direction),
        dim=dim,
        direction=direction,
    )

</t>
<t tx="ekr.20250122151620.1751">def match_x(self, mobject: OpenGLMobject, direction: Vector3D = ORIGIN) -&gt; Self:
    """Match x coord. to the x coord. of another :class:`~.OpenGLMobject`."""
    return self.match_coord(mobject, 0, direction)

</t>
<t tx="ekr.20250122151620.1752">def match_y(self, mobject: OpenGLMobject, direction: Vector3D = ORIGIN) -&gt; Self:
    """Match y coord. to the x coord. of another :class:`~.OpenGLMobject`."""
    return self.match_coord(mobject, 1, direction)

</t>
<t tx="ekr.20250122151620.1753">def match_z(self, mobject: OpenGLMobject, direction: Vector3D = ORIGIN) -&gt; Self:
    """Match z coord. to the x coord. of another :class:`~.OpenGLMobject`."""
    return self.match_coord(mobject, 2, direction)

</t>
<t tx="ekr.20250122151620.1754">def align_to(
    self,
    mobject_or_point: OpenGLMobject | Point3DLike,
    direction: Vector3D = ORIGIN,
) -&gt; Self:
    """
    Examples:
    mob1.align_to(mob2, UP) moves mob1 vertically so that its
    top edge lines ups with mob2's top edge.

    mob1.align_to(mob2, alignment_vect = RIGHT) moves mob1
    horizontally so that it's center is directly above/below
    the center of mob2
    """
    if isinstance(mobject_or_point, OpenGLMobject):
        point = mobject_or_point.get_bounding_box_point(direction)
    else:
        point = mobject_or_point

    for dim in range(self.dim):
        if direction[dim] != 0:
            self.set_coord(point[dim], dim, direction)
    return self

</t>
<t tx="ekr.20250122151620.1755">def get_group_class(self) -&gt; type[OpenGLGroup]:
    return OpenGLGroup

</t>
<t tx="ekr.20250122151620.1756">@staticmethod
def get_mobject_type_class() -&gt; type[OpenGLMobject]:
    """Return the base class of this mobject type."""
    return OpenGLMobject

</t>
<t tx="ekr.20250122151620.1757"># Alignment

def align_data_and_family(self, mobject: OpenGLMobject) -&gt; Self:
    self.align_family(mobject)
    self.align_data(mobject)
    return self

</t>
<t tx="ekr.20250122151620.1758">def align_data(self, mobject: OpenGLMobject) -&gt; Self:
    # In case any data arrays get resized when aligned to shader data
    # self.refresh_shader_data()
    for mob1, mob2 in zip(self.get_family(), mobject.get_family()):
        # Separate out how points are treated so that subclasses
        # can handle that case differently if they choose
        mob1.align_points(mob2)
        for key in mob1.data.keys() &amp; mob2.data.keys():
            if key == "points":
                continue
            arr1 = mob1.data[key]
            arr2 = mob2.data[key]
            if len(arr2) &gt; len(arr1):
                mob1.data[key] = resize_preserving_order(arr1, len(arr2))
            elif len(arr1) &gt; len(arr2):
                mob2.data[key] = resize_preserving_order(arr2, len(arr1))
    return self

</t>
<t tx="ekr.20250122151620.1759">def align_points(self, mobject: OpenGLMobject) -&gt; Self:
    max_len = max(self.get_num_points(), mobject.get_num_points())
    for mob in (self, mobject):
        mob.resize_points(max_len, resize_func=resize_preserving_order)
    return self

</t>
<t tx="ekr.20250122151620.176">@text_dir.setter
def text_dir(self, value: str | Path) -&gt; None:
    self._set_dir("text_dir", value)

</t>
<t tx="ekr.20250122151620.1760">def align_family(self, mobject: OpenGLMobject) -&gt; Self:
    mob1 = self
    mob2 = mobject
    n1 = len(mob1)
    n2 = len(mob2)
    if n1 != n2:
        mob1.add_n_more_submobjects(max(0, n2 - n1))
        mob2.add_n_more_submobjects(max(0, n1 - n2))
    # Recurse
    for sm1, sm2 in zip(mob1.submobjects, mob2.submobjects):
        sm1.align_family(sm2)
    return self

</t>
<t tx="ekr.20250122151620.1761">def push_self_into_submobjects(self) -&gt; Self:
    copy = self.deepcopy()
    copy.submobjects = []
    self.resize_points(0)
    self.add(copy)
    return self

</t>
<t tx="ekr.20250122151620.1762">def add_n_more_submobjects(self, n: int) -&gt; Self:
    if n == 0:
        return self

    curr = len(self.submobjects)
    if curr == 0:
        # If empty, simply add n point mobjects
        null_mob = self.copy()
        null_mob.set_points([self.get_center()])
        self.submobjects = [null_mob.copy() for k in range(n)]
        return self
    target = curr + n
    repeat_indices = (np.arange(target) * curr) // target
    split_factors = [(repeat_indices == i).sum() for i in range(curr)]
    new_submobs = []
    for submob, sf in zip(self.submobjects, split_factors):
        new_submobs.append(submob)
        for _ in range(1, sf):
            new_submob = submob.copy()
            # If the submobject is at all transparent, then
            # make the copy completely transparent
            if submob.get_opacity() &lt; 1:
                new_submob.set_opacity(0)
            new_submobs.append(new_submob)
    self.submobjects = new_submobs
    return self

</t>
<t tx="ekr.20250122151620.1763"># Interpolate

def interpolate(
    self,
    mobject1: OpenGLMobject,
    mobject2: OpenGLMobject,
    alpha: float,
    path_func: PathFuncType = straight_path(),
</t>
<t tx="ekr.20250122151620.1764">) -&gt; Self:
    """Turns this :class:`~.OpenGLMobject` into an interpolation between ``mobject1``
    and ``mobject2``.

    Examples
    --------

    .. manim:: DotInterpolation
        :save_last_frame:

        class DotInterpolation(Scene):
            def construct(self):
                dotR = Dot(color=DARK_GREY)
                dotR.shift(2 * RIGHT)
                dotL = Dot(color=WHITE)
                dotL.shift(2 * LEFT)

                dotMiddle = OpenGLVMobject().interpolate(dotL, dotR, alpha=0.3)

                self.add(dotL, dotR, dotMiddle)
    """
    for key in self.data:
        if key in self.locked_data_keys:
            continue
        if len(self.data[key]) == 0:
            continue
        if key not in mobject1.data or key not in mobject2.data:
            continue

        func = path_func if key in ("points", "bounding_box") else interpolate

        self.data[key][:] = func(mobject1.data[key], mobject2.data[key], alpha)

    for key in self.uniforms:
        if key != "fixed_orientation_center":
            self.uniforms[key] = interpolate(
                mobject1.uniforms[key],
                mobject2.uniforms[key],
                alpha,
            )
        else:
            self.uniforms["fixed_orientation_center"] = tuple(
                interpolate(
                    np.array(mobject1.uniforms["fixed_orientation_center"]),
                    np.array(mobject2.uniforms["fixed_orientation_center"]),
                    alpha,
                )
            )
    return self

def pointwise_become_partial(
    self, mobject: OpenGLMobject, a: float, b: float
) -&gt; None:
    """
    Set points in such a way as to become only
    part of mobject.
    Inputs 0 &lt;= a &lt; b &lt;= 1 determine what portion
    of mobject to become.
    """
    pass  # To implement in subclass

</t>
<t tx="ekr.20250122151620.1765">def become(
    self,
    mobject: OpenGLMobject,
    match_height: bool = False,
    match_width: bool = False,
    match_depth: bool = False,
    match_center: bool = False,
    stretch: bool = False,
) -&gt; Self:
    """Edit all data and submobjects to be identical
    to another :class:`~.OpenGLMobject`

    .. note::

        If both match_height and match_width are ``True`` then the transformed :class:`~.OpenGLMobject`
        will match the height first and then the width

    Parameters
    ----------
    match_height
        If ``True``, then the transformed :class:`~.OpenGLMobject` will match the height of the original
    match_width
        If ``True``, then the transformed :class:`~.OpenGLMobject` will match the width of the original
    match_depth
        If ``True``, then the transformed :class:`~.OpenGLMobject` will match the depth of the original
    match_center
        If ``True``, then the transformed :class:`~.OpenGLMobject` will match the center of the original
    stretch
        If ``True``, then the transformed :class:`~.OpenGLMobject` will stretch to fit the proportions of the original

    Examples
    --------
    .. manim:: BecomeScene

        class BecomeScene(Scene):
            def construct(self):
                circ = Circle(fill_color=RED, fill_opacity=0.8)
                square = Square(fill_color=BLUE, fill_opacity=0.2)
                self.add(circ)
                self.wait(0.5)
                circ.become(square)
                self.wait(0.5)
    """
    if stretch:
        mobject.stretch_to_fit_height(self.height)
        mobject.stretch_to_fit_width(self.width)
        mobject.stretch_to_fit_depth(self.depth)
    else:
        if match_height:
            mobject.match_height(self)
        if match_width:
            mobject.match_width(self)
        if match_depth:
            mobject.match_depth(self)

    if match_center:
        mobject.move_to(self.get_center())

    self.align_family(mobject)
    for sm1, sm2 in zip(self.get_family(), mobject.get_family()):
        sm1.set_data(sm2.data)
        sm1.set_uniforms(sm2.uniforms)
    self.refresh_bounding_box(recurse_down=True)
    return self

</t>
<t tx="ekr.20250122151620.1766"># Locking data

def lock_data(self, keys: Iterable[str]) -&gt; None:
    """
    To speed up some animations, particularly transformations,
    it can be handy to acknowledge which pieces of data
    won't change during the animation so that calls to
    interpolate can skip this, and so that it's not
    read into the shader_wrapper objects needlessly
    """
    if self.has_updaters:
        return
    # Be sure shader data has most up to date information
    self.refresh_shader_data()
    self.locked_data_keys = set(keys)

</t>
<t tx="ekr.20250122151620.1767">def lock_matching_data(
    self, mobject1: OpenGLMobject, mobject2: OpenGLMobject
) -&gt; Self:
    for sm, sm1, sm2 in zip(
        self.get_family(),
        mobject1.get_family(),
        mobject2.get_family(),
    ):
        keys = sm.data.keys() &amp; sm1.data.keys() &amp; sm2.data.keys()
        sm.lock_data(
            list(
                filter(
                    lambda key: np.all(sm1.data[key] == sm2.data[key]),
                    keys,
                ),
            ),
        )
    return self

</t>
<t tx="ekr.20250122151620.1768">def unlock_data(self) -&gt; None:
    for mob in self.get_family():
        mob.locked_data_keys = set()

</t>
<t tx="ekr.20250122151620.1769"># Operations touching shader uniforms

@affects_shader_info_id
def fix_in_frame(self) -&gt; Self:
    self.is_fixed_in_frame = 1.0
    return self

</t>
<t tx="ekr.20250122151620.177">@property
def tex_dir(self) -&gt; str:
    """Directory to place tex (no flag).  See :meth:`ManimConfig.get_dir`."""
    return self._d["tex_dir"]

</t>
<t tx="ekr.20250122151620.1770">@affects_shader_info_id
def fix_orientation(self) -&gt; Self:
    self.is_fixed_orientation = 1.0
    self.fixed_orientation_center = tuple(self.get_center())
    self.depth_test = True
    return self

</t>
<t tx="ekr.20250122151620.1771">@affects_shader_info_id
def unfix_from_frame(self) -&gt; Self:
    self.is_fixed_in_frame = 0.0
    return self

</t>
<t tx="ekr.20250122151620.1772">@affects_shader_info_id
def unfix_orientation(self) -&gt; Self:
    self.is_fixed_orientation = 0.0
    self.fixed_orientation_center = (0, 0, 0)
    self.depth_test = False
    return self

</t>
<t tx="ekr.20250122151620.1773">@affects_shader_info_id
def apply_depth_test(self) -&gt; Self:
    self.depth_test = True
    return self

</t>
<t tx="ekr.20250122151620.1774">@affects_shader_info_id
def deactivate_depth_test(self) -&gt; Self:
    self.depth_test = False
    return self

</t>
<t tx="ekr.20250122151620.1775"># Shader code manipulation

def replace_shader_code(self, old_code: str, new_code: str) -&gt; Self:
    # TODO, will this work with VMobject structure, given
    # that it does not simpler return shader_wrappers of
    # family?
    for wrapper in self.get_shader_wrapper_list():
        wrapper.replace_code(old_code, new_code)
    return self

</t>
<t tx="ekr.20250122151620.1776">def set_color_by_code(self, glsl_code: str) -&gt; Self:
    """
    Takes a snippet of code and inserts it into a
    context which has the following variables:
    vec4 color, vec3 point, vec3 unit_normal.
    The code should change the color variable
    """
    self.replace_shader_code("///// INSERT COLOR FUNCTION HERE /////", glsl_code)
    return self

</t>
<t tx="ekr.20250122151620.1777">def set_color_by_xyz_func(
    self,
    glsl_snippet: str,
    min_value: float = -5.0,
    max_value: float = 5.0,
    colormap: str = "viridis",
) -&gt; Self:
    """
    Pass in a glsl expression in terms of x, y and z which returns
    a float.
    """
    # TODO, add a version of this which changes the point data instead
    # of the shader code
    for char in "xyz":
        glsl_snippet = glsl_snippet.replace(char, "point." + char)
    rgb_list = get_colormap_list(colormap)
    self.set_color_by_code(
        f"color.rgb = float_to_color({glsl_snippet}, {float(min_value)}, {float(max_value)}, {get_colormap_code(rgb_list)});",
    )
    return self

</t>
<t tx="ekr.20250122151620.1778"># For shader data

def refresh_shader_wrapper_id(self) -&gt; Self:
    self.get_shader_wrapper().refresh_id()
    return self

</t>
<t tx="ekr.20250122151620.1779">def get_shader_wrapper(self) -&gt; ShaderWrapper:
    from manim.renderer.shader_wrapper import ShaderWrapper

    # if hasattr(self, "__shader_wrapper"):
    # return self.__shader_wrapper

    self.shader_wrapper = ShaderWrapper(
        vert_data=self.get_shader_data(),
        vert_indices=self.get_shader_vert_indices(),
        uniforms=self.get_shader_uniforms(),
        depth_test=self.depth_test,
        texture_paths=self.texture_paths,
        render_primitive=self.render_primitive,
        shader_folder=self.__class__.shader_folder,
    )
    return self.shader_wrapper

</t>
<t tx="ekr.20250122151620.178">@tex_dir.setter
def tex_dir(self, value: str | Path) -&gt; None:
    self._set_dir("tex_dir", value)

</t>
<t tx="ekr.20250122151620.1780">def get_shader_wrapper_list(self) -&gt; Sequence[ShaderWrapper]:
    shader_wrappers = it.chain(
        [self.get_shader_wrapper()],
        *(sm.get_shader_wrapper_list() for sm in self.submobjects),
    )
    batches = batch_by_property(shader_wrappers, lambda sw: sw.get_id())

    result = []
    for wrapper_group, _ in batches:
        shader_wrapper = wrapper_group[0]
        if not shader_wrapper.is_valid():
            continue
        shader_wrapper.combine_with(*wrapper_group[1:])
        if len(shader_wrapper.vert_data) &gt; 0:
            result.append(shader_wrapper)
    return result

</t>
<t tx="ekr.20250122151620.1781">def check_data_alignment(self, array: npt.NDArray, data_key: str) -&gt; Self:
    # Makes sure that self.data[key] can be broadcast into
    # the given array, meaning its length has to be either 1
    # or the length of the array
    d_len = len(self.data[data_key])
    if d_len != 1 and d_len != len(array):
        self.data[data_key] = resize_with_interpolation(
            self.data[data_key],
            len(array),
        )
    return self

</t>
<t tx="ekr.20250122151620.1782">def get_resized_shader_data_array(self, length: float) -&gt; npt.NDArray:
    # If possible, try to populate an existing array, rather
    # than recreating it each frame
    points = self.points
    shader_data = np.zeros(len(points), dtype=self.shader_dtype)
    return shader_data

</t>
<t tx="ekr.20250122151620.1783">def read_data_to_shader(
    self,
    shader_data: npt.NDArray,  # has structured data type, ex. ("point", np.float32, (3,))
    shader_data_key: str,
    data_key: str,
) -&gt; None:
    if data_key in self.locked_data_keys:
        return
    self.check_data_alignment(shader_data, data_key)
    shader_data[shader_data_key] = self.data[data_key]

</t>
<t tx="ekr.20250122151620.1784">def get_shader_data(self) -&gt; npt.NDArray:
    shader_data = self.get_resized_shader_data_array(self.get_num_points())
    self.read_data_to_shader(shader_data, "point", "points")
    return shader_data

</t>
<t tx="ekr.20250122151620.1785">def refresh_shader_data(self) -&gt; None:
    self.get_shader_data()

</t>
<t tx="ekr.20250122151620.1786">def get_shader_uniforms(self) -&gt; dict[str, Any]:
    return self.uniforms

</t>
<t tx="ekr.20250122151620.1787">def get_shader_vert_indices(self) -&gt; Sequence[int]:
    return self.shader_indices

</t>
<t tx="ekr.20250122151620.1788">@property
def submobjects(self) -&gt; Sequence[OpenGLMobject]:
    return self._submobjects if hasattr(self, "_submobjects") else []

</t>
<t tx="ekr.20250122151620.1789">@submobjects.setter
def submobjects(self, submobject_list: Iterable[OpenGLMobject]) -&gt; None:
    self.remove(*self.submobjects)
    self.add(*submobject_list)

</t>
<t tx="ekr.20250122151620.179">@property
def partial_movie_dir(self) -&gt; str:
    """Directory to place partial movie files (no flag).  See :meth:`ManimConfig.get_dir`."""
    return self._d["partial_movie_dir"]

</t>
<t tx="ekr.20250122151620.1790"># Errors

def throw_error_if_no_points(self) -&gt; None:
    if not self.has_points():
        message = (
            "Cannot call OpenGLMobject.{} " + "for a OpenGLMobject with no points"
        )
        caller_name = sys._getframe(1).f_code.co_name
        raise Exception(message.format(caller_name))


</t>
<t tx="ekr.20250122151620.1791">def __init__(self, *mobjects: OpenGLMobject, **kwargs):
    super().__init__(**kwargs)
    self.add(*mobjects)


</t>
<t tx="ekr.20250122151620.1792">def __init__(
    self,
    location: Point3DLike = ORIGIN,
    artificial_width: float = 1e-6,
    artificial_height: float = 1e-6,
    **kwargs,
):
    self.artificial_width = artificial_width
    self.artificial_height = artificial_height
    super().__init__(**kwargs)
    self.set_location(location)

</t>
<t tx="ekr.20250122151620.1793">def get_width(self) -&gt; float:
    return self.artificial_width

</t>
<t tx="ekr.20250122151620.1794">def get_height(self) -&gt; float:
    return self.artificial_height

</t>
<t tx="ekr.20250122151620.1795">def get_location(self) -&gt; Point3D:
    return self.points[0].copy()

</t>
<t tx="ekr.20250122151620.1796">def get_bounding_box_point(self, *args, **kwargs) -&gt; Point3D:
    return self.get_location()

</t>
<t tx="ekr.20250122151620.1797">def set_location(self, new_loc: Point3D) -&gt; None:
    self.set_points(np.array(new_loc, ndmin=2, dtype=float))


</t>
<t tx="ekr.20250122151620.1798">def __init__(self, mobject: OpenGLMobject):
    self.mobject = mobject
    self.mobject.generate_target()

    self.overridden_animation = None
    self.is_chaining = False
    self.methods = []

    # Whether animation args can be passed
    self.cannot_pass_args = False
    self.anim_args = {}

</t>
<t tx="ekr.20250122151620.1799">def __call__(self, **kwargs) -&gt; Self:
    if self.cannot_pass_args:
        raise ValueError(
            "Animation arguments must be passed before accessing methods and can only be passed once",
        )

    self.anim_args = kwargs
    self.cannot_pass_args = True

    return self

</t>
<t tx="ekr.20250122151620.18">def parse_cli_ctx(parser: configparser.SectionProxy) -&gt; dict[str, Any]:
    formatter_settings: dict[str, str | int] = {
        "indent_increment": int(parser["indent_increment"]),
        "width": int(parser["width"]),
        "col1_max_width": int(parser["col1_max_width"]),
        "col2_min_width": int(parser["col2_min_width"]),
        "col_spacing": int(parser["col_spacing"]),
        "row_sep": parser["row_sep"] if parser["row_sep"] else None,
    }
    theme_settings = {}
    theme_keys = {
        "command_help",
        "invoked_command",
        "heading",
        "constraint",
        "section_help",
        "col1",
        "col2",
        "epilog",
    }
    for k, v in parser.items():
        if k in theme_keys and v:
            theme_settings.update({k: Style(v)})

    formatter = {}
    theme = parser["theme"] if parser["theme"] else None
    if theme is None:
        formatter = HelpFormatter.settings(
            theme=HelpTheme(**theme_settings),
            **formatter_settings,  # type: ignore[arg-type]
        )
    elif theme.lower() == "dark":
        formatter = HelpFormatter.settings(
            theme=HelpTheme.dark().with_(**theme_settings),
            **formatter_settings,  # type: ignore[arg-type]
        )
    elif theme.lower() == "light":
        formatter = HelpFormatter.settings(
            theme=HelpTheme.light().with_(**theme_settings),
            **formatter_settings,  # type: ignore[arg-type]
        )

    return Context.settings(
        align_option_groups=parser["align_option_groups"].lower() == "true",
        align_sections=parser["align_sections"].lower() == "true",
        show_constraints=True,
        formatter_settings=formatter,
    )
</t>
<t tx="ekr.20250122151620.180">@partial_movie_dir.setter
def partial_movie_dir(self, value: str | Path) -&gt; None:
    self._set_dir("partial_movie_dir", value)

</t>
<t tx="ekr.20250122151620.1800">def __getattr__(self, method_name: str) -&gt; Callable[..., Self]:
    method = getattr(self.mobject.target, method_name)
    has_overridden_animation = hasattr(method, "_override_animate")

    if (self.is_chaining and has_overridden_animation) or self.overridden_animation:
        raise NotImplementedError(
            "Method chaining is currently not supported for overridden animations",
        )

    def update_target(*method_args, **method_kwargs):
        if has_overridden_animation:
            self.overridden_animation = method._override_animate(
                self.mobject,
                *method_args,
                anim_args=self.anim_args,
                **method_kwargs,
            )
        else:
            self.methods.append([method, method_args, method_kwargs])
            method(*method_args, **method_kwargs)
        return self

    self.is_chaining = True
    self.cannot_pass_args = True

    return update_target

</t>
<t tx="ekr.20250122151620.1801">def build(self) -&gt; _MethodAnimation:
    from manim.animation.transform import _MethodAnimation

    if self.overridden_animation:
        anim = self.overridden_animation
    else:
        anim = _MethodAnimation(self.mobject, self.methods)

    for attr, value in self.anim_args.items():
        setattr(anim, attr, value)

    return anim


</t>
<t tx="ekr.20250122151620.1802">from __future__ import annotations

__all__ = ["OpenGLPMobject", "OpenGLPGroup", "OpenGLPMPoint"]

import moderngl
import numpy as np

from manim.constants import *
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.utils.bezier import interpolate
from manim.utils.color import BLACK, WHITE, YELLOW, color_gradient, color_to_rgba
from manim.utils.config_ops import _Uniforms
from manim.utils.iterables import resize_with_interpolation

__all__ = ["OpenGLPMobject", "OpenGLPGroup", "OpenGLPMPoint"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1803">class OpenGLPMobject(OpenGLMobject):
    @others
</t>
<t tx="ekr.20250122151620.1804">class OpenGLPGroup(OpenGLPMobject):
    @others
</t>
<t tx="ekr.20250122151620.1805">class OpenGLPMPoint(OpenGLPMobject):
    @others
</t>
<t tx="ekr.20250122151620.1806">shader_folder = "true_dot"
# Scale for consistency with cairo units
OPENGL_POINT_RADIUS_SCALE_FACTOR = 0.01
shader_dtype = [
    ("point", np.float32, (3,)),
    ("color", np.float32, (4,)),
]

point_radius = _Uniforms()

def __init__(
    self, stroke_width=2.0, color=YELLOW, render_primitive=moderngl.POINTS, **kwargs
):
    self.stroke_width = stroke_width
    super().__init__(color=color, render_primitive=render_primitive, **kwargs)
    self.point_radius = (
        self.stroke_width * OpenGLPMobject.OPENGL_POINT_RADIUS_SCALE_FACTOR
    )

</t>
<t tx="ekr.20250122151620.1807">def reset_points(self):
    self.rgbas = np.zeros((1, 4))
    self.points = np.zeros((0, 3))
    return self

</t>
<t tx="ekr.20250122151620.1808">def get_array_attrs(self):
    return ["points", "rgbas"]

</t>
<t tx="ekr.20250122151620.1809">def add_points(self, points, rgbas=None, color=None, opacity=None):
    """Add points.

    Points must be a Nx3 numpy array.
    Rgbas must be a Nx4 numpy array if it is not None.
    """
    if rgbas is None and color is None:
        color = YELLOW
    self.append_points(points)
    # rgbas array will have been resized with points
    if color is not None:
        if opacity is None:
            opacity = self.rgbas[-1, 3]
        new_rgbas = np.repeat([color_to_rgba(color, opacity)], len(points), axis=0)
    elif rgbas is not None:
        new_rgbas = rgbas
    elif len(rgbas) != len(points):
        raise ValueError("points and rgbas must have same length")
    self.rgbas = np.append(self.rgbas, new_rgbas, axis=0)
    return self

</t>
<t tx="ekr.20250122151620.181">@property
def custom_folders(self) -&gt; str:
    """Whether to use custom folder output."""
    return self._d["custom_folders"]

</t>
<t tx="ekr.20250122151620.1810">def thin_out(self, factor=5):
    """Removes all but every nth point for n = factor"""
    for mob in self.family_members_with_points():
        num_points = mob.get_num_points()

        def thin_func(num_points=num_points):
            return np.arange(0, num_points, factor)

        if len(mob.points) == len(mob.rgbas):
            mob.set_rgba_array_direct(mob.rgbas[thin_func()])
        mob.set_points(mob.points[thin_func()])

    return self

</t>
<t tx="ekr.20250122151620.1811">def set_color_by_gradient(self, *colors):
    self.rgbas = np.array(
        list(map(color_to_rgba, color_gradient(*colors, self.get_num_points()))),
    )
    return self

</t>
<t tx="ekr.20250122151620.1812">def set_colors_by_radial_gradient(
    self,
    center=None,
    radius=1,
    inner_color=WHITE,
    outer_color=BLACK,
):
    start_rgba, end_rgba = list(map(color_to_rgba, [inner_color, outer_color]))
    if center is None:
        center = self.get_center()
    for mob in self.family_members_with_points():
        distances = np.abs(self.points - center)
        alphas = np.linalg.norm(distances, axis=1) / radius

        mob.rgbas = np.array(
            np.array(
                [interpolate(start_rgba, end_rgba, alpha) for alpha in alphas],
            ),
        )
    return self

</t>
<t tx="ekr.20250122151620.1813">def match_colors(self, pmobject):
    self.rgbas[:] = resize_with_interpolation(pmobject.rgbas, self.get_num_points())
    return self

</t>
<t tx="ekr.20250122151620.1814">def fade_to(self, color, alpha, family=True):
    rgbas = interpolate(self.rgbas, color_to_rgba(color), alpha)
    for mob in self.submobjects:
        mob.fade_to(color, alpha, family)
    self.set_rgba_array_direct(rgbas)
    return self

</t>
<t tx="ekr.20250122151620.1815">def filter_out(self, condition):
    for mob in self.family_members_with_points():
        to_keep = ~np.apply_along_axis(condition, 1, mob.points)
        for key in mob.data:
            mob.data[key] = mob.data[key][to_keep]
    return self

</t>
<t tx="ekr.20250122151620.1816">def sort_points(self, function=lambda p: p[0]):
    """function is any map from R^3 to R"""
    for mob in self.family_members_with_points():
        indices = np.argsort(np.apply_along_axis(function, 1, mob.points))
        for key in mob.data:
            mob.data[key] = mob.data[key][indices]
    return self

</t>
<t tx="ekr.20250122151620.1817">def ingest_submobjects(self):
    for key in self.data:
        self.data[key] = np.vstack([sm.data[key] for sm in self.get_family()])
    return self

</t>
<t tx="ekr.20250122151620.1818">def point_from_proportion(self, alpha):
    index = alpha * (self.get_num_points() - 1)
    return self.points[int(index)]

</t>
<t tx="ekr.20250122151620.1819">def pointwise_become_partial(self, pmobject, a, b):
    lower_index = int(a * pmobject.get_num_points())
    upper_index = int(b * pmobject.get_num_points())
    for key in self.data:
        self.data[key] = pmobject.data[key][lower_index:upper_index]
    return self

</t>
<t tx="ekr.20250122151620.182">@custom_folders.setter
def custom_folders(self, value: str | Path) -&gt; None:
    self._set_dir("custom_folders", value)

</t>
<t tx="ekr.20250122151620.1820">def get_shader_data(self):
    shader_data = np.zeros(len(self.points), dtype=self.shader_dtype)
    self.read_data_to_shader(shader_data, "point", "points")
    self.read_data_to_shader(shader_data, "color", "rgbas")
    return shader_data

</t>
<t tx="ekr.20250122151620.1821">@staticmethod
def get_mobject_type_class():
    return OpenGLPMobject


</t>
<t tx="ekr.20250122151620.1822">def __init__(self, *pmobs, **kwargs):
    if not all(isinstance(m, OpenGLPMobject) for m in pmobs):
        raise Exception("All submobjects must be of type OpenglPMObject")
    super().__init__(**kwargs)
    self.add(*pmobs)

</t>
<t tx="ekr.20250122151620.1823">def fade_to(self, color, alpha, family=True):
    if family:
        for mob in self.submobjects:
            mob.fade_to(color, alpha, family)


</t>
<t tx="ekr.20250122151620.1824">def __init__(self, location=ORIGIN, stroke_width=4.0, **kwargs):
    self.location = location
    super().__init__(stroke_width=stroke_width, **kwargs)

</t>
<t tx="ekr.20250122151620.1825">def init_points(self):
    self.points = np.array([self.location], dtype=np.float32)
</t>
<t tx="ekr.20250122151620.1826">from __future__ import annotations

from collections.abc import Iterable
from pathlib import Path

import moderngl
import numpy as np
from PIL import Image

from manim.constants import *
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.utils.bezier import integer_interpolate, interpolate
from manim.utils.color import *
from manim.utils.config_ops import _Data, _Uniforms
from manim.utils.images import change_to_rgba_array, get_full_raster_image_path
from manim.utils.iterables import listify
from manim.utils.space_ops import normalize_along_axis

__all__ = ["OpenGLSurface", "OpenGLTexturedSurface"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1827">class OpenGLSurface(OpenGLMobject):
    @others
</t>
<t tx="ekr.20250122151620.1828">class OpenGLSurfaceGroup(OpenGLSurface):
    @others
</t>
<t tx="ekr.20250122151620.1829">class OpenGLTexturedSurface(OpenGLSurface):
    @others
</t>
<t tx="ekr.20250122151620.183">@property
def input_file(self) -&gt; str:
    """Input file name."""
    return self._d["input_file"]

</t>
<t tx="ekr.20250122151620.1830">r"""Creates a Surface.

Parameters
----------
uv_func
    The function that defines the surface.
u_range
    The range of the ``u`` variable: ``(u_min, u_max)``.
v_range
    The range of the ``v`` variable: ``(v_min, v_max)``.
resolution
    The number of samples taken of the surface.
axes
    Axes on which the surface is to be drawn. Optional
    parameter used when coloring a surface by z-value.
color
    Color of the surface. Defaults to grey.
colorscale
    Colors of the surface. Optional parameter used when
    coloring a surface by values. Passing a list of
    colors and an axes will color the surface by z-value.
    Passing a list of tuples in the form ``(color, pivot)``
    allows user-defined pivots where the color transitions.
colorscale_axis
    Defines the axis on which the colorscale is applied
    (0 = x, 1 = y, 2 = z), default is z-axis (2).
opacity
    Opacity of the surface from 0 being fully transparent
    to 1 being fully opaque. Defaults to 1.
"""

shader_dtype = [
    ("point", np.float32, (3,)),
    ("du_point", np.float32, (3,)),
    ("dv_point", np.float32, (3,)),
    ("color", np.float32, (4,)),
]
shader_folder = "surface"

def __init__(
    self,
    uv_func=None,
    u_range=None,
    v_range=None,
    # Resolution counts number of points sampled, which for
    # each coordinate is one more than the the number of
    # rows/columns of approximating squares
    resolution=None,
    axes=None,
    color=GREY,
    colorscale=None,
    colorscale_axis=2,
    opacity=1.0,
    gloss=0.3,
    shadow=0.4,
    prefered_creation_axis=1,
    # For du and dv steps.  Much smaller and numerical error
    # can crop up in the shaders.
    epsilon=1e-5,
    render_primitive=moderngl.TRIANGLES,
    depth_test=True,
    shader_folder=None,
    **kwargs,
):
    self.passed_uv_func = uv_func
    self.u_range = u_range if u_range is not None else (0, 1)
    self.v_range = v_range if v_range is not None else (0, 1)
    # Resolution counts number of points sampled, which for
    # each coordinate is one more than the the number of
    # rows/columns of approximating squares
    self.resolution = resolution if resolution is not None else (101, 101)
    self.axes = axes
    self.colorscale = colorscale
    self.colorscale_axis = colorscale_axis
    self.prefered_creation_axis = prefered_creation_axis
    # For du and dv steps.  Much smaller and numerical error
    # can crop up in the shaders.
    self.epsilon = epsilon

    self.triangle_indices = None
    super().__init__(
        color=color,
        opacity=opacity,
        gloss=gloss,
        shadow=shadow,
        shader_folder=shader_folder if shader_folder is not None else "surface",
        render_primitive=render_primitive,
        depth_test=depth_test,
        **kwargs,
    )
    self.compute_triangle_indices()

</t>
<t tx="ekr.20250122151620.1831">def uv_func(self, u, v):
    # To be implemented in subclasses
    if self.passed_uv_func:
        return self.passed_uv_func(u, v)
    return (u, v, 0.0)

</t>
<t tx="ekr.20250122151620.1832">def init_points(self):
    dim = self.dim
    nu, nv = self.resolution
    u_range = np.linspace(*self.u_range, nu)
    v_range = np.linspace(*self.v_range, nv)

    # Get three lists:
    # - Points generated by pure uv values
    # - Those generated by values nudged by du
    # - Those generated by values nudged by dv
    point_lists = []
    for du, dv in [(0, 0), (self.epsilon, 0), (0, self.epsilon)]:
        uv_grid = np.array([[[u + du, v + dv] for v in v_range] for u in u_range])
        point_grid = np.apply_along_axis(lambda p: self.uv_func(*p), 2, uv_grid)
        point_lists.append(point_grid.reshape((nu * nv, dim)))
    # Rather than tracking normal vectors, the points list will hold on to the
    # infinitesimal nudged values alongside the original values.  This way, one
    # can perform all the manipulations they'd like to the surface, and normals
    # are still easily recoverable.
    self.set_points(np.vstack(point_lists))

</t>
<t tx="ekr.20250122151620.1833">def compute_triangle_indices(self):
    # TODO, if there is an event which changes
    # the resolution of the surface, make sure
    # this is called.
    nu, nv = self.resolution
    if nu == 0 or nv == 0:
        self.triangle_indices = np.zeros(0, dtype=int)
        return
    index_grid = np.arange(nu * nv).reshape((nu, nv))
    indices = np.zeros(6 * (nu - 1) * (nv - 1), dtype=int)
    indices[0::6] = index_grid[:-1, :-1].flatten()  # Top left
    indices[1::6] = index_grid[+1:, :-1].flatten()  # Bottom left
    indices[2::6] = index_grid[:-1, +1:].flatten()  # Top right
    indices[3::6] = index_grid[:-1, +1:].flatten()  # Top right
    indices[4::6] = index_grid[+1:, :-1].flatten()  # Bottom left
    indices[5::6] = index_grid[+1:, +1:].flatten()  # Bottom right
    self.triangle_indices = indices

</t>
<t tx="ekr.20250122151620.1834">def get_triangle_indices(self):
    return self.triangle_indices

</t>
<t tx="ekr.20250122151620.1835">def get_surface_points_and_nudged_points(self):
    points = self.points
    k = len(points) // 3
    return points[:k], points[k : 2 * k], points[2 * k :]

</t>
<t tx="ekr.20250122151620.1836">def get_unit_normals(self):
    s_points, du_points, dv_points = self.get_surface_points_and_nudged_points()
    normals = np.cross(
        (du_points - s_points) / self.epsilon,
        (dv_points - s_points) / self.epsilon,
    )
    return normalize_along_axis(normals, 1)

</t>
<t tx="ekr.20250122151620.1837">def pointwise_become_partial(self, smobject, a, b, axis=None):
    assert isinstance(smobject, OpenGLSurface)
    if axis is None:
        axis = self.prefered_creation_axis
    if a &lt;= 0 and b &gt;= 1:
        self.match_points(smobject)
        return self

    nu, nv = smobject.resolution
    self.set_points(
        np.vstack(
            [
                self.get_partial_points_array(
                    arr.copy(),
                    a,
                    b,
                    (nu, nv, 3),
                    axis=axis,
                )
                for arr in smobject.get_surface_points_and_nudged_points()
            ],
        ),
    )
    return self

</t>
<t tx="ekr.20250122151620.1838">def get_partial_points_array(self, points, a, b, resolution, axis):
    if len(points) == 0:
        return points
    nu, nv = resolution[:2]
    points = points.reshape(resolution)
    max_index = resolution[axis] - 1
    lower_index, lower_residue = integer_interpolate(0, max_index, a)
    upper_index, upper_residue = integer_interpolate(0, max_index, b)
    if axis == 0:
        points[:lower_index] = interpolate(
            points[lower_index],
            points[lower_index + 1],
            lower_residue,
        )
        points[upper_index + 1 :] = interpolate(
            points[upper_index],
            points[upper_index + 1],
            upper_residue,
        )
    else:
        shape = (nu, 1, resolution[2])
        points[:, :lower_index] = interpolate(
            points[:, lower_index],
            points[:, lower_index + 1],
            lower_residue,
        ).reshape(shape)
        points[:, upper_index + 1 :] = interpolate(
            points[:, upper_index],
            points[:, upper_index + 1],
            upper_residue,
        ).reshape(shape)
    return points.reshape((nu * nv, *resolution[2:]))

</t>
<t tx="ekr.20250122151620.1839">def sort_faces_back_to_front(self, vect=OUT):
    tri_is = self.triangle_indices
    indices = list(range(len(tri_is) // 3))
    points = self.points

    def index_dot(index):
        return np.dot(points[tri_is[3 * index]], vect)

    indices.sort(key=index_dot)
    for k in range(3):
        tri_is[k::3] = tri_is[k::3][indices]
    return self

</t>
<t tx="ekr.20250122151620.184">@input_file.setter
def input_file(self, value: str | Path) -&gt; None:
    self._set_dir("input_file", value)

</t>
<t tx="ekr.20250122151620.1840"># For shaders
def get_shader_data(self):
    """Called by parent Mobject to calculate and return
    the shader data.

    Returns
    -------
    shader_dtype
        An array containing the shader data (vertices and
        color of each vertex)
    """
    s_points, du_points, dv_points = self.get_surface_points_and_nudged_points()
    shader_data = np.zeros(len(s_points), dtype=self.shader_dtype)
    if "points" not in self.locked_data_keys:
        shader_data["point"] = s_points
        shader_data["du_point"] = du_points
        shader_data["dv_point"] = dv_points
        if self.colorscale:
            if not hasattr(self, "color_by_val"):
                self.color_by_val = self._get_color_by_value(s_points)
            shader_data["color"] = self.color_by_val
        else:
            self.fill_in_shader_color_info(shader_data)
    return shader_data

</t>
<t tx="ekr.20250122151620.1841">def fill_in_shader_color_info(self, shader_data):
    """Fills in the shader color data when the surface
    is all one color.

    Parameters
    ----------
    shader_data
        The vertices of the surface.

    Returns
    -------
    shader_dtype
        An array containing the shader data (vertices and
        color of each vertex)
    """
    self.read_data_to_shader(shader_data, "color", "rgbas")
    return shader_data

</t>
<t tx="ekr.20250122151620.1842">def _get_color_by_value(self, s_points):
    """Matches each vertex to a color associated to it's z-value.

    Parameters
    ----------
    s_points
       The vertices of the surface.

    Returns
    -------
    List
        A list of colors matching the vertex inputs.
    """
    if type(self.colorscale[0]) in (list, tuple):
        new_colors, pivots = [
            [i for i, j in self.colorscale],
            [j for i, j in self.colorscale],
        ]
    else:
        new_colors = self.colorscale

        pivot_min = self.axes.z_range[0]
        pivot_max = self.axes.z_range[1]
        pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)
        pivots = np.arange(
            start=pivot_min,
            stop=pivot_max + pivot_frequency,
            step=pivot_frequency,
        )

    return_colors = []
    for point in s_points:
        axis_value = self.axes.point_to_coords(point)[self.colorscale_axis]
        if axis_value &lt;= pivots[0]:
            return_colors.append(color_to_rgba(new_colors[0], self.opacity))
        elif axis_value &gt;= pivots[-1]:
            return_colors.append(color_to_rgba(new_colors[-1], self.opacity))
        else:
            for i, pivot in enumerate(pivots):
                if pivot &gt; axis_value:
                    color_index = (axis_value - pivots[i - 1]) / (
                        pivots[i] - pivots[i - 1]
                    )
                    color_index = max(min(color_index, 1), 0)
                    temp_color = interpolate_color(
                        new_colors[i - 1],
                        new_colors[i],
                        color_index,
                    )
                    break
            return_colors.append(color_to_rgba(temp_color, self.opacity))

    return return_colors

</t>
<t tx="ekr.20250122151620.1843">def get_shader_vert_indices(self):
    return self.get_triangle_indices()


</t>
<t tx="ekr.20250122151620.1844">def __init__(self, *parametric_surfaces, resolution=None, **kwargs):
    self.resolution = (0, 0) if resolution is None else resolution
    super().__init__(uv_func=None, **kwargs)
    self.add(*parametric_surfaces)

</t>
<t tx="ekr.20250122151620.1845">def init_points(self):
    pass  # Needed?


</t>
<t tx="ekr.20250122151620.1846">shader_dtype = [
    ("point", np.float32, (3,)),
    ("du_point", np.float32, (3,)),
    ("dv_point", np.float32, (3,)),
    ("im_coords", np.float32, (2,)),
    ("opacity", np.float32, (1,)),
]
shader_folder = "textured_surface"
im_coords = _Data()
opacity = _Data()
num_textures = _Uniforms()

def __init__(
    self,
    uv_surface: OpenGLSurface,
    image_file: str | Path,
    dark_image_file: str | Path = None,
    image_mode: str | Iterable[str] = "RGBA",
    shader_folder: str | Path = None,
    **kwargs,
):
    self.uniforms = {}

    if not isinstance(uv_surface, OpenGLSurface):
        raise Exception("uv_surface must be of type OpenGLSurface")
    if isinstance(image_file, np.ndarray):
        image_file = change_to_rgba_array(image_file)

    # Set texture information
    if isinstance(image_mode, (str, Path)):
        image_mode = [image_mode] * 2
    image_mode_light, image_mode_dark = image_mode
    texture_paths = {
        "LightTexture": self.get_image_from_file(
            image_file,
            image_mode_light,
        ),
        "DarkTexture": self.get_image_from_file(
            dark_image_file or image_file,
            image_mode_dark,
        ),
    }
    if dark_image_file:
        self.num_textures = 2

    self.uv_surface = uv_surface
    self.uv_func = uv_surface.uv_func
    self.u_range = uv_surface.u_range
    self.v_range = uv_surface.v_range
    self.resolution = uv_surface.resolution
    self.gloss = self.uv_surface.gloss
    super().__init__(texture_paths=texture_paths, **kwargs)

</t>
<t tx="ekr.20250122151620.1847">def get_image_from_file(
    self,
    image_file: str | Path,
    image_mode: str,
):
    image_file = get_full_raster_image_path(image_file)
    return Image.open(image_file).convert(image_mode)

</t>
<t tx="ekr.20250122151620.1848">def init_data(self):
    super().init_data()
    self.im_coords = np.zeros((0, 2))
    self.opacity = np.zeros((0, 1))

</t>
<t tx="ekr.20250122151620.1849">def init_points(self):
    nu, nv = self.uv_surface.resolution
    self.set_points(self.uv_surface.points)
    self.im_coords = np.array(
        [
            [u, v]
            for u in np.linspace(0, 1, nu)
            for v in np.linspace(1, 0, nv)  # Reverse y-direction
        ],
    )

</t>
<t tx="ekr.20250122151620.185">@property
def output_file(self) -&gt; str:
    """Output file name (-o)."""
    return self._d["output_file"]

</t>
<t tx="ekr.20250122151620.1850">def init_colors(self):
    self.opacity = np.array([self.uv_surface.rgbas[:, 3]])

</t>
<t tx="ekr.20250122151620.1851">def set_opacity(self, opacity, recurse=True):
    for mob in self.get_family(recurse):
        mob.opacity = np.array([[o] for o in listify(opacity)])
    return self

</t>
<t tx="ekr.20250122151620.1852">def pointwise_become_partial(self, tsmobject, a, b, axis=1):
    super().pointwise_become_partial(tsmobject, a, b, axis)
    im_coords = self.im_coords
    im_coords[:] = tsmobject.im_coords
    if a &lt;= 0 and b &gt;= 1:
        return self
    nu, nv = tsmobject.resolution
    im_coords[:] = self.get_partial_points_array(im_coords, a, b, (nu, nv, 2), axis)
    return self

</t>
<t tx="ekr.20250122151620.1853">def fill_in_shader_color_info(self, shader_data):
    self.read_data_to_shader(shader_data, "opacity", "opacity")
    self.read_data_to_shader(shader_data, "im_coords", "im_coords")
    return shader_data
</t>
<t tx="ekr.20250122151620.1854">from __future__ import annotations

import numpy as np

from manim.mobject.opengl.opengl_surface import OpenGLSurface
from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVGroup, OpenGLVMobject

__all__ = ["OpenGLSurfaceMesh"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1855">class OpenGLSurfaceMesh(OpenGLVGroup):
    @others
</t>
<t tx="ekr.20250122151620.1856">def __init__(
    self,
    uv_surface,
    resolution=None,
    stroke_width=1,
    normal_nudge=1e-2,
    depth_test=True,
    flat_stroke=False,
    **kwargs,
):
    if not isinstance(uv_surface, OpenGLSurface):
        raise Exception("uv_surface must be of type OpenGLSurface")
    self.uv_surface = uv_surface
    self.resolution = resolution if resolution is not None else (21, 21)
    self.normal_nudge = normal_nudge
    super().__init__(
        stroke_width=stroke_width,
        depth_test=depth_test,
        flat_stroke=flat_stroke,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.1857">def init_points(self):
    uv_surface = self.uv_surface

    full_nu, full_nv = uv_surface.resolution
    part_nu, part_nv = self.resolution
    u_indices = np.linspace(0, full_nu, part_nu).astype(int)
    v_indices = np.linspace(0, full_nv, part_nv).astype(int)

    points, du_points, dv_points = uv_surface.get_surface_points_and_nudged_points()
    normals = uv_surface.get_unit_normals()
    nudged_points = points + self.normal_nudge * normals

    for ui in u_indices:
        path = OpenGLVMobject()
        full_ui = full_nv * ui
        path.set_points_smoothly(nudged_points[full_ui : full_ui + full_nv])
        self.add(path)
    for vi in v_indices:
        path = OpenGLVMobject()
        path.set_points_smoothly(nudged_points[vi::full_nv])
        self.add(path)
</t>
<t tx="ekr.20250122151620.1858">from __future__ import annotations

import itertools as it
import operator as op
from collections.abc import Iterable, Sequence
from functools import reduce, wraps
from typing import Callable

import moderngl
import numpy as np

from manim import config
from manim.constants import *
from manim.mobject.opengl.opengl_mobject import OpenGLMobject, OpenGLPoint
from manim.renderer.shader_wrapper import ShaderWrapper
from manim.utils.bezier import (
    bezier,
    bezier_remap,
    get_quadratic_approximation_of_cubic,
    get_smooth_cubic_bezier_handle_points,
    integer_interpolate,
    interpolate,
    partial_bezier_points,
    proportions_along_bezier_curve_for_point,
)
from manim.utils.color import BLACK, WHITE, ManimColor, ParsableManimColor
from manim.utils.config_ops import _Data
from manim.utils.iterables import make_even, resize_with_interpolation, tuplify
from manim.utils.space_ops import (
    angle_between_vectors,
    cross2d,
    earclip_triangulation,
    get_unit_normal,
    shoelace_direction,
    z_to_vector,
)

__all__ = [
    "triggers_refreshed_triangulation",
    "OpenGLVMobject",
    "OpenGLVGroup",
    "OpenGLVectorizedPoint",
    "OpenGLCurvesAsSubmobjects",
    "OpenGLDashedVMobject",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1859">def triggers_refreshed_triangulation(func):
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        old_points = np.empty((0, 3))
        for mob in self.family_members_with_points():
            old_points = np.concatenate((old_points, mob.points), axis=0)
        func(self, *args, **kwargs)
        new_points = np.empty((0, 3))
        for mob in self.family_members_with_points():
            new_points = np.concatenate((new_points, mob.points), axis=0)
        if not np.array_equal(new_points, old_points):
            self.refresh_triangulation()
            self.refresh_unit_normal()
        return self

    return wrapper


</t>
<t tx="ekr.20250122151620.186">@output_file.setter
def output_file(self, value: str | Path) -&gt; None:
    self._set_dir("output_file", value)

</t>
<t tx="ekr.20250122151620.1860">class OpenGLVMobject(OpenGLMobject):
    """A vectorized mobject."""

    @others
</t>
<t tx="ekr.20250122151620.1861">class OpenGLVGroup(OpenGLVMobject):
    """A group of vectorized mobjects.

    This can be used to group multiple :class:`~.OpenGLVMobject` instances together
    in order to scale, move, ... them together.

    Examples
    --------

    To add :class:`~.OpenGLVMobject`s to a :class:`~.OpenGLVGroup`, you can either use the
    :meth:`~.OpenGLVGroup.add` method, or use the `+` and `+=` operators. Similarly, you
    can subtract elements of a OpenGLVGroup via :meth:`~.OpenGLVGroup.remove` method, or
    `-` and `-=` operators:

    .. doctest::

        &gt;&gt;&gt; from manim import config
        &gt;&gt;&gt; original_renderer = config.renderer
        &gt;&gt;&gt; config.renderer = "opengl"

        &gt;&gt;&gt; from manim import Triangle, Square
        &gt;&gt;&gt; from manim.opengl import OpenGLVGroup
        &gt;&gt;&gt; config.renderer
        &lt;RendererType.OPENGL: 'opengl'&gt;
        &gt;&gt;&gt; vg = OpenGLVGroup()
        &gt;&gt;&gt; triangle, square = Triangle(), Square()
        &gt;&gt;&gt; vg.add(triangle)
        OpenGLVGroup(Triangle)
        &gt;&gt;&gt; vg + square  # a new OpenGLVGroup is constructed
        OpenGLVGroup(Triangle, Square)
        &gt;&gt;&gt; vg  # not modified
        OpenGLVGroup(Triangle)
        &gt;&gt;&gt; vg += square  # modifies vg
        &gt;&gt;&gt; vg
        OpenGLVGroup(Triangle, Square)
        &gt;&gt;&gt; vg.remove(triangle)
        OpenGLVGroup(Square)
        &gt;&gt;&gt; vg - square  # a new OpenGLVGroup is constructed
        OpenGLVGroup()
        &gt;&gt;&gt; vg  # not modified
        OpenGLVGroup(Square)
        &gt;&gt;&gt; vg -= square  # modifies vg
        &gt;&gt;&gt; vg
        OpenGLVGroup()

        &gt;&gt;&gt; config.renderer = original_renderer

    .. manim:: ArcShapeIris
        :save_last_frame:

        class ArcShapeIris(Scene):
            def construct(self):
                colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]
                radius = [1 + rad * 0.1 for rad in range(len(colors))]

                circles_group = OpenGLVGroup()

                # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]
                circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)
                                    for rad, col in zip(radius, colors)])
                self.add(circles_group)
    """

    @others
</t>
<t tx="ekr.20250122151620.1862">class OpenGLVectorizedPoint(OpenGLPoint, OpenGLVMobject):
    @others
</t>
<t tx="ekr.20250122151620.1863">class OpenGLCurvesAsSubmobjects(OpenGLVGroup):
    """Convert a curve's elements to submobjects.

    Examples
    --------
    .. manim:: LineGradientExample
        :save_last_frame:

        class LineGradientExample(Scene):
            def construct(self):
                curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)
                new_curve = CurvesAsSubmobjects(curve)
                new_curve.set_color_by_gradient(BLUE, RED)
                self.add(new_curve.shift(UP), curve)

    """

    @others
</t>
<t tx="ekr.20250122151620.1864">class OpenGLDashedVMobject(OpenGLVMobject):
    """A :class:`OpenGLVMobject` composed of dashes instead of lines.

    Examples
    --------
    .. manim:: DashedVMobjectExample
        :save_last_frame:

        class DashedVMobjectExample(Scene):
            def construct(self):
                r = 0.5

                top_row = OpenGLVGroup()  # Increasing num_dashes
                for dashes in range(2, 12):
                    circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)
                    top_row.add(circ)

                middle_row = OpenGLVGroup()  # Increasing dashed_ratio
                for ratio in np.arange(1 / 11, 1, 1 / 11):
                    circ = DashedVMobject(
                        Circle(radius=r, color=WHITE), dashed_ratio=ratio
                    )
                    middle_row.add(circ)

                sq = DashedVMobject(Square(1.5, color=RED))
                penta = DashedVMobject(RegularPolygon(5, color=BLUE))
                bottom_row = OpenGLVGroup(sq, penta)

                top_row.arrange(buff=0.4)
                middle_row.arrange()
                bottom_row.arrange(buff=1)
                everything = OpenGLVGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)
                self.add(everything)
    """

    @others
</t>
<t tx="ekr.20250122151620.1865">fill_dtype = [
    ("point", np.float32, (3,)),
    ("unit_normal", np.float32, (3,)),
    ("color", np.float32, (4,)),
    ("vert_index", np.float32, (1,)),
]
stroke_dtype = [
    ("point", np.float32, (3,)),
    ("prev_point", np.float32, (3,)),
    ("next_point", np.float32, (3,)),
    ("unit_normal", np.float32, (3,)),
    ("stroke_width", np.float32, (1,)),
    ("color", np.float32, (4,)),
]
stroke_shader_folder = "quadratic_bezier_stroke"
fill_shader_folder = "quadratic_bezier_fill"

fill_rgba = _Data()
stroke_rgba = _Data()
stroke_width = _Data()
unit_normal = _Data()

def __init__(
    self,
    fill_color: ParsableManimColor | None = None,
    fill_opacity: float = 0.0,
    stroke_color: ParsableManimColor | None = None,
    stroke_opacity: float = 1.0,
    stroke_width: float = DEFAULT_STROKE_WIDTH,
    draw_stroke_behind_fill: bool = False,
    # Indicates that it will not be displayed, but
    # that it should count in parent mobject's path
    pre_function_handle_to_anchor_scale_factor: float = 0.01,
    make_smooth_after_applying_functions: float = False,
    background_image_file: str | None = None,
    # This is within a pixel
    # TODO, do we care about accounting for
    # varying zoom levels?
    tolerance_for_point_equality: float = 1e-8,
    n_points_per_curve: int = 3,
    long_lines: bool = False,
    should_subdivide_sharp_curves: bool = False,
    should_remove_null_curves: bool = False,
    # Could also be "bevel", "miter", "round"
    joint_type: LineJointType | None = None,
    flat_stroke: bool = True,
    render_primitive=moderngl.TRIANGLES,
    triangulation_locked: bool = False,
    **kwargs,
):
    self.data = {}
    self.fill_opacity = fill_opacity
    self.stroke_opacity = stroke_opacity
    self.stroke_width = stroke_width
    self.draw_stroke_behind_fill = draw_stroke_behind_fill
    # Indicates that it will not be displayed, but
    # that it should count in parent mobject's path
    self.pre_function_handle_to_anchor_scale_factor = (
        pre_function_handle_to_anchor_scale_factor
    )
    self.make_smooth_after_applying_functions = make_smooth_after_applying_functions
    self.background_image_file = background_image_file
    # This is within a pixel
    # TODO, do we care about accounting for
    # varying zoom levels?
    self.tolerance_for_point_equality = tolerance_for_point_equality
    self.n_points_per_curve = n_points_per_curve
    self.long_lines = long_lines
    self.should_subdivide_sharp_curves = should_subdivide_sharp_curves
    self.should_remove_null_curves = should_remove_null_curves
    if joint_type is None:
        joint_type = LineJointType.AUTO
    self.joint_type = joint_type
    self.flat_stroke = flat_stroke
    self.render_primitive = render_primitive
    self.triangulation_locked = triangulation_locked

    self.needs_new_triangulation = True
    self.triangulation = np.zeros(0, dtype="i4")
    self.orientation = 1

    self.fill_data = None
    self.stroke_data = None
    self.fill_shader_wrapper = None
    self.stroke_shader_wrapper = None
    self.init_shader_data()

    super().__init__(**kwargs)
    self.refresh_unit_normal()

    if fill_color is not None:
        self.fill_color = ManimColor.parse(fill_color)
    if stroke_color is not None:
        self.stroke_color = ManimColor.parse(stroke_color)

</t>
<t tx="ekr.20250122151620.1866">def _assert_valid_submobjects(self, submobjects: Iterable[OpenGLVMobject]) -&gt; Self:
    return self._assert_valid_submobjects_internal(submobjects, OpenGLVMobject)

</t>
<t tx="ekr.20250122151620.1867">def get_group_class(self):
    return OpenGLVGroup

</t>
<t tx="ekr.20250122151620.1868">@staticmethod
def get_mobject_type_class():
    return OpenGLVMobject

</t>
<t tx="ekr.20250122151620.1869">def init_data(self):
    super().init_data()
    self.data.pop("rgbas")
    self.fill_rgba = np.zeros((1, 4))
    self.stroke_rgba = np.zeros((1, 4))
    self.unit_normal = np.zeros((1, 3))
</t>
<t tx="ekr.20250122151620.187">@property
def scene_names(self) -&gt; list[str]:
    """Scenes to play from file."""
    return self._d["scene_names"]

</t>
<t tx="ekr.20250122151620.1870">    # stroke_width belongs to self.data, but is defined through init_colors+set_stroke

# Colors
def init_colors(self):
    self.set_fill(
        color=self.fill_color or self.color,
        opacity=self.fill_opacity,
    )
    self.set_stroke(
        color=self.stroke_color or self.color,
        width=self.stroke_width,
        opacity=self.stroke_opacity,
        background=self.draw_stroke_behind_fill,
    )
    self.set_gloss(self.gloss)
    self.set_flat_stroke(self.flat_stroke)
    return self

</t>
<t tx="ekr.20250122151620.1871">def set_fill(
    self,
    color: ParsableManimColor | None = None,
    opacity: float | None = None,
    recurse: bool = True,
) -&gt; OpenGLVMobject:
    """Set the fill color and fill opacity of a :class:`OpenGLVMobject`.

    Parameters
    ----------
    color
        Fill color of the :class:`OpenGLVMobject`.
    opacity
        Fill opacity of the :class:`OpenGLVMobject`.
    recurse
        If ``True``, the fill color of all submobjects is also set.

    Returns
    -------
    OpenGLVMobject
        self. For chaining purposes.

    Examples
    --------
    .. manim:: SetFill
        :save_last_frame:

        class SetFill(Scene):
            def construct(self):
                square = Square().scale(2).set_fill(WHITE,1)
                circle1 = Circle().set_fill(GREEN,0.8)
                circle2 = Circle().set_fill(YELLOW) # No fill_opacity
                circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)
                group = Group(circle1,circle2,circle3).arrange()
                self.add(square)
                self.add(group)

    See Also
    --------
    :meth:`~.OpenGLVMobject.set_style`
    """
    if opacity is not None:
        self.fill_opacity = opacity
    if recurse:
        for submobject in self.submobjects:
            submobject.set_fill(color, opacity, recurse)

    self.set_rgba_array(color, opacity, "fill_rgba", recurse)
    return self

</t>
<t tx="ekr.20250122151620.1872">def set_stroke(
    self,
    color=None,
    width=None,
    opacity=None,
    background=None,
    recurse=True,
):
    if opacity is not None:
        self.stroke_opacity = opacity
    if recurse:
        for submobject in self.submobjects:
            submobject.set_stroke(
                color=color,
                width=width,
                opacity=opacity,
                background=background,
                recurse=recurse,
            )

    self.set_rgba_array(color, opacity, "stroke_rgba", recurse)

    if width is not None:
        for mob in self.get_family(recurse):
            mob.stroke_width = np.array([[width] for width in tuplify(width)])

    if background is not None:
        for mob in self.get_family(recurse):
            mob.draw_stroke_behind_fill = background
    return self

</t>
<t tx="ekr.20250122151620.1873">def set_style(
    self,
    fill_color=None,
    fill_opacity=None,
    fill_rgba=None,
    stroke_color=None,
    stroke_opacity=None,
    stroke_rgba=None,
    stroke_width=None,
    gloss=None,
    shadow=None,
    recurse=True,
):
    if fill_rgba is not None:
        self.fill_rgba = resize_with_interpolation(fill_rgba, len(fill_rgba))
    else:
        self.set_fill(color=fill_color, opacity=fill_opacity, recurse=recurse)

    if stroke_rgba is not None:
        self.stroke_rgba = resize_with_interpolation(stroke_rgba, len(fill_rgba))
        self.set_stroke(width=stroke_width)
    else:
        self.set_stroke(
            color=stroke_color,
            width=stroke_width,
            opacity=stroke_opacity,
            recurse=recurse,
        )

    if gloss is not None:
        self.set_gloss(gloss, recurse=recurse)
    if shadow is not None:
        self.set_shadow(shadow, recurse=recurse)
    return self

</t>
<t tx="ekr.20250122151620.1874">def get_style(self):
    return {
        "fill_rgba": self.fill_rgba,
        "stroke_rgba": self.stroke_rgba,
        "stroke_width": self.stroke_width,
        "gloss": self.gloss,
        "shadow": self.shadow,
    }

</t>
<t tx="ekr.20250122151620.1875">def match_style(self, vmobject, recurse=True):
    vmobject_style = vmobject.get_style()
    if config.renderer == RendererType.OPENGL:
        vmobject_style["stroke_width"] = vmobject_style["stroke_width"][0][0]
        vmobject_style["fill_opacity"] = self.get_fill_opacity()
    self.set_style(**vmobject_style, recurse=False)
    if recurse:
        # Does its best to match up submobject lists, and
        # match styles accordingly
        submobs1, submobs2 = self.submobjects, vmobject.submobjects
        if len(submobs1) == 0:
            return self
        elif len(submobs2) == 0:
            submobs2 = [vmobject]
        for sm1, sm2 in zip(*make_even(submobs1, submobs2)):
            sm1.match_style(sm2)
    return self

</t>
<t tx="ekr.20250122151620.1876">def set_color(self, color, opacity=None, recurse=True):
    if opacity is not None:
        self.opacity = opacity

    self.set_fill(color, opacity=opacity, recurse=recurse)
    self.set_stroke(color, opacity=opacity, recurse=recurse)
    return self

</t>
<t tx="ekr.20250122151620.1877">def set_opacity(self, opacity, recurse=True):
    self.set_fill(opacity=opacity, recurse=recurse)
    self.set_stroke(opacity=opacity, recurse=recurse)
    return self

</t>
<t tx="ekr.20250122151620.1878">def fade(self, darkness=0.5, recurse=True):
    factor = 1.0 - darkness
    self.set_fill(
        opacity=factor * self.get_fill_opacity(),
        recurse=False,
    )
    self.set_stroke(
        opacity=factor * self.get_stroke_opacity(),
        recurse=False,
    )
    super().fade(darkness, recurse)
    return self

</t>
<t tx="ekr.20250122151620.1879"># Todo im not quite sure why we are doing this
def get_fill_colors(self):
    return [ManimColor.from_rgb(rgba[:3]) for rgba in self.fill_rgba]

</t>
<t tx="ekr.20250122151620.188">@scene_names.setter
def scene_names(self, value: list[str]) -&gt; None:
    self._d.__setitem__("scene_names", value)

</t>
<t tx="ekr.20250122151620.1880">def get_fill_opacities(self):
    return self.fill_rgba[:, 3]

</t>
<t tx="ekr.20250122151620.1881">def get_stroke_colors(self):
    return [ManimColor.from_rgb(rgba[:3]) for rgba in self.stroke_rgba]

</t>
<t tx="ekr.20250122151620.1882">def get_stroke_opacities(self):
    return self.stroke_rgba[:, 3]

</t>
<t tx="ekr.20250122151620.1883">def get_stroke_widths(self):
    return self.stroke_width

</t>
<t tx="ekr.20250122151620.1884"># TODO, it's weird for these to return the first of various lists
# rather than the full information
def get_fill_color(self):
    """
    If there are multiple colors (for gradient)
    this returns the first one
    """
    return self.get_fill_colors()[0]

</t>
<t tx="ekr.20250122151620.1885">def get_fill_opacity(self):
    """
    If there are multiple opacities, this returns the
    first
    """
    return self.get_fill_opacities()[0]

</t>
<t tx="ekr.20250122151620.1886">def get_stroke_color(self):
    return self.get_stroke_colors()[0]

</t>
<t tx="ekr.20250122151620.1887">def get_stroke_width(self):
    return self.get_stroke_widths()[0]

</t>
<t tx="ekr.20250122151620.1888">def get_stroke_opacity(self):
    return self.get_stroke_opacities()[0]

</t>
<t tx="ekr.20250122151620.1889">def get_color(self):
    if not self.has_fill():
        return self.get_stroke_color()
    return self.get_fill_color()

</t>
<t tx="ekr.20250122151620.189">@property
def tex_template(self) -&gt; TexTemplate:
    """Template used when rendering Tex.  See :class:`.TexTemplate`."""
    if not hasattr(self, "_tex_template") or not self._tex_template:
        fn = self._d["tex_template_file"]
        if fn:
            self._tex_template = TexTemplate.from_file(fn)
        else:
            self._tex_template = TexTemplate()
    return self._tex_template

</t>
<t tx="ekr.20250122151620.1890">def get_colors(self):
    if self.has_stroke():
        return self.get_stroke_colors()
    return self.get_fill_colors()

</t>
<t tx="ekr.20250122151620.1891">stroke_color = property(get_stroke_color, set_stroke)
color = property(get_color, set_color)
fill_color = property(get_fill_color, set_fill)

def has_stroke(self):
    stroke_widths = self.get_stroke_widths()
    stroke_opacities = self.get_stroke_opacities()
    return (
        stroke_widths is not None
        and stroke_opacities is not None
        and any(stroke_widths)
        and any(stroke_opacities)
    )

</t>
<t tx="ekr.20250122151620.1892">def has_fill(self):
    fill_opacities = self.get_fill_opacities()
    return fill_opacities is not None and any(fill_opacities)

</t>
<t tx="ekr.20250122151620.1893">def get_opacity(self):
    if self.has_fill():
        return self.get_fill_opacity()
    return self.get_stroke_opacity()

</t>
<t tx="ekr.20250122151620.1894">def set_flat_stroke(self, flat_stroke=True, recurse=True):
    for mob in self.get_family(recurse):
        mob.flat_stroke = flat_stroke
    return self

</t>
<t tx="ekr.20250122151620.1895">def get_flat_stroke(self):
    return self.flat_stroke

</t>
<t tx="ekr.20250122151620.1896"># Points
def set_anchors_and_handles(self, anchors1, handles, anchors2):
    assert len(anchors1) == len(handles) == len(anchors2)
    nppc = self.n_points_per_curve
    new_points = np.zeros((nppc * len(anchors1), self.dim))
    arrays = [anchors1, handles, anchors2]
    for index, array in enumerate(arrays):
        new_points[index::nppc] = array
    self.set_points(new_points)
    return self

</t>
<t tx="ekr.20250122151620.1897">def start_new_path(self, point):
    assert self.get_num_points() % self.n_points_per_curve == 0
    self.append_points([point])
    return self

</t>
<t tx="ekr.20250122151620.1898">def add_cubic_bezier_curve(self, anchor1, handle1, handle2, anchor2):
    new_points = get_quadratic_approximation_of_cubic(
        anchor1,
        handle1,
        handle2,
        anchor2,
    )
    self.append_points(new_points)

</t>
<t tx="ekr.20250122151620.1899">def add_cubic_bezier_curve_to(self, handle1, handle2, anchor):
    """Add cubic bezier curve to the path."""
    self.throw_error_if_no_points()
    quadratic_approx = get_quadratic_approximation_of_cubic(
        self.get_last_point(),
        handle1,
        handle2,
        anchor,
    )
    if self.has_new_path_started():
        self.append_points(quadratic_approx[1:])
    else:
        self.append_points(quadratic_approx)

</t>
<t tx="ekr.20250122151620.19">"""Utilities to create and set the logger.

Manim's logger can be accessed as ``manim.logger``, or as
``logging.getLogger("manim")``, once the library has been imported.  Manim also
exports a second object, ``console``, which should be used to print on screen
messages that need not be logged.

Both ``logger`` and ``console`` use the ``rich`` library to produce rich text
format.

"""

from __future__ import annotations

import configparser
import copy
import json
import logging
from typing import TYPE_CHECKING

from rich import color, errors
from rich import print as printf
from rich.console import Console
from rich.logging import RichHandler
from rich.theme import Theme

if TYPE_CHECKING:
    from pathlib import Path

__all__ = ["make_logger", "parse_theme", "set_file_logger", "JSONFormatter"]

HIGHLIGHTED_KEYWORDS = [  # these keywords are highlighted specially
    "Played",
    "animations",
    "scene",
    "Reading",
    "Writing",
    "script",
    "arguments",
    "Invalid",
    "Aborting",
    "module",
    "File",
    "Rendering",
    "Rendered",
]

WRONG_COLOR_CONFIG_MSG = """
[logging.level.error]Your colour configuration couldn't be parsed.
Loading the default color configuration.[/logging.level.error]
"""


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.190">@tex_template.setter
def tex_template(self, val: TexTemplate) -&gt; None:
    if isinstance(val, TexTemplate):
        self._tex_template = val

</t>
<t tx="ekr.20250122151620.1900">def add_quadratic_bezier_curve_to(self, handle, anchor):
    self.throw_error_if_no_points()
    if self.has_new_path_started():
        self.append_points([handle, anchor])
    else:
        self.append_points([self.get_last_point(), handle, anchor])

</t>
<t tx="ekr.20250122151620.1901">def add_line_to(self, point: Sequence[float]) -&gt; OpenGLVMobject:
    """Add a straight line from the last point of OpenGLVMobject to the given point.

    Parameters
    ----------

    point
        end of the straight line.
    """
    end = self.points[-1]
    alphas = np.linspace(0, 1, self.n_points_per_curve)
    if self.long_lines:
        halfway = interpolate(end, point, 0.5)
        points = [interpolate(end, halfway, a) for a in alphas] + [
            interpolate(halfway, point, a) for a in alphas
        ]
    else:
        points = [interpolate(end, point, a) for a in alphas]
    if self.has_new_path_started():
        points = points[1:]
    self.append_points(points)
    return self

</t>
<t tx="ekr.20250122151620.1902">def add_smooth_curve_to(self, point):
    if self.has_new_path_started():
        self.add_line_to(point)
    else:
        self.throw_error_if_no_points()
        new_handle = self.get_reflection_of_last_handle()
        self.add_quadratic_bezier_curve_to(new_handle, point)
    return self

</t>
<t tx="ekr.20250122151620.1903">def add_smooth_cubic_curve_to(self, handle, point):
    self.throw_error_if_no_points()
    new_handle = self.get_reflection_of_last_handle()
    self.add_cubic_bezier_curve_to(new_handle, handle, point)

</t>
<t tx="ekr.20250122151620.1904">def has_new_path_started(self):
    return self.get_num_points() % self.n_points_per_curve == 1

</t>
<t tx="ekr.20250122151620.1905">def get_last_point(self):
    return self.points[-1]

</t>
<t tx="ekr.20250122151620.1906">def get_reflection_of_last_handle(self):
    points = self.points
    return 2 * points[-1] - points[-2]

</t>
<t tx="ekr.20250122151620.1907">def close_path(self):
    if not self.is_closed():
        self.add_line_to(self.get_subpaths()[-1][0])

</t>
<t tx="ekr.20250122151620.1908">def is_closed(self):
    return self.consider_points_equals(self.points[0], self.points[-1])

</t>
<t tx="ekr.20250122151620.1909">def subdivide_sharp_curves(self, angle_threshold=30 * DEGREES, recurse=True):
    vmobs = [vm for vm in self.get_family(recurse) if vm.has_points()]
    for vmob in vmobs:
        new_points = []
        for tup in vmob.get_bezier_tuples():
            angle = angle_between_vectors(tup[1] - tup[0], tup[2] - tup[1])
            if angle &gt; angle_threshold:
                n = int(np.ceil(angle / angle_threshold))
                alphas = np.linspace(0, 1, n + 1)
                new_points.extend(
                    [
                        partial_bezier_points(tup, a1, a2)
                        for a1, a2 in zip(alphas, alphas[1:])
                    ],
                )
            else:
                new_points.append(tup)
        vmob.set_points(np.vstack(new_points))
    return self

</t>
<t tx="ekr.20250122151620.191">@property
def tex_template_file(self) -&gt; Path:
    """File to read Tex template from (no flag).  See :class:`.TexTemplate`."""
    return self._d["tex_template_file"]

</t>
<t tx="ekr.20250122151620.1910">def add_points_as_corners(self, points):
    for point in points:
        self.add_line_to(point)
    return points

</t>
<t tx="ekr.20250122151620.1911">def set_points_as_corners(self, points: Iterable[float]) -&gt; OpenGLVMobject:
    """Given an array of points, set them as corner of the vmobject.

    To achieve that, this algorithm sets handles aligned with the anchors such that the resultant bezier curve will be the segment
    between the two anchors.

    Parameters
    ----------
    points
        Array of points that will be set as corners.

    Returns
    -------
    OpenGLVMobject
        self. For chaining purposes.
    """
    nppc = self.n_points_per_curve
    points = np.array(points)
    self.set_anchors_and_handles(
        *(interpolate(points[:-1], points[1:], a) for a in np.linspace(0, 1, nppc))
    )
    return self

</t>
<t tx="ekr.20250122151620.1912">def set_points_smoothly(self, points, true_smooth=False):
    self.set_points_as_corners(points)
    self.make_smooth()
    return self

</t>
<t tx="ekr.20250122151620.1913">def change_anchor_mode(self, mode):
    """Changes the anchor mode of the bezier curves. This will modify the handles.

    There can be only three modes, "jagged", "approx_smooth"  and "true_smooth".

    Returns
    -------
    OpenGLVMobject
        For chaining purposes.
    """
    assert mode in ("jagged", "approx_smooth", "true_smooth")
    nppc = self.n_points_per_curve
    for submob in self.family_members_with_points():
        subpaths = submob.get_subpaths()
        submob.clear_points()
        for subpath in subpaths:
            anchors = np.vstack([subpath[::nppc], subpath[-1:]])
            new_subpath = np.array(subpath)
            if mode == "approx_smooth":
                # TODO: get_smooth_quadratic_bezier_handle_points is not defined
                new_subpath[1::nppc] = get_smooth_quadratic_bezier_handle_points(
                    anchors,
                )
            elif mode == "true_smooth":
                h1, h2 = get_smooth_cubic_bezier_handle_points(anchors)
                new_subpath = get_quadratic_approximation_of_cubic(
                    anchors[:-1],
                    h1,
                    h2,
                    anchors[1:],
                )
            elif mode == "jagged":
                new_subpath[1::nppc] = 0.5 * (anchors[:-1] + anchors[1:])
            submob.append_points(new_subpath)
        submob.refresh_triangulation()
    return self

</t>
<t tx="ekr.20250122151620.1914">def make_smooth(self):
    """
    This will double the number of points in the mobject,
    so should not be called repeatedly.  It also means
    transforming between states before and after calling
    this might have strange artifacts
    """
    self.change_anchor_mode("true_smooth")
    return self

</t>
<t tx="ekr.20250122151620.1915">def make_approximately_smooth(self):
    """
    Unlike make_smooth, this will not change the number of
    points, but it also does not result in a perfectly smooth
    curve.  It's most useful when the points have been
    sampled at a not-too-low rate from a continuous function,
    as in the case of ParametricCurve
    """
    self.change_anchor_mode("approx_smooth")
    return self

</t>
<t tx="ekr.20250122151620.1916">def make_jagged(self):
    self.change_anchor_mode("jagged")
    return self

</t>
<t tx="ekr.20250122151620.1917">def add_subpath(self, points):
    assert len(points) % self.n_points_per_curve == 0
    self.append_points(points)
    return self

</t>
<t tx="ekr.20250122151620.1918">def append_vectorized_mobject(self, vectorized_mobject):
    new_points = list(vectorized_mobject.points)

    if self.has_new_path_started():
        # Remove last point, which is starting
        # a new path
        self.resize_data(len(self.points - 1))
    self.append_points(new_points)
    return self

</t>
<t tx="ekr.20250122151620.1919">#
def consider_points_equals(self, p0, p1):
    return np.linalg.norm(p1 - p0) &lt; self.tolerance_for_point_equality

</t>
<t tx="ekr.20250122151620.192">@tex_template_file.setter
def tex_template_file(self, val: str) -&gt; None:
    if val:
        if not os.access(val, os.R_OK):
            logger.warning(
                f"Custom TeX template {val} not found or not readable.",
            )
        else:
            self._d["tex_template_file"] = Path(val)
    else:
        self._d["tex_template_file"] = val  # actually set the falsy value

</t>
<t tx="ekr.20250122151620.1920"># Information about the curve
def force_direction(self, target_direction: str):
    """Makes sure that points are either directed clockwise or
    counterclockwise.

    Parameters
    ----------
    target_direction
        Either ``"CW"`` or ``"CCW"``.
    """
    if target_direction not in ("CW", "CCW"):
        raise ValueError('Invalid input for force_direction. Use "CW" or "CCW"')

    if self.get_direction() != target_direction:
        self.reverse_points()

    return self

</t>
<t tx="ekr.20250122151620.1921">def reverse_direction(self):
    """Reverts the point direction by inverting the point order.

    Returns
    -------
    :class:`OpenGLVMobject`
        Returns self.

    Examples
    --------
    .. manim:: ChangeOfDirection

        class ChangeOfDirection(Scene):
            def construct(self):
                ccw = RegularPolygon(5)
                ccw.shift(LEFT)
                cw = RegularPolygon(5)
                cw.shift(RIGHT).reverse_direction()

                self.play(Create(ccw), Create(cw),
                run_time=4)
    """
    self.set_points(self.points[::-1])
    return self

</t>
<t tx="ekr.20250122151620.1922">def get_bezier_tuples_from_points(self, points):
    nppc = self.n_points_per_curve
    remainder = len(points) % nppc
    points = points[: len(points) - remainder]
    return points.reshape((-1, nppc, 3))

</t>
<t tx="ekr.20250122151620.1923">def get_bezier_tuples(self):
    return self.get_bezier_tuples_from_points(self.points)

</t>
<t tx="ekr.20250122151620.1924">def get_subpaths_from_points(self, points):
    nppc = self.n_points_per_curve
    diffs = points[nppc - 1 : -1 : nppc] - points[nppc::nppc]
    splits = (diffs * diffs).sum(1) &gt; self.tolerance_for_point_equality
    split_indices = np.arange(nppc, len(points), nppc, dtype=int)[splits]

    # split_indices = filter(
    #     lambda n: not self.consider_points_equals(points[n - 1], points[n]),
    #     range(nppc, len(points), nppc)
    # )
    split_indices = [0, *split_indices, len(points)]
    return [
        points[i1:i2]
        for i1, i2 in zip(split_indices, split_indices[1:])
        if (i2 - i1) &gt;= nppc
    ]

</t>
<t tx="ekr.20250122151620.1925">def get_subpaths(self):
    """Returns subpaths formed by the curves of the OpenGLVMobject.

    Subpaths are ranges of curves with each pair of consecutive
    curves having their end/start points coincident.

    Returns
    -------
    Tuple
        subpaths.
    """
    return self.get_subpaths_from_points(self.points)

</t>
<t tx="ekr.20250122151620.1926">def get_nth_curve_points(self, n: int) -&gt; np.ndarray:
    """Returns the points defining the nth curve of the vmobject.

    Parameters
    ----------
    n
        index of the desired bezier curve.

    Returns
    -------
    np.ndarray
        points defininf the nth bezier curve (anchors, handles)
    """
    assert n &lt; self.get_num_curves()
    nppc = self.n_points_per_curve
    return self.points[nppc * n : nppc * (n + 1)]

</t>
<t tx="ekr.20250122151620.1927">def get_nth_curve_function(self, n: int) -&gt; Callable[[float], np.ndarray]:
    """Returns the expression of the nth curve.

    Parameters
    ----------
    n
        index of the desired curve.

    Returns
    -------
    typing.Callable[float]
        expression of the nth bezier curve.
    """
    return bezier(self.get_nth_curve_points(n))

</t>
<t tx="ekr.20250122151620.1928">def get_nth_curve_function_with_length(
    self,
    n: int,
    sample_points: int | None = None,
) -&gt; tuple[Callable[[float], np.ndarray], float]:
    """Returns the expression of the nth curve along with its (approximate) length.

    Parameters
    ----------
    n
        The index of the desired curve.
    sample_points
        The number of points to sample to find the length.

    Returns
    -------
    curve : Callable[[float], np.ndarray]
        The function for the nth curve.
    length : :class:`float`
        The length of the nth curve.
    """
    if sample_points is None:
        sample_points = 10

    curve = self.get_nth_curve_function(n)
    norms = self.get_nth_curve_length_pieces(n, sample_points)

    length = np.sum(norms)

    return curve, length

</t>
<t tx="ekr.20250122151620.1929">def get_num_curves(self) -&gt; int:
    """Returns the number of curves of the vmobject.

    Returns
    -------
    int
        number of curves. of the vmobject.
    """
    return self.get_num_points() // self.n_points_per_curve

</t>
<t tx="ekr.20250122151620.193">@property
def plugins(self) -&gt; list[str]:
    """List of plugins to enable."""
    return self._d["plugins"]

</t>
<t tx="ekr.20250122151620.1930">def get_nth_curve_length(
    self,
    n: int,
    sample_points: int | None = None,
) -&gt; float:
    """Returns the (approximate) length of the nth curve.

    Parameters
    ----------
    n
        The index of the desired curve.
    sample_points
        The number of points to sample to find the length.

    Returns
    -------
    length : :class:`float`
        The length of the nth curve.
    """
    _, length = self.get_nth_curve_function_with_length(n, sample_points)

    return length

</t>
<t tx="ekr.20250122151620.1931">def get_curve_functions(
    self,
) -&gt; Iterable[Callable[[float], np.ndarray]]:
    """Gets the functions for the curves of the mobject.

    Returns
    -------
    Iterable[Callable[[float], np.ndarray]]
        The functions for the curves.
    """
    num_curves = self.get_num_curves()

    for n in range(num_curves):
        yield self.get_nth_curve_function(n)

</t>
<t tx="ekr.20250122151620.1932">def get_nth_curve_length_pieces(
    self,
    n: int,
    sample_points: int | None = None,
) -&gt; np.ndarray:
    """Returns the array of short line lengths used for length approximation.

    Parameters
    ----------
    n
        The index of the desired curve.
    sample_points
        The number of points to sample to find the length.

    Returns
    -------
    np.ndarray
        The short length-pieces of the nth curve.
    """
    if sample_points is None:
        sample_points = 10

    curve = self.get_nth_curve_function(n)
    points = np.array([curve(a) for a in np.linspace(0, 1, sample_points)])
    diffs = points[1:] - points[:-1]
    norms = np.apply_along_axis(np.linalg.norm, 1, diffs)

    return norms

</t>
<t tx="ekr.20250122151620.1933">def get_curve_functions_with_lengths(
    self, **kwargs
) -&gt; Iterable[tuple[Callable[[float], np.ndarray], float]]:
    """Gets the functions and lengths of the curves for the mobject.

    Parameters
    ----------
    **kwargs
        The keyword arguments passed to :meth:`get_nth_curve_function_with_length`

    Returns
    -------
    Iterable[Tuple[Callable[[float], np.ndarray], float]]
        The functions and lengths of the curves.
    """
    num_curves = self.get_num_curves()

    for n in range(num_curves):
        yield self.get_nth_curve_function_with_length(n, **kwargs)

</t>
<t tx="ekr.20250122151620.1934">def point_from_proportion(self, alpha: float) -&gt; np.ndarray:
    """Gets the point at a proportion along the path of the :class:`OpenGLVMobject`.

    Parameters
    ----------
    alpha
        The proportion along the the path of the :class:`OpenGLVMobject`.

    Returns
    -------
    :class:`numpy.ndarray`
        The point on the :class:`OpenGLVMobject`.

    Raises
    ------
    :exc:`ValueError`
        If ``alpha`` is not between 0 and 1.
    :exc:`Exception`
        If the :class:`OpenGLVMobject` has no points.
    """
    if alpha &lt; 0 or alpha &gt; 1:
        raise ValueError(f"Alpha {alpha} not between 0 and 1.")

    self.throw_error_if_no_points()
    if alpha == 1:
        return self.points[-1]

    curves_and_lengths = tuple(self.get_curve_functions_with_lengths())

    target_length = alpha * np.sum(
        np.fromiter((length for _, length in curves_and_lengths), dtype=np.float64)
    )
    current_length = 0

    for curve, length in curves_and_lengths:
        if current_length + length &gt;= target_length:
            if length != 0:
                residue = (target_length - current_length) / length
            else:
                residue = 0

            return curve(residue)

        current_length += length

</t>
<t tx="ekr.20250122151620.1935">def proportion_from_point(
    self,
    point: Iterable[float | int],
) -&gt; float:
    """Returns the proportion along the path of the :class:`OpenGLVMobject`
    a particular given point is at.

    Parameters
    ----------
    point
        The Cartesian coordinates of the point which may or may not lie on the :class:`OpenGLVMobject`

    Returns
    -------
    float
        The proportion along the path of the :class:`OpenGLVMobject`.

    Raises
    ------
    :exc:`ValueError`
        If ``point`` does not lie on the curve.
    :exc:`Exception`
        If the :class:`OpenGLVMobject` has no points.
    """
    self.throw_error_if_no_points()

    # Iterate over each bezier curve that the ``VMobject`` is composed of, checking
    # if the point lies on that curve. If it does not lie on that curve, add
    # the whole length of the curve to ``target_length`` and move onto the next
    # curve. If the point does lie on the curve, add how far along the curve
    # the point is to ``target_length``.
    # Then, divide ``target_length`` by the total arc length of the shape to get
    # the proportion along the ``VMobject`` the point is at.

    num_curves = self.get_num_curves()
    total_length = self.get_arc_length()
    target_length = 0
    for n in range(num_curves):
        control_points = self.get_nth_curve_points(n)
        length = self.get_nth_curve_length(n)
        proportions_along_bezier = proportions_along_bezier_curve_for_point(
            point,
            control_points,
        )
        if len(proportions_along_bezier) &gt; 0:
            proportion_along_nth_curve = max(proportions_along_bezier)
            target_length += length * proportion_along_nth_curve
            break
        target_length += length
    else:
        raise ValueError(f"Point {point} does not lie on this curve.")

    alpha = target_length / total_length

    return alpha

</t>
<t tx="ekr.20250122151620.1936">def get_anchors_and_handles(self) -&gt; Iterable[np.ndarray]:
    """
    Returns anchors1, handles, anchors2,
    where (anchors1[i], handles[i], anchors2[i])
    will be three points defining a quadratic bezier curve
    for any i in range(0, len(anchors1))
    """
    nppc = self.n_points_per_curve
    points = self.points
    return [points[i::nppc] for i in range(nppc)]

</t>
<t tx="ekr.20250122151620.1937">def get_start_anchors(self) -&gt; np.ndarray:
    """Returns the start anchors of the bezier curves.

    Returns
    -------
    np.ndarray
        Starting anchors
    """
    return self.points[0 :: self.n_points_per_curve]

</t>
<t tx="ekr.20250122151620.1938">def get_end_anchors(self) -&gt; np.ndarray:
    """Return the starting anchors of the bezier curves.

    Returns
    -------
    np.ndarray
        Starting anchors
    """
    nppc = self.n_points_per_curve
    return self.points[nppc - 1 :: nppc]

</t>
<t tx="ekr.20250122151620.1939">def get_anchors(self) -&gt; Iterable[np.ndarray]:
    """Returns the anchors of the curves forming the OpenGLVMobject.

    Returns
    -------
    Iterable[np.ndarray]
        The anchors.
    """
    points = self.points
    if len(points) == 1:
        return points

    s = self.get_start_anchors()
    e = self.get_end_anchors()
    return list(it.chain.from_iterable(zip(s, e)))

</t>
<t tx="ekr.20250122151620.194">@plugins.setter
def plugins(self, value: list[str]):
    self._d["plugins"] = value


</t>
<t tx="ekr.20250122151620.1940">def get_points_without_null_curves(self, atol=1e-9):
    nppc = self.n_points_per_curve
    points = self.points
    distinct_curves = reduce(
        op.or_,
        [
            (abs(points[i::nppc] - points[0::nppc]) &gt; atol).any(1)
            for i in range(1, nppc)
        ],
    )
    return points[distinct_curves.repeat(nppc)]

</t>
<t tx="ekr.20250122151620.1941">def get_arc_length(self, sample_points_per_curve: int | None = None) -&gt; float:
    """Return the approximated length of the whole curve.

    Parameters
    ----------
    sample_points_per_curve
        Number of sample points per curve used to approximate the length. More points result in a better approximation.

    Returns
    -------
    float
        The length of the :class:`OpenGLVMobject`.
    """
    return np.sum(
        length
        for _, length in self.get_curve_functions_with_lengths(
            sample_points=sample_points_per_curve,
        )
    )

</t>
<t tx="ekr.20250122151620.1942">def get_area_vector(self):
    # Returns a vector whose length is the area bound by
    # the polygon formed by the anchor points, pointing
    # in a direction perpendicular to the polygon according
    # to the right hand rule.
    if not self.has_points():
        return np.zeros(3)

    nppc = self.n_points_per_curve
    points = self.points
    p0 = points[0::nppc]
    p1 = points[nppc - 1 :: nppc]

    # Each term goes through all edges [(x1, y1, z1), (x2, y2, z2)]
    return 0.5 * np.array(
        [
            sum(
                (p0[:, 1] + p1[:, 1]) * (p1[:, 2] - p0[:, 2]),
            ),  # Add up (y1 + y2)*(z2 - z1)
            sum(
                (p0[:, 2] + p1[:, 2]) * (p1[:, 0] - p0[:, 0]),
            ),  # Add up (z1 + z2)*(x2 - x1)
            sum(
                (p0[:, 0] + p1[:, 0]) * (p1[:, 1] - p0[:, 1]),
            ),  # Add up (x1 + x2)*(y2 - y1)
        ],
    )

</t>
<t tx="ekr.20250122151620.1943">def get_direction(self):
    """Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.
    The direction of points determines in which direction the
    object is drawn, clockwise or counterclockwise.

    Examples
    --------
    The default direction of a :class:`~.Circle` is counterclockwise::

        &gt;&gt;&gt; from manim import Circle
        &gt;&gt;&gt; Circle().get_direction()
        'CCW'

    Returns
    -------
    :class:`str`
        Either ``"CW"`` or ``"CCW"``.
    """
    return shoelace_direction(self.get_start_anchors())

</t>
<t tx="ekr.20250122151620.1944">def get_unit_normal(self, recompute=False):
    if not recompute:
        return self.unit_normal[0]

    if len(self.points) &lt; 3:
        return OUT

    area_vect = self.get_area_vector()
    area = np.linalg.norm(area_vect)
    if area &gt; 0:
        return area_vect / area
    else:
        points = self.points
        return get_unit_normal(
            points[1] - points[0],
            points[2] - points[1],
        )

</t>
<t tx="ekr.20250122151620.1945">def refresh_unit_normal(self):
    for mob in self.get_family():
        mob.unit_normal[:] = mob.get_unit_normal(recompute=True)
    return self

</t>
<t tx="ekr.20250122151620.1946"># Alignment
def align_points(self, vmobject):
    # TODO: This shortcut can be a bit over eager. What if they have the same length, but different subpath lengths?
    if self.get_num_points() == len(vmobject.points):
        return

    for mob in self, vmobject:
        # If there are no points, add one to
        # where the "center" is
        if not mob.has_points():
            mob.start_new_path(mob.get_center())
        # If there's only one point, turn it into
        # a null curve
        if mob.has_new_path_started():
            mob.add_line_to(mob.points[0])

    # Figure out what the subpaths are, and align
    subpaths1 = self.get_subpaths()
    subpaths2 = vmobject.get_subpaths()
    n_subpaths = max(len(subpaths1), len(subpaths2))
    # Start building new ones
    new_subpaths1 = []
    new_subpaths2 = []

    nppc = self.n_points_per_curve

    def get_nth_subpath(path_list, n):
        if n &gt;= len(path_list):
            # Create a null path at the very end
            return [path_list[-1][-1]] * nppc
        path = path_list[n]
        # Check for useless points at the end of the path and remove them
        # https://github.com/ManimCommunity/manim/issues/1959
        while len(path) &gt; nppc:
            # If the last nppc points are all equal to the preceding point
            if self.consider_points_equals(path[-nppc:], path[-nppc - 1]):
                path = path[:-nppc]
            else:
                break
        return path

    for n in range(n_subpaths):
        sp1 = np.asarray(get_nth_subpath(subpaths1, n))
        sp2 = np.asarray(get_nth_subpath(subpaths2, n))
        diff1 = max(0, (len(sp2) - len(sp1)) // nppc)
        diff2 = max(0, (len(sp1) - len(sp2)) // nppc)
        sp1 = self.insert_n_curves_to_point_list(diff1, sp1)
        sp2 = self.insert_n_curves_to_point_list(diff2, sp2)
        new_subpaths1.append(sp1)
        new_subpaths2.append(sp2)
    self.set_points(np.vstack(new_subpaths1))
    vmobject.set_points(np.vstack(new_subpaths2))
    return self

</t>
<t tx="ekr.20250122151620.1947">def insert_n_curves(self, n: int, recurse=True) -&gt; OpenGLVMobject:
    """Inserts n curves to the bezier curves of the vmobject.

    Parameters
    ----------
    n
        Number of curves to insert.

    Returns
    -------
    OpenGLVMobject
        for chaining.
    """
    for mob in self.get_family(recurse):
        if mob.get_num_curves() &gt; 0:
            new_points = mob.insert_n_curves_to_point_list(n, mob.points)
            # TODO, this should happen in insert_n_curves_to_point_list
            if mob.has_new_path_started():
                new_points = np.vstack([new_points, mob.get_last_point()])
            mob.set_points(new_points)
    return self

</t>
<t tx="ekr.20250122151620.1948">def insert_n_curves_to_point_list(self, n: int, points: np.ndarray) -&gt; np.ndarray:
    """Given an array of k points defining a bezier curves
     (anchors and handles), returns points defining exactly
    k + n bezier curves.

    Parameters
    ----------
    n
        Number of desired curves.
    points
        Starting points.

    Returns
    -------
    np.ndarray
        Points generated.
    """
    nppc = self.n_points_per_curve
    if len(points) == 1:
        return np.repeat(points, nppc * n, 0)

    bezier_tuples = self.get_bezier_tuples_from_points(points)
    current_number_of_curves = len(bezier_tuples)
    new_number_of_curves = current_number_of_curves + n
    new_bezier_tuples = bezier_remap(bezier_tuples, new_number_of_curves)
    new_points = new_bezier_tuples.reshape(-1, 3)
    return new_points

</t>
<t tx="ekr.20250122151620.1949">def interpolate(self, mobject1, mobject2, alpha, *args, **kwargs):
    super().interpolate(mobject1, mobject2, alpha, *args, **kwargs)
    if config["use_projection_fill_shaders"]:
        self.refresh_triangulation()
    else:
        if self.has_fill():
            tri1 = mobject1.get_triangulation()
            tri2 = mobject2.get_triangulation()
            if len(tri1) != len(tri2) or not np.all(tri1 == tri2):
                self.refresh_triangulation()
    return self

</t>
<t tx="ekr.20250122151620.195">_OPTS: ClassVar[set[str]] = {
    "pixel_width",
    "pixel_height",
    "aspect_ratio",
    "frame_height",
    "frame_width",
    "frame_y_radius",
    "frame_x_radius",
    "top",
    "bottom",
    "left_side",
    "right_side",
}
_CONSTANTS: ClassVar[dict[str, Vector3D]] = {
    "UP": np.array((0.0, 1.0, 0.0)),
    "DOWN": np.array((0.0, -1.0, 0.0)),
    "RIGHT": np.array((1.0, 0.0, 0.0)),
    "LEFT": np.array((-1.0, 0.0, 0.0)),
    "IN": np.array((0.0, 0.0, -1.0)),
    "OUT": np.array((0.0, 0.0, 1.0)),
    "ORIGIN": np.array((0.0, 0.0, 0.0)),
    "X_AXIS": np.array((1.0, 0.0, 0.0)),
    "Y_AXIS": np.array((0.0, 1.0, 0.0)),
    "Z_AXIS": np.array((0.0, 0.0, 1.0)),
    "UL": np.array((-1.0, 1.0, 0.0)),
    "UR": np.array((1.0, 1.0, 0.0)),
    "DL": np.array((-1.0, -1.0, 0.0)),
    "DR": np.array((1.0, -1.0, 0.0)),
}

_c: ManimConfig

def __init__(self, c: ManimConfig) -&gt; None:
    if not isinstance(c, ManimConfig):
        raise TypeError("argument must be instance of 'ManimConfig'")
    # need to use __dict__ directly because setting attributes is not
    # allowed (see __setattr__)
    self.__dict__["_c"] = c

</t>
<t tx="ekr.20250122151620.1950">def pointwise_become_partial(
    self, vmobject: OpenGLVMobject, a: float, b: float, remap: bool = True
) -&gt; OpenGLVMobject:
    """Given two bounds a and b, transforms the points of the self vmobject into the points of the vmobject
    passed as parameter with respect to the bounds. Points here stand for control points of the bezier curves (anchors and handles)

    Parameters
    ----------
    vmobject
        The vmobject that will serve as a model.
    a
        upper-bound.
    b
        lower-bound
    remap
        if the point amount should be kept the same (True)
        This option should be manually set to False if keeping the number of points is not needed
    """
    assert isinstance(vmobject, OpenGLVMobject)
    # Partial curve includes three portions:
    # - A middle section, which matches the curve exactly
    # - A start, which is some ending portion of an inner cubic
    # - An end, which is the starting portion of a later inner cubic
    if a &lt;= 0 and b &gt;= 1:
        self.set_points(vmobject.points)
        return self
    bezier_triplets = vmobject.get_bezier_tuples()
    num_quadratics = len(bezier_triplets)

    # The following two lines will compute which bezier curves of the given mobject need to be processed.
    # The residue basically indicates the proportion of the selected Bèzier curve.
    # Ex: if lower_index is 3, and lower_residue is 0.4, then the algorithm will append to the points 0.4 of the third bezier curve
    lower_index, lower_residue = integer_interpolate(0, num_quadratics, a)
    upper_index, upper_residue = integer_interpolate(0, num_quadratics, b)
    self.clear_points()
    if num_quadratics == 0:
        return self
    if lower_index == upper_index:
        self.append_points(
            partial_bezier_points(
                bezier_triplets[lower_index],
                lower_residue,
                upper_residue,
            ),
        )
    else:
        self.append_points(
            partial_bezier_points(bezier_triplets[lower_index], lower_residue, 1),
        )
        inner_points = bezier_triplets[lower_index + 1 : upper_index]
        if len(inner_points) &gt; 0:
            if remap:
                new_triplets = bezier_remap(inner_points, num_quadratics - 2)
            else:
                new_triplets = bezier_triplets

            self.append_points(np.asarray(new_triplets).reshape(-1, 3))
        self.append_points(
            partial_bezier_points(bezier_triplets[upper_index], 0, upper_residue),
        )
    return self

</t>
<t tx="ekr.20250122151620.1951">def get_subcurve(self, a: float, b: float) -&gt; OpenGLVMobject:
    """Returns the subcurve of the OpenGLVMobject between the interval [a, b].
    The curve is a OpenGLVMobject itself.

    Parameters
    ----------

    a
        The lower bound.
    b
        The upper bound.

    Returns
    -------
    OpenGLVMobject
        The subcurve between of [a, b]
    """
    vmob = self.copy()
    vmob.pointwise_become_partial(self, a, b)
    return vmob

</t>
<t tx="ekr.20250122151620.1952"># Related to triangulation

def refresh_triangulation(self):
    for mob in self.get_family():
        mob.needs_new_triangulation = True
    return self

</t>
<t tx="ekr.20250122151620.1953">def get_triangulation(self, normal_vector=None):
    # Figure out how to triangulate the interior to know
    # how to send the points as to the vertex shader.
    # First triangles come directly from the points
    if normal_vector is None:
        normal_vector = self.get_unit_normal()

    if not self.needs_new_triangulation:
        return self.triangulation

    points = self.points

    if len(points) &lt;= 1:
        self.triangulation = np.zeros(0, dtype="i4")
        self.needs_new_triangulation = False
        return self.triangulation

    if not np.isclose(normal_vector, OUT).all():
        # Rotate points such that unit normal vector is OUT
        points = np.dot(points, z_to_vector(normal_vector))
    indices = np.arange(len(points), dtype=int)

    b0s = points[0::3]
    b1s = points[1::3]
    b2s = points[2::3]
    v01s = b1s - b0s
    v12s = b2s - b1s

    crosses = cross2d(v01s, v12s)
    convexities = np.sign(crosses)

    atol = self.tolerance_for_point_equality
    end_of_loop = np.zeros(len(b0s), dtype=bool)
    end_of_loop[:-1] = (np.abs(b2s[:-1] - b0s[1:]) &gt; atol).any(1)
    end_of_loop[-1] = True

    concave_parts = convexities &lt; 0

    # These are the vertices to which we'll apply a polygon triangulation
    inner_vert_indices = np.hstack(
        [
            indices[0::3],
            indices[1::3][concave_parts],
            indices[2::3][end_of_loop],
        ],
    )
    inner_vert_indices.sort()
    rings = np.arange(1, len(inner_vert_indices) + 1)[inner_vert_indices % 3 == 2]

    # Triangulate
    inner_verts = points[inner_vert_indices]
    inner_tri_indices = inner_vert_indices[
        earclip_triangulation(inner_verts, rings)
    ]

    tri_indices = np.hstack([indices, inner_tri_indices])
    self.triangulation = tri_indices
    self.needs_new_triangulation = False
    return tri_indices

</t>
<t tx="ekr.20250122151620.1954">@triggers_refreshed_triangulation
def set_points(self, points):
    super().set_points(points)
    return self

</t>
<t tx="ekr.20250122151620.1955">@triggers_refreshed_triangulation
def set_data(self, data):
    super().set_data(data)
    return self

</t>
<t tx="ekr.20250122151620.1956"># TODO, how to be smart about tangents here?
@triggers_refreshed_triangulation
def apply_function(self, function, make_smooth=False, **kwargs):
    super().apply_function(function, **kwargs)
    if self.make_smooth_after_applying_functions or make_smooth:
        self.make_approximately_smooth()
    return self

</t>
<t tx="ekr.20250122151620.1957">@triggers_refreshed_triangulation
def apply_points_function(self, *args, **kwargs):
    super().apply_points_function(*args, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.1958">@triggers_refreshed_triangulation
def flip(self, *args, **kwargs):
    super().flip(*args, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.1959"># For shaders
def init_shader_data(self):
    self.fill_data = np.zeros(0, dtype=self.fill_dtype)
    self.stroke_data = np.zeros(0, dtype=self.stroke_dtype)
    self.fill_shader_wrapper = ShaderWrapper(
        vert_data=self.fill_data,
        vert_indices=np.zeros(0, dtype="i4"),
        shader_folder=self.fill_shader_folder,
        render_primitive=self.render_primitive,
    )
    self.stroke_shader_wrapper = ShaderWrapper(
        vert_data=self.stroke_data,
        shader_folder=self.stroke_shader_folder,
        render_primitive=self.render_primitive,
    )

</t>
<t tx="ekr.20250122151620.196"># there are required by parent class Mapping to behave like a dict
def __getitem__(self, key: str | int) -&gt; Any:
    if key in self._OPTS:
        return self._c[key]
    elif key in self._CONSTANTS:
        return self._CONSTANTS[key]
    else:
        raise KeyError(key)

</t>
<t tx="ekr.20250122151620.1960">def refresh_shader_wrapper_id(self):
    for wrapper in [self.fill_shader_wrapper, self.stroke_shader_wrapper]:
        wrapper.refresh_id()
    return self

</t>
<t tx="ekr.20250122151620.1961">def get_fill_shader_wrapper(self):
    self.update_fill_shader_wrapper()
    return self.fill_shader_wrapper

</t>
<t tx="ekr.20250122151620.1962">def update_fill_shader_wrapper(self):
    self.fill_shader_wrapper.vert_data = self.get_fill_shader_data()
    self.fill_shader_wrapper.vert_indices = self.get_triangulation()
    self.fill_shader_wrapper.uniforms = self.get_fill_uniforms()
    self.fill_shader_wrapper.depth_test = self.depth_test

</t>
<t tx="ekr.20250122151620.1963">def get_stroke_shader_wrapper(self):
    self.update_stroke_shader_wrapper()
    return self.stroke_shader_wrapper

</t>
<t tx="ekr.20250122151620.1964">def update_stroke_shader_wrapper(self):
    self.stroke_shader_wrapper.vert_data = self.get_stroke_shader_data()
    self.stroke_shader_wrapper.uniforms = self.get_stroke_uniforms()
    self.stroke_shader_wrapper.depth_test = self.depth_test

</t>
<t tx="ekr.20250122151620.1965">def get_shader_wrapper_list(self):
    # Build up data lists
    fill_shader_wrappers = []
    stroke_shader_wrappers = []
    back_stroke_shader_wrappers = []
    for submob in self.family_members_with_points():
        if submob.has_fill() and not config["use_projection_fill_shaders"]:
            fill_shader_wrappers.append(submob.get_fill_shader_wrapper())
        if submob.has_stroke() and not config["use_projection_stroke_shaders"]:
            ssw = submob.get_stroke_shader_wrapper()
            if submob.draw_stroke_behind_fill:
                back_stroke_shader_wrappers.append(ssw)
            else:
                stroke_shader_wrappers.append(ssw)

    # Combine data lists
    wrapper_lists = [
        back_stroke_shader_wrappers,
        fill_shader_wrappers,
        stroke_shader_wrappers,
    ]
    result = []
    for wlist in wrapper_lists:
        if wlist:
            wrapper = wlist[0]
            wrapper.combine_with(*wlist[1:])
            result.append(wrapper)
    return result

</t>
<t tx="ekr.20250122151620.1966">def get_stroke_uniforms(self):
    result = dict(super().get_shader_uniforms())
    result["joint_type"] = self.joint_type.value
    result["flat_stroke"] = float(self.flat_stroke)
    return result

</t>
<t tx="ekr.20250122151620.1967">def get_fill_uniforms(self):
    return {
        "is_fixed_in_frame": float(self.is_fixed_in_frame),
        "is_fixed_orientation": float(self.is_fixed_orientation),
        "fixed_orientation_center": self.fixed_orientation_center,
        "gloss": self.gloss,
        "shadow": self.shadow,
    }

</t>
<t tx="ekr.20250122151620.1968">def get_stroke_shader_data(self):
    points = self.points
    if len(self.stroke_data) != len(points):
        self.stroke_data = np.zeros(len(points), dtype=OpenGLVMobject.stroke_dtype)

    if "points" not in self.locked_data_keys:
        nppc = self.n_points_per_curve
        self.stroke_data["point"] = points
        self.stroke_data["prev_point"][:nppc] = points[-nppc:]
        self.stroke_data["prev_point"][nppc:] = points[:-nppc]
        self.stroke_data["next_point"][:-nppc] = points[nppc:]
        self.stroke_data["next_point"][-nppc:] = points[:nppc]

    self.read_data_to_shader(self.stroke_data, "color", "stroke_rgba")
    self.read_data_to_shader(self.stroke_data, "stroke_width", "stroke_width")
    self.read_data_to_shader(self.stroke_data, "unit_normal", "unit_normal")

    return self.stroke_data

</t>
<t tx="ekr.20250122151620.1969">def get_fill_shader_data(self):
    points = self.points
    if len(self.fill_data) != len(points):
        self.fill_data = np.zeros(len(points), dtype=OpenGLVMobject.fill_dtype)
        self.fill_data["vert_index"][:, 0] = range(len(points))

    self.read_data_to_shader(self.fill_data, "point", "points")
    self.read_data_to_shader(self.fill_data, "color", "fill_rgba")
    self.read_data_to_shader(self.fill_data, "unit_normal", "unit_normal")

    return self.fill_data

</t>
<t tx="ekr.20250122151620.197">def __iter__(self) -&gt; Iterable[str]:
    return iter(list(self._OPTS) + list(self._CONSTANTS))

</t>
<t tx="ekr.20250122151620.1970">def refresh_shader_data(self):
    self.get_fill_shader_data()
    self.get_stroke_shader_data()

</t>
<t tx="ekr.20250122151620.1971">def get_fill_shader_vert_indices(self):
    return self.get_triangulation()


</t>
<t tx="ekr.20250122151620.1972">def __init__(self, *vmobjects, **kwargs):
    super().__init__(**kwargs)
    self.add(*vmobjects)

</t>
<t tx="ekr.20250122151620.1973">def __repr__(self):
    return (
        self.__class__.__name__
        + "("
        + ", ".join(str(mob) for mob in self.submobjects)
        + ")"
    )

</t>
<t tx="ekr.20250122151620.1974">def __str__(self):
    return (
        f"{self.__class__.__name__} of {len(self.submobjects)} "
        f"submobject{'s' if len(self.submobjects) &gt; 0 else ''}"
    )

</t>
<t tx="ekr.20250122151620.1975">def add(self, *vmobjects: OpenGLVMobject):
    """Checks if all passed elements are an instance of OpenGLVMobject and then add them to submobjects

    Parameters
    ----------
    vmobjects
        List of OpenGLVMobject to add

    Returns
    -------
    :class:`OpenGLVGroup`

    Raises
    ------
    TypeError
        If one element of the list is not an instance of OpenGLVMobject

    Examples
    --------
    .. manim:: AddToOpenGLVGroup

        class AddToOpenGLVGroup(Scene):
            def construct(self):
                circle_red = Circle(color=RED)
                circle_green = Circle(color=GREEN)
                circle_blue = Circle(color=BLUE)
                circle_red.shift(LEFT)
                circle_blue.shift(RIGHT)
                gr = OpenGLVGroup(circle_red, circle_green)
                gr2 = OpenGLVGroup(circle_blue) # Constructor uses add directly
                self.add(gr,gr2)
                self.wait()
                gr += gr2 # Add group to another
                self.play(
                    gr.animate.shift(DOWN),
                )
                gr -= gr2 # Remove group
                self.play( # Animate groups separately
                    gr.animate.shift(LEFT),
                    gr2.animate.shift(UP),
                )
                self.play( #Animate groups without modification
                    (gr+gr2).animate.shift(RIGHT)
                )
                self.play( # Animate group without component
                    (gr-circle_red).animate.shift(RIGHT)
                )
    """
    return super().add(*vmobjects)

</t>
<t tx="ekr.20250122151620.1976">def __add__(self, vmobject):
    return OpenGLVGroup(*self.submobjects, vmobject)

</t>
<t tx="ekr.20250122151620.1977">def __iadd__(self, vmobject):
    return self.add(vmobject)

</t>
<t tx="ekr.20250122151620.1978">def __sub__(self, vmobject):
    copy = OpenGLVGroup(*self.submobjects)
    copy.remove(vmobject)
    return copy

</t>
<t tx="ekr.20250122151620.1979">def __isub__(self, vmobject):
    return self.remove(vmobject)

</t>
<t tx="ekr.20250122151620.198">def __len__(self) -&gt; int:
    return len(self._OPTS)

</t>
<t tx="ekr.20250122151620.1980">def __setitem__(self, key: int, value: OpenGLVMobject | Sequence[OpenGLVMobject]):
    """Override the [] operator for item assignment.

    Parameters
    ----------
    key
        The index of the submobject to be assigned
    value
        The vmobject value to assign to the key

    Returns
    -------
    None

    Tests
    -----

    .. doctest::

        &gt;&gt;&gt; from manim import config
        &gt;&gt;&gt; original_renderer = config.renderer
        &gt;&gt;&gt; config.renderer = "opengl"

        &gt;&gt;&gt; vgroup = OpenGLVGroup(OpenGLVMobject())
        &gt;&gt;&gt; new_obj = OpenGLVMobject()
        &gt;&gt;&gt; vgroup[0] = new_obj

        &gt;&gt;&gt; config.renderer = original_renderer
    """
    self._assert_valid_submobjects(tuplify(value))
    self.submobjects[key] = value


</t>
<t tx="ekr.20250122151620.1981">def __init__(
    self,
    location=ORIGIN,
    color=BLACK,
    fill_opacity=0,
    stroke_width=0,
    artificial_width=0.01,
    artificial_height=0.01,
    **kwargs,
):
    self.artificial_width = artificial_width
    self.artificial_height = artificial_height

    super().__init__(
        color=color, fill_opacity=fill_opacity, stroke_width=stroke_width, **kwargs
    )
    self.set_points(np.array([location]))


</t>
<t tx="ekr.20250122151620.1982">def __init__(self, vmobject, **kwargs):
    super().__init__(**kwargs)
    for tup in vmobject.get_bezier_tuples():
        part = OpenGLVMobject()
        part.set_points(tup)
        part.match_style(vmobject)
        self.add(part)


</t>
<t tx="ekr.20250122151620.1983">def __init__(
    self,
    vmobject: OpenGLVMobject,
    num_dashes: int = 15,
    dashed_ratio: float = 0.5,
    color: ParsableManimColor = WHITE,
    **kwargs,
):
    self.dashed_ratio = dashed_ratio
    self.num_dashes = num_dashes
    super().__init__(color=color, **kwargs)
    r = self.dashed_ratio
    n = self.num_dashes
    if num_dashes &gt; 0:
        # Assuming total length is 1
        dash_len = r / n
        void_len = (1 - r) / n if vmobject.is_closed() else (1 - r) / (n - 1)

        self.add(
            *(
                vmobject.get_subcurve(
                    i * (dash_len + void_len),
                    i * (dash_len + void_len) + dash_len,
                )
                for i in range(n)
            )
        )
    # Family is already taken care of by get_subcurve
    # implementation
    self.match_style(vmobject, recurse=False)
</t>
<t tx="ekr.20250122151620.1984"></t>
<t tx="ekr.20250122151620.1985">"""Mobjects related to SVG images.

Modules
=======

.. autosummary::
    :toctree: ../reference

    ~brace
    ~svg_mobject
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1986">"""Mobject representing curly braces."""

from __future__ import annotations

__all__ = ["Brace", "BraceLabel", "ArcBrace", "BraceText", "BraceBetweenPoints"]

from collections.abc import Sequence
from typing import TYPE_CHECKING

import numpy as np
import svgelements as se

from manim._config import config
from manim.mobject.geometry.arc import Arc
from manim.mobject.geometry.line import Line
from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.text.tex_mobject import MathTex, Tex

from ...animation.composition import AnimationGroup
from ...animation.fading import FadeIn
from ...animation.growing import GrowFromCenter
from ...constants import *
from ...mobject.types.vectorized_mobject import VMobject
from ...utils.color import BLACK
from ..svg.svg_mobject import VMobjectFromSVGPath

if TYPE_CHECKING:
    from manim.typing import Point3DLike, Vector3D
    from manim.utils.color.core import ParsableManimColor

__all__ = ["Brace", "BraceBetweenPoints", "BraceLabel", "ArcBrace"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.1987">class Brace(VMobjectFromSVGPath):
    """Takes a mobject and draws a brace adjacent to it.

    Passing a direction vector determines the direction from which the
    brace is drawn. By default it is drawn from below.

    Parameters
    ----------
    mobject
        The mobject adjacent to which the brace is placed.
    direction :
        The direction from which the brace faces the mobject.

    See Also
    --------
    :class:`BraceBetweenPoints`

    Examples
    --------
    .. manim:: BraceExample
        :save_last_frame:

        class BraceExample(Scene):
            def construct(self):
                s = Square()
                self.add(s)
                for i in np.linspace(0.1,1.0,4):
                    br = Brace(s, sharpness=i)
                    t = Text(f"sharpness= {i}").next_to(br, RIGHT)
                    self.add(t)
                    self.add(br)
                VGroup(*self.mobjects).arrange(DOWN, buff=0.2)

    """

    @others
</t>
<t tx="ekr.20250122151620.1988">class BraceLabel(VMobject, metaclass=ConvertToOpenGL):
    """Create a brace with a label attached.

    Parameters
    ----------
    obj
        The mobject adjacent to which the brace is placed.
    text
        The label text.
    brace_direction
        The direction of the brace. By default ``DOWN``.
    label_constructor
        A class or function used to construct a mobject representing
        the label. By default :class:`~.MathTex`.
    font_size
        The font size of the label, passed to the ``label_constructor``.
    buff
        The buffer between the mobject and the brace.
    brace_config
        Arguments to be passed to :class:`.Brace`.
    kwargs
        Additional arguments to be passed to :class:`~.VMobject`.
    """

    @others
</t>
<t tx="ekr.20250122151620.1989">class BraceText(BraceLabel):
    @others
</t>
<t tx="ekr.20250122151620.199"># make this truly immutable
def __setattr__(self, attr: Any, val: Any) -&gt; NoReturn:
    raise TypeError("'ManimFrame' object does not support item assignment")

</t>
<t tx="ekr.20250122151620.1990">class BraceBetweenPoints(Brace):
    """Similar to Brace, but instead of taking a mobject it uses 2
    points to place the brace.

    A fitting direction for the brace is
    computed, but it still can be manually overridden.
    If the points go from left to right, the brace is drawn from below.
    Swapping the points places the brace on the opposite side.

    Parameters
    ----------
    point_1 :
        The first point.
    point_2 :
        The second point.
    direction :
        The direction from which the brace faces towards the points.

    Examples
    --------
        .. manim:: BraceBPExample

            class BraceBPExample(Scene):
                def construct(self):
                    p1 = [0,0,0]
                    p2 = [1,2,0]
                    brace = BraceBetweenPoints(p1,p2)
                    self.play(Create(NumberPlane()))
                    self.play(Create(brace))
                    self.wait(2)
    """

    @others
</t>
<t tx="ekr.20250122151620.1991">class ArcBrace(Brace):
    """Creates a :class:`~Brace` that wraps around an :class:`~.Arc`.

    The direction parameter allows the brace to be applied
    from outside or inside the arc.

    .. warning::
        The :class:`ArcBrace` is smaller for arcs with smaller radii.

    .. note::
        The :class:`ArcBrace` is initially a vertical :class:`Brace` defined by the
        length of the :class:`~.Arc`, but is scaled down to match the start and end
        angles. An exponential function is then applied after it is shifted based on
        the radius of the arc.

        The scaling effect is not applied for arcs with radii smaller than 1 to prevent
        over-scaling.

    Parameters
    ----------
    arc
        The :class:`~.Arc` that wraps around the :class:`Brace` mobject.
    direction
        The direction from which the brace faces the arc.
        ``LEFT`` for inside the arc, and ``RIGHT`` for the outside.

    Example
    -------
        .. manim:: ArcBraceExample
            :save_last_frame:
            :ref_classes: Arc

            class ArcBraceExample(Scene):
                def construct(self):
                    arc_1 = Arc(radius=1.5,start_angle=0,angle=2*PI/3).set_color(RED)
                    brace_1 = ArcBrace(arc_1,LEFT)
                    group_1 = VGroup(arc_1,brace_1)

                    arc_2 = Arc(radius=3,start_angle=0,angle=5*PI/6).set_color(YELLOW)
                    brace_2 = ArcBrace(arc_2)
                    group_2 = VGroup(arc_2,brace_2)

                    arc_3 = Arc(radius=0.5,start_angle=-0,angle=PI).set_color(BLUE)
                    brace_3 = ArcBrace(arc_3)
                    group_3 = VGroup(arc_3,brace_3)

                    arc_4 = Arc(radius=0.2,start_angle=0,angle=3*PI/2).set_color(GREEN)
                    brace_4 = ArcBrace(arc_4)
                    group_4 = VGroup(arc_4,brace_4)

                    arc_group = VGroup(group_1, group_2, group_3, group_4).arrange_in_grid(buff=1.5)
                    self.add(arc_group.center())

    """

    @others
</t>
<t tx="ekr.20250122151620.1992">def __init__(
    self,
    mobject: Mobject,
    direction: Vector3D | None = DOWN,
    buff: float = 0.2,
    sharpness: float = 2,
    stroke_width: float = 0,
    fill_opacity: float = 1.0,
    background_stroke_width: float = 0,
    background_stroke_color: ParsableManimColor = BLACK,
    **kwargs,
):
    path_string_template = (
        "m0.01216 0c-0.01152 0-0.01216 6.103e-4 -0.01216 0.01311v0.007762c0.06776 "
        "0.122 0.1799 0.1455 0.2307 0.1455h{0}c0.03046 3.899e-4 0.07964 0.00449 "
        "0.1246 0.02636 0.0537 0.02695 0.07418 0.05816 0.08648 0.07769 0.001562 "
        "0.002538 0.004539 0.002563 0.01098 0.002563 0.006444-2e-8 0.009421-2.47e-"
        "5 0.01098-0.002563 0.0123-0.01953 0.03278-0.05074 0.08648-0.07769 0.04491"
        "-0.02187 0.09409-0.02597 0.1246-0.02636h{0}c0.05077 0 0.1629-0.02346 "
        "0.2307-0.1455v-0.007762c-1.78e-6 -0.0125-6.365e-4 -0.01311-0.01216-0.0131"
        "1-0.006444-3.919e-8 -0.009348 2.448e-5 -0.01091 0.002563-0.0123 0.01953-"
        "0.03278 0.05074-0.08648 0.07769-0.04491 0.02187-0.09416 0.02597-0.1246 "
        "0.02636h{1}c-0.04786 0-0.1502 0.02094-0.2185 0.1256-0.06833-0.1046-0.1706"
        "-0.1256-0.2185-0.1256h{1}c-0.03046-3.899e-4 -0.07972-0.004491-0.1246-0.02"
        "636-0.0537-0.02695-0.07418-0.05816-0.08648-0.07769-0.001562-0.002538-"
        "0.004467-0.002563-0.01091-0.002563z"
    )
    default_min_width = 0.90552

    self.buff = buff

    angle = -np.arctan2(*direction[:2]) + np.pi
    mobject.rotate(-angle, about_point=ORIGIN)
    left = mobject.get_corner(DOWN + LEFT)
    right = mobject.get_corner(DOWN + RIGHT)
    target_width = right[0] - left[0]
    linear_section_length = max(
        0,
        (target_width * sharpness - default_min_width) / 2,
    )

    path = se.Path(
        path_string_template.format(
            linear_section_length,
            -linear_section_length,
        )
    )

    super().__init__(
        path_obj=path,
        stroke_width=stroke_width,
        fill_opacity=fill_opacity,
        background_stroke_width=background_stroke_width,
        background_stroke_color=background_stroke_color,
        **kwargs,
    )
    self.flip(RIGHT)
    self.stretch_to_fit_width(target_width)
    self.shift(left - self.get_corner(UP + LEFT) + self.buff * DOWN)

    for mob in mobject, self:
        mob.rotate(angle, about_point=ORIGIN)

</t>
<t tx="ekr.20250122151620.1993">def put_at_tip(self, mob: Mobject, use_next_to: bool = True, **kwargs):
    """Puts the given mobject at the brace tip.

    Parameters
    ----------
    mob
        The mobject to be placed at the tip.
    use_next_to
        If true, then :meth:`next_to` is used to place the mobject at the
        tip.
    kwargs
        Any additional keyword arguments are passed to :meth:`next_to` which
        is used to put the mobject next to the brace tip.
    """
    if use_next_to:
        mob.next_to(self.get_tip(), np.round(self.get_direction()), **kwargs)
    else:
        mob.move_to(self.get_tip())
        buff = kwargs.get("buff", DEFAULT_MOBJECT_TO_MOBJECT_BUFFER)
        shift_distance = mob.width / 2.0 + buff
        mob.shift(self.get_direction() * shift_distance)
    return self

</t>
<t tx="ekr.20250122151620.1994">def get_text(self, *text, **kwargs):
    """Places the text at the brace tip.

    Parameters
    ----------
    text
        The text to be placed at the brace tip.
    kwargs
        Any additional keyword arguments are passed to :meth:`.put_at_tip` which
        is used to position the text at the brace tip.

    Returns
    -------
    :class:`~.Tex`
    """
    text_mob = Tex(*text)
    self.put_at_tip(text_mob, **kwargs)
    return text_mob

</t>
<t tx="ekr.20250122151620.1995">def get_tex(self, *tex, **kwargs):
    """Places the tex at the brace tip.

    Parameters
    ----------
    tex
        The tex to be placed at the brace tip.
    kwargs
        Any further keyword arguments are passed to :meth:`.put_at_tip` which
        is used to position the tex at the brace tip.

    Returns
    -------
    :class:`~.MathTex`
    """
    tex_mob = MathTex(*tex)
    self.put_at_tip(tex_mob, **kwargs)
    return tex_mob

</t>
<t tx="ekr.20250122151620.1996">def get_tip(self):
    """Returns the point at the brace tip."""
    # Returns the position of the seventh point in the path, which is the tip.
    if config["renderer"] == "opengl":
        return self.points[34]

    return self.points[28]  # = 7*4

</t>
<t tx="ekr.20250122151620.1997">def get_direction(self):
    """Returns the direction from the center to the brace tip."""
    vect = self.get_tip() - self.get_center()
    return vect / np.linalg.norm(vect)


</t>
<t tx="ekr.20250122151620.1998">def __init__(
    self,
    obj: Mobject,
    text: str,
    brace_direction: np.ndarray = DOWN,
    label_constructor: type = MathTex,
    font_size: float = DEFAULT_FONT_SIZE,
    buff: float = 0.2,
    brace_config: dict | None = None,
    **kwargs,
):
    self.label_constructor = label_constructor
    super().__init__(**kwargs)

    self.brace_direction = brace_direction
    if brace_config is None:
        brace_config = {}
    self.brace = Brace(obj, brace_direction, buff, **brace_config)

    if isinstance(text, (tuple, list)):
        self.label = self.label_constructor(*text, font_size=font_size, **kwargs)
    else:
        self.label = self.label_constructor(str(text), font_size=font_size)

    self.brace.put_at_tip(self.label)
    self.add(self.brace, self.label)

</t>
<t tx="ekr.20250122151620.1999">def creation_anim(self, label_anim=FadeIn, brace_anim=GrowFromCenter):
    return AnimationGroup(brace_anim(self.brace), label_anim(self.label))

</t>
<t tx="ekr.20250122151620.2"></t>
<t tx="ekr.20250122151620.20">def make_logger(
    parser: configparser.SectionProxy,
    verbosity: str,
) -&gt; tuple[logging.Logger, Console, Console]:
    """Make the manim logger and console.

    Parameters
    ----------
    parser
        A parser containing any .cfg files in use.

    verbosity
        The verbosity level of the logger.

    Returns
    -------
    :class:`logging.Logger`, :class:`rich.Console`, :class:`rich.Console`
        The manim logger and consoles. The first console outputs
        to stdout, the second to stderr. All use the theme returned by
        :func:`parse_theme`.

    See Also
    --------
    :func:`~._config.utils.make_config_parser`, :func:`parse_theme`

    Notes
    -----
    The ``parser`` is assumed to contain only the options related to
    configuring the logger at the top level.

    """
    # Throughout the codebase, use console.print() instead of print()
    theme = parse_theme(parser)
    console = Console(theme=theme)

    error_console = Console(theme=theme, stderr=True)

    # set the rich handler
    rich_handler = RichHandler(
        console=console,
        show_time=parser.getboolean("log_timestamps"),
        keywords=HIGHLIGHTED_KEYWORDS,
    )

    # finally, the logger
    logger = logging.getLogger("manim")
    logger.addHandler(rich_handler)
    logger.setLevel(verbosity)
    logger.propagate = False

    if not (libav_logger := logging.getLogger()).hasHandlers():
        libav_logger.addHandler(rich_handler)
        libav_logger.setLevel(verbosity)

    return logger, console, error_console


</t>
<t tx="ekr.20250122151620.200">def __setitem__(self, key: Any, val: Any) -&gt; NoReturn:
    raise TypeError("'ManimFrame' object does not support item assignment")

</t>
<t tx="ekr.20250122151620.2000">def shift_brace(self, obj, **kwargs):
    if isinstance(obj, list):
        obj = self.get_group_class()(*obj)
    self.brace = Brace(obj, self.brace_direction, **kwargs)
    self.brace.put_at_tip(self.label)
    return self

</t>
<t tx="ekr.20250122151620.2001">def change_label(self, *text, **kwargs):
    self.label = self.label_constructor(*text, **kwargs)

    self.brace.put_at_tip(self.label)
    return self

</t>
<t tx="ekr.20250122151620.2002">def change_brace_label(self, obj, *text, **kwargs):
    self.shift_brace(obj)
    self.change_label(*text, **kwargs)
    return self


</t>
<t tx="ekr.20250122151620.2003">def __init__(self, obj, text, label_constructor=Tex, **kwargs):
    super().__init__(obj, text, label_constructor=label_constructor, **kwargs)


</t>
<t tx="ekr.20250122151620.2004">def __init__(
    self,
    point_1: Point3DLike | None,
    point_2: Point3DLike | None,
    direction: Vector3D | None = ORIGIN,
    **kwargs,
):
    if all(direction == ORIGIN):
        line_vector = np.array(point_2) - np.array(point_1)
        direction = np.array([line_vector[1], -line_vector[0], 0])
    super().__init__(Line(point_1, point_2), direction=direction, **kwargs)


</t>
<t tx="ekr.20250122151620.2005">def __init__(
    self,
    arc: Arc | None = None,
    direction: Sequence[float] = RIGHT,
    **kwargs,
):
    if arc is None:
        arc = Arc(start_angle=-1, angle=2, radius=1)
    arc_end_angle = arc.start_angle + arc.angle
    line = Line(UP * arc.start_angle, UP * arc_end_angle)
    scale_shift = RIGHT * np.log(arc.radius)

    if arc.radius &gt;= 1:
        line.scale(arc.radius, about_point=ORIGIN)
        super().__init__(line, direction=direction, **kwargs)
        self.scale(1 / (arc.radius), about_point=ORIGIN)
    else:
        super().__init__(line, direction=direction, **kwargs)

    if arc.radius &gt;= 0.3:
        self.shift(scale_shift)
    else:
        self.shift(RIGHT * np.log(0.3))

    self.apply_complex_function(np.exp)
    self.shift(arc.get_arc_center())
</t>
<t tx="ekr.20250122151620.2006">"""Mobjects generated from an SVG file."""

from __future__ import annotations

import os
from pathlib import Path
from xml.etree import ElementTree as ET

import numpy as np
import svgelements as se

from manim import config, logger

from ...constants import RIGHT
from ...utils.bezier import get_quadratic_approximation_of_cubic
from ...utils.images import get_full_vector_image_path
from ...utils.iterables import hash_obj
from ..geometry.arc import Circle
from ..geometry.line import Line
from ..geometry.polygram import Polygon, Rectangle, RoundedRectangle
from ..opengl.opengl_compatibility import ConvertToOpenGL
from ..types.vectorized_mobject import VMobject

__all__ = ["SVGMobject", "VMobjectFromSVGPath"]


SVG_HASH_TO_MOB_MAP: dict[int, VMobject] = {}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.2007">def _convert_point_to_3d(x: float, y: float) -&gt; np.ndarray:
    return np.array([x, y, 0.0])


</t>
<t tx="ekr.20250122151620.2008">class SVGMobject(VMobject, metaclass=ConvertToOpenGL):
    """A vectorized mobject created from importing an SVG file.

    Parameters
    ----------
    file_name
        The path to the SVG file.
    should_center
        Whether or not the mobject should be centered after
        being imported.
    height
        The target height of the mobject, set to 2 Manim units by default.
        If the height and width are both set to ``None``, the mobject
        is imported without being scaled.
    width
        The target width of the mobject, set to ``None`` by default. If
        the height and the width are both set to ``None``, the mobject
        is imported without being scaled.
    color
        The color (both fill and stroke color) of the mobject. If
        ``None`` (the default), the colors set in the SVG file
        are used.
    opacity
        The opacity (both fill and stroke opacity) of the mobject.
        If ``None`` (the default), the opacity set in the SVG file
        is used.
    fill_color
        The fill color of the mobject. If ``None`` (the default),
        the fill colors set in the SVG file are used.
    fill_opacity
        The fill opacity of the mobject. If ``None`` (the default),
        the fill opacities set in the SVG file are used.
    stroke_color
        The stroke color of the mobject. If ``None`` (the default),
        the stroke colors set in the SVG file are used.
    stroke_opacity
        The stroke opacity of the mobject. If ``None`` (the default),
        the stroke opacities set in the SVG file are used.
    stroke_width
        The stroke width of the mobject. If ``None`` (the default),
        the stroke width values set in the SVG file are used.
    svg_default
        A dictionary in which fallback values for unspecified
        properties of elements in the SVG file are defined. If
        ``None`` (the default), ``color``, ``opacity``, ``fill_color``
        ``fill_opacity``, ``stroke_color``, and ``stroke_opacity``
        are set to ``None``, and ``stroke_width`` is set to 0.
    path_string_config
        A dictionary with keyword arguments passed to
        :class:`.VMobjectFromSVGPath` used for importing path elements.
        If ``None`` (the default), no additional arguments are passed.
    use_svg_cache
        If True (default), the svg inputs (e.g. file_name, settings)
        will be used as a key and a copy of the created mobject will
        be saved using that key to be quickly retrieved if the same
        inputs need be processed later. For large SVGs which are used
        only once, this can be omitted to improve performance.
    kwargs
        Further arguments passed to the parent class.
    """

    @others
</t>
<t tx="ekr.20250122151620.2009">class VMobjectFromSVGPath(VMobject, metaclass=ConvertToOpenGL):
    """A vectorized mobject representing an SVG path.

    .. note::

        The ``long_lines``, ``should_subdivide_sharp_curves``,
        and ``should_remove_null_curves`` keyword arguments are
        only respected with the OpenGL renderer.

    Parameters
    ----------
    path_obj
        A parsed SVG path object.
    long_lines
        Whether or not straight lines in the vectorized mobject
        are drawn in one or two segments.
    should_subdivide_sharp_curves
        Whether or not to subdivide subcurves further in case
        two segments meet at an angle that is sharper than a
        given threshold.
    should_remove_null_curves
        Whether or not to remove subcurves of length 0.
    kwargs
        Further keyword arguments are passed to the parent
        class.
    """

    @others
</t>
<t tx="ekr.20250122151620.201">def __delitem__(self, key: Any) -&gt; NoReturn:
    raise TypeError("'ManimFrame' object does not support item deletion")


</t>
<t tx="ekr.20250122151620.2010">def __init__(
    self,
    file_name: str | os.PathLike | None = None,
    should_center: bool = True,
    height: float | None = 2,
    width: float | None = None,
    color: str | None = None,
    opacity: float | None = None,
    fill_color: str | None = None,
    fill_opacity: float | None = None,
    stroke_color: str | None = None,
    stroke_opacity: float | None = None,
    stroke_width: float | None = None,
    svg_default: dict | None = None,
    path_string_config: dict | None = None,
    use_svg_cache: bool = True,
    **kwargs,
):
    super().__init__(color=None, stroke_color=None, fill_color=None, **kwargs)

    # process keyword arguments
    self.file_name = Path(file_name) if file_name is not None else None

    self.should_center = should_center
    self.svg_height = height
    self.svg_width = width
    self.color = color
    self.opacity = opacity
    self.fill_color = fill_color
    self.fill_opacity = fill_opacity
    self.stroke_color = stroke_color
    self.stroke_opacity = stroke_opacity
    self.stroke_width = stroke_width

    if svg_default is None:
        svg_default = {
            "color": None,
            "opacity": None,
            "fill_color": None,
            "fill_opacity": None,
            "stroke_width": 0,
            "stroke_color": None,
            "stroke_opacity": None,
        }
    self.svg_default = svg_default

    if path_string_config is None:
        path_string_config = {}
    self.path_string_config = path_string_config

    self.init_svg_mobject(use_svg_cache=use_svg_cache)

    self.set_style(
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_color=stroke_color,
        stroke_opacity=stroke_opacity,
        stroke_width=stroke_width,
    )
    self.move_into_position()

</t>
<t tx="ekr.20250122151620.2011">def init_svg_mobject(self, use_svg_cache: bool) -&gt; None:
    """Checks whether the SVG has already been imported and
    generates it if not.

    See also
    --------
    :meth:`.SVGMobject.generate_mobject`
    """
    if use_svg_cache:
        hash_val = hash_obj(self.hash_seed)
        if hash_val in SVG_HASH_TO_MOB_MAP:
            mob = SVG_HASH_TO_MOB_MAP[hash_val].copy()
            self.add(*mob)
            return

    self.generate_mobject()
    if use_svg_cache:
        SVG_HASH_TO_MOB_MAP[hash_val] = self.copy()

</t>
<t tx="ekr.20250122151620.2012">@property
def hash_seed(self) -&gt; tuple:
    """A unique hash representing the result of the generated
    mobject points.

    Used as keys in the ``SVG_HASH_TO_MOB_MAP`` caching dictionary.
    """
    return (
        self.__class__.__name__,
        self.svg_default,
        self.path_string_config,
        self.file_name,
        config.renderer,
    )

</t>
<t tx="ekr.20250122151620.2013">def generate_mobject(self) -&gt; None:
    """Parse the SVG and translate its elements to submobjects."""
    file_path = self.get_file_path()
    element_tree = ET.parse(file_path)
    new_tree = self.modify_xml_tree(element_tree)
    # Create a temporary svg file to dump modified svg to be parsed
    modified_file_path = file_path.with_name(f"{file_path.stem}_{file_path.suffix}")
    new_tree.write(modified_file_path)

    svg = se.SVG.parse(modified_file_path)
    modified_file_path.unlink()

    mobjects = self.get_mobjects_from(svg)
    self.add(*mobjects)
    self.flip(RIGHT)  # Flip y

</t>
<t tx="ekr.20250122151620.2014">def get_file_path(self) -&gt; Path:
    """Search for an existing file based on the specified file name."""
    if self.file_name is None:
        raise ValueError("Must specify file for SVGMobject")
    return get_full_vector_image_path(self.file_name)

</t>
<t tx="ekr.20250122151620.2015">def modify_xml_tree(self, element_tree: ET.ElementTree) -&gt; ET.ElementTree:
    """Modifies the SVG element tree to include default
    style information.

    Parameters
    ----------
    element_tree
        The parsed element tree from the SVG file.
    """
    config_style_dict = self.generate_config_style_dict()
    style_keys = (
        "fill",
        "fill-opacity",
        "stroke",
        "stroke-opacity",
        "stroke-width",
        "style",
    )
    root = element_tree.getroot()
    root_style_dict = {k: v for k, v in root.attrib.items() if k in style_keys}

    new_root = ET.Element("svg", {})
    config_style_node = ET.SubElement(new_root, "g", config_style_dict)
    root_style_node = ET.SubElement(config_style_node, "g", root_style_dict)
    root_style_node.extend(root)
    return ET.ElementTree(new_root)

</t>
<t tx="ekr.20250122151620.2016">def generate_config_style_dict(self) -&gt; dict[str, str]:
    """Generate a dictionary holding the default style information."""
    keys_converting_dict = {
        "fill": ("color", "fill_color"),
        "fill-opacity": ("opacity", "fill_opacity"),
        "stroke": ("color", "stroke_color"),
        "stroke-opacity": ("opacity", "stroke_opacity"),
        "stroke-width": ("stroke_width",),
    }
    svg_default_dict = self.svg_default
    result = {}
    for svg_key, style_keys in keys_converting_dict.items():
        for style_key in style_keys:
            if svg_default_dict[style_key] is None:
                continue
            result[svg_key] = str(svg_default_dict[style_key])
    return result

</t>
<t tx="ekr.20250122151620.2017">def get_mobjects_from(self, svg: se.SVG) -&gt; list[VMobject]:
    """Convert the elements of the SVG to a list of mobjects.

    Parameters
    ----------
    svg
        The parsed SVG file.
    """
    result = []
    for shape in svg.elements():
        # can we combine the two continue cases into one?
        if isinstance(shape, se.Group):  # noqa: SIM114
            continue
        elif isinstance(shape, se.Path):
            mob = self.path_to_mobject(shape)
        elif isinstance(shape, se.SimpleLine):
            mob = self.line_to_mobject(shape)
        elif isinstance(shape, se.Rect):
            mob = self.rect_to_mobject(shape)
        elif isinstance(shape, (se.Circle, se.Ellipse)):
            mob = self.ellipse_to_mobject(shape)
        elif isinstance(shape, se.Polygon):
            mob = self.polygon_to_mobject(shape)
        elif isinstance(shape, se.Polyline):
            mob = self.polyline_to_mobject(shape)
        elif isinstance(shape, se.Text):
            mob = self.text_to_mobject(shape)
        elif isinstance(shape, se.Use) or type(shape) is se.SVGElement:
            continue
        else:
            logger.warning(f"Unsupported element type: {type(shape)}")
            continue
        if mob is None or not mob.has_points():
            continue
        self.apply_style_to_mobject(mob, shape)
        if isinstance(shape, se.Transformable) and shape.apply:
            self.handle_transform(mob, shape.transform)
        result.append(mob)
    return result

</t>
<t tx="ekr.20250122151620.2018">@staticmethod
def handle_transform(mob: VMobject, matrix: se.Matrix) -&gt; VMobject:
    """Apply SVG transformations to the converted mobject.

    Parameters
    ----------
    mob
        The converted mobject.
    matrix
        The transformation matrix determined from the SVG
        transformation.
    """
    mat = np.array([[matrix.a, matrix.c], [matrix.b, matrix.d]])
    vec = np.array([matrix.e, matrix.f, 0.0])
    mob.apply_matrix(mat)
    mob.shift(vec)
    return mob

</t>
<t tx="ekr.20250122151620.2019">@staticmethod
def apply_style_to_mobject(mob: VMobject, shape: se.GraphicObject) -&gt; VMobject:
    """Apply SVG style information to the converted mobject.

    Parameters
    ----------
    mob
        The converted mobject.
    shape
        The parsed SVG element.
    """
    mob.set_style(
        stroke_width=shape.stroke_width,
        stroke_color=shape.stroke.hexrgb,
        stroke_opacity=shape.stroke.opacity,
        fill_color=shape.fill.hexrgb,
        fill_opacity=shape.fill.opacity,
    )
    return mob

</t>
<t tx="ekr.20250122151620.202"></t>
<t tx="ekr.20250122151620.2020">def path_to_mobject(self, path: se.Path) -&gt; VMobjectFromSVGPath:
    """Convert a path element to a vectorized mobject.

    Parameters
    ----------
    path
        The parsed SVG path.
    """
    return VMobjectFromSVGPath(path, **self.path_string_config)

</t>
<t tx="ekr.20250122151620.2021">@staticmethod
def line_to_mobject(line: se.Line) -&gt; Line:
    """Convert a line element to a vectorized mobject.

    Parameters
    ----------
    line
        The parsed SVG line.
    """
    return Line(
        start=_convert_point_to_3d(line.x1, line.y1),
        end=_convert_point_to_3d(line.x2, line.y2),
    )

</t>
<t tx="ekr.20250122151620.2022">@staticmethod
def rect_to_mobject(rect: se.Rect) -&gt; Rectangle:
    """Convert a rectangle element to a vectorized mobject.

    Parameters
    ----------
    rect
        The parsed SVG rectangle.
    """
    if rect.rx == 0 or rect.ry == 0:
        mob = Rectangle(
            width=rect.width,
            height=rect.height,
        )
    else:
        mob = RoundedRectangle(
            width=rect.width,
            height=rect.height * rect.rx / rect.ry,
            corner_radius=rect.rx,
        )
        mob.stretch_to_fit_height(rect.height)
    mob.shift(
        _convert_point_to_3d(rect.x + rect.width / 2, rect.y + rect.height / 2)
    )
    return mob

</t>
<t tx="ekr.20250122151620.2023">@staticmethod
def ellipse_to_mobject(ellipse: se.Ellipse | se.Circle) -&gt; Circle:
    """Convert an ellipse or circle element to a vectorized mobject.

    Parameters
    ----------
    ellipse
        The parsed SVG ellipse or circle.
    """
    mob = Circle(radius=ellipse.rx)
    if ellipse.rx != ellipse.ry:
        mob.stretch_to_fit_height(2 * ellipse.ry)
    mob.shift(_convert_point_to_3d(ellipse.cx, ellipse.cy))
    return mob

</t>
<t tx="ekr.20250122151620.2024">@staticmethod
def polygon_to_mobject(polygon: se.Polygon) -&gt; Polygon:
    """Convert a polygon element to a vectorized mobject.

    Parameters
    ----------
    polygon
        The parsed SVG polygon.
    """
    points = [_convert_point_to_3d(*point) for point in polygon]
    return Polygon(*points)

</t>
<t tx="ekr.20250122151620.2025">def polyline_to_mobject(self, polyline: se.Polyline) -&gt; VMobject:
    """Convert a polyline element to a vectorized mobject.

    Parameters
    ----------
    polyline
        The parsed SVG polyline.
    """
    points = [_convert_point_to_3d(*point) for point in polyline]
    vmobject_class = self.get_mobject_type_class()
    return vmobject_class().set_points_as_corners(points)

</t>
<t tx="ekr.20250122151620.2026">@staticmethod
def text_to_mobject(text: se.Text):
    """Convert a text element to a vectorized mobject.

    .. warning::

        Not yet implemented.

    Parameters
    ----------
    text
        The parsed SVG text.
    """
    logger.warning(f"Unsupported element type: {type(text)}")
    return

</t>
<t tx="ekr.20250122151620.2027">def move_into_position(self) -&gt; None:
    """Scale and move the generated mobject into position."""
    if self.should_center:
        self.center()
    if self.svg_height is not None:
        self.set(height=self.svg_height)
    if self.svg_width is not None:
        self.set(width=self.svg_width)


</t>
<t tx="ekr.20250122151620.2028">def __init__(
    self,
    path_obj: se.Path,
    long_lines: bool = False,
    should_subdivide_sharp_curves: bool = False,
    should_remove_null_curves: bool = False,
    **kwargs,
):
    # Get rid of arcs
    path_obj.approximate_arcs_with_quads()
    self.path_obj = path_obj

    self.long_lines = long_lines
    self.should_subdivide_sharp_curves = should_subdivide_sharp_curves
    self.should_remove_null_curves = should_remove_null_curves

    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.2029">def init_points(self) -&gt; None:
    # TODO: cache mobject in a re-importable way

    self.handle_commands()

    if config.renderer == "opengl":
        if self.should_subdivide_sharp_curves:
            # For a healthy triangulation later
            self.subdivide_sharp_curves()
        if self.should_remove_null_curves:
            # Get rid of any null curves
            self.set_points(self.get_points_without_null_curves())

</t>
<t tx="ekr.20250122151620.203"></t>
<t tx="ekr.20250122151620.2030">generate_points = init_points

def handle_commands(self) -&gt; None:
    all_points: list[np.ndarray] = []
    last_move = None
    curve_start = None
    last_true_move = None

    def move_pen(pt, *, true_move: bool = False):
        nonlocal last_move, curve_start, last_true_move
        last_move = pt
        if curve_start is None:
            curve_start = last_move
        if true_move:
            last_true_move = last_move

    if self.n_points_per_curve == 4:

        def add_cubic(start, cp1, cp2, end):
            nonlocal all_points
            assert len(all_points) % 4 == 0, len(all_points)
            all_points += [start, cp1, cp2, end]
            move_pen(end)

        def add_quad(start, cp, end):
            add_cubic(start, (start + cp + cp) / 3, (cp + cp + end) / 3, end)
            move_pen(end)

        def add_line(start, end):
            add_cubic(
                start, (start + start + end) / 3, (start + end + end) / 3, end
            )
            move_pen(end)

    else:

        def add_cubic(start, cp1, cp2, end):
            nonlocal all_points
            assert len(all_points) % 3 == 0, len(all_points)
            two_quads = get_quadratic_approximation_of_cubic(
                start,
                cp1,
                cp2,
                end,
            )
            all_points += two_quads[:3].tolist()
            all_points += two_quads[3:].tolist()
            move_pen(end)

        def add_quad(start, cp, end):
            nonlocal all_points
            assert len(all_points) % 3 == 0, len(all_points)
            all_points += [start, cp, end]
            move_pen(end)

        def add_line(start, end):
            add_quad(start, (start + end) / 2, end)
            move_pen(end)

    for segment in self.path_obj:
        segment_class = segment.__class__
        if segment_class == se.Move:
            move_pen(_convert_point_to_3d(*segment.end), true_move=True)
        elif segment_class == se.Line:
            add_line(last_move, _convert_point_to_3d(*segment.end))
        elif segment_class == se.QuadraticBezier:
            add_quad(
                last_move,
                _convert_point_to_3d(*segment.control),
                _convert_point_to_3d(*segment.end),
            )
        elif segment_class == se.CubicBezier:
            add_cubic(
                last_move,
                _convert_point_to_3d(*segment.control1),
                _convert_point_to_3d(*segment.control2),
                _convert_point_to_3d(*segment.end),
            )
        elif segment_class == se.Close:
            # If the SVG path naturally ends at the beginning of the curve,
            # we do *not* need to draw a closing line. To account for floating
            # point precision, we use a small value to compare the two points.
            if abs(np.linalg.norm(last_move - last_true_move)) &gt; 0.0001:
                add_line(last_move, last_true_move)
            curve_start = None
        else:
            raise AssertionError(f"Not implemented: {segment_class}")

    self.points = np.array(all_points, ndmin=2, dtype="float64")
    # If we have no points, make sure the array is shaped properly
    # (0 rows tall by 3 columns wide) so future operations can
    # add or remove points correctly.
    if len(all_points) == 0:
        self.points = np.reshape(self.points, (0, 3))
</t>
<t tx="ekr.20250122151620.2031"></t>
<t tx="ekr.20250122151620.2032">"""Mobjects used to display Text using Pango or LaTeX.

Modules
=======

.. autosummary::
    :toctree: ../reference

    ~code_mobject
    ~numbers
    ~tex_mobject
    ~text_mobject
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.2033">"""Mobject representing highlighted source code listings."""

from __future__ import annotations

__all__ = [
    "Code",
]

from pathlib import Path
from typing import Any, Literal

from bs4 import BeautifulSoup, Tag
from pygments import highlight
from pygments.formatters.html import HtmlFormatter
from pygments.lexers import get_lexer_by_name, guess_lexer, guess_lexer_for_filename
from pygments.styles import get_all_styles

from manim.constants import *
from manim.mobject.geometry.arc import Dot
from manim.mobject.geometry.shape_matchers import SurroundingRectangle
from manim.mobject.text.text_mobject import Paragraph
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from manim.typing import StrPath
from manim.utils.color import WHITE, ManimColor


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.2034">class Code(VMobject):
    """A highlighted source code listing.

    Examples
    --------

    Normal usage::

        listing = Code(
            "helloworldcpp.cpp",
            tab_width=4,
            formatter_style="emacs",
            background="window",
            language="cpp",
            background_config={"stroke_color": WHITE},
            paragraph_config={"font": "Noto Sans Mono"},
        )

    We can also render code passed as a string. As the automatic language
    detection can be a bit flaky, it is recommended to specify the language
    explicitly:

    .. manim:: CodeFromString
        :save_last_frame:

        class CodeFromString(Scene):
            def construct(self):
                code = '''from manim import Scene, Square

        class FadeInSquare(Scene):
            def construct(self):
                s = Square()
                self.play(FadeIn(s))
                self.play(s.animate.scale(2))
                self.wait()'''

                rendered_code = Code(
                    code_string=code,
                    language="python",
                    background="window",
                    background_config={"stroke_color": "maroon"},
                )
                self.add(rendered_code)

    Parameters
    ----------
    code_file
        The path to the code file to display.
    code_string
        Alternatively, the code string to display.
    language
        The programming language of the code. If not specified, it will be
        guessed from the file extension or the code itself.
    formatter_style
        The style to use for the code highlighting. Defaults to ``"vim"``.
        A list of all available styles can be obtained by calling
        :meth:`.Code.get_styles_list`.
    tab_width
        The width of a tab character in spaces. Defaults to 4.
    add_line_numbers
        Whether to display line numbers. Defaults to ``True``.
    line_numbers_from
        The first line number to display. Defaults to 1.
    background
        The type of background to use. Can be either ``"rectangle"`` (the
        default) or ``"window"``.
    background_config
        Keyword arguments passed to the background constructor. Default
        settings are stored in the class attribute
        :attr:`.default_background_config` (which can also be modified
        directly).
    paragraph_config
        Keyword arguments passed to the constructor of the
        :class:`.Paragraph` objects holding the code, and the line
        numbers. Default settings are stored in the class attribute
        :attr:`.default_paragraph_config` (which can also be modified
        directly).
    """

    @others
</t>
<t tx="ekr.20250122151620.2035">_styles_list_cache: list[str] | None = None
default_background_config: dict[str, Any] = {
    "buff": 0.3,
    "fill_color": ManimColor("#222"),
    "stroke_color": WHITE,
    "corner_radius": 0.2,
    "stroke_width": 1,
    "fill_opacity": 1,
}
default_paragraph_config: dict[str, Any] = {
    "font": "Monospace",
    "font_size": 24,
    "line_spacing": 0.5,
    "disable_ligatures": True,
}

def __init__(
    self,
    code_file: StrPath | None = None,
    code_string: str | None = None,
    language: str | None = None,
    formatter_style: str = "vim",
    tab_width: int = 4,
    add_line_numbers: bool = True,
    line_numbers_from: int = 1,
    background: Literal["rectangle", "window"] = "rectangle",
    background_config: dict[str, Any] | None = None,
    paragraph_config: dict[str, Any] | None = None,
):
    super().__init__()

    if code_file is not None:
        code_file = Path(code_file)
        code_string = code_file.read_text(encoding="utf-8")
        lexer = guess_lexer_for_filename(code_file.name, code_string)
    elif code_string is not None:
        if language is not None:
            lexer = get_lexer_by_name(language)
        else:
            lexer = guess_lexer(code_string)
    else:
        raise ValueError("Either a code file or a code string must be specified.")

    code_string = code_string.expandtabs(tabsize=tab_width)

    formatter = HtmlFormatter(
        style=formatter_style,
        noclasses=True,
        cssclasses="",
    )
    soup = BeautifulSoup(
        highlight(code_string, lexer, formatter), features="html.parser"
    )
    self._code_html = soup.find("pre")
    assert isinstance(self._code_html, Tag)

    # as we are using Paragraph to render the text, we need to find the character indices
    # of the segments of changed color in the HTML code
    color_ranges = []
    current_line_color_ranges = []
    current_line_char_index = 0
    for child in self._code_html.children:
        if child.name == "span":
            try:
                child_style = child["style"]
                if isinstance(child_style, str):
                    color = child_style.removeprefix("color: ")
                else:
                    color = None
            except KeyError:
                color = None
            current_line_color_ranges.append(
                (
                    current_line_char_index,
                    current_line_char_index + len(child.text),
                    color,
                )
            )
            current_line_char_index += len(child.text)
        else:
            for char in child.text:
                if char == "\n":
                    color_ranges.append(current_line_color_ranges)
                    current_line_color_ranges = []
                    current_line_char_index = 0
                else:
                    current_line_char_index += 1

    color_ranges.append(current_line_color_ranges)
    code_lines = self._code_html.get_text().removesuffix("\n").split("\n")

    if paragraph_config is None:
        paragraph_config = {}
    base_paragraph_config = self.default_paragraph_config.copy()
    base_paragraph_config.update(paragraph_config)

    self.code_lines = Paragraph(
        *code_lines,
        **base_paragraph_config,
    )
    for line, color_range in zip(self.code_lines, color_ranges):
        for start, end, color in color_range:
            line[start:end].set_color(color)

    if add_line_numbers:
        base_paragraph_config.update({"alignment": "right"})
        self.line_numbers = Paragraph(
            *[
                str(i)
                for i in range(
                    line_numbers_from, line_numbers_from + len(self.code_lines)
                )
            ],
            **base_paragraph_config,
        )
        self.line_numbers.next_to(self.code_lines, direction=LEFT).align_to(
            self.code_lines, UP
        )
        self.add(self.line_numbers)

    self.add(self.code_lines)

    if background_config is None:
        background_config = {}
    background_config_base = self.default_background_config.copy()
    background_config_base.update(background_config)

    if background == "rectangle":
        self.background = SurroundingRectangle(
            self,
            **background_config_base,
        )
    elif background == "window":
        buttons = VGroup(
            Dot(radius=0.1, stroke_width=0, color=button_color)
            for button_color in ["#ff5f56", "#ffbd2e", "#27c93f"]
        ).arrange(RIGHT, buff=0.1)
        buttons.next_to(self, UP, buff=0.1).align_to(self, LEFT).shift(LEFT * 0.1)
        self.background = SurroundingRectangle(
            VGroup(self, buttons),
            **background_config_base,
        )
        buttons.shift(UP * 0.1 + LEFT * 0.1)
        self.background.add(buttons)
    else:
        raise ValueError(f"Unknown background type: {background}")

    self.add_to_back(self.background)

</t>
<t tx="ekr.20250122151620.2036">@classmethod
def get_styles_list(cls) -&gt; list[str]:
    """Get the list of all available formatter styles."""
    if cls._styles_list_cache is None:
        cls._styles_list_cache = list(get_all_styles())
    return cls._styles_list_cache
</t>
<t tx="ekr.20250122151620.2037">"""Mobjects representing numbers."""

from __future__ import annotations

__all__ = ["DecimalNumber", "Integer", "Variable"]

from collections.abc import Sequence
from typing import Any

import numpy as np

from manim import config
from manim.constants import *
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.text.tex_mobject import MathTex, SingleStringMathTex, Tex
from manim.mobject.text.text_mobject import Text
from manim.mobject.types.vectorized_mobject import VMobject
from manim.mobject.value_tracker import ValueTracker

string_to_mob_map = {}

__all__ = ["DecimalNumber", "Integer", "Variable"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.2038">class DecimalNumber(VMobject, metaclass=ConvertToOpenGL):
    @others
</t>
<t tx="ekr.20250122151620.2039">class Integer(DecimalNumber):
    """A class for displaying Integers.

    Examples
    --------

    .. manim:: IntegerExample
        :save_last_frame:

        class IntegerExample(Scene):
            def construct(self):
                self.add(Integer(number=2.5).set_color(ORANGE).scale(2.5).set_x(-0.5).set_y(0.8))
                self.add(Integer(number=3.14159, show_ellipsis=True).set_x(3).set_y(3.3).scale(3.14159))
                self.add(Integer(number=42).set_x(2.5).set_y(-2.3).set_color_by_gradient(BLUE, TEAL).scale(1.7))
                self.add(Integer(number=6.28).set_x(-1.5).set_y(-2).set_color(YELLOW).scale(1.4))
    """

    @others
</t>
<t tx="ekr.20250122151620.204">"""Animate mobjects."""

from __future__ import annotations

from manim.mobject.opengl.opengl_mobject import OpenGLMobject

from .. import config, logger
from ..constants import RendererType
from ..mobject import mobject
from ..mobject.mobject import Group, Mobject
from ..mobject.opengl import opengl_mobject
from ..utils.rate_functions import linear, smooth

__all__ = ["Animation", "Wait", "Add", "override_animation"]


from collections.abc import Iterable, Sequence
from copy import deepcopy
from functools import partialmethod
from typing import TYPE_CHECKING, Any, Callable

from typing_extensions import Self

if TYPE_CHECKING:
    from manim.scene.scene import Scene


DEFAULT_ANIMATION_RUN_TIME: float = 1.0
DEFAULT_ANIMATION_LAG_RATIO: float = 0.0


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.2040">class Variable(VMobject, metaclass=ConvertToOpenGL):
    """A class for displaying text that shows "label = value" with
    the value continuously updated from a :class:`~.ValueTracker`.

    Parameters
    ----------
    var
        The initial value you need to keep track of and display.
    label
        The label for your variable. Raw strings are convertex to :class:`~.MathTex` objects.
    var_type
        The class used for displaying the number. Defaults to :class:`DecimalNumber`.
    num_decimal_places
        The number of decimal places to display in your variable. Defaults to 2.
        If `var_type` is an :class:`Integer`, this parameter is ignored.
    kwargs
            Other arguments to be passed to `~.Mobject`.

    Attributes
    ----------
    label : Union[:class:`str`, :class:`~.Tex`, :class:`~.MathTex`, :class:`~.Text`, :class:`~.SingleStringMathTex`]
        The label for your variable, for example ``x = ...``.
    tracker : :class:`~.ValueTracker`
        Useful in updating the value of your variable on-screen.
    value : Union[:class:`DecimalNumber`, :class:`Integer`]
        The tex for the value of your variable.

    Examples
    --------
    Normal usage::

        # DecimalNumber type
        var = 0.5
        on_screen_var = Variable(var, Text("var"), num_decimal_places=3)
        # Integer type
        int_var = 0
        on_screen_int_var = Variable(int_var, Text("int_var"), var_type=Integer)
        # Using math mode for the label
        on_screen_int_var = Variable(int_var, "{a}_{i}", var_type=Integer)

    .. manim:: VariablesWithValueTracker

        class VariablesWithValueTracker(Scene):
            def construct(self):
                var = 0.5
                on_screen_var = Variable(var, Text("var"), num_decimal_places=3)

                # You can also change the colours for the label and value
                on_screen_var.label.set_color(RED)
                on_screen_var.value.set_color(GREEN)

                self.play(Write(on_screen_var))
                # The above line will just display the variable with
                # its initial value on the screen. If you also wish to
                # update it, you can do so by accessing the `tracker` attribute
                self.wait()
                var_tracker = on_screen_var.tracker
                var = 10.5
                self.play(var_tracker.animate.set_value(var))
                self.wait()

                int_var = 0
                on_screen_int_var = Variable(
                    int_var, Text("int_var"), var_type=Integer
                ).next_to(on_screen_var, DOWN)
                on_screen_int_var.label.set_color(RED)
                on_screen_int_var.value.set_color(GREEN)

                self.play(Write(on_screen_int_var))
                self.wait()
                var_tracker = on_screen_int_var.tracker
                var = 10.5
                self.play(var_tracker.animate.set_value(var))
                self.wait()

                # If you wish to have a somewhat more complicated label for your
                # variable with subscripts, superscripts, etc. the default class
                # for the label is MathTex
                subscript_label_var = 10
                on_screen_subscript_var = Variable(subscript_label_var, "{a}_{i}").next_to(
                    on_screen_int_var, DOWN
                )
                self.play(Write(on_screen_subscript_var))
                self.wait()

    .. manim:: VariableExample

        class VariableExample(Scene):
            def construct(self):
                start = 2.0

                x_var = Variable(start, 'x', num_decimal_places=3)
                sqr_var = Variable(start**2, 'x^2', num_decimal_places=3)
                Group(x_var, sqr_var).arrange(DOWN)

                sqr_var.add_updater(lambda v: v.tracker.set_value(x_var.tracker.get_value()**2))

                self.add(x_var, sqr_var)
                self.play(x_var.tracker.animate.set_value(5), run_time=2, rate_func=linear)
                self.wait(0.1)

    """

    @others
</t>
<t tx="ekr.20250122151620.2041">r"""An mobject representing a decimal number.

Parameters
----------
number
    The numeric value to be displayed. It can later be modified using :meth:`.set_value`.
num_decimal_places
    The number of decimal places after the decimal separator. Values are automatically rounded.
mob_class
    The class for rendering digits and units, by default :class:`.MathTex`.
include_sign
    Set to ``True`` to include a sign for positive numbers and zero.
group_with_commas
    When ``True`` thousands groups are separated by commas for readability.
digit_buff_per_font_unit
    Additional spacing between digits. Scales with font size.
show_ellipsis
    When a number has been truncated by rounding, indicate with an ellipsis (``...``).
unit
    A unit string which can be placed to the right of the numerical values.
unit_buff_per_font_unit
    An additional spacing between the numerical values and the unit. A value
    of ``unit_buff_per_font_unit=0.003`` gives a decent spacing. Scales with font size.
include_background_rectangle
    Adds a background rectangle to increase contrast on busy scenes.
edge_to_fix
    Assuring right- or left-alignment of the full object.
font_size
    Size of the font.

Examples
--------

.. manim:: MovingSquareWithUpdaters

    class MovingSquareWithUpdaters(Scene):
        def construct(self):
            decimal = DecimalNumber(
                0,
                show_ellipsis=True,
                num_decimal_places=3,
                include_sign=True,
                unit=r"\text{M-Units}",
                unit_buff_per_font_unit=0.003
            )
            square = Square().to_edge(UP)

            decimal.add_updater(lambda d: d.next_to(square, RIGHT))
            decimal.add_updater(lambda d: d.set_value(square.get_center()[1]))
            self.add(square, decimal)
            self.play(
                square.animate.to_edge(DOWN),
                rate_func=there_and_back,
                run_time=5,
            )
            self.wait()

"""

def __init__(
    self,
    number: float = 0,
    num_decimal_places: int = 2,
    mob_class: VMobject = MathTex,
    include_sign: bool = False,
    group_with_commas: bool = True,
    digit_buff_per_font_unit: float = 0.001,
    show_ellipsis: bool = False,
    unit: str | None = None,  # Aligned to bottom unless it starts with "^"
    unit_buff_per_font_unit: float = 0,
    include_background_rectangle: bool = False,
    edge_to_fix: Sequence[float] = LEFT,
    font_size: float = DEFAULT_FONT_SIZE,
    stroke_width: float = 0,
    fill_opacity: float = 1.0,
    **kwargs,
):
    super().__init__(**kwargs, stroke_width=stroke_width)
    self.number = number
    self.num_decimal_places = num_decimal_places
    self.include_sign = include_sign
    self.mob_class = mob_class
    self.group_with_commas = group_with_commas
    self.digit_buff_per_font_unit = digit_buff_per_font_unit
    self.show_ellipsis = show_ellipsis
    self.unit = unit
    self.unit_buff_per_font_unit = unit_buff_per_font_unit
    self.include_background_rectangle = include_background_rectangle
    self.edge_to_fix = edge_to_fix
    self._font_size = font_size
    self.fill_opacity = fill_opacity

    self.initial_config = kwargs.copy()
    self.initial_config.update(
        {
            "num_decimal_places": num_decimal_places,
            "include_sign": include_sign,
            "group_with_commas": group_with_commas,
            "digit_buff_per_font_unit": digit_buff_per_font_unit,
            "show_ellipsis": show_ellipsis,
            "unit": unit,
            "unit_buff_per_font_unit": unit_buff_per_font_unit,
            "include_background_rectangle": include_background_rectangle,
            "edge_to_fix": edge_to_fix,
            "font_size": font_size,
            "stroke_width": stroke_width,
            "fill_opacity": fill_opacity,
        },
    )

    self._set_submobjects_from_number(number)
    self.init_colors()

</t>
<t tx="ekr.20250122151620.2042">@property
def font_size(self):
    """The font size of the tex mobject."""
    return self.height / self.initial_height * self._font_size

</t>
<t tx="ekr.20250122151620.2043">@font_size.setter
def font_size(self, font_val):
    if font_val &lt;= 0:
        raise ValueError("font_size must be greater than 0.")
    elif self.height &gt; 0:
        # sometimes manim generates a SingleStringMathex mobject with 0 height.
        # can't be scaled regardless and will error without the elif.

        # scale to a factor of the initial height so that setting
        # font_size does not depend on current size.
        self.scale(font_val / self.font_size)

</t>
<t tx="ekr.20250122151620.2044">def _set_submobjects_from_number(self, number):
    self.number = number
    self.submobjects = []

    num_string = self._get_num_string(number)
    self.add(*(map(self._string_to_mob, num_string)))

    # Add non-numerical bits
    if self.show_ellipsis:
        self.add(
            self._string_to_mob("\\dots", SingleStringMathTex, color=self.color),
        )

    self.arrange(
        buff=self.digit_buff_per_font_unit * self._font_size,
        aligned_edge=DOWN,
    )

    if self.unit is not None:
        self.unit_sign = self._string_to_mob(self.unit, SingleStringMathTex)
        self.add(
            self.unit_sign.next_to(
                self,
                direction=RIGHT,
                buff=(self.unit_buff_per_font_unit + self.digit_buff_per_font_unit)
                * self._font_size,
                aligned_edge=DOWN,
            )
        )

    self.move_to(ORIGIN)

    # Handle alignment of parts that should be aligned
    # to the bottom
    for i, c in enumerate(num_string):
        if c == "-" and len(num_string) &gt; i + 1:
            self[i].align_to(self[i + 1], UP)
            self[i].shift(self[i + 1].height * DOWN / 2)
        elif c == ",":
            self[i].shift(self[i].height * DOWN / 2)
    if self.unit and self.unit.startswith("^"):
        self.unit_sign.align_to(self, UP)

    # track the initial height to enable scaling via font_size
    self.initial_height = self.height

    if self.include_background_rectangle:
        self.add_background_rectangle()

</t>
<t tx="ekr.20250122151620.2045">def _get_num_string(self, number):
    if isinstance(number, complex):
        formatter = self._get_complex_formatter()
    else:
        formatter = self._get_formatter()
    num_string = formatter.format(number)

    rounded_num = np.round(number, self.num_decimal_places)
    if num_string.startswith("-") and rounded_num == 0:
        num_string = "+" + num_string[1:] if self.include_sign else num_string[1:]

    return num_string

</t>
<t tx="ekr.20250122151620.2046">def _string_to_mob(self, string: str, mob_class: VMobject | None = None, **kwargs):
    if mob_class is None:
        mob_class = self.mob_class

    if string not in string_to_mob_map:
        string_to_mob_map[string] = mob_class(string, **kwargs)
    mob = string_to_mob_map[string].copy()
    mob.font_size = self._font_size
    return mob

</t>
<t tx="ekr.20250122151620.2047">def _get_formatter(self, **kwargs):
    """
    Configuration is based first off instance attributes,
    but overwritten by any kew word argument.  Relevant
    key words:
    - include_sign
    - group_with_commas
    - num_decimal_places
    - field_name (e.g. 0 or 0.real)
    """
    config = {
        attr: getattr(self, attr)
        for attr in [
            "include_sign",
            "group_with_commas",
            "num_decimal_places",
        ]
    }
    config.update(kwargs)
    return "".join(
        [
            "{",
            config.get("field_name", ""),
            ":",
            "+" if config["include_sign"] else "",
            "," if config["group_with_commas"] else "",
            ".",
            str(config["num_decimal_places"]),
            "f",
            "}",
        ],
    )

</t>
<t tx="ekr.20250122151620.2048">def _get_complex_formatter(self):
    return "".join(
        [
            self._get_formatter(field_name="0.real"),
            self._get_formatter(field_name="0.imag", include_sign=True),
            "i",
        ],
    )

</t>
<t tx="ekr.20250122151620.2049">def set_value(self, number: float):
    """Set the value of the :class:`~.DecimalNumber` to a new number.

    Parameters
    ----------
    number
        The value that will overwrite the current number of the :class:`~.DecimalNumber`.

    """
    # creates a new number mob via `set_submobjects_from_number`
    # then matches the properties (color, font_size, etc...)
    # of the previous mobject to the new one

    # old_family needed with cairo
    old_family = self.get_family()

    old_font_size = self.font_size
    move_to_point = self.get_edge_center(self.edge_to_fix)
    old_submobjects = self.submobjects

    self._set_submobjects_from_number(number)
    self.font_size = old_font_size
    self.move_to(move_to_point, self.edge_to_fix)
    for sm1, sm2 in zip(self.submobjects, old_submobjects):
        sm1.match_style(sm2)

    if config.renderer == RendererType.CAIRO:
        for mob in old_family:
            # Dumb hack...due to how scene handles families
            # of animated mobjects
            # for compatibility with updaters to not leave first number in place while updating,
            # not needed with opengl renderer
            mob.points[:] = 0

    self.init_colors()
    return self

</t>
<t tx="ekr.20250122151620.205">class Animation:
    """An animation.

    Animations have a fixed time span.

    Parameters
    ----------
    mobject
        The mobject to be animated. This is not required for all types of animations.
    lag_ratio
        Defines the delay after which the animation is applied to submobjects. This lag
        is relative to the duration of the animation.

        This does not influence the total
        runtime of the animation. Instead the runtime of individual animations is
        adjusted so that the complete animation has the defined run time.

    run_time
        The duration of the animation in seconds.
    rate_func
        The function defining the animation progress based on the relative runtime (see  :mod:`~.rate_functions`) .

        For example ``rate_func(0.5)`` is the proportion of the animation that is done
        after half of the animations run time.


    reverse_rate_function
        Reverses the rate function of the animation. Setting ``reverse_rate_function``
        does not have any effect on ``remover`` or ``introducer``. These need to be
        set explicitly if an introducer-animation should be turned into a remover one
        and vice versa.
    name
        The name of the animation. This gets displayed while rendering the animation.
        Defaults to &lt;class-name&gt;(&lt;Mobject-name&gt;).
    remover
        Whether the given mobject should be removed from the scene after this animation.
    suspend_mobject_updating
        Whether updaters of the mobject should be suspended during the animation.


    .. NOTE::

        In the current implementation of this class, the specified rate function is applied
        within :meth:`.Animation.interpolate_mobject` call as part of the call to
        :meth:`.Animation.interpolate_submobject`. For subclasses of :class:`.Animation`
        that are implemented by overriding :meth:`interpolate_mobject`, the rate function
        has to be applied manually (e.g., by passing ``self.rate_func(alpha)`` instead
        of just ``alpha``).


    Examples
    --------

    .. manim:: LagRatios

        class LagRatios(Scene):
            def construct(self):
                ratios = [0, 0.1, 0.5, 1, 2]  # demonstrated lag_ratios

                # Create dot groups
                group = VGroup(*[Dot() for _ in range(4)]).arrange_submobjects()
                groups = VGroup(*[group.copy() for _ in ratios]).arrange_submobjects(buff=1)
                self.add(groups)

                # Label groups
                self.add(Text("lag_ratio = ", font_size=36).next_to(groups, UP, buff=1.5))
                for group, ratio in zip(groups, ratios):
                    self.add(Text(str(ratio), font_size=36).next_to(group, UP))

                #Animate groups with different lag_ratios
                self.play(AnimationGroup(*[
                    group.animate(lag_ratio=ratio, run_time=1.5).shift(DOWN * 2)
                    for group, ratio in zip(groups, ratios)
                ]))

                # lag_ratio also works recursively on nested submobjects:
                self.play(groups.animate(run_time=1, lag_ratio=0.1).shift(UP * 2))

    """

    @others
</t>
<t tx="ekr.20250122151620.2050">def get_value(self):
    return self.number

</t>
<t tx="ekr.20250122151620.2051">def increment_value(self, delta_t=1):
    self.set_value(self.get_value() + delta_t)


</t>
<t tx="ekr.20250122151620.2052">def __init__(
    self, number: float = 0, num_decimal_places: int = 0, **kwargs: Any
) -&gt; None:
    super().__init__(number=number, num_decimal_places=num_decimal_places, **kwargs)

</t>
<t tx="ekr.20250122151620.2053">def get_value(self):
    return int(np.round(super().get_value()))


</t>
<t tx="ekr.20250122151620.2054">def __init__(
    self,
    var: float,
    label: str | Tex | MathTex | Text | SingleStringMathTex,
    var_type: DecimalNumber | Integer = DecimalNumber,
    num_decimal_places: int = 2,
    **kwargs,
):
    self.label = MathTex(label) if isinstance(label, str) else label
    equals = MathTex("=").next_to(self.label, RIGHT)
    self.label.add(equals)

    self.tracker = ValueTracker(var)

    if var_type == DecimalNumber:
        self.value = DecimalNumber(
            self.tracker.get_value(),
            num_decimal_places=num_decimal_places,
        )
    elif var_type == Integer:
        self.value = Integer(self.tracker.get_value())

    self.value.add_updater(lambda v: v.set_value(self.tracker.get_value())).next_to(
        self.label,
        RIGHT,
    )

    super().__init__(**kwargs)
    self.add(self.label, self.value)
</t>
<t tx="ekr.20250122151620.2055">r"""Mobjects representing text rendered using LaTeX.

.. important::

   See the corresponding tutorial :ref:`rendering-with-latex`

.. note::

   Just as you can use :class:`~.Text` (from the module :mod:`~.text_mobject`) to add text to your videos, you can use :class:`~.Tex` and :class:`~.MathTex` to insert LaTeX.

"""

from __future__ import annotations

from manim.utils.color import BLACK, ManimColor, ParsableManimColor

__all__ = [
    "SingleStringMathTex",
    "MathTex",
    "Tex",
    "BulletedList",
    "Title",
]


import itertools as it
import operator as op
import re
from collections.abc import Iterable
from functools import reduce
from textwrap import dedent

from manim import config, logger
from manim.constants import *
from manim.mobject.geometry.line import Line
from manim.mobject.svg.svg_mobject import SVGMobject
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from manim.utils.tex import TexTemplate
from manim.utils.tex_file_writing import tex_to_svg_file

tex_string_to_mob_map = {}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.2056">class SingleStringMathTex(SVGMobject):
    """Elementary building block for rendering text with LaTeX.

    Tests
    -----
    Check that creating a :class:`~.SingleStringMathTex` object works::

        &gt;&gt;&gt; SingleStringMathTex('Test') # doctest: +SKIP
        SingleStringMathTex('Test')
    """

    @others
</t>
<t tx="ekr.20250122151620.2057">class MathTex(SingleStringMathTex):
    @others
</t>
<t tx="ekr.20250122151620.2058">class Tex(MathTex):
    @others
</t>
<t tx="ekr.20250122151620.2059">class BulletedList(Tex):
    """A bulleted list.

    Examples
    --------

    .. manim:: BulletedListExample
        :save_last_frame:

        class BulletedListExample(Scene):
            def construct(self):
                blist = BulletedList("Item 1", "Item 2", "Item 3", height=2, width=2)
                blist.set_color_by_tex("Item 1", RED)
                blist.set_color_by_tex("Item 2", GREEN)
                blist.set_color_by_tex("Item 3", BLUE)
                self.add(blist)
    """

    @others
</t>
<t tx="ekr.20250122151620.206">def prepare_animation(
    anim: Animation | mobject._AnimationBuilder,
) -&gt; Animation:
    r"""Returns either an unchanged animation, or the animation built
    from a passed animation factory.

    Examples
    --------

    ::

        &gt;&gt;&gt; from manim import Square, FadeIn
        &gt;&gt;&gt; s = Square()
        &gt;&gt;&gt; prepare_animation(FadeIn(s))
        FadeIn(Square)

    ::

        &gt;&gt;&gt; prepare_animation(s.animate.scale(2).rotate(42))
        _MethodAnimation(Square)

    ::

        &gt;&gt;&gt; prepare_animation(42)
        Traceback (most recent call last):
        ...
        TypeError: Object 42 cannot be converted to an animation

    """
    if isinstance(anim, mobject._AnimationBuilder):
        return anim.build()

    if isinstance(anim, opengl_mobject._AnimationBuilder):
        return anim.build()

    if isinstance(anim, Animation):
        return anim

    raise TypeError(f"Object {anim} cannot be converted to an animation")


</t>
<t tx="ekr.20250122151620.2060">class Title(Tex):
    """A mobject representing an underlined title.

    Examples
    --------
    .. manim:: TitleExample
        :save_last_frame:

        import manim

        class TitleExample(Scene):
            def construct(self):
                banner = ManimBanner()
                title = Title(f"Manim version {manim.__version__}")
                self.add(banner, title)

    """

    @others
</t>
<t tx="ekr.20250122151620.2061">def __init__(
    self,
    tex_string: str,
    stroke_width: float = 0,
    should_center: bool = True,
    height: float | None = None,
    organize_left_to_right: bool = False,
    tex_environment: str = "align*",
    tex_template: TexTemplate | None = None,
    font_size: float = DEFAULT_FONT_SIZE,
    color: ParsableManimColor | None = None,
    **kwargs,
):
    if color is None:
        color = VMobject().color

    self._font_size = font_size
    self.organize_left_to_right = organize_left_to_right
    self.tex_environment = tex_environment
    if tex_template is None:
        tex_template = config["tex_template"]
    self.tex_template = tex_template

    assert isinstance(tex_string, str)
    self.tex_string = tex_string
    file_name = tex_to_svg_file(
        self._get_modified_expression(tex_string),
        environment=self.tex_environment,
        tex_template=self.tex_template,
    )
    super().__init__(
        file_name=file_name,
        should_center=should_center,
        stroke_width=stroke_width,
        height=height,
        color=color,
        path_string_config={
            "should_subdivide_sharp_curves": True,
            "should_remove_null_curves": True,
        },
        **kwargs,
    )
    self.init_colors()

    # used for scaling via font_size.setter
    self.initial_height = self.height

    if height is None:
        self.font_size = self._font_size

    if self.organize_left_to_right:
        self._organize_submobjects_left_to_right()

</t>
<t tx="ekr.20250122151620.2062">def __repr__(self):
    return f"{type(self).__name__}({repr(self.tex_string)})"

</t>
<t tx="ekr.20250122151620.2063">@property
def font_size(self):
    """The font size of the tex mobject."""
    return self.height / self.initial_height / SCALE_FACTOR_PER_FONT_POINT

</t>
<t tx="ekr.20250122151620.2064">@font_size.setter
def font_size(self, font_val):
    if font_val &lt;= 0:
        raise ValueError("font_size must be greater than 0.")
    elif self.height &gt; 0:
        # sometimes manim generates a SingleStringMathex mobject with 0 height.
        # can't be scaled regardless and will error without the elif.

        # scale to a factor of the initial height so that setting
        # font_size does not depend on current size.
        self.scale(font_val / self.font_size)

</t>
<t tx="ekr.20250122151620.2065">def _get_modified_expression(self, tex_string):
    result = tex_string
    result = result.strip()
    result = self._modify_special_strings(result)
    return result

</t>
<t tx="ekr.20250122151620.2066">def _modify_special_strings(self, tex):
    tex = tex.strip()
    should_add_filler = reduce(
        op.or_,
        [
            # Fraction line needs something to be over
            tex == "\\over",
            tex == "\\overline",
            # Make sure sqrt has overbar
            tex == "\\sqrt",
            tex == "\\sqrt{",
            # Need to add blank subscript or superscript
            tex.endswith("_"),
            tex.endswith("^"),
            tex.endswith("dot"),
        ],
    )

    if should_add_filler:
        filler = "{\\quad}"
        tex += filler

    if tex == "\\substack":
        tex = "\\quad"

    if tex == "":
        tex = "\\quad"

    # To keep files from starting with a line break
    if tex.startswith("\\\\"):
        tex = tex.replace("\\\\", "\\quad\\\\")

    # Handle imbalanced \left and \right
    num_lefts, num_rights = (
        len([s for s in tex.split(substr)[1:] if s and s[0] in "(){}[]|.\\"])
        for substr in ("\\left", "\\right")
    )
    if num_lefts != num_rights:
        tex = tex.replace("\\left", "\\big")
        tex = tex.replace("\\right", "\\big")

    tex = self._remove_stray_braces(tex)

    for context in ["array"]:
        begin_in = ("\\begin{%s}" % context) in tex  # noqa: UP031
        end_in = ("\\end{%s}" % context) in tex  # noqa: UP031
        if begin_in ^ end_in:
            # Just turn this into a blank string,
            # which means caller should leave a
            # stray \\begin{...} with other symbols
            tex = ""
    return tex

</t>
<t tx="ekr.20250122151620.2067">def _remove_stray_braces(self, tex):
    r"""
    Makes :class:`~.MathTex` resilient to unmatched braces.

    This is important when the braces in the TeX code are spread over
    multiple arguments as in, e.g., ``MathTex(r"e^{i", r"\tau} = 1")``.
    """
    # "\{" does not count (it's a brace literal), but "\\{" counts (it's a new line and then brace)
    num_lefts = tex.count("{") - tex.count("\\{") + tex.count("\\\\{")
    num_rights = tex.count("}") - tex.count("\\}") + tex.count("\\\\}")
    while num_rights &gt; num_lefts:
        tex = "{" + tex
        num_lefts += 1
    while num_lefts &gt; num_rights:
        tex = tex + "}"
        num_rights += 1
    return tex

</t>
<t tx="ekr.20250122151620.2068">def _organize_submobjects_left_to_right(self):
    self.sort(lambda p: p[0])
    return self

</t>
<t tx="ekr.20250122151620.2069">def get_tex_string(self):
    return self.tex_string

</t>
<t tx="ekr.20250122151620.207">class Wait(Animation):
    """A "no operation" animation.

    Parameters
    ----------
    run_time
        The amount of time that should pass.
    stop_condition
        A function without positional arguments that evaluates to a boolean.
        The function is evaluated after every new frame has been rendered.
        Playing the animation stops after the return value is truthy, or
        after the specified ``run_time`` has passed.
    frozen_frame
        Controls whether or not the wait animation is static, i.e., corresponds
        to a frozen frame. If ``False`` is passed, the render loop still
        progresses through the animation as usual and (among other things)
        continues to call updater functions. If ``None`` (the default value),
        the :meth:`.Scene.play` call tries to determine whether the Wait call
        can be static or not itself via :meth:`.Scene.should_mobjects_update`.
    kwargs
        Keyword arguments to be passed to the parent class, :class:`.Animation`.
    """

    @others
</t>
<t tx="ekr.20250122151620.2070">def init_colors(self, propagate_colors=True):
    for submobject in self.submobjects:
        # needed to preserve original (non-black)
        # TeX colors of individual submobjects
        if submobject.color != BLACK:
            continue
        submobject.color = self.color
        if config.renderer == RendererType.OPENGL:
            submobject.init_colors()
        elif config.renderer == RendererType.CAIRO:
            submobject.init_colors(propagate_colors=propagate_colors)


</t>
<t tx="ekr.20250122151620.2071">r"""A string compiled with LaTeX in math mode.

Examples
--------
.. manim:: Formula
    :save_last_frame:

    class Formula(Scene):
        def construct(self):
            t = MathTex(r"\int_a^b f'(x) dx = f(b)- f(a)")
            self.add(t)

Tests
-----
Check that creating a :class:`~.MathTex` works::

    &gt;&gt;&gt; MathTex('a^2 + b^2 = c^2') # doctest: +SKIP
    MathTex('a^2 + b^2 = c^2')

Check that double brace group splitting works correctly::

    &gt;&gt;&gt; t1 = MathTex('{{ a }} + {{ b }} = {{ c }}') # doctest: +SKIP
    &gt;&gt;&gt; len(t1.submobjects) # doctest: +SKIP
    5
    &gt;&gt;&gt; t2 = MathTex(r"\frac{1}{a+b\sqrt{2}}") # doctest: +SKIP
    &gt;&gt;&gt; len(t2.submobjects) # doctest: +SKIP
    1

"""

def __init__(
    self,
    *tex_strings,
    arg_separator: str = " ",
    substrings_to_isolate: Iterable[str] | None = None,
    tex_to_color_map: dict[str, ManimColor] = None,
    tex_environment: str = "align*",
    **kwargs,
):
    self.tex_template = kwargs.pop("tex_template", config["tex_template"])
    self.arg_separator = arg_separator
    self.substrings_to_isolate = (
        [] if substrings_to_isolate is None else substrings_to_isolate
    )
    self.tex_to_color_map = tex_to_color_map
    if self.tex_to_color_map is None:
        self.tex_to_color_map = {}
    self.tex_environment = tex_environment
    self.brace_notation_split_occurred = False
    self.tex_strings = self._break_up_tex_strings(tex_strings)
    try:
        super().__init__(
            self.arg_separator.join(self.tex_strings),
            tex_environment=self.tex_environment,
            tex_template=self.tex_template,
            **kwargs,
        )
        self._break_up_by_substrings()
    except ValueError as compilation_error:
        if self.brace_notation_split_occurred:
            logger.error(
                dedent(
                    """\
                    A group of double braces, {{ ... }}, was detected in
                    your string. Manim splits TeX strings at the double
                    braces, which might have caused the current
                    compilation error. If you didn't use the double brace
                    split intentionally, add spaces between the braces to
                    avoid the automatic splitting: {{ ... }} --&gt; { { ... } }.
                    """,
                ),
            )
        raise compilation_error
    self.set_color_by_tex_to_color_map(self.tex_to_color_map)

    if self.organize_left_to_right:
        self._organize_submobjects_left_to_right()

</t>
<t tx="ekr.20250122151620.2072">def _break_up_tex_strings(self, tex_strings):
    # Separate out anything surrounded in double braces
    pre_split_length = len(tex_strings)
    tex_strings = [re.split("{{(.*?)}}", str(t)) for t in tex_strings]
    tex_strings = sum(tex_strings, [])
    if len(tex_strings) &gt; pre_split_length:
        self.brace_notation_split_occurred = True

    # Separate out any strings specified in the isolate
    # or tex_to_color_map lists.
    patterns = []
    patterns.extend(
        [
            f"({re.escape(ss)})"
            for ss in it.chain(
                self.substrings_to_isolate,
                self.tex_to_color_map.keys(),
            )
        ],
    )
    pattern = "|".join(patterns)
    if pattern:
        pieces = []
        for s in tex_strings:
            pieces.extend(re.split(pattern, s))
    else:
        pieces = tex_strings
    return [p for p in pieces if p]

</t>
<t tx="ekr.20250122151620.2073">def _break_up_by_substrings(self):
    """
    Reorganize existing submobjects one layer
    deeper based on the structure of tex_strings (as a list
    of tex_strings)
    """
    new_submobjects = []
    curr_index = 0
    for tex_string in self.tex_strings:
        sub_tex_mob = SingleStringMathTex(
            tex_string,
            tex_environment=self.tex_environment,
            tex_template=self.tex_template,
        )
        num_submobs = len(sub_tex_mob.submobjects)
        new_index = (
            curr_index + num_submobs + len("".join(self.arg_separator.split()))
        )
        if num_submobs == 0:
            last_submob_index = min(curr_index, len(self.submobjects) - 1)
            sub_tex_mob.move_to(self.submobjects[last_submob_index], RIGHT)
        else:
            sub_tex_mob.submobjects = self.submobjects[curr_index:new_index]
        new_submobjects.append(sub_tex_mob)
        curr_index = new_index
    self.submobjects = new_submobjects
    return self

</t>
<t tx="ekr.20250122151620.2074">def get_parts_by_tex(self, tex, substring=True, case_sensitive=True):
    def test(tex1, tex2):
        if not case_sensitive:
            tex1 = tex1.lower()
            tex2 = tex2.lower()
        if substring:
            return tex1 in tex2
        else:
            return tex1 == tex2

    return VGroup(*(m for m in self.submobjects if test(tex, m.get_tex_string())))

</t>
<t tx="ekr.20250122151620.2075">def get_part_by_tex(self, tex, **kwargs):
    all_parts = self.get_parts_by_tex(tex, **kwargs)
    return all_parts[0] if all_parts else None

</t>
<t tx="ekr.20250122151620.2076">def set_color_by_tex(self, tex, color, **kwargs):
    parts_to_color = self.get_parts_by_tex(tex, **kwargs)
    for part in parts_to_color:
        part.set_color(color)
    return self

</t>
<t tx="ekr.20250122151620.2077">def set_opacity_by_tex(
    self, tex: str, opacity: float = 0.5, remaining_opacity: float = None, **kwargs
):
    """
    Sets the opacity of the tex specified. If 'remaining_opacity' is specified,
    then the remaining tex will be set to that opacity.

    Parameters
    ----------
    tex
        The tex to set the opacity of.
    opacity
        Default 0.5. The opacity to set the tex to
    remaining_opacity
        Default None. The opacity to set the remaining tex to.
        If None, then the remaining tex will not be changed
    """
    if remaining_opacity is not None:
        self.set_opacity(opacity=remaining_opacity)
    for part in self.get_parts_by_tex(tex):
        part.set_opacity(opacity)
    return self

</t>
<t tx="ekr.20250122151620.2078">def set_color_by_tex_to_color_map(self, texs_to_color_map, **kwargs):
    for texs, color in list(texs_to_color_map.items()):
        try:
            # If the given key behaves like tex_strings
            texs + ""
            self.set_color_by_tex(texs, color, **kwargs)
        except TypeError:
            # If the given key is a tuple
            for tex in texs:
                self.set_color_by_tex(tex, color, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.2079">def index_of_part(self, part):
    split_self = self.split()
    if part not in split_self:
        raise ValueError("Trying to get index of part not in MathTex")
    return split_self.index(part)

</t>
<t tx="ekr.20250122151620.208">class Add(Animation):
    """Add Mobjects to a scene, without animating them in any other way. This
    is similar to the :meth:`.Scene.add` method, but :class:`Add` is an
    animation which can be grouped into other animations.

    Parameters
    ----------
    mobjects
        One :class:`~.Mobject` or more to add to a scene.
    run_time
        The duration of the animation after adding the ``mobjects``. Defaults
        to 0, which means this is an instant animation without extra wait time
        after adding them.
    **kwargs
        Additional arguments to pass to the parent :class:`Animation` class.

    Examples
    --------

    .. manim:: DefaultAddScene

        class DefaultAddScene(Scene):
            def construct(self):
                text_1 = Text("I was added with Add!")
                text_2 = Text("Me too!")
                text_3 = Text("And me!")
                texts = VGroup(text_1, text_2, text_3).arrange(DOWN)
                rect = SurroundingRectangle(texts, buff=0.5)

                self.play(
                    Create(rect, run_time=3.0),
                    Succession(
                        Wait(1.0),
                        # You can Add a Mobject in the middle of an animation...
                        Add(text_1),
                        Wait(1.0),
                        # ...or multiple Mobjects at once!
                        Add(text_2, text_3),
                    ),
                )
                self.wait()

    .. manim:: AddWithRunTimeScene

        class AddWithRunTimeScene(Scene):
            def construct(self):
                # A 5x5 grid of circles
                circles = VGroup(
                    *[Circle(radius=0.5) for _ in range(25)]
                ).arrange_in_grid(5, 5)

                self.play(
                    Succession(
                        # Add a run_time of 0.2 to wait for 0.2 seconds after
                        # adding the circle, instead of using Wait(0.2) after Add!
                        *[Add(circle, run_time=0.2) for circle in circles],
                        rate_func=smooth,
                    )
                )
                self.wait()
    """

    @others
</t>
<t tx="ekr.20250122151620.2080">def index_of_part_by_tex(self, tex, **kwargs):
    part = self.get_part_by_tex(tex, **kwargs)
    return self.index_of_part(part)

</t>
<t tx="ekr.20250122151620.2081">def sort_alphabetically(self):
    self.submobjects.sort(key=lambda m: m.get_tex_string())


</t>
<t tx="ekr.20250122151620.2082">r"""A string compiled with LaTeX in normal mode.

The color can be set using
the ``color`` argument. Any parts of the ``tex_string`` that are colored by the
TeX commands ``\color`` or ``\textcolor`` will retain their original color.

Tests
-----

Check whether writing a LaTeX string works::

    &gt;&gt;&gt; Tex('The horse does not eat cucumber salad.') # doctest: +SKIP
    Tex('The horse does not eat cucumber salad.')

"""

def __init__(
    self, *tex_strings, arg_separator="", tex_environment="center", **kwargs
):
    super().__init__(
        *tex_strings,
        arg_separator=arg_separator,
        tex_environment=tex_environment,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.2083">def __init__(
    self,
    *items,
    buff=MED_LARGE_BUFF,
    dot_scale_factor=2,
    tex_environment=None,
    **kwargs,
):
    self.buff = buff
    self.dot_scale_factor = dot_scale_factor
    self.tex_environment = tex_environment
    line_separated_items = [s + "\\\\" for s in items]
    super().__init__(
        *line_separated_items, tex_environment=tex_environment, **kwargs
    )
    for part in self:
        dot = MathTex("\\cdot").scale(self.dot_scale_factor)
        dot.next_to(part[0], LEFT, SMALL_BUFF)
        part.add_to_back(dot)
    self.arrange(DOWN, aligned_edge=LEFT, buff=self.buff)

</t>
<t tx="ekr.20250122151620.2084">def fade_all_but(self, index_or_string, opacity=0.5):
    arg = index_or_string
    if isinstance(arg, str):
        part = self.get_part_by_tex(arg)
    elif isinstance(arg, int):
        part = self.submobjects[arg]
    else:
        raise TypeError(f"Expected int or string, got {arg}")
    for other_part in self.submobjects:
        if other_part is part:
            other_part.set_fill(opacity=1)
        else:
            other_part.set_fill(opacity=opacity)


</t>
<t tx="ekr.20250122151620.2085">def __init__(
    self,
    *text_parts,
    include_underline=True,
    match_underline_width_to_text=False,
    underline_buff=MED_SMALL_BUFF,
    **kwargs,
):
    self.include_underline = include_underline
    self.match_underline_width_to_text = match_underline_width_to_text
    self.underline_buff = underline_buff
    super().__init__(*text_parts, **kwargs)
    self.to_edge(UP)
    if self.include_underline:
        underline_width = config["frame_width"] - 2
        underline = Line(LEFT, RIGHT)
        underline.next_to(self, DOWN, buff=self.underline_buff)
        if self.match_underline_width_to_text:
            underline.match_width(self)
        else:
            underline.width = underline_width
        self.add(underline)
        self.underline = underline
</t>
<t tx="ekr.20250122151620.2086">"""Mobjects used for displaying (non-LaTeX) text.

.. note::
   Just as you can use :class:`~.Tex` and :class:`~.MathTex` (from the module :mod:`~.tex_mobject`)
   to insert LaTeX to your videos, you can use :class:`~.Text` to to add normal text.

.. important::

   See the corresponding tutorial :ref:`using-text-objects`, especially for information about fonts.


The simplest way to add text to your animations is to use the :class:`~.Text` class. It uses the Pango library to render text.
With Pango, you are also able to render non-English alphabets like `你好` or  `こんにちは` or `안녕하세요` or `مرحبا بالعالم`.

Examples
--------

.. manim:: HelloWorld
    :save_last_frame:

    class HelloWorld(Scene):
        def construct(self):
            text = Text('Hello world').scale(3)
            self.add(text)

.. manim:: TextAlignment
    :save_last_frame:

    class TextAlignment(Scene):
        def construct(self):
            title = Text("K-means clustering and Logistic Regression", color=WHITE)
            title.scale(0.75)
            self.add(title.to_edge(UP))

            t1 = Text("1. Measuring").set_color(WHITE)

            t2 = Text("2. Clustering").set_color(WHITE)

            t3 = Text("3. Regression").set_color(WHITE)

            t4 = Text("4. Prediction").set_color(WHITE)

            x = VGroup(t1, t2, t3, t4).arrange(direction=DOWN, aligned_edge=LEFT).scale(0.7).next_to(ORIGIN,DR)
            x.set_opacity(0.5)
            x.submobjects[1].set_opacity(1)
            self.add(x)

"""

from __future__ import annotations

import functools

__all__ = ["Text", "Paragraph", "MarkupText", "register_font"]


import copy
import hashlib
import re
from collections.abc import Iterable, Sequence
from contextlib import contextmanager
from itertools import chain
from pathlib import Path

import manimpango
import numpy as np
from manimpango import MarkupUtils, PangoUtils, TextSetting

from manim import config, logger
from manim.constants import *
from manim.mobject.geometry.arc import Dot
from manim.mobject.svg.svg_mobject import SVGMobject
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from manim.utils.color import ManimColor, ParsableManimColor, color_gradient
from manim.utils.deprecation import deprecated

TEXT_MOB_SCALE_FACTOR = 0.05
DEFAULT_LINE_SPACING_SCALE = 0.3
TEXT2SVG_ADJUSTMENT_FACTOR = 4.8

__all__ = ["Text", "Paragraph", "MarkupText", "register_font"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.2087">def remove_invisible_chars(mobject: SVGMobject) -&gt; SVGMobject:
    """Function to remove unwanted invisible characters from some mobjects.

    Parameters
    ----------
    mobject
        Any SVGMobject from which we want to remove unwanted invisible characters.

    Returns
    -------
    :class:`~.SVGMobject`
        The SVGMobject without unwanted invisible characters.
    """
    # TODO: Refactor needed
    iscode = False
    if mobject.__class__.__name__ == "Text":
        mobject = mobject[:]
    elif mobject.__class__.__name__ == "Code":
        iscode = True
        code = mobject
        mobject = mobject.code
    mobject_without_dots = VGroup()
    if mobject[0].__class__ == VGroup:
        for i in range(len(mobject)):
            mobject_without_dots.add(VGroup())
            mobject_without_dots[i].add(*(k for k in mobject[i] if k.__class__ != Dot))
    else:
        mobject_without_dots.add(*(k for k in mobject if k.__class__ != Dot))
    if iscode:
        code.code = mobject_without_dots
        return code
    return mobject_without_dots


</t>
<t tx="ekr.20250122151620.2088">class Paragraph(VGroup):
    @others
</t>
<t tx="ekr.20250122151620.2089">class Text(SVGMobject):
    @others
</t>
<t tx="ekr.20250122151620.209">def override_animation(
    animation_class: type[Animation],
) -&gt; Callable[[Callable], Callable]:
    """Decorator used to mark methods as overrides for specific :class:`~.Animation` types.

    Should only be used to decorate methods of classes derived from :class:`~.Mobject`.
    ``Animation`` overrides get inherited to subclasses of the ``Mobject`` who defined
    them. They don't override subclasses of the ``Animation`` they override.

    See Also
    --------
    :meth:`~.Mobject.add_animation_override`

    Parameters
    ----------
    animation_class
        The animation to be overridden.

    Returns
    -------
    Callable[[Callable], Callable]
        The actual decorator. This marks the method as overriding an animation.

    Examples
    --------

    .. manim:: OverrideAnimationExample

        class MySquare(Square):
            @override_animation(FadeIn)
            def _fade_in_override(self, **kwargs):
                return Create(self, **kwargs)

        class OverrideAnimationExample(Scene):
            def construct(self):
                self.play(FadeIn(MySquare()))

    """

    def decorator(func):
        func._override_animation = animation_class
        return func

    return decorator
</t>
<t tx="ekr.20250122151620.2090">class MarkupText(SVGMobject):
    @others
</t>
<t tx="ekr.20250122151620.2091">@contextmanager
def register_font(font_file: str | Path):
    """Temporarily add a font file to Pango's search path.

    This searches for the font_file at various places. The order it searches it described below.

    1. Absolute path.
    2. In ``assets/fonts`` folder.
    3. In ``font/`` folder.
    4. In the same directory.

    Parameters
    ----------
    font_file
        The font file to add.

    Examples
    --------
    Use ``with register_font(...)`` to add a font file to search
    path.

    .. code-block:: python

        with register_font("path/to/font_file.ttf"):
            a = Text("Hello", font="Custom Font Name")

    Raises
    ------
    FileNotFoundError:
        If the font doesn't exists.

    AttributeError:
        If this method is used on macOS.

    .. important ::

        This method is available for macOS for ``ManimPango&gt;=v0.2.3``. Using this
        method with previous releases will raise an :class:`AttributeError` on macOS.
    """
    input_folder = Path(config.input_file).parent.resolve()
    possible_paths = [
        Path(font_file),
        input_folder / "assets/fonts" / font_file,
        input_folder / "fonts" / font_file,
        input_folder / font_file,
    ]
    for path in possible_paths:
        path = path.resolve()
        if path.exists():
            file_path = path
            logger.debug("Found file at %s", file_path.absolute())
            break
    else:
        error = f"Can't find {font_file}.Tried these : {possible_paths}"
        raise FileNotFoundError(error)

    try:
        assert manimpango.register_font(str(file_path))
        yield
    finally:
        manimpango.unregister_font(str(file_path))
</t>
<t tx="ekr.20250122151620.2092">r"""Display a paragraph of text.

For a given :class:`.Paragraph` ``par``, the attribute ``par.chars`` is a
:class:`.VGroup` containing all the lines. In this context, every line is
constructed as a :class:`.VGroup` of characters contained in the line.


Parameters
----------
line_spacing
    Represents the spacing between lines. Defaults to -1, which means auto.
alignment
    Defines the alignment of paragraph. Defaults to None. Possible values are "left", "right" or "center".

Examples
--------
Normal usage::

    paragraph = Paragraph(
        "this is a awesome",
        "paragraph",
        "With \nNewlines",
        "\tWith Tabs",
        "  With Spaces",
        "With Alignments",
        "center",
        "left",
        "right",
    )

Remove unwanted invisible characters::

    self.play(Transform(remove_invisible_chars(paragraph.chars[0:2]),
                        remove_invisible_chars(paragraph.chars[3][0:3]))

"""

def __init__(
    self,
    *text: Sequence[str],
    line_spacing: float = -1,
    alignment: str | None = None,
    **kwargs,
) -&gt; None:
    self.line_spacing = line_spacing
    self.alignment = alignment
    self.consider_spaces_as_chars = kwargs.get("disable_ligatures", False)
    super().__init__()

    lines_str = "\n".join(list(text))
    self.lines_text = Text(lines_str, line_spacing=line_spacing, **kwargs)
    lines_str_list = lines_str.split("\n")
    self.chars = self._gen_chars(lines_str_list)

    self.lines = [list(self.chars), [self.alignment] * len(self.chars)]
    self.lines_initial_positions = [line.get_center() for line in self.lines[0]]
    self.add(*self.lines[0])
    self.move_to(np.array([0, 0, 0]))
    if self.alignment:
        self._set_all_lines_alignments(self.alignment)

</t>
<t tx="ekr.20250122151620.2093">def _gen_chars(self, lines_str_list: list) -&gt; VGroup:
    """Function to convert a list of plain strings to a VGroup of VGroups of chars.

    Parameters
    ----------
    lines_str_list
        List of plain text strings.

    Returns
    -------
    :class:`~.VGroup`
        The generated 2d-VGroup of chars.
    """
    char_index_counter = 0
    chars = self.get_group_class()()
    for line_no in range(len(lines_str_list)):
        line_str = lines_str_list[line_no]
        # Count all the characters in line_str
        # Spaces may or may not count as characters
        if self.consider_spaces_as_chars:
            char_count = len(line_str)
        else:
            char_count = 0
            for char in line_str:
                if not char.isspace():
                    char_count += 1

        chars.add(self.get_group_class()())
        chars[line_no].add(
            *self.lines_text.chars[
                char_index_counter : char_index_counter + char_count
            ]
        )
        char_index_counter += char_count
        if self.consider_spaces_as_chars:
            # If spaces count as characters, count the extra \n character
            # which separates Paragraph's lines to avoid issues
            char_index_counter += 1
    return chars

</t>
<t tx="ekr.20250122151620.2094">def _set_all_lines_alignments(self, alignment: str) -&gt; Paragraph:
    """Function to set all line's alignment to a specific value.

    Parameters
    ----------
    alignment
        Defines the alignment of paragraph. Possible values are "left", "right", "center".
    """
    for line_no in range(len(self.lines[0])):
        self._change_alignment_for_a_line(alignment, line_no)
    return self

</t>
<t tx="ekr.20250122151620.2095">def _set_line_alignment(self, alignment: str, line_no: int) -&gt; Paragraph:
    """Function to set one line's alignment to a specific value.

    Parameters
    ----------
    alignment
        Defines the alignment of paragraph. Possible values are "left", "right", "center".
    line_no
        Defines the line number for which we want to set given alignment.
    """
    self._change_alignment_for_a_line(alignment, line_no)
    return self

</t>
<t tx="ekr.20250122151620.2096">def _set_all_lines_to_initial_positions(self) -&gt; Paragraph:
    """Set all lines to their initial positions."""
    self.lines[1] = [None] * len(self.lines[0])
    for line_no in range(len(self.lines[0])):
        self[line_no].move_to(
            self.get_center() + self.lines_initial_positions[line_no],
        )
    return self

</t>
<t tx="ekr.20250122151620.2097">def _set_line_to_initial_position(self, line_no: int) -&gt; Paragraph:
    """Function to set one line to initial positions.

    Parameters
    ----------
    line_no
        Defines the line number for which we want to set given alignment.
    """
    self.lines[1][line_no] = None
    self[line_no].move_to(self.get_center() + self.lines_initial_positions[line_no])
    return self

</t>
<t tx="ekr.20250122151620.2098">def _change_alignment_for_a_line(self, alignment: str, line_no: int) -&gt; None:
    """Function to change one line's alignment to a specific value.

    Parameters
    ----------
    alignment
        Defines the alignment of paragraph. Possible values are "left", "right", "center".
    line_no
        Defines the line number for which we want to set given alignment.
    """
    self.lines[1][line_no] = alignment
    if self.lines[1][line_no] == "center":
        self[line_no].move_to(
            np.array([self.get_center()[0], self[line_no].get_center()[1], 0]),
        )
    elif self.lines[1][line_no] == "right":
        self[line_no].move_to(
            np.array(
                [
                    self.get_right()[0] - self[line_no].width / 2,
                    self[line_no].get_center()[1],
                    0,
                ],
            ),
        )
    elif self.lines[1][line_no] == "left":
        self[line_no].move_to(
            np.array(
                [
                    self.get_left()[0] + self[line_no].width / 2,
                    self[line_no].get_center()[1],
                    0,
                ],
            ),
        )


</t>
<t tx="ekr.20250122151620.2099">r"""Display (non-LaTeX) text rendered using `Pango &lt;https://pango.gnome.org/&gt;`_.

Text objects behave like a :class:`.VGroup`-like iterable of all characters
in the given text. In particular, slicing is possible.

Parameters
----------
text
    The text that needs to be created as a mobject.
font
    The font family to be used to render the text. This is either a system font or
    one loaded with `register_font()`. Note that font family names may be different
    across operating systems.
warn_missing_font
    If True (default), Manim will issue a warning if the font does not exist in the
    (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.

Returns
-------
:class:`Text`
    The mobject-like :class:`.VGroup`.

Examples
---------

.. manim:: Example1Text
    :save_last_frame:

    class Example1Text(Scene):
        def construct(self):
            text = Text('Hello world').scale(3)
            self.add(text)

.. manim:: TextColorExample
    :save_last_frame:

    class TextColorExample(Scene):
        def construct(self):
            text1 = Text('Hello world', color=BLUE).scale(3)
            text2 = Text('Hello world', gradient=(BLUE, GREEN)).scale(3).next_to(text1, DOWN)
            self.add(text1, text2)

.. manim:: TextItalicAndBoldExample
    :save_last_frame:

    class TextItalicAndBoldExample(Scene):
        def construct(self):
            text1 = Text("Hello world", slant=ITALIC)
            text2 = Text("Hello world", t2s={'world':ITALIC})
            text3 = Text("Hello world", weight=BOLD)
            text4 = Text("Hello world", t2w={'world':BOLD})
            text5 = Text("Hello world", t2c={'o':YELLOW}, disable_ligatures=True)
            text6 = Text(
                "Visit us at docs.manim.community",
                t2c={"docs.manim.community": YELLOW},
                disable_ligatures=True,
           )
            text6.scale(1.3).shift(DOWN)
            self.add(text1, text2, text3, text4, text5 , text6)
            Group(*self.mobjects).arrange(DOWN, buff=.8).set(height=config.frame_height-LARGE_BUFF)

.. manim:: TextMoreCustomization
        :save_last_frame:

        class TextMoreCustomization(Scene):
            def construct(self):
                text1 = Text(
                    'Google',
                    t2c={'[:1]': '#3174f0', '[1:2]': '#e53125',
                         '[2:3]': '#fbb003', '[3:4]': '#3174f0',
                         '[4:5]': '#269a43', '[5:]': '#e53125'}, font_size=58).scale(3)
                self.add(text1)

As :class:`Text` uses Pango to render text, rendering non-English
characters is easily possible:

.. manim:: MultipleFonts
    :save_last_frame:

    class MultipleFonts(Scene):
        def construct(self):
            morning = Text("வணக்கம்", font="sans-serif")
            japanese = Text(
                "日本へようこそ", t2c={"日本": BLUE}
            )  # works same as ``Text``.
            mess = Text("Multi-Language", weight=BOLD)
            russ = Text("Здравствуйте मस नम म ", font="sans-serif")
            hin = Text("नमस्ते", font="sans-serif")
            arb = Text(
                "صباح الخير \n تشرفت بمقابلتك", font="sans-serif"
            )  # don't mix RTL and LTR languages nothing shows up then ;-)
            chinese = Text("臂猿「黛比」帶著孩子", font="sans-serif")
            self.add(morning, japanese, mess, russ, hin, arb, chinese)
            for i,mobj in enumerate(self.mobjects):
                mobj.shift(DOWN*(i-3))


.. manim:: PangoRender
    :quality: low

    class PangoRender(Scene):
        def construct(self):
            morning = Text("வணக்கம்", font="sans-serif")
            self.play(Write(morning))
            self.wait(2)

Tests
-----

Check that the creation of :class:`~.Text` works::

    &gt;&gt;&gt; Text('The horse does not eat cucumber salad.')
    Text('The horse does not eat cucumber salad.')

"""

@staticmethod
@functools.cache
def font_list() -&gt; list[str]:
    return manimpango.list_fonts()

</t>
<t tx="ekr.20250122151620.21">def parse_theme(parser: configparser.SectionProxy) -&gt; Theme:
    """Configure the rich style of logger and console output.

    Parameters
    ----------
    parser
        A parser containing any .cfg files in use.

    Returns
    -------
    :class:`rich.Theme`
        The rich theme to be used by the manim logger.

    See Also
    --------
    :func:`make_logger`.

    """
    theme = {key.replace("_", "."): parser[key] for key in parser}

    theme["log.width"] = None if theme["log.width"] == "-1" else int(theme["log.width"])
    theme["log.height"] = (
        None if theme["log.height"] == "-1" else int(theme["log.height"])
    )
    theme["log.timestamps"] = False
    try:
        custom_theme = Theme(
            {
                k: v
                for k, v in theme.items()
                if k not in ["log.width", "log.height", "log.timestamps"]
            },
        )
    except (color.ColorParseError, errors.StyleSyntaxError):
        printf(WRONG_COLOR_CONFIG_MSG)
        custom_theme = None

    return custom_theme


</t>
<t tx="ekr.20250122151620.210">def __new__(
    cls,
    mobject=None,
    *args,
    use_override=True,
    **kwargs,
) -&gt; Self:
    if isinstance(mobject, Mobject) and use_override:
        func = mobject.animation_override_for(cls)
        if func is not None:
            anim = func(mobject, *args, **kwargs)
            logger.debug(
                f"The {cls.__name__} animation has been is overridden for "
                f"{type(mobject).__name__} mobjects. use_override = False can "
                f" be used as keyword argument to prevent animation overriding.",
            )
            return anim
    return super().__new__(cls)

</t>
<t tx="ekr.20250122151620.2100">def __init__(
    self,
    text: str,
    fill_opacity: float = 1.0,
    stroke_width: float = 0,
    color: ParsableManimColor | None = None,
    font_size: float = DEFAULT_FONT_SIZE,
    line_spacing: float = -1,
    font: str = "",
    slant: str = NORMAL,
    weight: str = NORMAL,
    t2c: dict[str, str] = None,
    t2f: dict[str, str] = None,
    t2g: dict[str, tuple] = None,
    t2s: dict[str, str] = None,
    t2w: dict[str, str] = None,
    gradient: tuple = None,
    tab_width: int = 4,
    warn_missing_font: bool = True,
    # Mobject
    height: float = None,
    width: float = None,
    should_center: bool = True,
    disable_ligatures: bool = False,
    use_svg_cache: bool = False,
    **kwargs,
) -&gt; None:
    self.line_spacing = line_spacing
    if font and warn_missing_font:
        fonts_list = Text.font_list()
        # handle special case of sans/sans-serif
        if font.lower() == "sans-serif":
            font = "sans"
        if font not in fonts_list:
            # check if the capitalized version is in the supported fonts
            if font.capitalize() in fonts_list:
                font = font.capitalize()
            elif font.lower() in fonts_list:
                font = font.lower()
            elif font.title() in fonts_list:
                font = font.title()
            else:
                logger.warning(f"Font {font} not in {fonts_list}.")
    self.font = font
    self._font_size = float(font_size)
    # needs to be a float or else size is inflated when font_size = 24
    # (unknown cause)
    self.slant = slant
    self.weight = weight
    self.gradient = gradient
    self.tab_width = tab_width
    if t2c is None:
        t2c = {}
    if t2f is None:
        t2f = {}
    if t2g is None:
        t2g = {}
    if t2s is None:
        t2s = {}
    if t2w is None:
        t2w = {}
    # If long form arguments are present, they take precedence
    t2c = kwargs.pop("text2color", t2c)
    t2f = kwargs.pop("text2font", t2f)
    t2g = kwargs.pop("text2gradient", t2g)
    t2s = kwargs.pop("text2slant", t2s)
    t2w = kwargs.pop("text2weight", t2w)
    self.t2c = {k: ManimColor(v).to_hex() for k, v in t2c.items()}
    self.t2f = t2f
    self.t2g = t2g
    self.t2s = t2s
    self.t2w = t2w

    self.original_text = text
    self.disable_ligatures = disable_ligatures
    text_without_tabs = text
    if text.find("\t") != -1:
        text_without_tabs = text.replace("\t", " " * self.tab_width)
    self.text = text_without_tabs
    if self.line_spacing == -1:
        self.line_spacing = (
            self._font_size + self._font_size * DEFAULT_LINE_SPACING_SCALE
        )
    else:
        self.line_spacing = self._font_size + self._font_size * self.line_spacing

    color: ManimColor = ManimColor(color) if color else VMobject().color
    file_name = self._text2svg(color.to_hex())
    PangoUtils.remove_last_M(file_name)
    super().__init__(
        file_name,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        height=height,
        width=width,
        should_center=should_center,
        use_svg_cache=use_svg_cache,
        **kwargs,
    )
    self.text = text
    if self.disable_ligatures:
        self.submobjects = [*self._gen_chars()]
    self.chars = self.get_group_class()(*self.submobjects)
    self.text = text_without_tabs.replace(" ", "").replace("\n", "")
    nppc = self.n_points_per_curve
    for each in self:
        if len(each.points) == 0:
            continue
        points = each.points
        curve_start = points[0]
        assert len(curve_start) == self.dim, curve_start
        # Some of the glyphs in this text might not be closed,
        # so we close them by identifying when one curve ends
        # but it is not where the next curve starts.
        # It is more efficient to temporarily create a list
        # of points and add them one at a time, then turn them
        # into a numpy array at the end, rather than creating
        # new numpy arrays every time a point or fixing line
        # is added (which is O(n^2) for numpy arrays).
        closed_curve_points = []
        # OpenGL has points be part of quadratic Bezier curves;
        # Cairo uses cubic Bezier curves.
        if nppc == 3:  # RendererType.OPENGL

            def add_line_to(end):
                nonlocal closed_curve_points
                start = closed_curve_points[-1]
                closed_curve_points += [
                    start,
                    (start + end) / 2,
                    end,
                ]

        else:  # RendererType.CAIRO

            def add_line_to(end):
                nonlocal closed_curve_points
                start = closed_curve_points[-1]
                closed_curve_points += [
                    start,
                    (start + start + end) / 3,
                    (start + end + end) / 3,
                    end,
                ]

        for index, point in enumerate(points):
            closed_curve_points.append(point)
            if (
                index != len(points) - 1
                and (index + 1) % nppc == 0
                and any(point != points[index + 1])
            ):
                # Add straight line from last point on this curve to the
                # start point on the next curve. We represent the line
                # as a cubic bezier curve where the two control points
                # are half-way between the start and stop point.
                add_line_to(curve_start)
                curve_start = points[index + 1]
        # Make sure last curve is closed
        add_line_to(curve_start)
        each.points = np.array(closed_curve_points, ndmin=2)
    # anti-aliasing
    if height is None and width is None:
        self.scale(TEXT_MOB_SCALE_FACTOR)
    self.initial_height = self.height

</t>
<t tx="ekr.20250122151620.2101">def __repr__(self):
    return f"Text({repr(self.original_text)})"

</t>
<t tx="ekr.20250122151620.2102">@property
def font_size(self):
    return (
        self.height
        / self.initial_height
        / TEXT_MOB_SCALE_FACTOR
        * 2.4
        * self._font_size
        / DEFAULT_FONT_SIZE
    )

</t>
<t tx="ekr.20250122151620.2103">@font_size.setter
def font_size(self, font_val):
    # TODO: use pango's font size scaling.
    if font_val &lt;= 0:
        raise ValueError("font_size must be greater than 0.")
    else:
        self.scale(font_val / self.font_size)

</t>
<t tx="ekr.20250122151620.2104">def _gen_chars(self):
    chars = self.get_group_class()()
    submobjects_char_index = 0
    for char_index in range(len(self.text)):
        if self.text[char_index].isspace():
            space = Dot(radius=0, fill_opacity=0, stroke_opacity=0)
            if char_index == 0:
                space.move_to(self.submobjects[submobjects_char_index].get_center())
            else:
                space.move_to(
                    self.submobjects[submobjects_char_index - 1].get_center(),
                )
            chars.add(space)
        else:
            chars.add(self.submobjects[submobjects_char_index])
            submobjects_char_index += 1
    return chars

</t>
<t tx="ekr.20250122151620.2105">def _find_indexes(self, word: str, text: str):
    """Finds the indexes of ``text`` in ``word``."""
    temp = re.match(r"\[([0-9\-]{0,}):([0-9\-]{0,})\]", word)
    if temp:
        start = int(temp.group(1)) if temp.group(1) != "" else 0
        end = int(temp.group(2)) if temp.group(2) != "" else len(text)
        start = len(text) + start if start &lt; 0 else start
        end = len(text) + end if end &lt; 0 else end
        return [(start, end)]
    indexes = []
    index = text.find(word)
    while index != -1:
        indexes.append((index, index + len(word)))
        index = text.find(word, index + len(word))
    return indexes

</t>
<t tx="ekr.20250122151620.2106">@deprecated(
    since="v0.14.0",
    until="v0.15.0",
    message="This was internal function, you shouldn't be using it anyway.",
)
def _set_color_by_t2c(self, t2c=None):
    """Sets color for specified strings."""
    t2c = t2c if t2c else self.t2c
    for word, color in list(t2c.items()):
        for start, end in self._find_indexes(word, self.text):
            self.chars[start:end].set_color(color)

</t>
<t tx="ekr.20250122151620.2107">@deprecated(
    since="v0.14.0",
    until="v0.15.0",
    message="This was internal function, you shouldn't be using it anyway.",
)
def _set_color_by_t2g(self, t2g=None):
    """Sets gradient colors for specified
    strings. Behaves similarly to ``set_color_by_t2c``.
    """
    t2g = t2g if t2g else self.t2g
    for word, gradient in list(t2g.items()):
        for start, end in self._find_indexes(word, self.text):
            self.chars[start:end].set_color_by_gradient(*gradient)

</t>
<t tx="ekr.20250122151620.2108">def _text2hash(self, color: ManimColor):
    """Generates ``sha256`` hash for file name."""
    settings = (
        "PANGO" + self.font + self.slant + self.weight + str(color)
    )  # to differentiate Text and CairoText
    settings += str(self.t2f) + str(self.t2s) + str(self.t2w) + str(self.t2c)
    settings += str(self.line_spacing) + str(self._font_size)
    settings += str(self.disable_ligatures)
    id_str = self.text + settings
    hasher = hashlib.sha256()
    hasher.update(id_str.encode())
    return hasher.hexdigest()[:16]

</t>
<t tx="ekr.20250122151620.2109">def _merge_settings(
    self,
    left_setting: TextSetting,
    right_setting: TextSetting,
    default_args: dict[str, Iterable[str]],
) -&gt; TextSetting:
    contained = right_setting.end &lt; left_setting.end
    new_setting = copy.copy(left_setting) if contained else copy.copy(right_setting)

    new_setting.start = right_setting.end if contained else left_setting.end
    left_setting.end = right_setting.start
    if not contained:
        right_setting.end = new_setting.start

    for arg in default_args:
        left = getattr(left_setting, arg)
        right = getattr(right_setting, arg)
        default = default_args[arg]
        if left != default and getattr(right_setting, arg) != default:
            raise ValueError(
                f"Ambiguous style for text '{self.text[right_setting.start : right_setting.end]}':"
                + f"'{arg}' cannot be both '{left}' and '{right}'."
            )
        setattr(right_setting, arg, left if left != default else right)
    return new_setting

</t>
<t tx="ekr.20250122151620.211">def __init__(
    self,
    mobject: Mobject | None,
    lag_ratio: float = DEFAULT_ANIMATION_LAG_RATIO,
    run_time: float = DEFAULT_ANIMATION_RUN_TIME,
    rate_func: Callable[[float], float] = smooth,
    reverse_rate_function: bool = False,
    name: str = None,
    remover: bool = False,  # remove a mobject from the screen?
    suspend_mobject_updating: bool = True,
    introducer: bool = False,
    *,
    _on_finish: Callable[[], None] = lambda _: None,
    **kwargs,
) -&gt; None:
    self._typecheck_input(mobject)
    self.run_time: float = run_time
    self.rate_func: Callable[[float], float] = rate_func
    self.reverse_rate_function: bool = reverse_rate_function
    self.name: str | None = name
    self.remover: bool = remover
    self.introducer: bool = introducer
    self.suspend_mobject_updating: bool = suspend_mobject_updating
    self.lag_ratio: float = lag_ratio
    self._on_finish: Callable[[Scene], None] = _on_finish
    if config["renderer"] == RendererType.OPENGL:
        self.starting_mobject: OpenGLMobject = OpenGLMobject()
        self.mobject: OpenGLMobject = (
            mobject if mobject is not None else OpenGLMobject()
        )
    else:
        self.starting_mobject: Mobject = Mobject()
        self.mobject: Mobject = mobject if mobject is not None else Mobject()
    if kwargs:
        logger.debug("Animation received extra kwargs: %s", kwargs)

    if hasattr(self, "CONFIG"):
        logger.error(
            (
                "CONFIG has been removed from ManimCommunity.",
                "Please use keyword arguments instead.",
            ),
        )

</t>
<t tx="ekr.20250122151620.2110">def _get_settings_from_t2xs(
    self,
    t2xs: Sequence[tuple[dict[str, str], str]],
    default_args: dict[str, Iterable[str]],
) -&gt; Sequence[TextSetting]:
    settings = []
    t2xwords = set(chain(*([*t2x.keys()] for t2x, _ in t2xs)))
    for word in t2xwords:
        setting_args = {
            arg: str(t2x[word]) if word in t2x else default_args[arg]
            # NOTE: when t2x[word] is a ManimColor, str will yield the
            # hex representation
            for t2x, arg in t2xs
        }

        for start, end in self._find_indexes(word, self.text):
            settings.append(TextSetting(start, end, **setting_args))
    return settings

</t>
<t tx="ekr.20250122151620.2111">def _get_settings_from_gradient(
    self, default_args: dict[str, Iterable[str]]
) -&gt; Sequence[TextSetting]:
    settings = []
    args = copy.copy(default_args)
    if self.gradient:
        colors = color_gradient(self.gradient, len(self.text))
        for i in range(len(self.text)):
            args["color"] = colors[i].to_hex()
            settings.append(TextSetting(i, i + 1, **args))

    for word, gradient in self.t2g.items():
        if isinstance(gradient, str) or len(gradient) == 1:
            color = gradient if isinstance(gradient, str) else gradient[0]
            gradient = [ManimColor(color)]
        colors = (
            color_gradient(gradient, len(word))
            if len(gradient) != 1
            else len(word) * gradient
        )
        for start, end in self._find_indexes(word, self.text):
            for i in range(start, end):
                args["color"] = colors[i - start].to_hex()
                settings.append(TextSetting(i, i + 1, **args))
    return settings

</t>
<t tx="ekr.20250122151620.2112">def _text2settings(self, color: str):
    """Converts the texts and styles to a setting for parsing."""
    t2xs = [
        (self.t2f, "font"),
        (self.t2s, "slant"),
        (self.t2w, "weight"),
        (self.t2c, "color"),
    ]
    # setting_args requires values to be strings

    default_args = {
        arg: getattr(self, arg) if arg != "color" else color for _, arg in t2xs
    }

    settings = self._get_settings_from_t2xs(t2xs, default_args)
    settings.extend(self._get_settings_from_gradient(default_args))

    # Handle overlaps

    settings.sort(key=lambda setting: setting.start)
    for index, setting in enumerate(settings):
        if index + 1 == len(settings):
            break

        next_setting = settings[index + 1]
        if setting.end &gt; next_setting.start:
            new_setting = self._merge_settings(setting, next_setting, default_args)
            new_index = index + 1
            while (
                new_index &lt; len(settings)
                and settings[new_index].start &lt; new_setting.start
            ):
                new_index += 1
            settings.insert(new_index, new_setting)

    # Set all text settings (default font, slant, weight)
    temp_settings = settings.copy()
    start = 0
    for setting in settings:
        if setting.start != start:
            temp_settings.append(TextSetting(start, setting.start, **default_args))
        start = setting.end
    if start != len(self.text):
        temp_settings.append(TextSetting(start, len(self.text), **default_args))
    settings = sorted(temp_settings, key=lambda setting: setting.start)

    line_num = 0
    if re.search(r"\n", self.text):
        for start, end in self._find_indexes("\n", self.text):
            for setting in settings:
                if setting.line_num == -1:
                    setting.line_num = line_num
                if start &lt; setting.end:
                    line_num += 1
                    new_setting = copy.copy(setting)
                    setting.end = end
                    new_setting.start = end
                    new_setting.line_num = line_num
                    settings.append(new_setting)
                    settings.sort(key=lambda setting: setting.start)
                    break
    for setting in settings:
        if setting.line_num == -1:
            setting.line_num = line_num

    return settings

</t>
<t tx="ekr.20250122151620.2113">def _text2svg(self, color: ManimColor):
    """Convert the text to SVG using Pango."""
    size = self._font_size
    line_spacing = self.line_spacing
    size /= TEXT2SVG_ADJUSTMENT_FACTOR
    line_spacing /= TEXT2SVG_ADJUSTMENT_FACTOR

    dir_name = config.get_dir("text_dir")
    if not dir_name.is_dir():
        dir_name.mkdir(parents=True)
    hash_name = self._text2hash(color)
    file_name = dir_name / (hash_name + ".svg")

    if file_name.exists():
        svg_file = str(file_name.resolve())
    else:
        settings = self._text2settings(color)
        width = config["pixel_width"]
        height = config["pixel_height"]

        svg_file = manimpango.text2svg(
            settings,
            size,
            line_spacing,
            self.disable_ligatures,
            str(file_name.resolve()),
            START_X,
            START_Y,
            width,
            height,
            self.text,
        )

    return svg_file

</t>
<t tx="ekr.20250122151620.2114">def init_colors(self, propagate_colors=True):
    if config.renderer == RendererType.OPENGL:
        super().init_colors()
    elif config.renderer == RendererType.CAIRO:
        super().init_colors(propagate_colors=propagate_colors)


</t>
<t tx="ekr.20250122151620.2115">r"""Display (non-LaTeX) text rendered using `Pango &lt;https://pango.gnome.org/&gt;`_.

Text objects behave like a :class:`.VGroup`-like iterable of all characters
in the given text. In particular, slicing is possible.

**What is PangoMarkup?**

PangoMarkup is a small markup language like html and it helps you avoid using
"range of characters" while coloring or styling a piece a Text. You can use
this language with :class:`~.MarkupText`.

A simple example of a marked-up string might be::

    &lt;span foreground="blue" size="x-large"&gt;Blue text&lt;/span&gt; is &lt;i&gt;cool&lt;/i&gt;!"

and it can be used with :class:`~.MarkupText` as

.. manim:: MarkupExample
    :save_last_frame:

    class MarkupExample(Scene):
        def construct(self):
            text = MarkupText('&lt;span foreground="blue" size="x-large"&gt;Blue text&lt;/span&gt; is &lt;i&gt;cool&lt;/i&gt;!"')
            self.add(text)

A more elaborate example would be:

.. manim:: MarkupElaborateExample
    :save_last_frame:

    class MarkupElaborateExample(Scene):
        def construct(self):
            text = MarkupText(
                '&lt;span foreground="purple"&gt;ا&lt;/span&gt;&lt;span foreground="red"&gt;َ&lt;/span&gt;'
                'ل&lt;span foreground="blue"&gt;ْ&lt;/span&gt;ع&lt;span foreground="red"&gt;َ&lt;/span&gt;ر'
                '&lt;span foreground="red"&gt;َ&lt;/span&gt;ب&lt;span foreground="red"&gt;ِ&lt;/span&gt;ي'
                '&lt;span foreground="green"&gt;ّ&lt;/span&gt;&lt;span foreground="red"&gt;َ&lt;/span&gt;ة'
                '&lt;span foreground="blue"&gt;ُ&lt;/span&gt;'
            )
            self.add(text)

PangoMarkup can also contain XML features such as numeric character
entities such as ``&amp;#169;`` for © can be used too.

The most general markup tag is ``&lt;span&gt;``, then there are some
convenience tags.

Here is a list of supported tags:

- ``&lt;b&gt;bold&lt;/b&gt;``, ``&lt;i&gt;italic&lt;/i&gt;`` and ``&lt;b&gt;&lt;i&gt;bold+italic&lt;/i&gt;&lt;/b&gt;``
- ``&lt;u&gt;underline&lt;/u&gt;`` and ``&lt;s&gt;strike through&lt;/s&gt;``
- ``&lt;tt&gt;typewriter font&lt;/tt&gt;``
- ``&lt;big&gt;bigger font&lt;/big&gt;`` and ``&lt;small&gt;smaller font&lt;/small&gt;``
- ``&lt;sup&gt;superscript&lt;/sup&gt;`` and ``&lt;sub&gt;subscript&lt;/sub&gt;``
- ``&lt;span underline="double" underline_color="green"&gt;double underline&lt;/span&gt;``
- ``&lt;span underline="error"&gt;error underline&lt;/span&gt;``
- ``&lt;span overline="single" overline_color="green"&gt;overline&lt;/span&gt;``
- ``&lt;span strikethrough="true" strikethrough_color="red"&gt;strikethrough&lt;/span&gt;``
- ``&lt;span font_family="sans"&gt;temporary change of font&lt;/span&gt;``
- ``&lt;span foreground="red"&gt;temporary change of color&lt;/span&gt;``
- ``&lt;span fgcolor="red"&gt;temporary change of color&lt;/span&gt;``
- ``&lt;gradient from="YELLOW" to="RED"&gt;temporary gradient&lt;/gradient&gt;``

For ``&lt;span&gt;`` markup, colors can be specified either as
hex triples like ``#aabbcc`` or as named CSS colors like
``AliceBlue``.
The ``&lt;gradient&gt;`` tag is handled by Manim rather than
Pango, and supports hex triplets or Manim constants like
``RED`` or ``RED_A``.
If you want to use Manim constants like ``RED_A`` together
with ``&lt;span&gt;``, you will need to use Python's f-String
syntax as follows::

    MarkupText(f'&lt;span foreground="{RED_A}"&gt;here you go&lt;/span&gt;')

If your text contains ligatures, the :class:`MarkupText` class may
incorrectly determine the first and last letter when creating the
gradient. This is due to the fact that ``fl`` are two separate characters,
but might be set as one single glyph - a ligature. If your language
does not depend on ligatures, consider setting ``disable_ligatures``
to ``True``. If you must use ligatures, the ``gradient`` tag supports an optional
attribute ``offset`` which can be used to compensate for that error.

For example:

- ``&lt;gradient from="RED" to="YELLOW" offset="1"&gt;example&lt;/gradient&gt;`` to *start* the gradient one letter earlier
- ``&lt;gradient from="RED" to="YELLOW" offset=",1"&gt;example&lt;/gradient&gt;`` to *end* the gradient one letter earlier
- ``&lt;gradient from="RED" to="YELLOW" offset="2,1"&gt;example&lt;/gradient&gt;`` to *start* the gradient two letters earlier and *end* it one letter earlier

Specifying a second offset may be necessary if the text to be colored does
itself contain ligatures. The same can happen when using HTML entities for
special chars.

When using ``underline``, ``overline`` or ``strikethrough`` together with
``&lt;gradient&gt;`` tags, you will also need to use the offset, because
underlines are additional paths in the final :class:`SVGMobject`.
Check out the following example.

Escaping of special characters: ``&gt;`` **should** be written as ``&amp;gt;``
whereas ``&lt;`` and ``&amp;`` *must* be written as ``&amp;lt;`` and
``&amp;amp;``.

You can find more information about Pango markup formatting at the
corresponding documentation page:
`Pango Markup &lt;https://docs.gtk.org/Pango/pango_markup.html&gt;`_.
Please be aware that not all features are supported by this class and that
the ``&lt;gradient&gt;`` tag mentioned above is not supported by Pango.

Parameters
----------

text
    The text that needs to be created as mobject.
fill_opacity
    The fill opacity, with 1 meaning opaque and 0 meaning transparent.
stroke_width
    Stroke width.
font_size
    Font size.
line_spacing
    Line spacing.
font
    Global font setting for the entire text. Local overrides are possible.
slant
    Global slant setting, e.g. `NORMAL` or `ITALIC`. Local overrides are possible.
weight
    Global weight setting, e.g. `NORMAL` or `BOLD`. Local overrides are possible.
gradient
    Global gradient setting. Local overrides are possible.
warn_missing_font
    If True (default), Manim will issue a warning if the font does not exist in the
    (case-sensitive) list of fonts returned from `manimpango.list_fonts()`.

Returns
-------
:class:`MarkupText`
    The text displayed in form of a :class:`.VGroup`-like mobject.

Examples
---------

.. manim:: BasicMarkupExample
    :save_last_frame:

    class BasicMarkupExample(Scene):
        def construct(self):
            text1 = MarkupText("&lt;b&gt;foo&lt;/b&gt; &lt;i&gt;bar&lt;/i&gt; &lt;b&gt;&lt;i&gt;foobar&lt;/i&gt;&lt;/b&gt;")
            text2 = MarkupText("&lt;s&gt;foo&lt;/s&gt; &lt;u&gt;bar&lt;/u&gt; &lt;big&gt;big&lt;/big&gt; &lt;small&gt;small&lt;/small&gt;")
            text3 = MarkupText("H&lt;sub&gt;2&lt;/sub&gt;O and H&lt;sub&gt;3&lt;/sub&gt;O&lt;sup&gt;+&lt;/sup&gt;")
            text4 = MarkupText("type &lt;tt&gt;help&lt;/tt&gt; for help")
            text5 = MarkupText(
                '&lt;span underline="double"&gt;foo&lt;/span&gt; &lt;span underline="error"&gt;bar&lt;/span&gt;'
            )
            group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
            self.add(group)

.. manim:: ColorExample
    :save_last_frame:

    class ColorExample(Scene):
        def construct(self):
            text1 = MarkupText(
                f'all in red &lt;span fgcolor="{YELLOW}"&gt;except this&lt;/span&gt;', color=RED
            )
            text2 = MarkupText("nice gradient", gradient=(BLUE, GREEN))
            text3 = MarkupText(
                'nice &lt;gradient from="RED" to="YELLOW"&gt;intermediate&lt;/gradient&gt; gradient',
                gradient=(BLUE, GREEN),
            )
            text4 = MarkupText(
                'fl ligature &lt;gradient from="RED" to="YELLOW"&gt;causing trouble&lt;/gradient&gt; here'
            )
            text5 = MarkupText(
                'fl ligature &lt;gradient from="RED" to="YELLOW" offset="1"&gt;defeated&lt;/gradient&gt; with offset'
            )
            text6 = MarkupText(
                'fl ligature &lt;gradient from="RED" to="YELLOW" offset="1"&gt;floating&lt;/gradient&gt; inside'
            )
            text7 = MarkupText(
                'fl ligature &lt;gradient from="RED" to="YELLOW" offset="1,1"&gt;floating&lt;/gradient&gt; inside'
            )
            group = VGroup(text1, text2, text3, text4, text5, text6, text7).arrange(DOWN)
            self.add(group)

.. manim:: UnderlineExample
    :save_last_frame:

    class UnderlineExample(Scene):
        def construct(self):
            text1 = MarkupText(
                '&lt;span underline="double" underline_color="green"&gt;bla&lt;/span&gt;'
            )
            text2 = MarkupText(
                '&lt;span underline="single" underline_color="green"&gt;xxx&lt;/span&gt;&lt;gradient from="#ffff00" to="RED"&gt;aabb&lt;/gradient&gt;y'
            )
            text3 = MarkupText(
                '&lt;span underline="single" underline_color="green"&gt;xxx&lt;/span&gt;&lt;gradient from="#ffff00" to="RED" offset="-1"&gt;aabb&lt;/gradient&gt;y'
            )
            text4 = MarkupText(
                '&lt;span underline="double" underline_color="green"&gt;xxx&lt;/span&gt;&lt;gradient from="#ffff00" to="RED"&gt;aabb&lt;/gradient&gt;y'
            )
            text5 = MarkupText(
                '&lt;span underline="double" underline_color="green"&gt;xxx&lt;/span&gt;&lt;gradient from="#ffff00" to="RED" offset="-2"&gt;aabb&lt;/gradient&gt;y'
            )
            group = VGroup(text1, text2, text3, text4, text5).arrange(DOWN)
            self.add(group)

.. manim:: FontExample
    :save_last_frame:

    class FontExample(Scene):
        def construct(self):
            text1 = MarkupText(
                'all in sans &lt;span font_family="serif"&gt;except this&lt;/span&gt;', font="sans"
            )
            text2 = MarkupText(
                '&lt;span font_family="serif"&gt;mixing&lt;/span&gt; &lt;span font_family="sans"&gt;fonts&lt;/span&gt; &lt;span font_family="monospace"&gt;is ugly&lt;/span&gt;'
            )
            text3 = MarkupText("special char &gt; or &amp;gt;")
            text4 = MarkupText("special char &amp;lt; and &amp;amp;")
            group = VGroup(text1, text2, text3, text4).arrange(DOWN)
            self.add(group)

.. manim:: NewlineExample
    :save_last_frame:

    class NewlineExample(Scene):
        def construct(self):
            text = MarkupText('foooo&lt;span foreground="red"&gt;oo\nbaa&lt;/span&gt;aar')
            self.add(text)

.. manim:: NoLigaturesExample
    :save_last_frame:

    class NoLigaturesExample(Scene):
        def construct(self):
            text1 = MarkupText('fl&lt;gradient from="RED" to="GREEN"&gt;oat&lt;/gradient&gt;ing')
            text2 = MarkupText('fl&lt;gradient from="RED" to="GREEN"&gt;oat&lt;/gradient&gt;ing', disable_ligatures=True)
            group = VGroup(text1, text2).arrange(DOWN)
            self.add(group)


As :class:`MarkupText` uses Pango to render text, rendering non-English
characters is easily possible:

.. manim:: MultiLanguage
    :save_last_frame:

    class MultiLanguage(Scene):
        def construct(self):
            morning = MarkupText("வணக்கம்", font="sans-serif")
            japanese = MarkupText(
                '&lt;span fgcolor="blue"&gt;日本&lt;/span&gt;へようこそ'
            )  # works as in ``Text``.
            mess = MarkupText("Multi-Language", weight=BOLD)
            russ = MarkupText("Здравствуйте मस नम म ", font="sans-serif")
            hin = MarkupText("नमस्ते", font="sans-serif")
            chinese = MarkupText("臂猿「黛比」帶著孩子", font="sans-serif")
            group = VGroup(morning, japanese, mess, russ, hin, chinese).arrange(DOWN)
            self.add(group)

You can justify the text by passing :attr:`justify` parameter.

.. manim:: JustifyText

    class JustifyText(Scene):
        def construct(self):
            ipsum_text = (
                "Lorem ipsum dolor sit amet, consectetur adipiscing elit."
                "Praesent feugiat metus sit amet iaculis pulvinar. Nulla posuere "
                "quam a ex aliquam, eleifend consectetur tellus viverra. Aliquam "
                "fermentum interdum justo, nec rutrum elit pretium ac. Nam quis "
                "leo pulvinar, dignissim est at, venenatis nisi."
            )
            justified_text = MarkupText(ipsum_text, justify=True).scale(0.4)
            not_justified_text = MarkupText(ipsum_text, justify=False).scale(0.4)
            just_title = Title("Justified")
            njust_title = Title("Not Justified")
            self.add(njust_title, not_justified_text)
            self.play(
                FadeOut(not_justified_text),
                FadeIn(justified_text),
                FadeOut(njust_title),
                FadeIn(just_title),
            )
            self.wait(1)

Tests
-----

Check that the creation of :class:`~.MarkupText` works::

    &gt;&gt;&gt; MarkupText('The horse does not eat cucumber salad.')
    MarkupText('The horse does not eat cucumber salad.')

"""

@staticmethod
@functools.cache
def font_list() -&gt; list[str]:
    return manimpango.list_fonts()

</t>
<t tx="ekr.20250122151620.2116">def __init__(
    self,
    text: str,
    fill_opacity: float = 1,
    stroke_width: float = 0,
    color: ParsableManimColor | None = None,
    font_size: float = DEFAULT_FONT_SIZE,
    line_spacing: int = -1,
    font: str = "",
    slant: str = NORMAL,
    weight: str = NORMAL,
    justify: bool = False,
    gradient: tuple = None,
    tab_width: int = 4,
    height: int = None,
    width: int = None,
    should_center: bool = True,
    disable_ligatures: bool = False,
    warn_missing_font: bool = True,
    **kwargs,
) -&gt; None:
    self.text = text
    self.line_spacing = line_spacing
    if font and warn_missing_font:
        fonts_list = Text.font_list()
        # handle special case of sans/sans-serif
        if font.lower() == "sans-serif":
            font = "sans"
        if font not in fonts_list:
            # check if the capitalized version is in the supported fonts
            if font.capitalize() in fonts_list:
                font = font.capitalize()
            elif font.lower() in fonts_list:
                font = font.lower()
            elif font.title() in fonts_list:
                font = font.title()
            else:
                logger.warning(f"Font {font} not in {fonts_list}.")
    self.font = font
    self._font_size = float(font_size)
    self.slant = slant
    self.weight = weight
    self.gradient = gradient
    self.tab_width = tab_width
    self.justify = justify

    self.original_text = text
    self.disable_ligatures = disable_ligatures
    text_without_tabs = text
    if "\t" in text:
        text_without_tabs = text.replace("\t", " " * self.tab_width)

    colormap = self._extract_color_tags()
    if len(colormap) &gt; 0:
        logger.warning(
            'Using &lt;color&gt; tags in MarkupText is deprecated. Please use &lt;span foreground="..."&gt; instead.',
        )
    gradientmap = self._extract_gradient_tags()
    validate_error = MarkupUtils.validate(self.text)
    if validate_error:
        raise ValueError(validate_error)

    if self.line_spacing == -1:
        self.line_spacing = (
            self._font_size + self._font_size * DEFAULT_LINE_SPACING_SCALE
        )
    else:
        self.line_spacing = self._font_size + self._font_size * self.line_spacing

    color: ManimColor = ManimColor(color) if color else VMobject().color
    file_name = self._text2svg(color)

    PangoUtils.remove_last_M(file_name)
    super().__init__(
        file_name,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        height=height,
        width=width,
        should_center=should_center,
        **kwargs,
    )

    self.chars = self.get_group_class()(*self.submobjects)
    self.text = text_without_tabs.replace(" ", "").replace("\n", "")

    nppc = self.n_points_per_curve
    for each in self:
        if len(each.points) == 0:
            continue
        points = each.points
        curve_start = points[0]
        assert len(curve_start) == self.dim, curve_start
        # Some of the glyphs in this text might not be closed,
        # so we close them by identifying when one curve ends
        # but it is not where the next curve starts.
        # It is more efficient to temporarily create a list
        # of points and add them one at a time, then turn them
        # into a numpy array at the end, rather than creating
        # new numpy arrays every time a point or fixing line
        # is added (which is O(n^2) for numpy arrays).
        closed_curve_points = []
        # OpenGL has points be part of quadratic Bezier curves;
        # Cairo uses cubic Bezier curves.
        if nppc == 3:  # RendererType.OPENGL

            def add_line_to(end):
                nonlocal closed_curve_points
                start = closed_curve_points[-1]
                closed_curve_points += [
                    start,
                    (start + end) / 2,
                    end,
                ]

        else:  # RendererType.CAIRO

            def add_line_to(end):
                nonlocal closed_curve_points
                start = closed_curve_points[-1]
                closed_curve_points += [
                    start,
                    (start + start + end) / 3,
                    (start + end + end) / 3,
                    end,
                ]

        for index, point in enumerate(points):
            closed_curve_points.append(point)
            if (
                index != len(points) - 1
                and (index + 1) % nppc == 0
                and any(point != points[index + 1])
            ):
                # Add straight line from last point on this curve to the
                # start point on the next curve.
                add_line_to(curve_start)
                curve_start = points[index + 1]
        # Make sure last curve is closed
        add_line_to(curve_start)
        each.points = np.array(closed_curve_points, ndmin=2)

    if self.gradient:
        self.set_color_by_gradient(*self.gradient)
    for col in colormap:
        self.chars[
            col["start"] - col["start_offset"] : col["end"]
            - col["start_offset"]
            - col["end_offset"]
        ].set_color(self._parse_color(col["color"]))
    for grad in gradientmap:
        self.chars[
            grad["start"] - grad["start_offset"] : grad["end"]
            - grad["start_offset"]
            - grad["end_offset"]
        ].set_color_by_gradient(
            *(self._parse_color(grad["from"]), self._parse_color(grad["to"]))
        )
    # anti-aliasing
    if height is None and width is None:
        self.scale(TEXT_MOB_SCALE_FACTOR)

    self.initial_height = self.height

</t>
<t tx="ekr.20250122151620.2117">@property
def font_size(self):
    return (
        self.height
        / self.initial_height
        / TEXT_MOB_SCALE_FACTOR
        * 2.4
        * self._font_size
        / DEFAULT_FONT_SIZE
    )

</t>
<t tx="ekr.20250122151620.2118">@font_size.setter
def font_size(self, font_val):
    # TODO: use pango's font size scaling.
    if font_val &lt;= 0:
        raise ValueError("font_size must be greater than 0.")
    else:
        self.scale(font_val / self.font_size)

</t>
<t tx="ekr.20250122151620.2119">def _text2hash(self, color: ParsableManimColor):
    """Generates ``sha256`` hash for file name."""
    settings = (
        "MARKUPPANGO"
        + self.font
        + self.slant
        + self.weight
        + ManimColor(color).to_hex().lower()
    )  # to differentiate from classical Pango Text
    settings += str(self.line_spacing) + str(self._font_size)
    settings += str(self.disable_ligatures)
    settings += str(self.justify)
    id_str = self.text + settings
    hasher = hashlib.sha256()
    hasher.update(id_str.encode())
    return hasher.hexdigest()[:16]

</t>
<t tx="ekr.20250122151620.212">@property
def run_time(self) -&gt; float:
    return self._run_time

</t>
<t tx="ekr.20250122151620.2120">def _text2svg(self, color: ParsableManimColor | None):
    """Convert the text to SVG using Pango."""
    color = ManimColor(color)
    size = self._font_size
    line_spacing = self.line_spacing
    size /= TEXT2SVG_ADJUSTMENT_FACTOR
    line_spacing /= TEXT2SVG_ADJUSTMENT_FACTOR

    dir_name = config.get_dir("text_dir")
    if not dir_name.is_dir():
        dir_name.mkdir(parents=True)
    hash_name = self._text2hash(color)
    file_name = dir_name / (hash_name + ".svg")

    if file_name.exists():
        svg_file = str(file_name.resolve())
    else:
        final_text = (
            f'&lt;span foreground="{color.to_hex()}"&gt;{self.text}&lt;/span&gt;'
            if color is not None
            else self.text
        )
        logger.debug(f"Setting Text {self.text}")
        svg_file = MarkupUtils.text2svg(
            final_text,
            self.font,
            self.slant,
            self.weight,
            size,
            line_spacing,
            self.disable_ligatures,
            str(file_name.resolve()),
            START_X,
            START_Y,
            600,  # width
            400,  # height
            justify=self.justify,
            pango_width=500,
        )
    return svg_file

</t>
<t tx="ekr.20250122151620.2121">def _count_real_chars(self, s):
    """Counts characters that will be displayed.

    This is needed for partial coloring or gradients, because space
    counts to the text's `len`, but has no corresponding character.
    """
    count = 0
    level = 0
    # temporarily replace HTML entities by single char
    s = re.sub("&amp;[^;]+;", "x", s)
    for c in s:
        if c == "&lt;":
            level += 1
        if c == "&gt;" and level &gt; 0:
            level -= 1
        elif c != " " and c != "\t" and level == 0:
            count += 1
    return count

</t>
<t tx="ekr.20250122151620.2122">def _extract_gradient_tags(self):
    """Used to determine which parts (if any) of the string should be formatted
    with a gradient.

    Removes the ``&lt;gradient&gt;`` tag, as it is not part of Pango's markup and would cause an error.
    """
    tags = re.finditer(
        r'&lt;gradient\s+from="([^"]+)"\s+to="([^"]+)"(\s+offset="([^"]+)")?&gt;(.+?)&lt;/gradient&gt;',
        self.original_text,
        re.S,
    )
    gradientmap = []
    for tag in tags:
        start = self._count_real_chars(self.original_text[: tag.start(0)])
        end = start + self._count_real_chars(tag.group(5))
        offsets = tag.group(4).split(",") if tag.group(4) else [0]
        start_offset = int(offsets[0]) if offsets[0] else 0
        end_offset = int(offsets[1]) if len(offsets) == 2 and offsets[1] else 0

        gradientmap.append(
            {
                "start": start,
                "end": end,
                "from": tag.group(1),
                "to": tag.group(2),
                "start_offset": start_offset,
                "end_offset": end_offset,
            },
        )
    self.text = re.sub(
        "&lt;gradient[^&gt;]+&gt;(.+?)&lt;/gradient&gt;", r"\1", self.text, count=0, flags=re.S
    )
    return gradientmap

</t>
<t tx="ekr.20250122151620.2123">def _parse_color(self, col):
    """Parse color given in ``&lt;color&gt;`` or ``&lt;gradient&gt;`` tags."""
    if re.match("#[0-9a-f]{6}", col):
        return col
    else:
        return ManimColor(col).to_hex()

</t>
<t tx="ekr.20250122151620.2124">def _extract_color_tags(self):
    """Used to determine which parts (if any) of the string should be formatted
    with a custom color.

    Removes the ``&lt;color&gt;`` tag, as it is not part of Pango's markup and would cause an error.

    Note: Using the ``&lt;color&gt;`` tags is deprecated. As soon as the legacy syntax is gone, this function
    will be removed.
    """
    tags = re.finditer(
        r'&lt;color\s+col="([^"]+)"(\s+offset="([^"]+)")?&gt;(.+?)&lt;/color&gt;',
        self.original_text,
        re.S,
    )

    colormap = []
    for tag in tags:
        start = self._count_real_chars(self.original_text[: tag.start(0)])
        end = start + self._count_real_chars(tag.group(4))
        offsets = tag.group(3).split(",") if tag.group(3) else [0]
        start_offset = int(offsets[0]) if offsets[0] else 0
        end_offset = int(offsets[1]) if len(offsets) == 2 and offsets[1] else 0

        colormap.append(
            {
                "start": start,
                "end": end,
                "color": tag.group(1),
                "start_offset": start_offset,
                "end_offset": end_offset,
            },
        )
    self.text = re.sub(
        "&lt;color[^&gt;]+&gt;(.+?)&lt;/color&gt;", r"\1", self.text, count=0, flags=re.S
    )
    return colormap

</t>
<t tx="ekr.20250122151620.2125">def __repr__(self):
    return f"MarkupText({repr(self.original_text)})"


</t>
<t tx="ekr.20250122151620.213">@run_time.setter
def run_time(self, value: float) -&gt; None:
    if value &lt; 0:
        raise ValueError(
            f"The run_time of {self.__class__.__name__} cannot be "
            f"negative. The given value was {value}."
        )
    self._run_time = value

</t>
<t tx="ekr.20250122151620.214">def _typecheck_input(self, mobject: Mobject | None) -&gt; None:
    if mobject is None:
        logger.debug("Animation with empty mobject")
    elif not isinstance(mobject, (Mobject, OpenGLMobject)):
        raise TypeError("Animation only works on Mobjects")

</t>
<t tx="ekr.20250122151620.215">def __str__(self) -&gt; str:
    if self.name:
        return self.name
    return f"{self.__class__.__name__}({str(self.mobject)})"

</t>
<t tx="ekr.20250122151620.216">def __repr__(self) -&gt; str:
    return str(self)

</t>
<t tx="ekr.20250122151620.217">def begin(self) -&gt; None:
    """Begin the animation.

    This method is called right as an animation is being played. As much
    initialization as possible, especially any mobject copying, should live in this
    method.

    """
    self.starting_mobject = self.create_starting_mobject()
    if self.suspend_mobject_updating:
        # All calls to self.mobject's internal updaters
        # during the animation, either from this Animation
        # or from the surrounding scene, should do nothing.
        # It is, however, okay and desirable to call
        # the internal updaters of self.starting_mobject,
        # or any others among self.get_all_mobjects()
        self.mobject.suspend_updating()
    self.interpolate(0)

</t>
<t tx="ekr.20250122151620.218">def finish(self) -&gt; None:
    # TODO: begin and finish should require a scene as parameter.
    # That way Animation.clean_up_from_screen and Scene.add_mobjects_from_animations
    # could be removed as they fulfill basically the same purpose.
    """Finish the animation.

    This method gets called when the animation is over.

    """
    self.interpolate(1)
    if self.suspend_mobject_updating and self.mobject is not None:
        self.mobject.resume_updating()

</t>
<t tx="ekr.20250122151620.219">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    """Clean up the :class:`~.Scene` after finishing the animation.

    This includes to :meth:`~.Scene.remove` the Animation's
    :class:`~.Mobject` if the animation is a remover.

    Parameters
    ----------
    scene
        The scene the animation should be cleaned up from.
    """
    self._on_finish(scene)
    if self.is_remover():
        scene.remove(self.mobject)

</t>
<t tx="ekr.20250122151620.22">def set_file_logger(scene_name: str, module_name: str, log_dir: Path) -&gt; None:
    """Add a file handler to manim logger.

    The path to the file is built using ``config.log_dir``.

    Parameters
    ----------
    scene_name
        The name of the scene, used in the name of the log file.
    module_name
        The name of the module, used in the name of the log file.
    log_dir
        Path to the folder where log files are stored.
    """
    # Note: The log file name will be
    # &lt;name_of_animation_file&gt;_&lt;name_of_scene&gt;.log, gotten from config.  So it
    # can differ from the real name of the scene.  &lt;name_of_scene&gt; would only
    # appear if scene name was provided when manim was called.
    log_file_name = f"{module_name}_{scene_name}.log"
    log_file_path = log_dir / log_file_name

    file_handler = logging.FileHandler(log_file_path, mode="w")
    file_handler.setFormatter(JSONFormatter())

    logger = logging.getLogger("manim")
    logger.addHandler(file_handler)
    logger.info("Log file will be saved in %(logpath)s", {"logpath": log_file_path})


</t>
<t tx="ekr.20250122151620.220">def _setup_scene(self, scene: Scene) -&gt; None:
    """Setup up the :class:`~.Scene` before starting the animation.

    This includes to :meth:`~.Scene.add` the Animation's
    :class:`~.Mobject` if the animation is an introducer.

    Parameters
    ----------
    scene
        The scene the animation should be cleaned up from.
    """
    if scene is None:
        return
    if (
        self.is_introducer()
        and self.mobject not in scene.get_mobject_family_members()
    ):
        scene.add(self.mobject)

</t>
<t tx="ekr.20250122151620.221">def create_starting_mobject(self) -&gt; Mobject:
    # Keep track of where the mobject starts
    return self.mobject.copy()

</t>
<t tx="ekr.20250122151620.222">def get_all_mobjects(self) -&gt; Sequence[Mobject]:
    """Get all mobjects involved in the animation.

    Ordering must match the ordering of arguments to interpolate_submobject

    Returns
    -------
    Sequence[Mobject]
        The sequence of mobjects.
    """
    return self.mobject, self.starting_mobject

</t>
<t tx="ekr.20250122151620.223">def get_all_families_zipped(self) -&gt; Iterable[tuple]:
    if config["renderer"] == RendererType.OPENGL:
        return zip(*(mob.get_family() for mob in self.get_all_mobjects()))
    return zip(
        *(mob.family_members_with_points() for mob in self.get_all_mobjects())
    )

</t>
<t tx="ekr.20250122151620.224">def update_mobjects(self, dt: float) -&gt; None:
    """
    Updates things like starting_mobject, and (for
    Transforms) target_mobject.  Note, since typically
    (always?) self.mobject will have its updating
    suspended during the animation, this will do
    nothing to self.mobject.
    """
    for mob in self.get_all_mobjects_to_update():
        mob.update(dt)

</t>
<t tx="ekr.20250122151620.225">def get_all_mobjects_to_update(self) -&gt; list[Mobject]:
    """Get all mobjects to be updated during the animation.

    Returns
    -------
    List[Mobject]
        The list of mobjects to be updated during the animation.
    """
    # The surrounding scene typically handles
    # updating of self.mobject.  Besides, in
    # most cases its updating is suspended anyway
    return list(filter(lambda m: m is not self.mobject, self.get_all_mobjects()))

</t>
<t tx="ekr.20250122151620.226">def copy(self) -&gt; Animation:
    """Create a copy of the animation.

    Returns
    -------
    Animation
        A copy of ``self``
    """
    return deepcopy(self)

</t>
<t tx="ekr.20250122151620.227"># Methods for interpolation, the mean of an Animation

# TODO: stop using alpha as parameter name in different meanings.
def interpolate(self, alpha: float) -&gt; None:
    """Set the animation progress.

    This method gets called for every frame during an animation.

    Parameters
    ----------
    alpha
        The relative time to set the animation to, 0 meaning the start, 1 meaning
        the end.
    """
    self.interpolate_mobject(alpha)

</t>
<t tx="ekr.20250122151620.228">def interpolate_mobject(self, alpha: float) -&gt; None:
    """Interpolates the mobject of the :class:`Animation` based on alpha value.

    Parameters
    ----------
    alpha
        A float between 0 and 1 expressing the ratio to which the animation
        is completed. For example, alpha-values of 0, 0.5, and 1 correspond
        to the animation being completed 0%, 50%, and 100%, respectively.
    """
    families = list(self.get_all_families_zipped())
    for i, mobs in enumerate(families):
        sub_alpha = self.get_sub_alpha(alpha, i, len(families))
        self.interpolate_submobject(*mobs, sub_alpha)

</t>
<t tx="ekr.20250122151620.229">def interpolate_submobject(
    self,
    submobject: Mobject,
    starting_submobject: Mobject,
    # target_copy: Mobject, #Todo: fix - signature of interpolate_submobject differs in Transform().
    alpha: float,
) -&gt; Animation:
    # Typically implemented by subclass
    pass

</t>
<t tx="ekr.20250122151620.23">class JSONFormatter(logging.Formatter):
    """A formatter that outputs logs in a custom JSON format.

    This class is used internally for testing purposes.

    """

    @others
</t>
<t tx="ekr.20250122151620.230">def get_sub_alpha(self, alpha: float, index: int, num_submobjects: int) -&gt; float:
    """Get the animation progress of any submobjects subanimation.

    Parameters
    ----------
    alpha
        The overall animation progress
    index
        The index of the subanimation.
    num_submobjects
        The total count of subanimations.

    Returns
    -------
    float
        The progress of the subanimation.
    """
    # TODO, make this more understandable, and/or combine
    # its functionality with AnimationGroup's method
    # build_animations_with_timings
    lag_ratio = self.lag_ratio
    full_length = (num_submobjects - 1) * lag_ratio + 1
    value = alpha * full_length
    lower = index * lag_ratio
    if self.reverse_rate_function:
        return self.rate_func(1 - (value - lower))
    else:
        return self.rate_func(value - lower)

</t>
<t tx="ekr.20250122151620.231"># Getters and setters
def set_run_time(self, run_time: float) -&gt; Animation:
    """Set the run time of the animation.

    Parameters
    ----------
    run_time
        The new time the animation should take in seconds.

    .. note::

        The run_time of an animation should not be changed while it is already
        running.

    Returns
    -------
    Animation
        ``self``
    """
    self.run_time = run_time
    return self

</t>
<t tx="ekr.20250122151620.232"># TODO: is this getter even necessary?
def get_run_time(self) -&gt; float:
    """Get the run time of the animation.

    Returns
    -------
    float
        The time the animation takes in seconds.
    """
    return self.run_time

</t>
<t tx="ekr.20250122151620.233">def set_rate_func(
    self,
    rate_func: Callable[[float], float],
) -&gt; Animation:
    """Set the rate function of the animation.

    Parameters
    ----------
    rate_func
        The new function defining the animation progress based on the
        relative runtime (see :mod:`~.rate_functions`).

    Returns
    -------
    Animation
        ``self``
    """
    self.rate_func = rate_func
    return self

</t>
<t tx="ekr.20250122151620.234">def get_rate_func(
    self,
) -&gt; Callable[[float], float]:
    """Get the rate function of the animation.

    Returns
    -------
    Callable[[float], float]
        The rate function of the animation.
    """
    return self.rate_func

</t>
<t tx="ekr.20250122151620.235">def set_name(self, name: str) -&gt; Animation:
    """Set the name of the animation.

    Parameters
    ----------
    name
        The new name of the animation.

    Returns
    -------
    Animation
        ``self``
    """
    self.name = name
    return self

</t>
<t tx="ekr.20250122151620.236">def is_remover(self) -&gt; bool:
    """Test if the animation is a remover.

    Returns
    -------
    bool
        ``True`` if the animation is a remover, ``False`` otherwise.
    """
    return self.remover

</t>
<t tx="ekr.20250122151620.237">def is_introducer(self) -&gt; bool:
    """Test if the animation is an introducer.

    Returns
    -------
    bool
        ``True`` if the animation is an introducer, ``False`` otherwise.
    """
    return self.introducer

</t>
<t tx="ekr.20250122151620.238">@classmethod
def __init_subclass__(cls, **kwargs) -&gt; None:
    super().__init_subclass__(**kwargs)

    cls._original__init__ = cls.__init__

</t>
<t tx="ekr.20250122151620.239">@classmethod
def set_default(cls, **kwargs) -&gt; None:
    """Sets the default values of keyword arguments.

    If this method is called without any additional keyword
    arguments, the original default values of the initialization
    method of this class are restored.

    Parameters
    ----------

    kwargs
        Passing any keyword argument will update the default
        values of the keyword arguments of the initialization
        function of this class.

    Examples
    --------

    .. manim:: ChangeDefaultAnimation

        class ChangeDefaultAnimation(Scene):
            def construct(self):
                Rotate.set_default(run_time=2, rate_func=rate_functions.linear)
                Indicate.set_default(color=None)

                S = Square(color=BLUE, fill_color=BLUE, fill_opacity=0.25)
                self.add(S)
                self.play(Rotate(S, PI))
                self.play(Indicate(S))

                Rotate.set_default()
                Indicate.set_default()

    """
    if kwargs:
        cls.__init__ = partialmethod(cls.__init__, **kwargs)
    else:
        cls.__init__ = cls._original__init__


</t>
<t tx="ekr.20250122151620.24">def format(self, record: logging.LogRecord) -&gt; str:
    """Format the record in a custom JSON format."""
    record_c = copy.deepcopy(record)
    if record_c.args:
        for arg in record_c.args:
            record_c.args[arg] = "&lt;&gt;"
    return json.dumps(
        {
            "levelname": record_c.levelname,
            "module": record_c.module,
            "message": super().format(record_c),
        },
    )
</t>
<t tx="ekr.20250122151620.240">def __init__(
    self,
    run_time: float = 1,
    stop_condition: Callable[[], bool] | None = None,
    frozen_frame: bool | None = None,
    rate_func: Callable[[float], float] = linear,
    **kwargs,
):
    if stop_condition and frozen_frame:
        raise ValueError("A static Wait animation cannot have a stop condition.")

    self.duration: float = run_time
    self.stop_condition = stop_condition
    self.is_static_wait: bool = frozen_frame
    super().__init__(None, run_time=run_time, rate_func=rate_func, **kwargs)
    # quick fix to work in opengl setting:
    self.mobject.shader_wrapper_list = []

</t>
<t tx="ekr.20250122151620.241">def begin(self) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151620.242">def finish(self) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151620.243">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151620.244">def update_mobjects(self, dt: float) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151620.245">def interpolate(self, alpha: float) -&gt; None:
    pass


</t>
<t tx="ekr.20250122151620.246">def __init__(
    self, *mobjects: Mobject, run_time: float = 0.0, **kwargs: Any
) -&gt; None:
    mobject = mobjects[0] if len(mobjects) == 1 else Group(*mobjects)
    super().__init__(mobject, run_time=run_time, introducer=True, **kwargs)

</t>
<t tx="ekr.20250122151620.247">def begin(self) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151620.248">def finish(self) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151620.249">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151620.25">"""Utilities to create and set the config.

The main class exported by this module is :class:`ManimConfig`.  This class
contains all configuration options, including frame geometry (e.g. frame
height/width, frame rate), output (e.g. directories, logging), styling
(e.g. background color, transparency), and general behavior (e.g. writing a
movie vs writing a single frame).

See :doc:`/guides/configuration` for an introduction to Manim's configuration system.

"""

from __future__ import annotations

import argparse
import configparser
import copy
import errno
import logging
import os
import re
import sys
from collections.abc import Iterable, Iterator, Mapping, MutableMapping
from pathlib import Path
from typing import TYPE_CHECKING, Any, ClassVar, NoReturn

import numpy as np

from manim import constants
from manim.constants import RendererType
from manim.utils.color import ManimColor
from manim.utils.tex import TexTemplate

if TYPE_CHECKING:
    from enum import EnumMeta

    from typing_extensions import Self

    from manim.typing import StrPath, Vector3D

__all__ = ["config_file_paths", "make_config_parser", "ManimConfig", "ManimFrame"]

logger = logging.getLogger("manim")


@others
for opt in list(ManimFrame._OPTS) + list(ManimFrame._CONSTANTS):
    setattr(ManimFrame, opt, property(lambda self, o=opt: self[o]))
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.250">def update_mobjects(self, dt: float) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151620.251">def interpolate(self, alpha: float) -&gt; None:
    pass


</t>
<t tx="ekr.20250122151620.252">"""Animation of a mobject boundary and tracing of points."""

from __future__ import annotations

__all__ = ["AnimatedBoundary", "TracedPath"]

from typing import Callable

from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.types.vectorized_mobject import VGroup, VMobject
from manim.utils.color import (
    BLUE_B,
    BLUE_D,
    BLUE_E,
    GREY_BROWN,
    WHITE,
    ParsableManimColor,
)
from manim.utils.rate_functions import smooth


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.253">class AnimatedBoundary(VGroup):
    """Boundary of a :class:`.VMobject` with animated color change.

    Examples
    --------
    .. manim:: AnimatedBoundaryExample

        class AnimatedBoundaryExample(Scene):
            def construct(self):
                text = Text("So shiny!")
                boundary = AnimatedBoundary(text, colors=[RED, GREEN, BLUE],
                                            cycle_rate=3)
                self.add(text, boundary)
                self.wait(2)

    """

    @others
</t>
<t tx="ekr.20250122151620.254">class TracedPath(VMobject, metaclass=ConvertToOpenGL):
    """Traces the path of a point returned by a function call.

    Parameters
    ----------
    traced_point_func
        The function to be traced.
    stroke_width
        The width of the trace.
    stroke_color
        The color of the trace.
    dissipating_time
        The time taken for the path to dissipate. Default set to ``None``
        which disables dissipation.

    Examples
    --------
    .. manim:: TracedPathExample

        class TracedPathExample(Scene):
            def construct(self):
                circ = Circle(color=RED).shift(4*LEFT)
                dot = Dot(color=RED).move_to(circ.get_start())
                rolling_circle = VGroup(circ, dot)
                trace = TracedPath(circ.get_start)
                rolling_circle.add_updater(lambda m: m.rotate(-0.3))
                self.add(trace, rolling_circle)
                self.play(rolling_circle.animate.shift(8*RIGHT), run_time=4, rate_func=linear)

    .. manim:: DissipatingPathExample

        class DissipatingPathExample(Scene):
            def construct(self):
                a = Dot(RIGHT * 2)
                b = TracedPath(a.get_center, dissipating_time=0.5, stroke_opacity=[0, 1])
                self.add(a, b)
                self.play(a.animate(path_arc=PI / 4).shift(LEFT * 2))
                self.play(a.animate(path_arc=-PI / 4).shift(LEFT * 2))
                self.wait()

    """

    @others
</t>
<t tx="ekr.20250122151620.255">def __init__(
    self,
    vmobject,
    colors=[BLUE_D, BLUE_B, BLUE_E, GREY_BROWN],
    max_stroke_width=3,
    cycle_rate=0.5,
    back_and_forth=True,
    draw_rate_func=smooth,
    fade_rate_func=smooth,
    **kwargs,
):
    super().__init__(**kwargs)
    self.colors = colors
    self.max_stroke_width = max_stroke_width
    self.cycle_rate = cycle_rate
    self.back_and_forth = back_and_forth
    self.draw_rate_func = draw_rate_func
    self.fade_rate_func = fade_rate_func
    self.vmobject = vmobject
    self.boundary_copies = [
        vmobject.copy().set_style(stroke_width=0, fill_opacity=0) for x in range(2)
    ]
    self.add(*self.boundary_copies)
    self.total_time = 0
    self.add_updater(lambda m, dt: self.update_boundary_copies(dt))

</t>
<t tx="ekr.20250122151620.256">def update_boundary_copies(self, dt):
    # Not actual time, but something which passes at
    # an altered rate to make the implementation below
    # cleaner
    time = self.total_time * self.cycle_rate
    growing, fading = self.boundary_copies
    colors = self.colors
    msw = self.max_stroke_width
    vmobject = self.vmobject

    index = int(time % len(colors))
    alpha = time % 1
    draw_alpha = self.draw_rate_func(alpha)
    fade_alpha = self.fade_rate_func(alpha)

    if self.back_and_forth and int(time) % 2 == 1:
        bounds = (1 - draw_alpha, 1)
    else:
        bounds = (0, draw_alpha)
    self.full_family_become_partial(growing, vmobject, *bounds)
    growing.set_stroke(colors[index], width=msw)

    if time &gt;= 1:
        self.full_family_become_partial(fading, vmobject, 0, 1)
        fading.set_stroke(color=colors[index - 1], width=(1 - fade_alpha) * msw)

    self.total_time += dt

</t>
<t tx="ekr.20250122151620.257">def full_family_become_partial(self, mob1, mob2, a, b):
    family1 = mob1.family_members_with_points()
    family2 = mob2.family_members_with_points()
    for sm1, sm2 in zip(family1, family2):
        sm1.pointwise_become_partial(sm2, a, b)
    return self


</t>
<t tx="ekr.20250122151620.258">def __init__(
    self,
    traced_point_func: Callable,
    stroke_width: float = 2,
    stroke_color: ParsableManimColor | None = WHITE,
    dissipating_time: float | None = None,
    **kwargs,
):
    super().__init__(stroke_color=stroke_color, stroke_width=stroke_width, **kwargs)
    self.traced_point_func = traced_point_func
    self.dissipating_time = dissipating_time
    self.time = 1 if self.dissipating_time else None
    self.add_updater(self.update_path)

</t>
<t tx="ekr.20250122151620.259">def update_path(self, mob, dt):
    new_point = self.traced_point_func()
    if not self.has_points():
        self.start_new_path(new_point)
    self.add_line_to(new_point)
    if self.dissipating_time:
        self.time += dt
        if self.time - 1 &gt; self.dissipating_time:
            nppcc = self.n_points_per_curve
            self.set_points(self.points[nppcc:])
</t>
<t tx="ekr.20250122151620.26">def config_file_paths() -&gt; list[Path]:
    """The paths where ``.cfg`` files will be searched for.

    When manim is first imported, it processes any ``.cfg`` files it finds.  This
    function returns the locations in which these files are searched for.  In
    ascending order of precedence, these are: the library-wide config file, the
    user-wide config file, and the folder-wide config file.

    The library-wide config file determines manim's default behavior.  The
    user-wide config file is stored in the user's home folder, and determines
    the behavior of manim whenever the user invokes it from anywhere in the
    system.  The folder-wide config file only affects scenes that are in the
    same folder.  The latter two files are optional.

    These files, if they exist, are meant to loaded into a single
    :class:`configparser.ConfigParser` object, and then processed by
    :class:`ManimConfig`.

    Returns
    -------
    List[:class:`Path`]
        List of paths which may contain ``.cfg`` files, in ascending order of
        precedence.

    See Also
    --------
    :func:`make_config_parser`, :meth:`ManimConfig.digest_file`,
    :meth:`ManimConfig.digest_parser`

    Notes
    -----
    The location of the user-wide config file is OS-specific.

    """
    library_wide = Path.resolve(Path(__file__).parent / "default.cfg")
    if sys.platform.startswith("win32"):
        user_wide = Path.home() / "AppData" / "Roaming" / "Manim" / "manim.cfg"
    else:
        user_wide = Path.home() / ".config" / "manim" / "manim.cfg"
    folder_wide = Path("manim.cfg")
    return [library_wide, user_wide, folder_wide]


</t>
<t tx="ekr.20250122151620.260">"""Tools for displaying multiple animations at once."""

from __future__ import annotations

import types
from collections.abc import Iterable, Sequence
from typing import TYPE_CHECKING, Callable

import numpy as np

from manim._config import config
from manim.animation.animation import Animation, prepare_animation
from manim.constants import RendererType
from manim.mobject.mobject import Group, Mobject
from manim.mobject.opengl.opengl_mobject import OpenGLGroup
from manim.scene.scene import Scene
from manim.utils.iterables import remove_list_redundancies
from manim.utils.parameter_parsing import flatten_iterable_parameters
from manim.utils.rate_functions import linear

if TYPE_CHECKING:
    from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVGroup
    from manim.mobject.types.vectorized_mobject import VGroup

__all__ = ["AnimationGroup", "Succession", "LaggedStart", "LaggedStartMap"]


DEFAULT_LAGGED_START_LAG_RATIO: float = 0.05


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.261">class AnimationGroup(Animation):
    """Plays a group or series of :class:`~.Animation`.

    Parameters
    ----------
    animations
        Sequence of :class:`~.Animation` objects to be played.
    group
        A group of multiple :class:`~.Mobject`.
    run_time
        The duration of the animation in seconds.
    rate_func
        The function defining the animation progress based on the relative
        runtime (see :mod:`~.rate_functions`) .
    lag_ratio
        Defines the delay after which the animation is applied to submobjects. A lag_ratio of
        ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.
        Defaults to 0.0, meaning that all animations will be played together.

        This does not influence the total runtime of the animation. Instead the runtime
        of individual animations is adjusted so that the complete animation has the defined
        run time.
    """

    @others
</t>
<t tx="ekr.20250122151620.262">class Succession(AnimationGroup):
    """Plays a series of animations in succession.

    Parameters
    ----------
    animations
        Sequence of :class:`~.Animation` objects to be played.
    lag_ratio
        Defines the delay after which the animation is applied to submobjects. A lag_ratio of
        ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.
        Defaults to 1.0, meaning that the next animation will begin when 100% of the current
        animation has played.

        This does not influence the total runtime of the animation. Instead the runtime
        of individual animations is adjusted so that the complete animation has the defined
        run time.

    Examples
    --------
    .. manim:: SuccessionExample

        class SuccessionExample(Scene):
            def construct(self):
                dot1 = Dot(point=LEFT * 2 + UP * 2, radius=0.16, color=BLUE)
                dot2 = Dot(point=LEFT * 2 + DOWN * 2, radius=0.16, color=MAROON)
                dot3 = Dot(point=RIGHT * 2 + DOWN * 2, radius=0.16, color=GREEN)
                dot4 = Dot(point=RIGHT * 2 + UP * 2, radius=0.16, color=YELLOW)
                self.add(dot1, dot2, dot3, dot4)

                self.play(Succession(
                    dot1.animate.move_to(dot2),
                    dot2.animate.move_to(dot3),
                    dot3.animate.move_to(dot4),
                    dot4.animate.move_to(dot1)
                ))
    """

    @others
</t>
<t tx="ekr.20250122151620.263">class LaggedStart(AnimationGroup):
    """Adjusts the timing of a series of :class:`~.Animation` according to ``lag_ratio``.

    Parameters
    ----------
    animations
        Sequence of :class:`~.Animation` objects to be played.
    lag_ratio
        Defines the delay after which the animation is applied to submobjects. A lag_ratio of
        ``n.nn`` means the next animation will play when ``nnn%`` of the current animation has played.
        Defaults to 0.05, meaning that the next animation will begin when 5% of the current
        animation has played.

        This does not influence the total runtime of the animation. Instead the runtime
        of individual animations is adjusted so that the complete animation has the defined
        run time.

    Examples
    --------
    .. manim:: LaggedStartExample

        class LaggedStartExample(Scene):
            def construct(self):
                title = Text("lag_ratio = 0.25").to_edge(UP)

                dot1 = Dot(point=LEFT * 2 + UP, radius=0.16)
                dot2 = Dot(point=LEFT * 2, radius=0.16)
                dot3 = Dot(point=LEFT * 2 + DOWN, radius=0.16)
                line_25 = DashedLine(
                    start=LEFT + UP * 2,
                    end=LEFT + DOWN * 2,
                    color=RED
                )
                label = Text("25%", font_size=24).next_to(line_25, UP)
                self.add(title, dot1, dot2, dot3, line_25, label)

                self.play(LaggedStart(
                    dot1.animate.shift(RIGHT * 4),
                    dot2.animate.shift(RIGHT * 4),
                    dot3.animate.shift(RIGHT * 4),
                    lag_ratio=0.25,
                    run_time=4
                ))
    """

    @others
</t>
<t tx="ekr.20250122151620.264">class LaggedStartMap(LaggedStart):
    """Plays a series of :class:`~.Animation` while mapping a function to submobjects.

    Parameters
    ----------
    AnimationClass
        :class:`~.Animation` to apply to mobject.
    mobject
        :class:`~.Mobject` whose submobjects the animation, and optionally the function,
        are to be applied.
    arg_creator
        Function which will be applied to :class:`~.Mobject`.
    run_time
        The duration of the animation in seconds.

    Examples
    --------
    .. manim:: LaggedStartMapExample

        class LaggedStartMapExample(Scene):
            def construct(self):
                title = Tex("LaggedStartMap").to_edge(UP, buff=LARGE_BUFF)
                dots = VGroup(
                    *[Dot(radius=0.16) for _ in range(35)]
                    ).arrange_in_grid(rows=5, cols=7, buff=MED_LARGE_BUFF)
                self.add(dots, title)

                # Animate yellow ripple effect
                for mob in dots, title:
                    self.play(LaggedStartMap(
                        ApplyMethod, mob,
                        lambda m : (m.set_color, YELLOW),
                        lag_ratio = 0.1,
                        rate_func = there_and_back,
                        run_time = 2
                    ))
    """

    @others
</t>
<t tx="ekr.20250122151620.265">def __init__(
    self,
    *animations: Animation | Iterable[Animation] | types.GeneratorType[Animation],
    group: Group | VGroup | OpenGLGroup | OpenGLVGroup = None,
    run_time: float | None = None,
    rate_func: Callable[[float], float] = linear,
    lag_ratio: float = 0,
    **kwargs,
) -&gt; None:
    arg_anim = flatten_iterable_parameters(animations)
    self.animations = [prepare_animation(anim) for anim in arg_anim]
    self.rate_func = rate_func
    self.group = group
    if self.group is None:
        mobjects = remove_list_redundancies(
            [anim.mobject for anim in self.animations if not anim.is_introducer()],
        )
        if config["renderer"] == RendererType.OPENGL:
            self.group = OpenGLGroup(*mobjects)
        else:
            self.group = Group(*mobjects)
    super().__init__(
        self.group, rate_func=self.rate_func, lag_ratio=lag_ratio, **kwargs
    )
    self.run_time: float = self.init_run_time(run_time)

</t>
<t tx="ekr.20250122151620.266">def get_all_mobjects(self) -&gt; Sequence[Mobject]:
    return list(self.group)

</t>
<t tx="ekr.20250122151620.267">def begin(self) -&gt; None:
    if not self.animations:
        raise ValueError(
            f"Trying to play {self} without animations, this is not supported. "
            "Please add at least one subanimation."
        )
    self.anim_group_time = 0.0
    if self.suspend_mobject_updating:
        self.group.suspend_updating()
    for anim in self.animations:
        anim.begin()

</t>
<t tx="ekr.20250122151620.268">def _setup_scene(self, scene) -&gt; None:
    for anim in self.animations:
        anim._setup_scene(scene)

</t>
<t tx="ekr.20250122151620.269">def finish(self) -&gt; None:
    for anim in self.animations:
        anim.finish()
    self.anims_begun[:] = True
    self.anims_finished[:] = True
    if self.suspend_mobject_updating:
        self.group.resume_updating()

</t>
<t tx="ekr.20250122151620.27">def make_config_parser(
    custom_file: StrPath | None = None,
) -&gt; configparser.ConfigParser:
    """Make a :class:`ConfigParser` object and load any ``.cfg`` files.

    The user-wide file, if it exists, overrides the library-wide file.  The
    folder-wide file, if it exists, overrides the other two.

    The folder-wide file can be ignored by passing ``custom_file``.  However,
    the user-wide and library-wide config files cannot be ignored.

    Parameters
    ----------
    custom_file
        Path to a custom config file.  If used, the folder-wide file in the
        relevant directory will be ignored, if it exists.  If None, the
        folder-wide file will be used, if it exists.

    Returns
    -------
    :class:`ConfigParser`
        A parser containing the config options found in the .cfg files that
        were found.  It is guaranteed to contain at least the config options
        found in the library-wide file.

    See Also
    --------
    :func:`config_file_paths`

    """
    library_wide, user_wide, folder_wide = config_file_paths()
    # From the documentation: "An application which requires initial values to
    # be loaded from a file should load the required file or files using
    # read_file() before calling read() for any optional files."
    # https://docs.python.org/3/library/configparser.html#configparser.ConfigParser.read
    parser = configparser.ConfigParser()
    with library_wide.open() as file:
        parser.read_file(file)  # necessary file

    other_files = [user_wide, Path(custom_file) if custom_file else folder_wide]
    parser.read(other_files)  # optional files

    return parser


</t>
<t tx="ekr.20250122151620.270">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    self._on_finish(scene)
    for anim in self.animations:
        if self.remover:
            anim.remover = self.remover
        anim.clean_up_from_scene(scene)

</t>
<t tx="ekr.20250122151620.271">def update_mobjects(self, dt: float) -&gt; None:
    for anim in self.anims_with_timings["anim"][
        self.anims_begun &amp; ~self.anims_finished
    ]:
        anim.update_mobjects(dt)

</t>
<t tx="ekr.20250122151620.272">def init_run_time(self, run_time) -&gt; float:
    """Calculates the run time of the animation, if different from ``run_time``.

    Parameters
    ----------
    run_time
        The duration of the animation in seconds.

    Returns
    -------
    run_time
        The duration of the animation in seconds.
    """
    self.build_animations_with_timings()
    # Note: if lag_ratio &lt; 1, then not necessarily the final animation's
    # end time will be the max end time! Therefore we must calculate the
    # maximum over all the end times, and not just take the last one.
    # Example: if you want to play 2 animations of 10s and 1s with a
    # lag_ratio of 0.1, the 1st one will end at t=10 and the 2nd one will
    # end at t=2, so the AnimationGroup will end at t=10.
    self.max_end_time = max(self.anims_with_timings["end"], default=0)
    return self.max_end_time if run_time is None else run_time

</t>
<t tx="ekr.20250122151620.273">def build_animations_with_timings(self) -&gt; None:
    """Creates a list of triplets of the form (anim, start_time, end_time)."""
    run_times = np.array([anim.run_time for anim in self.animations])
    num_animations = run_times.shape[0]
    dtype = [("anim", "O"), ("start", "f8"), ("end", "f8")]
    self.anims_with_timings = np.zeros(num_animations, dtype=dtype)
    self.anims_begun = np.zeros(num_animations, dtype=bool)
    self.anims_finished = np.zeros(num_animations, dtype=bool)
    if num_animations == 0:
        return

    lags = run_times[:-1] * self.lag_ratio
    self.anims_with_timings["anim"] = self.animations
    self.anims_with_timings["start"][1:] = np.add.accumulate(lags)
    self.anims_with_timings["end"] = self.anims_with_timings["start"] + run_times

</t>
<t tx="ekr.20250122151620.274">def interpolate(self, alpha: float) -&gt; None:
    # Note, if the run_time of AnimationGroup has been
    # set to something other than its default, these
    # times might not correspond to actual times,
    # e.g. of the surrounding scene.  Instead they'd
    # be a rescaled version.  But that's okay!
    anim_group_time = self.rate_func(alpha) * self.max_end_time
    time_goes_back = anim_group_time &lt; self.anim_group_time

    # Only update ongoing animations
    awt = self.anims_with_timings
    new_begun = anim_group_time &gt;= awt["start"]
    new_finished = anim_group_time &gt; awt["end"]
    to_update = awt[
        (self.anims_begun | new_begun) &amp; (~self.anims_finished | ~new_finished)
    ]

    run_times = to_update["end"] - to_update["start"]
    with_zero_run_time = run_times == 0
    run_times[with_zero_run_time] = 1
    sub_alphas = (anim_group_time - to_update["start"]) / run_times
    if time_goes_back:
        sub_alphas[(sub_alphas &lt; 0) | with_zero_run_time] = 0
    else:
        sub_alphas[(sub_alphas &gt; 1) | with_zero_run_time] = 1

    for anim_to_update, sub_alpha in zip(to_update["anim"], sub_alphas):
        anim_to_update.interpolate(sub_alpha)

    self.anim_group_time = anim_group_time
    self.anims_begun = new_begun
    self.anims_finished = new_finished


</t>
<t tx="ekr.20250122151620.275">def __init__(self, *animations: Animation, lag_ratio: float = 1, **kwargs) -&gt; None:
    super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)

</t>
<t tx="ekr.20250122151620.276">def begin(self) -&gt; None:
    if not self.animations:
        raise ValueError(
            f"Trying to play {self} without animations, this is not supported. "
            "Please add at least one subanimation."
        )
    self.update_active_animation(0)

</t>
<t tx="ekr.20250122151620.277">def finish(self) -&gt; None:
    while self.active_animation is not None:
        self.next_animation()

</t>
<t tx="ekr.20250122151620.278">def update_mobjects(self, dt: float) -&gt; None:
    if self.active_animation:
        self.active_animation.update_mobjects(dt)

</t>
<t tx="ekr.20250122151620.279">def _setup_scene(self, scene) -&gt; None:
    if scene is None:
        return
    if self.is_introducer():
        for anim in self.animations:
            if not anim.is_introducer() and anim.mobject is not None:
                scene.add(anim.mobject)

    self.scene = scene

</t>
<t tx="ekr.20250122151620.28">def _determine_quality(qual: str) -&gt; str:
    for quality, values in constants.QUALITIES.items():
        if values["flag"] is not None and values["flag"] == qual:
            return quality

    return qual


</t>
<t tx="ekr.20250122151620.280">def update_active_animation(self, index: int) -&gt; None:
    self.active_index = index
    if index &gt;= len(self.animations):
        self.active_animation: Animation | None = None
        self.active_start_time: float | None = None
        self.active_end_time: float | None = None
    else:
        self.active_animation = self.animations[index]
        self.active_animation._setup_scene(self.scene)
        self.active_animation.begin()
        self.active_start_time = self.anims_with_timings[index]["start"]
        self.active_end_time = self.anims_with_timings[index]["end"]

</t>
<t tx="ekr.20250122151620.281">def next_animation(self) -&gt; None:
    """Proceeds to the next animation.

    This method is called right when the active animation finishes.
    """
    if self.active_animation is not None:
        self.active_animation.finish()
    self.update_active_animation(self.active_index + 1)

</t>
<t tx="ekr.20250122151620.282">def interpolate(self, alpha: float) -&gt; None:
    current_time = self.rate_func(alpha) * self.max_end_time
    while self.active_end_time is not None and current_time &gt;= self.active_end_time:
        self.next_animation()
    if self.active_animation is not None and self.active_start_time is not None:
        elapsed = current_time - self.active_start_time
        active_run_time = self.active_animation.run_time
        subalpha = elapsed / active_run_time if active_run_time != 0.0 else 1.0
        self.active_animation.interpolate(subalpha)


</t>
<t tx="ekr.20250122151620.283">def __init__(
    self,
    *animations: Animation,
    lag_ratio: float = DEFAULT_LAGGED_START_LAG_RATIO,
    **kwargs,
):
    super().__init__(*animations, lag_ratio=lag_ratio, **kwargs)


</t>
<t tx="ekr.20250122151620.284">def __init__(
    self,
    AnimationClass: Callable[..., Animation],
    mobject: Mobject,
    arg_creator: Callable[[Mobject], str] = None,
    run_time: float = 2,
    **kwargs,
) -&gt; None:
    args_list = []
    for submob in mobject:
        if arg_creator:
            args_list.append(arg_creator(submob))
        else:
            args_list.append((submob,))
    anim_kwargs = dict(kwargs)
    if "lag_ratio" in anim_kwargs:
        anim_kwargs.pop("lag_ratio")
    animations = [AnimationClass(*args, **anim_kwargs) for args in args_list]
    super().__init__(*animations, run_time=run_time, **kwargs)
</t>
<t tx="ekr.20250122151620.285">r"""Animate the display or removal of a mobject from a scene.

.. manim:: CreationModule
    :hide_source:

    from manim import ManimBanner
    class CreationModule(Scene):
        def construct(self):
            s1 = Square()
            s2 = Square()
            s3 = Square()
            s4 = Square()
            VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.9).shift(UP)
            s5 = Square()
            s6 = Square()
            s7 = Square()
            VGroup(s5, s6, s7).set_x(0).arrange(buff=2.6).shift(2 * DOWN)
            t1 = Text("Write", font_size=24).next_to(s1, UP)
            t2 = Text("AddTextLetterByLetter", font_size=24).next_to(s2, UP)
            t3 = Text("Create", font_size=24).next_to(s3, UP)
            t4 = Text("Uncreate", font_size=24).next_to(s4, UP)
            t5 = Text("DrawBorderThenFill", font_size=24).next_to(s5, UP)
            t6 = Text("ShowIncreasingSubsets", font_size=22).next_to(s6, UP)
            t7 = Text("ShowSubmobjectsOneByOne", font_size=22).next_to(s7, UP)

            self.add(s1, s2, s3, s4, s5, s6, s7, t1, t2, t3, t4, t5, t6, t7)

            texts = [Text("manim", font_size=29), Text("manim", font_size=29)]
            texts[0].move_to(s1.get_center())
            texts[1].move_to(s2.get_center())
            self.add(*texts)

            objs = [ManimBanner().scale(0.25) for _ in range(5)]
            objs[0].move_to(s3.get_center())
            objs[1].move_to(s4.get_center())
            objs[2].move_to(s5.get_center())
            objs[3].move_to(s6.get_center())
            objs[4].move_to(s7.get_center())
            self.add(*objs)

            self.play(
                # text creation
                Write(texts[0]),
                AddTextLetterByLetter(texts[1]),
                # mobject creation
                Create(objs[0]),
                Uncreate(objs[1]),
                DrawBorderThenFill(objs[2]),
                ShowIncreasingSubsets(objs[3]),
                ShowSubmobjectsOneByOne(objs[4]),
                run_time=3,
            )

            self.wait()

"""

from __future__ import annotations

__all__ = [
    "Create",
    "Uncreate",
    "DrawBorderThenFill",
    "Write",
    "Unwrite",
    "ShowPartial",
    "ShowIncreasingSubsets",
    "SpiralIn",
    "AddTextLetterByLetter",
    "RemoveTextLetterByLetter",
    "ShowSubmobjectsOneByOne",
    "AddTextWordByWord",
    "TypeWithCursor",
    "UntypeWithCursor",
]


import itertools as it
from collections.abc import Iterable, Sequence
from typing import TYPE_CHECKING, Callable

import numpy as np

if TYPE_CHECKING:
    from manim.mobject.text.text_mobject import Text
    from manim.scene.scene import Scene

from manim.constants import RIGHT, TAU
from manim.mobject.opengl.opengl_surface import OpenGLSurface
from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject
from manim.utils.color import ManimColor

from .. import config
from ..animation.animation import Animation
from ..animation.composition import Succession
from ..mobject.mobject import Group, Mobject
from ..mobject.types.vectorized_mobject import VMobject
from ..utils.bezier import integer_interpolate
from ..utils.rate_functions import double_smooth, linear


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.286">class ShowPartial(Animation):
    """Abstract class for Animations that show the VMobject partially.

    Raises
    ------
    :class:`TypeError`
        If ``mobject`` is not an instance of :class:`~.VMobject`.

    See Also
    --------
    :class:`Create`, :class:`~.ShowPassingFlash`

    """

    @others
</t>
<t tx="ekr.20250122151620.287">class Create(ShowPartial):
    """Incrementally show a VMobject.

    Parameters
    ----------
    mobject
        The VMobject to animate.

    Raises
    ------
    :class:`TypeError`
        If ``mobject`` is not an instance of :class:`~.VMobject`.

    Examples
    --------
    .. manim:: CreateScene

        class CreateScene(Scene):
            def construct(self):
                self.play(Create(Square()))

    See Also
    --------
    :class:`~.ShowPassingFlash`

    """

    @others
</t>
<t tx="ekr.20250122151620.288">class Uncreate(Create):
    """Like :class:`Create` but in reverse.

    Examples
    --------
    .. manim:: ShowUncreate

        class ShowUncreate(Scene):
            def construct(self):
                self.play(Uncreate(Square()))

    See Also
    --------
    :class:`Create`

    """

    @others
</t>
<t tx="ekr.20250122151620.289">class DrawBorderThenFill(Animation):
    """Draw the border first and then show the fill.

    Examples
    --------
    .. manim:: ShowDrawBorderThenFill

        class ShowDrawBorderThenFill(Scene):
            def construct(self):
                self.play(DrawBorderThenFill(Square(fill_opacity=1, fill_color=ORANGE)))
    """

    @others
</t>
<t tx="ekr.20250122151620.29">class ManimConfig(MutableMapping):
    """Dict-like class storing all config options.

    The global ``config`` object is an instance of this class, and acts as a
    single source of truth for all of the library's customizable behavior.

    The global ``config`` object is capable of digesting different types of
    sources and converting them into a uniform interface.  These sources are
    (in ascending order of precedence): configuration files, command line
    arguments, and programmatic changes.  Regardless of how the user chooses to
    set a config option, she can access its current value using
    :class:`ManimConfig`'s attributes and properties.

    Notes
    -----
    Each config option is implemented as a property of this class.

    Each config option can be set via a config file, using the full name of the
    property.  If a config option has an associated CLI flag, then the flag is
    equal to the full name of the property.  Those that admit an alternative
    flag or no flag at all are documented in the individual property's
    docstring.

    Examples
    --------
    We use a copy of the global configuration object in the following
    examples for the sake of demonstration; you can skip these lines
    and just import ``config`` directly if you actually want to modify
    the configuration:

    .. code-block:: pycon

        &gt;&gt;&gt; from manim import config as global_config
        &gt;&gt;&gt; config = global_config.copy()

    Each config option allows for dict syntax and attribute syntax.  For
    example, the following two lines are equivalent,

    .. code-block:: pycon

        &gt;&gt;&gt; from manim import WHITE
        &gt;&gt;&gt; config.background_color = WHITE
        &gt;&gt;&gt; config["background_color"] = WHITE

    The former is preferred; the latter is provided mostly for backwards
    compatibility.

    The config options are designed to keep internal consistency.  For example,
    setting ``frame_y_radius`` will affect ``frame_height``:

    .. code-block:: pycon

        &gt;&gt;&gt; config.frame_height
        8.0
        &gt;&gt;&gt; config.frame_y_radius = 5.0
        &gt;&gt;&gt; config.frame_height
        10.0

    There are many ways of interacting with config options.  Take for example
    the config option ``background_color``.  There are three ways to change it:
    via a config file, via CLI flags, or programmatically.

    To set the background color via a config file, save the following
    ``manim.cfg`` file with the following contents.

    .. code-block::

       [CLI]
       background_color = WHITE

    In order to have this ``.cfg`` file apply to a manim scene, it needs to be
    placed in the same directory as the script,

    .. code-block:: bash

          project/
          ├─scene.py
          └─manim.cfg

    Now, when the user executes

    .. code-block:: bash

        manim scene.py

    the background of the scene will be set to ``WHITE``.  This applies regardless
    of where the manim command is invoked from.

    Command line arguments override ``.cfg`` files.  In the previous example,
    executing

    .. code-block:: bash

        manim scene.py -c BLUE

    will set the background color to BLUE, regardless of the contents of
    ``manim.cfg``.

    Finally, any programmatic changes made within the scene script itself will
    override the command line arguments.  For example, if ``scene.py`` contains
    the following

    .. code-block:: python

        from manim import *

        config.background_color = RED


        class MyScene(Scene): ...

    the background color will be set to RED, regardless of the contents of
    ``manim.cfg`` or the CLI arguments used when invoking manim.

    """

    @others
</t>
<t tx="ekr.20250122151620.290">class Write(DrawBorderThenFill):
    """Simulate hand-writing a :class:`~.Text` or hand-drawing a :class:`~.VMobject`.

    Examples
    --------
    .. manim:: ShowWrite

        class ShowWrite(Scene):
            def construct(self):
                self.play(Write(Text("Hello", font_size=144)))

    .. manim:: ShowWriteReversed

        class ShowWriteReversed(Scene):
            def construct(self):
                self.play(Write(Text("Hello", font_size=144), reverse=True, remover=False))

    Tests
    -----

    Check that creating empty :class:`.Write` animations works::

        &gt;&gt;&gt; from manim import Write, Text
        &gt;&gt;&gt; Write(Text(''))
        Write(Text(''))
    """

    @others
</t>
<t tx="ekr.20250122151620.291">class Unwrite(Write):
    """Simulate erasing by hand a :class:`~.Text` or a :class:`~.VMobject`.

    Parameters
    ----------
    reverse
        Set True to have the animation start erasing from the last submobject first.

    Examples
    --------

    .. manim :: UnwriteReverseTrue

        class UnwriteReverseTrue(Scene):
            def construct(self):
                text = Tex("Alice and Bob").scale(3)
                self.add(text)
                self.play(Unwrite(text))

    .. manim:: UnwriteReverseFalse

        class UnwriteReverseFalse(Scene):
            def construct(self):
                text = Tex("Alice and Bob").scale(3)
                self.add(text)
                self.play(Unwrite(text, reverse=False))
    """

    @others
</t>
<t tx="ekr.20250122151620.292">class SpiralIn(Animation):
    @others
</t>
<t tx="ekr.20250122151620.293">class ShowIncreasingSubsets(Animation):
    """Show one submobject at a time, leaving all previous ones displayed on screen.

    Examples
    --------

    .. manim:: ShowIncreasingSubsetsScene

        class ShowIncreasingSubsetsScene(Scene):
            def construct(self):
                p = VGroup(Dot(), Square(), Triangle())
                self.add(p)
                self.play(ShowIncreasingSubsets(p))
                self.wait()
    """

    @others
</t>
<t tx="ekr.20250122151620.294">class AddTextLetterByLetter(ShowIncreasingSubsets):
    """Show a :class:`~.Text` letter by letter on the scene.

    Parameters
    ----------
    time_per_char
        Frequency of appearance of the letters.

    .. tip::

        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`

    """

    @others
</t>
<t tx="ekr.20250122151620.295">class RemoveTextLetterByLetter(AddTextLetterByLetter):
    """Remove a :class:`~.Text` letter by letter from the scene.

    Parameters
    ----------
    time_per_char
        Frequency of appearance of the letters.

    .. tip::

        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`

    """

    @others
</t>
<t tx="ekr.20250122151620.296">class ShowSubmobjectsOneByOne(ShowIncreasingSubsets):
    """Show one submobject at a time, removing all previously displayed ones from screen."""

    @others
</t>
<t tx="ekr.20250122151620.297"># TODO, this is broken...
class AddTextWordByWord(Succession):
    """Show a :class:`~.Text` word by word on the scene. Note: currently broken."""

    @others
</t>
<t tx="ekr.20250122151620.298">class TypeWithCursor(AddTextLetterByLetter):
    """Similar to :class:`~.AddTextLetterByLetter` , but with an additional cursor mobject at the end.

    Parameters
    ----------
    time_per_char
        Frequency of appearance of the letters.
    cursor
        :class:`~.Mobject` shown after the last added letter.
    buff
        Controls how far away the cursor is to the right of the last added letter.
    keep_cursor_y
        If ``True``, the cursor's y-coordinate is set to the center of the ``Text`` and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter.
    leave_cursor_on
        Whether to show the cursor after the animation.

    .. tip::
        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`.


    Examples
    --------

    .. manim:: InsertingTextExample
        :ref_classes: Blink

        class InsertingTextExample(Scene):
            def construct(self):
                text = Text("Inserting", color=PURPLE).scale(1.5).to_edge(LEFT)
                cursor = Rectangle(
                    color = GREY_A,
                    fill_color = GREY_A,
                    fill_opacity = 1.0,
                    height = 1.1,
                    width = 0.5,
                ).move_to(text[0]) # Position the cursor

                self.play(TypeWithCursor(text, cursor))
                self.play(Blink(cursor, blinks=2))

    """

    @others
</t>
<t tx="ekr.20250122151620.299">class UntypeWithCursor(TypeWithCursor):
    """Similar to :class:`~.RemoveTextLetterByLetter` , but with an additional cursor mobject at the end.

    Parameters
    ----------
    time_per_char
        Frequency of appearance of the letters.
    cursor
        :class:`~.Mobject` shown after the last added letter.
    buff
        Controls how far away the cursor is to the right of the last added letter.
    keep_cursor_y
        If ``True``, the cursor's y-coordinate is set to the center of the ``Text`` and remains the same throughout the animation. Otherwise, it is set to the center of the last added letter.
    leave_cursor_on
        Whether to show the cursor after the animation.

    .. tip::
        This is currently only possible for class:`~.Text` and not for class:`~.MathTex`.


    Examples
    --------

    .. manim:: DeletingTextExample
        :ref_classes: Blink

        class DeletingTextExample(Scene):
            def construct(self):
                text = Text("Deleting", color=PURPLE).scale(1.5).to_edge(LEFT)
                cursor = Rectangle(
                    color = GREY_A,
                    fill_color = GREY_A,
                    fill_opacity = 1.0,
                    height = 1.1,
                    width = 0.5,
                ).move_to(text[0]) # Position the cursor

                self.play(UntypeWithCursor(text, cursor))
                self.play(Blink(cursor, blinks=2))

    """

    @others
</t>
<t tx="ekr.20250122151620.3">#!/usr/bin/env python
from __future__ import annotations

from importlib.metadata import version

__version__ = version(__name__)


# isort: off

# Importing the config module should be the first thing we do, since other
# modules depend on the global config dict for initialization.
from ._config import *

# many scripts depend on this -&gt; has to be loaded first
from .utils.commands import *

# isort: on
import numpy as np

from .animation.animation import *
from .animation.changing import *
from .animation.composition import *
from .animation.creation import *
from .animation.fading import *
from .animation.growing import *
from .animation.indication import *
from .animation.movement import *
from .animation.numbers import *
from .animation.rotation import *
from .animation.specialized import *
from .animation.speedmodifier import *
from .animation.transform import *
from .animation.transform_matching_parts import *
from .animation.updaters.mobject_update_utils import *
from .animation.updaters.update import *
from .camera.camera import *
from .camera.mapping_camera import *
from .camera.moving_camera import *
from .camera.multi_camera import *
from .camera.three_d_camera import *
from .constants import *
from .mobject.frame import *
from .mobject.geometry.arc import *
from .mobject.geometry.boolean_ops import *
from .mobject.geometry.labeled import *
from .mobject.geometry.line import *
from .mobject.geometry.polygram import *
from .mobject.geometry.shape_matchers import *
from .mobject.geometry.tips import *
from .mobject.graph import *
from .mobject.graphing.coordinate_systems import *
from .mobject.graphing.functions import *
from .mobject.graphing.number_line import *
from .mobject.graphing.probability import *
from .mobject.graphing.scale import *
from .mobject.logo import *
from .mobject.matrix import *
from .mobject.mobject import *
from .mobject.opengl.dot_cloud import *
from .mobject.opengl.opengl_point_cloud_mobject import *
from .mobject.svg.brace import *
from .mobject.svg.svg_mobject import *
from .mobject.table import *
from .mobject.text.code_mobject import *
from .mobject.text.numbers import *
from .mobject.text.tex_mobject import *
from .mobject.text.text_mobject import *
from .mobject.three_d.polyhedra import *
from .mobject.three_d.three_d_utils import *
from .mobject.three_d.three_dimensions import *
from .mobject.types.image_mobject import *
from .mobject.types.point_cloud_mobject import *
from .mobject.types.vectorized_mobject import *
from .mobject.value_tracker import *
from .mobject.vector_field import *
from .renderer.cairo_renderer import *
from .scene.moving_camera_scene import *
from .scene.scene import *
from .scene.scene_file_writer import *
from .scene.section import *
from .scene.three_d_scene import *
from .scene.vector_space_scene import *
from .scene.zoomed_scene import *
from .utils import color, rate_functions, unit
from .utils.bezier import *
from .utils.color import *
from .utils.config_ops import *
from .utils.debug import *
from .utils.file_ops import *
from .utils.images import *
from .utils.iterables import *
from .utils.paths import *
from .utils.rate_functions import *
from .utils.simple_functions import *
from .utils.sounds import *
from .utils.space_ops import *
from .utils.tex import *
from .utils.tex_templates import *

try:
    from IPython import get_ipython

    from .utils.ipython_magic import ManimMagic
except ImportError:
    pass
else:
    ipy = get_ipython()
    if ipy is not None:
        ipy.register_magics(ManimMagic)

from .plugins import *
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.30"># TODO: to be used in the future - see PR #620
# https://github.com/ManimCommunity/manim/pull/620
class ManimFrame(Mapping):
    @others
</t>
<t tx="ekr.20250122151620.300">def __init__(
    self,
    mobject: VMobject | OpenGLVMobject | OpenGLSurface | None,
    **kwargs,
):
    pointwise = getattr(mobject, "pointwise_become_partial", None)
    if not callable(pointwise):
        raise NotImplementedError("This animation is not defined for this Mobject.")
    super().__init__(mobject, **kwargs)

</t>
<t tx="ekr.20250122151620.301">def interpolate_submobject(
    self,
    submobject: Mobject,
    starting_submobject: Mobject,
    alpha: float,
) -&gt; None:
    submobject.pointwise_become_partial(
        starting_submobject, *self._get_bounds(alpha)
    )

</t>
<t tx="ekr.20250122151620.302">def _get_bounds(self, alpha: float) -&gt; None:
    raise NotImplementedError("Please use Create or ShowPassingFlash")


</t>
<t tx="ekr.20250122151620.303">def __init__(
    self,
    mobject: VMobject | OpenGLVMobject | OpenGLSurface,
    lag_ratio: float = 1.0,
    introducer: bool = True,
    **kwargs,
) -&gt; None:
    super().__init__(mobject, lag_ratio=lag_ratio, introducer=introducer, **kwargs)

</t>
<t tx="ekr.20250122151620.304">def _get_bounds(self, alpha: float) -&gt; tuple[int, float]:
    return (0, alpha)


</t>
<t tx="ekr.20250122151620.305">def __init__(
    self,
    mobject: VMobject | OpenGLVMobject,
    reverse_rate_function: bool = True,
    remover: bool = True,
    **kwargs,
) -&gt; None:
    super().__init__(
        mobject,
        reverse_rate_function=reverse_rate_function,
        introducer=False,
        remover=remover,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.306">def __init__(
    self,
    vmobject: VMobject | OpenGLVMobject,
    run_time: float = 2,
    rate_func: Callable[[float], float] = double_smooth,
    stroke_width: float = 2,
    stroke_color: str = None,
    draw_border_animation_config: dict = {},  # what does this dict accept?
    fill_animation_config: dict = {},
    introducer: bool = True,
    **kwargs,
) -&gt; None:
    self._typecheck_input(vmobject)
    super().__init__(
        vmobject,
        run_time=run_time,
        introducer=introducer,
        rate_func=rate_func,
        **kwargs,
    )
    self.stroke_width = stroke_width
    self.stroke_color = stroke_color
    self.draw_border_animation_config = draw_border_animation_config
    self.fill_animation_config = fill_animation_config
    self.outline = self.get_outline()

</t>
<t tx="ekr.20250122151620.307">def _typecheck_input(self, vmobject: VMobject | OpenGLVMobject) -&gt; None:
    if not isinstance(vmobject, (VMobject, OpenGLVMobject)):
        raise TypeError(
            f"{self.__class__.__name__} only works for vectorized Mobjects"
        )

</t>
<t tx="ekr.20250122151620.308">def begin(self) -&gt; None:
    self.outline = self.get_outline()
    super().begin()

</t>
<t tx="ekr.20250122151620.309">def get_outline(self) -&gt; Mobject:
    outline = self.mobject.copy()
    outline.set_fill(opacity=0)
    for sm in outline.family_members_with_points():
        sm.set_stroke(color=self.get_stroke_color(sm), width=self.stroke_width)
    return outline

</t>
<t tx="ekr.20250122151620.31">_OPTS = {
    "assets_dir",
    "background_color",
    "background_opacity",
    "custom_folders",
    "disable_caching",
    "disable_caching_warning",
    "dry_run",
    "enable_wireframe",
    "ffmpeg_loglevel",
    "format",
    "flush_cache",
    "frame_height",
    "frame_rate",
    "frame_width",
    "frame_x_radius",
    "frame_y_radius",
    "from_animation_number",
    "images_dir",
    "input_file",
    "media_embed",
    "media_width",
    "log_dir",
    "log_to_file",
    "max_files_cached",
    "media_dir",
    "movie_file_extension",
    "notify_outdated_version",
    "output_file",
    "partial_movie_dir",
    "pixel_height",
    "pixel_width",
    "plugins",
    "preview",
    "progress_bar",
    "quality",
    "save_as_gif",
    "save_sections",
    "save_last_frame",
    "save_pngs",
    "scene_names",
    "show_in_file_browser",
    "tex_dir",
    "tex_template",
    "tex_template_file",
    "text_dir",
    "upto_animation_number",
    "renderer",
    "enable_gui",
    "gui_location",
    "use_projection_fill_shaders",
    "use_projection_stroke_shaders",
    "verbosity",
    "video_dir",
    "sections_dir",
    "fullscreen",
    "window_position",
    "window_size",
    "window_monitor",
    "write_all",
    "write_to_movie",
    "zero_pad",
    "force_window",
    "no_latex_cleanup",
    "preview_command",
}

def __init__(self) -&gt; None:
    self._d: dict[str, Any | None] = dict.fromkeys(self._OPTS)

</t>
<t tx="ekr.20250122151620.310">def get_stroke_color(self, vmobject: VMobject | OpenGLVMobject) -&gt; ManimColor:
    if self.stroke_color:
        return self.stroke_color
    elif vmobject.get_stroke_width() &gt; 0:
        return vmobject.get_stroke_color()
    return vmobject.get_color()

</t>
<t tx="ekr.20250122151620.311">def get_all_mobjects(self) -&gt; Sequence[Mobject]:
    return [*super().get_all_mobjects(), self.outline]

</t>
<t tx="ekr.20250122151620.312">def interpolate_submobject(
    self,
    submobject: Mobject,
    starting_submobject: Mobject,
    outline,
    alpha: float,
) -&gt; None:  # Fixme: not matching the parent class? What is outline doing here?
    index: int
    subalpha: float
    index, subalpha = integer_interpolate(0, 2, alpha)
    if index == 0:
        submobject.pointwise_become_partial(outline, 0, subalpha)
        submobject.match_style(outline)
    else:
        submobject.interpolate(outline, starting_submobject, subalpha)


</t>
<t tx="ekr.20250122151620.313">def __init__(
    self,
    vmobject: VMobject | OpenGLVMobject,
    rate_func: Callable[[float], float] = linear,
    reverse: bool = False,
    **kwargs,
) -&gt; None:
    run_time: float | None = kwargs.pop("run_time", None)
    lag_ratio: float | None = kwargs.pop("lag_ratio", None)
    run_time, lag_ratio = self._set_default_config_from_length(
        vmobject,
        run_time,
        lag_ratio,
    )
    self.reverse = reverse
    if "remover" not in kwargs:
        kwargs["remover"] = reverse
    super().__init__(
        vmobject,
        rate_func=rate_func,
        run_time=run_time,
        lag_ratio=lag_ratio,
        introducer=not reverse,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.314">def _set_default_config_from_length(
    self,
    vmobject: VMobject | OpenGLVMobject,
    run_time: float | None,
    lag_ratio: float | None,
) -&gt; tuple[float, float]:
    length = len(vmobject.family_members_with_points())
    if run_time is None:
        run_time = 1 if length &lt; 15 else 2
    if lag_ratio is None:
        lag_ratio = min(4.0 / max(1.0, length), 0.2)
    return run_time, lag_ratio

</t>
<t tx="ekr.20250122151620.315">def reverse_submobjects(self) -&gt; None:
    self.mobject.invert(recursive=True)

</t>
<t tx="ekr.20250122151620.316">def begin(self) -&gt; None:
    if self.reverse:
        self.reverse_submobjects()
    super().begin()

</t>
<t tx="ekr.20250122151620.317">def finish(self) -&gt; None:
    super().finish()
    if self.reverse:
        self.reverse_submobjects()


</t>
<t tx="ekr.20250122151620.318">def __init__(
    self,
    vmobject: VMobject,
    rate_func: Callable[[float], float] = linear,
    reverse: bool = True,
    **kwargs,
) -&gt; None:
    run_time: float | None = kwargs.pop("run_time", None)
    lag_ratio: float | None = kwargs.pop("lag_ratio", None)
    run_time, lag_ratio = self._set_default_config_from_length(
        vmobject,
        run_time,
        lag_ratio,
    )
    super().__init__(
        vmobject,
        run_time=run_time,
        lag_ratio=lag_ratio,
        reverse_rate_function=True,
        reverse=reverse,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.319">r"""Create the Mobject with sub-Mobjects flying in on spiral trajectories.

Parameters
----------
shapes
    The Mobject on which to be operated.

scale_factor
    The factor used for scaling the effect.

fade_in_fraction
    Fractional duration of initial fade-in of sub-Mobjects as they fly inward.

Examples
--------
.. manim :: SpiralInExample

    class SpiralInExample(Scene):
        def construct(self):
            pi = MathTex(r"\pi").scale(7)
            pi.shift(2.25 * LEFT + 1.5 * UP)
            circle = Circle(color=GREEN_C, fill_opacity=1).shift(LEFT)
            square = Square(color=BLUE_D, fill_opacity=1).shift(UP)
            shapes = VGroup(pi, circle, square)
            self.play(SpiralIn(shapes))
"""

def __init__(
    self,
    shapes: Mobject,
    scale_factor: float = 8,
    fade_in_fraction=0.3,
    **kwargs,
) -&gt; None:
    self.shapes = shapes.copy()
    self.scale_factor = scale_factor
    self.shape_center = shapes.get_center()
    self.fade_in_fraction = fade_in_fraction
    for shape in shapes:
        shape.final_position = shape.get_center()
        shape.initial_position = (
            shape.final_position
            + (shape.final_position - self.shape_center) * self.scale_factor
        )
        shape.move_to(shape.initial_position)
        shape.save_state()

    super().__init__(shapes, introducer=True, **kwargs)

</t>
<t tx="ekr.20250122151620.32"># behave like a dict
def __iter__(self) -&gt; Iterator[str]:
    return iter(self._d)

</t>
<t tx="ekr.20250122151620.320">def interpolate_mobject(self, alpha: float) -&gt; None:
    alpha = self.rate_func(alpha)
    for original_shape, shape in zip(self.shapes, self.mobject):
        shape.restore()
        fill_opacity = original_shape.get_fill_opacity()
        stroke_opacity = original_shape.get_stroke_opacity()
        new_fill_opacity = min(
            fill_opacity, alpha * fill_opacity / self.fade_in_fraction
        )
        new_stroke_opacity = min(
            stroke_opacity, alpha * stroke_opacity / self.fade_in_fraction
        )
        shape.shift((shape.final_position - shape.initial_position) * alpha)
        shape.rotate(TAU * alpha, about_point=self.shape_center)
        shape.rotate(-TAU * alpha, about_point=shape.get_center_of_mass())
        shape.set_fill(opacity=new_fill_opacity)
        shape.set_stroke(opacity=new_stroke_opacity)


</t>
<t tx="ekr.20250122151620.321">def __init__(
    self,
    group: Mobject,
    suspend_mobject_updating: bool = False,
    int_func: Callable[[np.ndarray], np.ndarray] = np.floor,
    reverse_rate_function=False,
    **kwargs,
) -&gt; None:
    self.all_submobs = list(group.submobjects)
    self.int_func = int_func
    for mobj in self.all_submobs:
        mobj.set_opacity(0)
    super().__init__(
        group,
        suspend_mobject_updating=suspend_mobject_updating,
        reverse_rate_function=reverse_rate_function,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.322">def interpolate_mobject(self, alpha: float) -&gt; None:
    n_submobs = len(self.all_submobs)
    value = (
        1 - self.rate_func(alpha)
        if self.reverse_rate_function
        else self.rate_func(alpha)
    )
    index = int(self.int_func(value * n_submobs))
    self.update_submobject_list(index)

</t>
<t tx="ekr.20250122151620.323">def update_submobject_list(self, index: int) -&gt; None:
    for mobj in self.all_submobs[:index]:
        mobj.set_opacity(1)
    for mobj in self.all_submobs[index:]:
        mobj.set_opacity(0)


</t>
<t tx="ekr.20250122151620.324">def __init__(
    self,
    text: Text,
    suspend_mobject_updating: bool = False,
    int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,
    rate_func: Callable[[float], float] = linear,
    time_per_char: float = 0.1,
    run_time: float | None = None,
    reverse_rate_function=False,
    introducer=True,
    **kwargs,
) -&gt; None:
    self.time_per_char = time_per_char
    # Check for empty text using family_members_with_points()
    if not text.family_members_with_points():
        raise ValueError(
            f"The text mobject {text} does not seem to contain any characters."
        )
    if run_time is None:
        # minimum time per character is 1/frame_rate, otherwise
        # the animation does not finish.
        run_time = np.max((1 / config.frame_rate, self.time_per_char)) * len(text)
    super().__init__(
        text,
        suspend_mobject_updating=suspend_mobject_updating,
        int_func=int_func,
        rate_func=rate_func,
        run_time=run_time,
        reverse_rate_function=reverse_rate_function,
        introducer=introducer,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.325">def __init__(
    self,
    text: Text,
    suspend_mobject_updating: bool = False,
    int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,
    rate_func: Callable[[float], float] = linear,
    time_per_char: float = 0.1,
    run_time: float | None = None,
    reverse_rate_function=True,
    introducer=False,
    remover=True,
    **kwargs,
) -&gt; None:
    super().__init__(
        text,
        suspend_mobject_updating=suspend_mobject_updating,
        int_func=int_func,
        rate_func=rate_func,
        time_per_char=time_per_char,
        run_time=run_time,
        reverse_rate_function=reverse_rate_function,
        introducer=introducer,
        remover=remover,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.326">def __init__(
    self,
    group: Iterable[Mobject],
    int_func: Callable[[np.ndarray], np.ndarray] = np.ceil,
    **kwargs,
) -&gt; None:
    new_group = Group(*group)
    super().__init__(new_group, int_func=int_func, **kwargs)

</t>
<t tx="ekr.20250122151620.327">def update_submobject_list(self, index: int) -&gt; None:
    current_submobjects = self.all_submobs[:index]
    for mobj in current_submobjects[:-1]:
        mobj.set_opacity(0)
    if len(current_submobjects) &gt; 0:
        current_submobjects[-1].set_opacity(1)


</t>
<t tx="ekr.20250122151620.328">def __init__(
    self,
    text_mobject: Text,
    run_time: float = None,
    time_per_char: float = 0.06,
    **kwargs,
) -&gt; None:
    self.time_per_char = time_per_char
    tpc = self.time_per_char
    anims = it.chain(
        *(
            [
                ShowIncreasingSubsets(word, run_time=tpc * len(word)),
                Animation(word, run_time=0.005 * len(word) ** 1.5),
            ]
            for word in text_mobject
        )
    )
    super().__init__(*anims, **kwargs)


</t>
<t tx="ekr.20250122151620.329">def __init__(
    self,
    text: Text,
    cursor: Mobject,
    buff: float = 0.1,
    keep_cursor_y: bool = True,
    leave_cursor_on: bool = True,
    time_per_char: float = 0.1,
    reverse_rate_function=False,
    introducer=True,
    **kwargs,
) -&gt; None:
    self.cursor = cursor
    self.buff = buff
    self.keep_cursor_y = keep_cursor_y
    self.leave_cursor_on = leave_cursor_on
    super().__init__(
        text,
        time_per_char=time_per_char,
        reverse_rate_function=reverse_rate_function,
        introducer=introducer,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.33">def __len__(self) -&gt; int:
    return len(self._d)

</t>
<t tx="ekr.20250122151620.330">def begin(self) -&gt; None:
    self.y_cursor = self.cursor.get_y()
    self.cursor.initial_position = self.mobject.get_center()
    if self.keep_cursor_y:
        self.cursor.set_y(self.y_cursor)

    self.cursor.set_opacity(0)
    self.mobject.add(self.cursor)
    super().begin()

</t>
<t tx="ekr.20250122151620.331">def finish(self) -&gt; None:
    if self.leave_cursor_on:
        self.cursor.set_opacity(1)
    else:
        self.cursor.set_opacity(0)
        self.mobject.remove(self.cursor)
    super().finish()

</t>
<t tx="ekr.20250122151620.332">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    if not self.leave_cursor_on:
        scene.remove(self.cursor)
    super().clean_up_from_scene(scene)

</t>
<t tx="ekr.20250122151620.333">def update_submobject_list(self, index: int) -&gt; None:
    for mobj in self.all_submobs[:index]:
        mobj.set_opacity(1)

    for mobj in self.all_submobs[index:]:
        mobj.set_opacity(0)

    if index != 0:
        self.cursor.next_to(
            self.all_submobs[index - 1], RIGHT, buff=self.buff
        ).set_y(self.cursor.initial_position[1])
    else:
        self.cursor.move_to(self.all_submobs[0]).set_y(
            self.cursor.initial_position[1]
        )

    if self.keep_cursor_y:
        self.cursor.set_y(self.y_cursor)
    self.cursor.set_opacity(1)


</t>
<t tx="ekr.20250122151620.334">def __init__(
    self,
    text: Text,
    cursor: VMobject | None = None,
    time_per_char: float = 0.1,
    reverse_rate_function=True,
    introducer=False,
    remover=True,
    **kwargs,
) -&gt; None:
    super().__init__(
        text,
        cursor=cursor,
        time_per_char=time_per_char,
        reverse_rate_function=reverse_rate_function,
        introducer=introducer,
        remover=remover,
        **kwargs,
    )
</t>
<t tx="ekr.20250122151620.335">"""Fading in and out of view.

.. manim:: Fading

    class Fading(Scene):
        def construct(self):
            tex_in = Tex("Fade", "In").scale(3)
            tex_out = Tex("Fade", "Out").scale(3)
            self.play(FadeIn(tex_in, shift=DOWN, scale=0.66))
            self.play(ReplacementTransform(tex_in, tex_out))
            self.play(FadeOut(tex_out, shift=DOWN * 2, scale=1.5))

"""

from __future__ import annotations

__all__ = [
    "FadeOut",
    "FadeIn",
]

import numpy as np

from manim.mobject.opengl.opengl_mobject import OpenGLMobject

from ..animation.transform import Transform
from ..constants import ORIGIN
from ..mobject.mobject import Group, Mobject
from ..scene.scene import Scene


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.336">class _Fade(Transform):
    """Fade :class:`~.Mobject` s in or out.

    Parameters
    ----------
    mobjects
        The mobjects to be faded.
    shift
        The vector by which the mobject shifts while being faded.
    target_position
        The position to/from which the mobject moves while being faded in. In case
        another mobject is given as target position, its center is used.
    scale
        The factor by which the mobject is scaled initially before being rescaling to
        its original size while being faded in.

    """

    @others
</t>
<t tx="ekr.20250122151620.337">class FadeIn(_Fade):
    @others
</t>
<t tx="ekr.20250122151620.338">class FadeOut(_Fade):
    @others
</t>
<t tx="ekr.20250122151620.339">def __init__(
    self,
    *mobjects: Mobject,
    shift: np.ndarray | None = None,
    target_position: np.ndarray | Mobject | None = None,
    scale: float = 1,
    **kwargs,
) -&gt; None:
    if not mobjects:
        raise ValueError("At least one mobject must be passed.")
    mobject = mobjects[0] if len(mobjects) == 1 else Group(*mobjects)

    self.point_target = False
    if shift is None:
        if target_position is not None:
            if isinstance(target_position, (Mobject, OpenGLMobject)):
                target_position = target_position.get_center()
            shift = target_position - mobject.get_center()
            self.point_target = True
        else:
            shift = ORIGIN
    self.shift_vector = shift
    self.scale_factor = scale
    super().__init__(mobject, **kwargs)

</t>
<t tx="ekr.20250122151620.34">def __contains__(self, key: object) -&gt; bool:
    try:
        self.__getitem__(key)
        return True
    except AttributeError:
        return False

</t>
<t tx="ekr.20250122151620.340">def _create_faded_mobject(self, fadeIn: bool) -&gt; Mobject:
    """Create a faded, shifted and scaled copy of the mobject.

    Parameters
    ----------
    fadeIn
        Whether the faded mobject is used to fade in.

    Returns
    -------
    Mobject
        The faded, shifted and scaled copy of the mobject.
    """
    faded_mobject = self.mobject.copy()
    faded_mobject.fade(1)
    direction_modifier = -1 if fadeIn and not self.point_target else 1
    faded_mobject.shift(self.shift_vector * direction_modifier)
    faded_mobject.scale(self.scale_factor)
    return faded_mobject


</t>
<t tx="ekr.20250122151620.341">r"""Fade in :class:`~.Mobject` s.

Parameters
----------
mobjects
    The mobjects to be faded in.
shift
    The vector by which the mobject shifts while being faded in.
target_position
    The position from which the mobject starts while being faded in. In case
    another mobject is given as target position, its center is used.
scale
    The factor by which the mobject is scaled initially before being rescaling to
    its original size while being faded in.

Examples
--------

.. manim :: FadeInExample

    class FadeInExample(Scene):
        def construct(self):
            dot = Dot(UP * 2 + LEFT)
            self.add(dot)
            tex = Tex(
                "FadeIn with ", "shift ", r" or target\_position", " and scale"
            ).scale(1)
            animations = [
                FadeIn(tex[0]),
                FadeIn(tex[1], shift=DOWN),
                FadeIn(tex[2], target_position=dot),
                FadeIn(tex[3], scale=1.5),
            ]
            self.play(AnimationGroup(*animations, lag_ratio=0.5))

"""

def __init__(self, *mobjects: Mobject, **kwargs) -&gt; None:
    super().__init__(*mobjects, introducer=True, **kwargs)

</t>
<t tx="ekr.20250122151620.342">def create_target(self):
    return self.mobject

</t>
<t tx="ekr.20250122151620.343">def create_starting_mobject(self):
    return self._create_faded_mobject(fadeIn=True)


</t>
<t tx="ekr.20250122151620.344">r"""Fade out :class:`~.Mobject` s.

Parameters
----------
mobjects
    The mobjects to be faded out.
shift
    The vector by which the mobject shifts while being faded out.
target_position
    The position to which the mobject moves while being faded out. In case another
    mobject is given as target position, its center is used.
scale
    The factor by which the mobject is scaled while being faded out.

Examples
--------

.. manim :: FadeInExample

    class FadeInExample(Scene):
        def construct(self):
            dot = Dot(UP * 2 + LEFT)
            self.add(dot)
            tex = Tex(
                "FadeOut with ", "shift ", r" or target\_position", " and scale"
            ).scale(1)
            animations = [
                FadeOut(tex[0]),
                FadeOut(tex[1], shift=DOWN),
                FadeOut(tex[2], target_position=dot),
                FadeOut(tex[3], scale=0.5),
            ]
            self.play(AnimationGroup(*animations, lag_ratio=0.5))


"""

def __init__(self, *mobjects: Mobject, **kwargs) -&gt; None:
    super().__init__(*mobjects, remover=True, **kwargs)

</t>
<t tx="ekr.20250122151620.345">def create_target(self):
    return self._create_faded_mobject(fadeIn=False)

</t>
<t tx="ekr.20250122151620.346">def clean_up_from_scene(self, scene: Scene = None) -&gt; None:
    super().clean_up_from_scene(scene)
    self.interpolate(0)
</t>
<t tx="ekr.20250122151620.347">"""Animations that introduce mobjects to scene by growing them from points.

.. manim:: Growing

    class Growing(Scene):
        def construct(self):
            square = Square()
            circle = Circle()
            triangle = Triangle()
            arrow = Arrow(LEFT, RIGHT)
            star = Star()

            VGroup(square, circle, triangle).set_x(0).arrange(buff=1.5).set_y(2)
            VGroup(arrow, star).move_to(DOWN).set_x(0).arrange(buff=1.5).set_y(-2)

            self.play(GrowFromPoint(square, ORIGIN))
            self.play(GrowFromCenter(circle))
            self.play(GrowFromEdge(triangle, DOWN))
            self.play(GrowArrow(arrow))
            self.play(SpinInFromNothing(star))

"""

from __future__ import annotations

__all__ = [
    "GrowFromPoint",
    "GrowFromCenter",
    "GrowFromEdge",
    "GrowArrow",
    "SpinInFromNothing",
]

import typing

import numpy as np

from ..animation.transform import Transform
from ..constants import PI
from ..utils.paths import spiral_path

if typing.TYPE_CHECKING:
    from manim.mobject.geometry.line import Arrow

    from ..mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.348">class GrowFromPoint(Transform):
    """Introduce an :class:`~.Mobject` by growing it from a point.

    Parameters
    ----------
    mobject
        The mobjects to be introduced.
    point
        The point from which the mobject grows.
    point_color
        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.

    Examples
    --------

    .. manim :: GrowFromPointExample

        class GrowFromPointExample(Scene):
            def construct(self):
                dot = Dot(3 * UR, color=GREEN)
                squares = [Square() for _ in range(4)]
                VGroup(*squares).set_x(0).arrange(buff=1)
                self.add(dot)
                self.play(GrowFromPoint(squares[0], ORIGIN))
                self.play(GrowFromPoint(squares[1], [-2, 2, 0]))
                self.play(GrowFromPoint(squares[2], [3, -2, 0], RED))
                self.play(GrowFromPoint(squares[3], dot, dot.get_color()))

    """

    @others
</t>
<t tx="ekr.20250122151620.349">class GrowFromCenter(GrowFromPoint):
    """Introduce an :class:`~.Mobject` by growing it from its center.

    Parameters
    ----------
    mobject
        The mobjects to be introduced.
    point_color
        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.

    Examples
    --------

    .. manim :: GrowFromCenterExample

        class GrowFromCenterExample(Scene):
            def construct(self):
                squares = [Square() for _ in range(2)]
                VGroup(*squares).set_x(0).arrange(buff=2)
                self.play(GrowFromCenter(squares[0]))
                self.play(GrowFromCenter(squares[1], point_color=RED))

    """

    @others
</t>
<t tx="ekr.20250122151620.35">def __getitem__(self, key: str) -&gt; Any:
    return getattr(self, key)

</t>
<t tx="ekr.20250122151620.350">class GrowFromEdge(GrowFromPoint):
    """Introduce an :class:`~.Mobject` by growing it from one of its bounding box edges.

    Parameters
    ----------
    mobject
        The mobjects to be introduced.
    edge
        The direction to seek bounding box edge of mobject.
    point_color
        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.

    Examples
    --------

    .. manim :: GrowFromEdgeExample

        class GrowFromEdgeExample(Scene):
            def construct(self):
                squares = [Square() for _ in range(4)]
                VGroup(*squares).set_x(0).arrange(buff=1)
                self.play(GrowFromEdge(squares[0], DOWN))
                self.play(GrowFromEdge(squares[1], RIGHT))
                self.play(GrowFromEdge(squares[2], UR))
                self.play(GrowFromEdge(squares[3], UP, point_color=RED))


    """

    @others
</t>
<t tx="ekr.20250122151620.351">class GrowArrow(GrowFromPoint):
    """Introduce an :class:`~.Arrow` by growing it from its start toward its tip.

    Parameters
    ----------
    arrow
        The arrow to be introduced.
    point_color
        Initial color of the arrow before growing to its full size. Leave empty to match arrow's color.

    Examples
    --------

    .. manim :: GrowArrowExample

        class GrowArrowExample(Scene):
            def construct(self):
                arrows = [Arrow(2 * LEFT, 2 * RIGHT), Arrow(2 * DR, 2 * UL)]
                VGroup(*arrows).set_x(0).arrange(buff=2)
                self.play(GrowArrow(arrows[0]))
                self.play(GrowArrow(arrows[1], point_color=RED))

    """

    @others
</t>
<t tx="ekr.20250122151620.352">class SpinInFromNothing(GrowFromCenter):
    """Introduce an :class:`~.Mobject` spinning and growing it from its center.

    Parameters
    ----------
    mobject
        The mobjects to be introduced.
    angle
        The amount of spinning before mobject reaches its full size. E.g. 2*PI means
        that the object will do one full spin before being fully introduced.
    point_color
        Initial color of the mobject before growing to its full size. Leave empty to match mobject's color.

    Examples
    --------

    .. manim :: SpinInFromNothingExample

        class SpinInFromNothingExample(Scene):
            def construct(self):
                squares = [Square() for _ in range(3)]
                VGroup(*squares).set_x(0).arrange(buff=2)
                self.play(SpinInFromNothing(squares[0]))
                self.play(SpinInFromNothing(squares[1], angle=2 * PI))
                self.play(SpinInFromNothing(squares[2], point_color=RED))

    """

    @others
</t>
<t tx="ekr.20250122151620.353">def __init__(
    self, mobject: Mobject, point: np.ndarray, point_color: str = None, **kwargs
) -&gt; None:
    self.point = point
    self.point_color = point_color
    super().__init__(mobject, introducer=True, **kwargs)

</t>
<t tx="ekr.20250122151620.354">def create_target(self) -&gt; Mobject:
    return self.mobject

</t>
<t tx="ekr.20250122151620.355">def create_starting_mobject(self) -&gt; Mobject:
    start = super().create_starting_mobject()
    start.scale(0)
    start.move_to(self.point)
    if self.point_color:
        start.set_color(self.point_color)
    return start


</t>
<t tx="ekr.20250122151620.356">def __init__(self, mobject: Mobject, point_color: str = None, **kwargs) -&gt; None:
    point = mobject.get_center()
    super().__init__(mobject, point, point_color=point_color, **kwargs)


</t>
<t tx="ekr.20250122151620.357">def __init__(
    self, mobject: Mobject, edge: np.ndarray, point_color: str = None, **kwargs
) -&gt; None:
    point = mobject.get_critical_point(edge)
    super().__init__(mobject, point, point_color=point_color, **kwargs)


</t>
<t tx="ekr.20250122151620.358">def __init__(self, arrow: Arrow, point_color: str = None, **kwargs) -&gt; None:
    point = arrow.get_start()
    super().__init__(arrow, point, point_color=point_color, **kwargs)

</t>
<t tx="ekr.20250122151620.359">def create_starting_mobject(self) -&gt; Mobject:
    start_arrow = self.mobject.copy()
    start_arrow.scale(0, scale_tips=True, about_point=self.point)
    if self.point_color:
        start_arrow.set_color(self.point_color)
    return start_arrow


</t>
<t tx="ekr.20250122151620.36">def __setitem__(self, key: str, val: Any) -&gt; None:
    getattr(ManimConfig, key).fset(self, val)  # fset is the property's setter

</t>
<t tx="ekr.20250122151620.360">def __init__(
    self, mobject: Mobject, angle: float = PI / 2, point_color: str = None, **kwargs
) -&gt; None:
    self.angle = angle
    super().__init__(
        mobject, path_func=spiral_path(angle), point_color=point_color, **kwargs
    )
</t>
<t tx="ekr.20250122151620.361">"""Animations drawing attention to particular mobjects.

Examples
--------

.. manim:: Indications

    class Indications(Scene):
        def construct(self):
            indications = [ApplyWave,Circumscribe,Flash,FocusOn,Indicate,ShowPassingFlash,Wiggle]
            names = [Tex(i.__name__).scale(3) for i in indications]

            self.add(names[0])
            for i in range(len(names)):
                if indications[i] is Flash:
                    self.play(Flash(UP))
                elif indications[i] is ShowPassingFlash:
                    self.play(ShowPassingFlash(Underline(names[i])))
                else:
                    self.play(indications[i](names[i]))
                self.play(AnimationGroup(
                    FadeOut(names[i], shift=UP*1.5),
                    FadeIn(names[(i+1)%len(names)], shift=UP*1.5),
                ))

"""

from __future__ import annotations

__all__ = [
    "FocusOn",
    "Indicate",
    "Flash",
    "ShowPassingFlash",
    "ShowPassingFlashWithThinningStrokeWidth",
    "ApplyWave",
    "Circumscribe",
    "Wiggle",
    "Blink",
]

from collections.abc import Iterable
from typing import Callable

import numpy as np

from manim.mobject.geometry.arc import Circle, Dot
from manim.mobject.geometry.line import Line
from manim.mobject.geometry.polygram import Rectangle
from manim.mobject.geometry.shape_matchers import SurroundingRectangle
from manim.scene.scene import Scene

from .. import config
from ..animation.animation import Animation
from ..animation.composition import AnimationGroup, Succession
from ..animation.creation import Create, ShowPartial, Uncreate
from ..animation.fading import FadeIn, FadeOut
from ..animation.movement import Homotopy
from ..animation.transform import Transform
from ..animation.updaters.update import UpdateFromFunc
from ..constants import *
from ..mobject.mobject import Mobject
from ..mobject.types.vectorized_mobject import VGroup, VMobject
from ..utils.bezier import interpolate, inverse_interpolate
from ..utils.color import GREY, YELLOW, ParsableManimColor
from ..utils.rate_functions import smooth, there_and_back, wiggle
from ..utils.space_ops import normalize


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.362">class FocusOn(Transform):
    """Shrink a spotlight to a position.

    Parameters
    ----------
    focus_point
        The point at which to shrink the spotlight. If it is a :class:`.~Mobject` its center will be used.
    opacity
        The opacity of the spotlight.
    color
        The color of the spotlight.
    run_time
        The duration of the animation.

    Examples
    --------
    .. manim:: UsingFocusOn

        class UsingFocusOn(Scene):
            def construct(self):
                dot = Dot(color=YELLOW).shift(DOWN)
                self.add(Tex("Focusing on the dot below:"), dot)
                self.play(FocusOn(dot))
                self.wait()
    """

    @others
</t>
<t tx="ekr.20250122151620.363">class Indicate(Transform):
    """Indicate a Mobject by temporarily resizing and recoloring it.

    Parameters
    ----------
    mobject
        The mobject to indicate.
    scale_factor
        The factor by which the mobject will be temporally scaled
    color
        The color the mobject temporally takes.
    rate_func
        The function defining the animation progress at every point in time.
    kwargs
        Additional arguments to be passed to the :class:`~.Succession` constructor

    Examples
    --------
    .. manim:: UsingIndicate

        class UsingIndicate(Scene):
            def construct(self):
                tex = Tex("Indicate").scale(3)
                self.play(Indicate(tex))
                self.wait()
    """

    @others
</t>
<t tx="ekr.20250122151620.364">class Flash(AnimationGroup):
    """Send out lines in all directions.

    Parameters
    ----------
    point
        The center of the flash lines. If it is a :class:`.~Mobject` its center will be used.
    line_length
        The length of the flash lines.
    num_lines
        The number of flash lines.
    flash_radius
        The distance from `point` at which the flash lines start.
    line_stroke_width
        The stroke width of the flash lines.
    color
        The color of the flash lines.
    time_width
        The time width used for the flash lines. See :class:`.~ShowPassingFlash` for more details.
    run_time
        The duration of the animation.
    kwargs
        Additional arguments to be passed to the :class:`~.Succession` constructor

    Examples
    --------
    .. manim:: UsingFlash

        class UsingFlash(Scene):
            def construct(self):
                dot = Dot(color=YELLOW).shift(DOWN)
                self.add(Tex("Flash the dot below:"), dot)
                self.play(Flash(dot))
                self.wait()

    .. manim:: FlashOnCircle

        class FlashOnCircle(Scene):
            def construct(self):
                radius = 2
                circle = Circle(radius)
                self.add(circle)
                self.play(Flash(
                    circle, line_length=1,
                    num_lines=30, color=RED,
                    flash_radius=radius+SMALL_BUFF,
                    time_width=0.3, run_time=2,
                    rate_func = rush_from
                ))
    """

    @others
</t>
<t tx="ekr.20250122151620.365">class ShowPassingFlash(ShowPartial):
    @others
</t>
<t tx="ekr.20250122151620.366">class ShowPassingFlashWithThinningStrokeWidth(AnimationGroup):
    @others
</t>
<t tx="ekr.20250122151620.367">class ApplyWave(Homotopy):
    """Send a wave through the Mobject distorting it temporarily.

    Parameters
    ----------
    mobject
        The mobject to be distorted.
    direction
        The direction in which the wave nudges points of the shape
    amplitude
        The distance points of the shape get shifted
    wave_func
        The function defining the shape of one wave flank.
    time_width
        The length of the wave relative to the width of the mobject.
    ripples
        The number of ripples of the wave
    run_time
        The duration of the animation.

    Examples
    --------

    .. manim:: ApplyingWaves

        class ApplyingWaves(Scene):
            def construct(self):
                tex = Tex("WaveWaveWaveWaveWave").scale(2)
                self.play(ApplyWave(tex))
                self.play(ApplyWave(
                    tex,
                    direction=RIGHT,
                    time_width=0.5,
                    amplitude=0.3
                ))
                self.play(ApplyWave(
                    tex,
                    rate_func=linear,
                    ripples=4
                ))

    """

    @others
</t>
<t tx="ekr.20250122151620.368">class Wiggle(Animation):
    """Wiggle a Mobject.

    Parameters
    ----------
    mobject
        The mobject to wiggle.
    scale_value
        The factor by which the mobject will be temporarily scaled.
    rotation_angle
        The wiggle angle.
    n_wiggles
        The number of wiggles.
    scale_about_point
        The point about which the mobject gets scaled.
    rotate_about_point
        The point around which the mobject gets rotated.
    run_time
        The duration of the animation

    Examples
    --------

    .. manim:: ApplyingWaves

        class ApplyingWaves(Scene):
            def construct(self):
                tex = Tex("Wiggle").scale(3)
                self.play(Wiggle(tex))
                self.wait()

    """

    @others
</t>
<t tx="ekr.20250122151620.369">class Circumscribe(Succession):
    @others
</t>
<t tx="ekr.20250122151620.37">def update(self, obj: ManimConfig | dict[str, Any]) -&gt; None:  # type: ignore[override]
    """Digest the options found in another :class:`ManimConfig` or in a dict.

    Similar to :meth:`dict.update`, replaces the values of this object with
    those of ``obj``.

    Parameters
    ----------
    obj
        The object to copy values from.

    Returns
    -------
    None

    Raises
    -----
    :class:`AttributeError`
        If ``obj`` is a dict but contains keys that do not belong to any
        config options.

    See Also
    --------
    :meth:`~ManimConfig.digest_file`, :meth:`~ManimConfig.digest_args`,
    :meth:`~ManimConfig.digest_parser`

    """
    if isinstance(obj, ManimConfig):
        self._d.update(obj._d)
        if obj.tex_template:
            self.tex_template = obj.tex_template

    elif isinstance(obj, dict):
        # First update the underlying _d, then update other properties
        _dict = {k: v for k, v in obj.items() if k in self._d}
        for k, v in _dict.items():
            self[k] = v

        _dict = {k: v for k, v in obj.items() if k not in self._d}
        for k, v in _dict.items():
            self[k] = v

</t>
<t tx="ekr.20250122151620.370">class Blink(Succession):
    """Blink the mobject.

    Parameters
    ----------
    mobject
        The mobject to be blinked.
    time_on
        The duration that the mobject is shown for one blink.
    time_off
        The duration that the mobject is hidden for one blink.
    blinks
        The number of blinks
    hide_at_end
        Whether to hide the mobject at the end of the animation.
    kwargs
        Additional arguments to be passed to the :class:`~.Succession` constructor.

    Examples
    --------

    .. manim:: BlinkingExample

        class BlinkingExample(Scene):
            def construct(self):
                text = Text("Blinking").scale(1.5)
                self.add(text)
                self.play(Blink(text, blinks=3))

    """

    @others
</t>
<t tx="ekr.20250122151620.371">def __init__(
    self,
    focus_point: np.ndarray | Mobject,
    opacity: float = 0.2,
    color: str = GREY,
    run_time: float = 2,
    **kwargs,
) -&gt; None:
    self.focus_point = focus_point
    self.color = color
    self.opacity = opacity
    remover = True
    starting_dot = Dot(
        radius=config["frame_x_radius"] + config["frame_y_radius"],
        stroke_width=0,
        fill_color=self.color,
        fill_opacity=0,
    )
    super().__init__(starting_dot, run_time=run_time, remover=remover, **kwargs)

</t>
<t tx="ekr.20250122151620.372">def create_target(self) -&gt; Dot:
    little_dot = Dot(radius=0)
    little_dot.set_fill(self.color, opacity=self.opacity)
    little_dot.add_updater(lambda d: d.move_to(self.focus_point))
    return little_dot


</t>
<t tx="ekr.20250122151620.373">def __init__(
    self,
    mobject: Mobject,
    scale_factor: float = 1.2,
    color: str = YELLOW,
    rate_func: Callable[[float, float | None], np.ndarray] = there_and_back,
    **kwargs,
) -&gt; None:
    self.color = color
    self.scale_factor = scale_factor
    super().__init__(mobject, rate_func=rate_func, **kwargs)

</t>
<t tx="ekr.20250122151620.374">def create_target(self) -&gt; Mobject:
    target = self.mobject.copy()
    target.scale(self.scale_factor)
    target.set_color(self.color)
    return target


</t>
<t tx="ekr.20250122151620.375">def __init__(
    self,
    point: np.ndarray | Mobject,
    line_length: float = 0.2,
    num_lines: int = 12,
    flash_radius: float = 0.1,
    line_stroke_width: int = 3,
    color: str = YELLOW,
    time_width: float = 1,
    run_time: float = 1.0,
    **kwargs,
) -&gt; None:
    if isinstance(point, Mobject):
        self.point = point.get_center()
    else:
        self.point = point
    self.color = color
    self.line_length = line_length
    self.num_lines = num_lines
    self.flash_radius = flash_radius
    self.line_stroke_width = line_stroke_width
    self.run_time = run_time
    self.time_width = time_width
    self.animation_config = kwargs

    self.lines = self.create_lines()
    animations = self.create_line_anims()
    super().__init__(*animations, group=self.lines)

</t>
<t tx="ekr.20250122151620.376">def create_lines(self) -&gt; VGroup:
    lines = VGroup()
    for angle in np.arange(0, TAU, TAU / self.num_lines):
        line = Line(self.point, self.point + self.line_length * RIGHT)
        line.shift((self.flash_radius) * RIGHT)
        line.rotate(angle, about_point=self.point)
        lines.add(line)
    lines.set_color(self.color)
    lines.set_stroke(width=self.line_stroke_width)
    return lines

</t>
<t tx="ekr.20250122151620.377">def create_line_anims(self) -&gt; Iterable[ShowPassingFlash]:
    return [
        ShowPassingFlash(
            line,
            time_width=self.time_width,
            run_time=self.run_time,
            **self.animation_config,
        )
        for line in self.lines
    ]


</t>
<t tx="ekr.20250122151620.378">r"""Show only a sliver of the VMobject each frame.

Parameters
----------
mobject
    The mobject whose stroke is animated.
time_width
    The length of the sliver relative to the length of the stroke.

Examples
--------
.. manim:: TimeWidthValues

    class TimeWidthValues(Scene):
        def construct(self):
            p = RegularPolygon(5, color=DARK_GRAY, stroke_width=6).scale(3)
            lbl = VMobject()
            self.add(p, lbl)
            p = p.copy().set_color(BLUE)
            for time_width in [0.2, 0.5, 1, 2]:
                lbl.become(Tex(r"\texttt{time\_width={{%.1f}}}"%time_width))
                self.play(ShowPassingFlash(
                    p.copy().set_color(BLUE),
                    run_time=2,
                    time_width=time_width
                ))

See Also
--------
:class:`~.Create`

"""

def __init__(self, mobject: VMobject, time_width: float = 0.1, **kwargs) -&gt; None:
    self.time_width = time_width
    super().__init__(mobject, remover=True, introducer=True, **kwargs)

</t>
<t tx="ekr.20250122151620.379">def _get_bounds(self, alpha: float) -&gt; tuple[float]:
    tw = self.time_width
    upper = interpolate(0, 1 + tw, alpha)
    lower = upper - tw
    upper = min(upper, 1)
    lower = max(lower, 0)
    return (lower, upper)

</t>
<t tx="ekr.20250122151620.38"># don't allow to delete anything
def __delitem__(self, key: str) -&gt; NoReturn:
    raise AttributeError("'ManimConfig' object does not support item deletion")

</t>
<t tx="ekr.20250122151620.380">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    super().clean_up_from_scene(scene)
    for submob, start in self.get_all_families_zipped():
        submob.pointwise_become_partial(start, 0, 1)


</t>
<t tx="ekr.20250122151620.381">def __init__(self, vmobject, n_segments=10, time_width=0.1, remover=True, **kwargs):
    self.n_segments = n_segments
    self.time_width = time_width
    self.remover = remover
    max_stroke_width = vmobject.get_stroke_width()
    max_time_width = kwargs.pop("time_width", self.time_width)
    super().__init__(
        *(
            ShowPassingFlash(
                vmobject.copy().set_stroke(width=stroke_width),
                time_width=time_width,
                **kwargs,
            )
            for stroke_width, time_width in zip(
                np.linspace(0, max_stroke_width, self.n_segments),
                np.linspace(max_time_width, 0, self.n_segments),
            )
        ),
    )


</t>
<t tx="ekr.20250122151620.382">def __init__(
    self,
    mobject: Mobject,
    direction: np.ndarray = UP,
    amplitude: float = 0.2,
    wave_func: Callable[[float], float] = smooth,
    time_width: float = 1,
    ripples: int = 1,
    run_time: float = 2,
    **kwargs,
) -&gt; None:
    x_min = mobject.get_left()[0]
    x_max = mobject.get_right()[0]
    vect = amplitude * normalize(direction)

    def wave(t):
        # Creates a wave with n ripples from a simple rate_func
        # This wave is build up as follows:
        # The time is split into 2*ripples phases. In every phase the amplitude
        # either rises to one or goes down to zero. Consecutive ripples will have
        # their amplitudes in opposing directions (first ripple from 0 to 1 to 0,
        # second from 0 to -1 to 0 and so on). This is how two ripples would be
        # divided into phases:

        #         ####|####        |            |
        #       ##    |    ##      |            |
        #     ##      |      ##    |            |
        # ####        |        ####|####        |        ####
        #             |            |    ##      |      ##
        #             |            |      ##    |    ##
        #             |            |        ####|####

        # However, this looks weird in the middle between two ripples. Therefore the
        # middle phases do actually use only one appropriately scaled version of the
        # rate like this:

        # 1 / 4 Time  | 2 / 4 Time            | 1 / 4 Time
        #         ####|######                 |
        #       ##    |      ###              |
        #     ##      |         ##            |
        # ####        |           #           |        ####
        #             |            ##         |      ##
        #             |              ###      |    ##
        #             |                 ######|####

        # Mirrored looks better in the way the wave is used.
        t = 1 - t

        # Clamp input
        if t &gt;= 1 or t &lt;= 0:
            return 0

        phases = ripples * 2
        phase = int(t * phases)
        if phase == 0:
            # First rising ripple
            return wave_func(t * phases)
        elif phase == phases - 1:
            # last ripple. Rising or falling depending on the number of ripples
            # The (ripples % 2)-term is used to make this distinction.
            t -= phase / phases  # Time relative to the phase
            return (1 - wave_func(t * phases)) * (2 * (ripples % 2) - 1)
        else:
            # Longer phases:
            phase = int((phase - 1) / 2)
            t -= (2 * phase + 1) / phases

            # Similar to last ripple:
            return (1 - 2 * wave_func(t * ripples)) * (1 - 2 * ((phase) % 2))

    def homotopy(
        x: float,
        y: float,
        z: float,
        t: float,
    ) -&gt; tuple[float, float, float]:
        upper = interpolate(0, 1 + time_width, t)
        lower = upper - time_width
        relative_x = inverse_interpolate(x_min, x_max, x)
        wave_phase = inverse_interpolate(lower, upper, relative_x)
        nudge = wave(wave_phase) * vect
        return np.array([x, y, z]) + nudge

    super().__init__(homotopy, mobject, run_time=run_time, **kwargs)


</t>
<t tx="ekr.20250122151620.383">def __init__(
    self,
    mobject: Mobject,
    scale_value: float = 1.1,
    rotation_angle: float = 0.01 * TAU,
    n_wiggles: int = 6,
    scale_about_point: np.ndarray | None = None,
    rotate_about_point: np.ndarray | None = None,
    run_time: float = 2,
    **kwargs,
) -&gt; None:
    self.scale_value = scale_value
    self.rotation_angle = rotation_angle
    self.n_wiggles = n_wiggles
    self.scale_about_point = scale_about_point
    self.rotate_about_point = rotate_about_point
    super().__init__(mobject, run_time=run_time, **kwargs)

</t>
<t tx="ekr.20250122151620.384">def get_scale_about_point(self) -&gt; np.ndarray:
    if self.scale_about_point is None:
        return self.mobject.get_center()
    return self.scale_about_point

</t>
<t tx="ekr.20250122151620.385">def get_rotate_about_point(self) -&gt; np.ndarray:
    if self.rotate_about_point is None:
        return self.mobject.get_center()
    return self.rotate_about_point

</t>
<t tx="ekr.20250122151620.386">def interpolate_submobject(
    self,
    submobject: Mobject,
    starting_submobject: Mobject,
    alpha: float,
) -&gt; None:
    submobject.points[:, :] = starting_submobject.points
    submobject.scale(
        interpolate(1, self.scale_value, there_and_back(alpha)),
        about_point=self.get_scale_about_point(),
    )
    submobject.rotate(
        wiggle(alpha, self.n_wiggles) * self.rotation_angle,
        about_point=self.get_rotate_about_point(),
    )


</t>
<t tx="ekr.20250122151620.387">r"""Draw a temporary line surrounding the mobject.

Parameters
----------
mobject
    The mobject to be circumscribed.
shape
    The shape with which to surround the given mobject. Should be either
    :class:`~.Rectangle` or :class:`~.Circle`
fade_in
    Whether to make the surrounding shape to fade in. It will be drawn otherwise.
fade_out
    Whether to make the surrounding shape to fade out. It will be undrawn otherwise.
time_width
    The time_width of the drawing and undrawing. Gets ignored if either `fade_in` or `fade_out` is `True`.
buff
    The distance between the surrounding shape and the given mobject.
color
    The color of the surrounding shape.
run_time
    The duration of the entire animation.
kwargs
    Additional arguments to be passed to the :class:`~.Succession` constructor

Examples
--------

.. manim:: UsingCircumscribe

    class UsingCircumscribe(Scene):
        def construct(self):
            lbl = Tex(r"Circum-\\scribe").scale(2)
            self.add(lbl)
            self.play(Circumscribe(lbl))
            self.play(Circumscribe(lbl, Circle))
            self.play(Circumscribe(lbl, fade_out=True))
            self.play(Circumscribe(lbl, time_width=2))
            self.play(Circumscribe(lbl, Circle, True))

"""

def __init__(
    self,
    mobject: Mobject,
    shape: type = Rectangle,
    fade_in=False,
    fade_out=False,
    time_width=0.3,
    buff: float = SMALL_BUFF,
    color: ParsableManimColor = YELLOW,
    run_time=1,
    stroke_width=DEFAULT_STROKE_WIDTH,
    **kwargs,
):
    if shape is Rectangle:
        frame = SurroundingRectangle(
            mobject,
            color=color,
            buff=buff,
            stroke_width=stroke_width,
        )
    elif shape is Circle:
        frame = Circle(color=color, stroke_width=stroke_width).surround(
            mobject,
            buffer_factor=1,
        )
        radius = frame.width / 2
        frame.scale((radius + buff) / radius)
    else:
        raise ValueError("shape should be either Rectangle or Circle.")

    if fade_in and fade_out:
        super().__init__(
            FadeIn(frame, run_time=run_time / 2),
            FadeOut(frame, run_time=run_time / 2),
            **kwargs,
        )
    elif fade_in:
        frame.reverse_direction()
        super().__init__(
            FadeIn(frame, run_time=run_time / 2),
            Uncreate(frame, run_time=run_time / 2),
            **kwargs,
        )
    elif fade_out:
        super().__init__(
            Create(frame, run_time=run_time / 2),
            FadeOut(frame, run_time=run_time / 2),
            **kwargs,
        )
    else:
        super().__init__(
            ShowPassingFlash(frame, time_width, run_time=run_time), **kwargs
        )


</t>
<t tx="ekr.20250122151620.388">def __init__(
    self,
    mobject: Mobject,
    time_on: float = 0.5,
    time_off: float = 0.5,
    blinks: int = 1,
    hide_at_end: bool = False,
    **kwargs,
):
    animations = [
        UpdateFromFunc(
            mobject,
            update_function=lambda mob: mob.set_opacity(1.0),
            run_time=time_on,
        ),
        UpdateFromFunc(
            mobject,
            update_function=lambda mob: mob.set_opacity(0.0),
            run_time=time_off,
        ),
    ] * blinks

    if not hide_at_end:
        animations.append(
            UpdateFromFunc(
                mobject,
                update_function=lambda mob: mob.set_opacity(1.0),
                run_time=time_on,
            ),
        )

    super().__init__(*animations, **kwargs)
</t>
<t tx="ekr.20250122151620.389">"""Animations related to movement."""

from __future__ import annotations

__all__ = [
    "Homotopy",
    "SmoothedVectorizedHomotopy",
    "ComplexHomotopy",
    "PhaseFlow",
    "MoveAlongPath",
]

from typing import TYPE_CHECKING, Any, Callable

import numpy as np

from ..animation.animation import Animation
from ..utils.rate_functions import linear

if TYPE_CHECKING:
    from ..mobject.mobject import Mobject, VMobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.39">def __delattr__(self, key: str) -&gt; NoReturn:
    raise AttributeError("'ManimConfig' object does not support item deletion")

</t>
<t tx="ekr.20250122151620.390">class Homotopy(Animation):
    """A Homotopy.

    This is an animation transforming the points of a mobject according
    to the specified transformation function. With the parameter :math:`t`
    moving from 0 to 1 throughout the animation and :math:`(x, y, z)`
    describing the coordinates of the point of a mobject,
    the function passed to the ``homotopy`` keyword argument should
    transform the tuple :math:`(x, y, z, t)` to :math:`(x', y', z')`,
    the coordinates the original point is transformed to at time :math:`t`.

    Parameters
    ----------
    homotopy
        A function mapping :math:`(x, y, z, t)` to :math:`(x', y', z')`.
    mobject
        The mobject transformed under the given homotopy.
    run_time
        The run time of the animation.
    apply_function_kwargs
        Keyword arguments propagated to :meth:`.Mobject.apply_function`.
    kwargs
        Further keyword arguments passed to the parent class.

    Examples
    --------

    .. manim:: HomotopyExample

        class HomotopyExample(Scene):
            def construct(self):
                square = Square()

                def homotopy(x, y, z, t):
                    if t &lt;= 0.25:
                        progress = t / 0.25
                        return (x, y + progress * 0.2 * np.sin(x), z)
                    else:
                        wave_progress = (t - 0.25) / 0.75
                        return (x, y + 0.2 * np.sin(x + 10 * wave_progress), z)

                self.play(Homotopy(homotopy, square, rate_func= linear, run_time=2))

    """

    @others
</t>
<t tx="ekr.20250122151620.391">class SmoothedVectorizedHomotopy(Homotopy):
    @others
</t>
<t tx="ekr.20250122151620.392">class ComplexHomotopy(Homotopy):
    @others
</t>
<t tx="ekr.20250122151620.393">class PhaseFlow(Animation):
    @others
</t>
<t tx="ekr.20250122151620.394">class MoveAlongPath(Animation):
    """Make one mobject move along the path of another mobject.

    .. manim:: MoveAlongPathExample

        class MoveAlongPathExample(Scene):
            def construct(self):
                d1 = Dot().set_color(ORANGE)
                l1 = Line(LEFT, RIGHT)
                l2 = VMobject()
                self.add(d1, l1, l2)
                l2.add_updater(lambda x: x.become(Line(LEFT, d1.get_center()).set_color(ORANGE)))
                self.play(MoveAlongPath(d1, l1), rate_func=linear)
    """

    @others
</t>
<t tx="ekr.20250122151620.395">def __init__(
    self,
    homotopy: Callable[[float, float, float, float], tuple[float, float, float]],
    mobject: Mobject,
    run_time: float = 3,
    apply_function_kwargs: dict[str, Any] | None = None,
    **kwargs,
) -&gt; None:
    self.homotopy = homotopy
    self.apply_function_kwargs = (
        apply_function_kwargs if apply_function_kwargs is not None else {}
    )
    super().__init__(mobject, run_time=run_time, **kwargs)

</t>
<t tx="ekr.20250122151620.396">def function_at_time_t(self, t: float) -&gt; tuple[float, float, float]:
    return lambda p: self.homotopy(*p, t)

</t>
<t tx="ekr.20250122151620.397">def interpolate_submobject(
    self,
    submobject: Mobject,
    starting_submobject: Mobject,
    alpha: float,
) -&gt; None:
    submobject.points = starting_submobject.points
    submobject.apply_function(
        self.function_at_time_t(alpha), **self.apply_function_kwargs
    )


</t>
<t tx="ekr.20250122151620.398">def interpolate_submobject(
    self,
    submobject: Mobject,
    starting_submobject: Mobject,
    alpha: float,
) -&gt; None:
    super().interpolate_submobject(submobject, starting_submobject, alpha)
    submobject.make_smooth()


</t>
<t tx="ekr.20250122151620.399">def __init__(
    self, complex_homotopy: Callable[[complex], float], mobject: Mobject, **kwargs
) -&gt; None:
    """Complex Homotopy a function Cx[0, 1] to C"""

    def homotopy(
        x: float,
        y: float,
        z: float,
        t: float,
    ) -&gt; tuple[float, float, float]:
        c = complex_homotopy(complex(x, y), t)
        return (c.real, c.imag, z)

    super().__init__(homotopy, mobject, **kwargs)


</t>
<t tx="ekr.20250122151620.4">from __future__ import annotations

import click
import cloup

from manim import __version__
from manim._config import cli_ctx_settings, console
from manim.cli.cfg.group import cfg
from manim.cli.checkhealth.commands import checkhealth
from manim.cli.default_group import DefaultGroup
from manim.cli.init.commands import init
from manim.cli.plugins.commands import plugins
from manim.cli.render.commands import render
from manim.constants import EPILOG


@others
main.add_command(checkhealth)
main.add_command(cfg)
main.add_command(plugins)
main.add_command(init)
main.add_command(render)

if __name__ == "__main__":
    main()
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.40"># copy functions
def copy(self) -&gt; Self:
    """Deepcopy the contents of this ManimConfig.

    Returns
    -------
    :class:`ManimConfig`
        A copy of this object containing no shared references.

    See Also
    --------
    :func:`tempconfig`

    Notes
    -----
    This is the main mechanism behind :func:`tempconfig`.

    """
    return copy.deepcopy(self)

</t>
<t tx="ekr.20250122151620.400">def __init__(
    self,
    function: Callable[[np.ndarray], np.ndarray],
    mobject: Mobject,
    virtual_time: float = 1,
    suspend_mobject_updating: bool = False,
    rate_func: Callable[[float], float] = linear,
    **kwargs,
) -&gt; None:
    self.virtual_time = virtual_time
    self.function = function
    super().__init__(
        mobject,
        suspend_mobject_updating=suspend_mobject_updating,
        rate_func=rate_func,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.401">def interpolate_mobject(self, alpha: float) -&gt; None:
    if hasattr(self, "last_alpha"):
        dt = self.virtual_time * (
            self.rate_func(alpha) - self.rate_func(self.last_alpha)
        )
        self.mobject.apply_function(lambda p: p + dt * self.function(p))
    self.last_alpha = alpha


</t>
<t tx="ekr.20250122151620.402">def __init__(
    self,
    mobject: Mobject,
    path: VMobject,
    suspend_mobject_updating: bool | None = False,
    **kwargs,
) -&gt; None:
    self.path = path
    super().__init__(
        mobject, suspend_mobject_updating=suspend_mobject_updating, **kwargs
    )

</t>
<t tx="ekr.20250122151620.403">def interpolate_mobject(self, alpha: float) -&gt; None:
    point = self.path.point_from_proportion(self.rate_func(alpha))
    self.mobject.move_to(point)
</t>
<t tx="ekr.20250122151620.404">"""Animations for changing numbers."""

from __future__ import annotations

__all__ = ["ChangingDecimal", "ChangeDecimalToValue"]


import typing

from manim.mobject.text.numbers import DecimalNumber

from ..animation.animation import Animation
from ..utils.bezier import interpolate


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.405">class ChangingDecimal(Animation):
    @others
</t>
<t tx="ekr.20250122151620.406">class ChangeDecimalToValue(ChangingDecimal):
    @others
</t>
<t tx="ekr.20250122151620.407">def __init__(
    self,
    decimal_mob: DecimalNumber,
    number_update_func: typing.Callable[[float], float],
    suspend_mobject_updating: bool | None = False,
    **kwargs,
) -&gt; None:
    self.check_validity_of_input(decimal_mob)
    self.number_update_func = number_update_func
    super().__init__(
        decimal_mob, suspend_mobject_updating=suspend_mobject_updating, **kwargs
    )

</t>
<t tx="ekr.20250122151620.408">def check_validity_of_input(self, decimal_mob: DecimalNumber) -&gt; None:
    if not isinstance(decimal_mob, DecimalNumber):
        raise TypeError("ChangingDecimal can only take in a DecimalNumber")

</t>
<t tx="ekr.20250122151620.409">def interpolate_mobject(self, alpha: float) -&gt; None:
    self.mobject.set_value(self.number_update_func(self.rate_func(alpha)))


</t>
<t tx="ekr.20250122151620.41">def __copy__(self) -&gt; Self:
    """See ManimConfig.copy()."""
    return copy.deepcopy(self)

</t>
<t tx="ekr.20250122151620.410">def __init__(
    self, decimal_mob: DecimalNumber, target_number: int, **kwargs
) -&gt; None:
    start_number = decimal_mob.number
    super().__init__(
        decimal_mob, lambda a: interpolate(start_number, target_number, a), **kwargs
    )
</t>
<t tx="ekr.20250122151620.411">"""Animations related to rotation."""

from __future__ import annotations

__all__ = ["Rotating", "Rotate"]

from collections.abc import Sequence
from typing import TYPE_CHECKING, Callable

import numpy as np

from ..animation.animation import Animation
from ..animation.transform import Transform
from ..constants import OUT, PI, TAU
from ..utils.rate_functions import linear

if TYPE_CHECKING:
    from ..mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.412">class Rotating(Animation):
    @others
</t>
<t tx="ekr.20250122151620.413">class Rotate(Transform):
    """Animation that rotates a Mobject.

    Parameters
    ----------
    mobject
        The mobject to be rotated.
    angle
        The rotation angle.
    axis
        The rotation axis as a numpy vector.
    about_point
        The rotation center.
    about_edge
        If ``about_point`` is ``None``, this argument specifies
        the direction of the bounding box point to be taken as
        the rotation center.

    Examples
    --------
    .. manim:: UsingRotate

        class UsingRotate(Scene):
            def construct(self):
                self.play(
                    Rotate(
                        Square(side_length=0.5).shift(UP * 2),
                        angle=2*PI,
                        about_point=ORIGIN,
                        rate_func=linear,
                    ),
                    Rotate(Square(side_length=0.5), angle=2*PI, rate_func=linear),
                    )

    """

    @others
</t>
<t tx="ekr.20250122151620.414">def __init__(
    self,
    mobject: Mobject,
    axis: np.ndarray = OUT,
    radians: np.ndarray = TAU,
    about_point: np.ndarray | None = None,
    about_edge: np.ndarray | None = None,
    run_time: float = 5,
    rate_func: Callable[[float], float] = linear,
    **kwargs,
) -&gt; None:
    self.axis = axis
    self.radians = radians
    self.about_point = about_point
    self.about_edge = about_edge
    super().__init__(mobject, run_time=run_time, rate_func=rate_func, **kwargs)

</t>
<t tx="ekr.20250122151620.415">def interpolate_mobject(self, alpha: float) -&gt; None:
    self.mobject.become(self.starting_mobject)
    self.mobject.rotate(
        self.rate_func(alpha) * self.radians,
        axis=self.axis,
        about_point=self.about_point,
        about_edge=self.about_edge,
    )


</t>
<t tx="ekr.20250122151620.416">def __init__(
    self,
    mobject: Mobject,
    angle: float = PI,
    axis: np.ndarray = OUT,
    about_point: Sequence[float] | None = None,
    about_edge: Sequence[float] | None = None,
    **kwargs,
) -&gt; None:
    if "path_arc" not in kwargs:
        kwargs["path_arc"] = angle
    if "path_arc_axis" not in kwargs:
        kwargs["path_arc_axis"] = axis
    self.angle = angle
    self.axis = axis
    self.about_edge = about_edge
    self.about_point = about_point
    if self.about_point is None:
        self.about_point = mobject.get_center()
    super().__init__(mobject, path_arc_centers=self.about_point, **kwargs)

</t>
<t tx="ekr.20250122151620.417">def create_target(self) -&gt; Mobject:
    target = self.mobject.copy()
    target.rotate(
        self.angle,
        axis=self.axis,
        about_point=self.about_point,
        about_edge=self.about_edge,
    )
    return target
</t>
<t tx="ekr.20250122151620.418">from __future__ import annotations

__all__ = ["Broadcast"]

from collections.abc import Sequence
from typing import Any

from manim.animation.transform import Restore

from ..constants import *
from .composition import LaggedStart


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.419">class Broadcast(LaggedStart):
    """Broadcast a mobject starting from an ``initial_width``, up to the actual size of the mobject.

    Parameters
    ----------
    mobject
        The mobject to be broadcast.
    focal_point
        The center of the broadcast, by default ORIGIN.
    n_mobs
        The number of mobjects that emerge from the focal point, by default 5.
    initial_opacity
        The starting stroke opacity of the mobjects emitted from the broadcast, by default 1.
    final_opacity
        The final stroke opacity of the mobjects emitted from the broadcast, by default 0.
    initial_width
        The initial width of the mobjects, by default 0.0.
    remover
        Whether the mobjects should be removed from the scene after the animation, by default True.
    lag_ratio
        The time between each iteration of the mobject, by default 0.2.
    run_time
        The total duration of the animation, by default 3.
    kwargs
        Additional arguments to be passed to :class:`~.LaggedStart`.

    Examples
    ---------

    .. manim:: BroadcastExample

        class BroadcastExample(Scene):
            def construct(self):
                mob = Circle(radius=4, color=TEAL_A)
                self.play(Broadcast(mob))
    """

    @others
</t>
<t tx="ekr.20250122151620.42">def __deepcopy__(self, memo: dict[str, Any]) -&gt; Self:
    """See ManimConfig.copy()."""
    c = type(self)()
    # Deepcopying the underlying dict is enough because all properties
    # either read directly from it or compute their value on the fly from
    # values read directly from it.
    c._d = copy.deepcopy(self._d, memo)
    return c

</t>
<t tx="ekr.20250122151620.420">def __init__(
    self,
    mobject,
    focal_point: Sequence[float] = ORIGIN,
    n_mobs: int = 5,
    initial_opacity: float = 1,
    final_opacity: float = 0,
    initial_width: float = 0.0,
    remover: bool = True,
    lag_ratio: float = 0.2,
    run_time: float = 3,
    **kwargs: Any,
):
    self.focal_point = focal_point
    self.n_mobs = n_mobs
    self.initial_opacity = initial_opacity
    self.final_opacity = final_opacity
    self.initial_width = initial_width

    anims = []

    # Works by saving the mob that is passed into the animation, scaling it to 0 (or the initial_width) and then restoring the original mob.
    fill_o = bool(mobject.fill_opacity)

    for _ in range(self.n_mobs):
        mob = mobject.copy()

        if fill_o:
            mob.set_opacity(self.final_opacity)
        else:
            mob.set_stroke(opacity=self.final_opacity)

        mob.move_to(self.focal_point)
        mob.save_state()
        mob.set(width=self.initial_width)

        if fill_o:
            mob.set_opacity(self.initial_opacity)
        else:
            mob.set_stroke(opacity=self.initial_opacity)

        anims.append(Restore(mob, remover=remover))

    super().__init__(*anims, run_time=run_time, lag_ratio=lag_ratio, **kwargs)
</t>
<t tx="ekr.20250122151620.421">"""Utilities for modifying the speed at which animations are played."""

from __future__ import annotations

import inspect
import types
from typing import TYPE_CHECKING, Callable

from numpy import piecewise

from ..animation.animation import Animation, Wait, prepare_animation
from ..animation.composition import AnimationGroup
from ..mobject.mobject import Mobject, _AnimationBuilder
from ..scene.scene import Scene

if TYPE_CHECKING:
    from ..mobject.mobject import Updater

__all__ = ["ChangeSpeed"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.422">class ChangeSpeed(Animation):
    """Modifies the speed of passed animation.
    :class:`AnimationGroup` with different ``lag_ratio`` can also be used
    which combines multiple animations into one.
    The ``run_time`` of the passed animation is changed to modify the speed.

    Parameters
    ----------
    anim
        Animation of which the speed is to be modified.
    speedinfo
        Contains nodes (percentage of ``run_time``) and its corresponding speed factor.
    rate_func
        Overrides ``rate_func`` of passed animation, applied before changing speed.

    Examples
    --------

    .. manim:: SpeedModifierExample

        class SpeedModifierExample(Scene):
            def construct(self):
                a = Dot().shift(LEFT * 4)
                b = Dot().shift(RIGHT * 4)
                self.add(a, b)
                self.play(
                    ChangeSpeed(
                        AnimationGroup(
                            a.animate(run_time=1).shift(RIGHT * 8),
                            b.animate(run_time=1).shift(LEFT * 8),
                        ),
                        speedinfo={0.3: 1, 0.4: 0.1, 0.6: 0.1, 1: 1},
                        rate_func=linear,
                    )
                )

    .. manim:: SpeedModifierUpdaterExample

        class SpeedModifierUpdaterExample(Scene):
            def construct(self):
                a = Dot().shift(LEFT * 4)
                self.add(a)

                ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
                self.play(
                    ChangeSpeed(
                        Wait(2),
                        speedinfo={0.4: 1, 0.5: 0.2, 0.8: 0.2, 1: 1},
                        affects_speed_updaters=True,
                    )
                )

    .. manim:: SpeedModifierUpdaterExample2

        class SpeedModifierUpdaterExample2(Scene):
            def construct(self):
                a = Dot().shift(LEFT * 4)
                self.add(a)

                ChangeSpeed.add_updater(a, lambda x, dt: x.shift(RIGHT * 4 * dt))
                self.wait()
                self.play(
                    ChangeSpeed(
                        Wait(),
                        speedinfo={1: 0},
                        affects_speed_updaters=True,
                    )
                )

    """

    @others
</t>
<t tx="ekr.20250122151620.423">dt = 0
is_changing_dt = False

def __init__(
    self,
    anim: Animation | _AnimationBuilder,
    speedinfo: dict[float, float],
    rate_func: Callable[[float], float] | None = None,
    affects_speed_updaters: bool = True,
    **kwargs,
) -&gt; None:
    if issubclass(type(anim), AnimationGroup):
        self.anim = type(anim)(
            *map(self.setup, anim.animations),
            group=anim.group,
            run_time=anim.run_time,
            rate_func=anim.rate_func,
            lag_ratio=anim.lag_ratio,
        )
    else:
        self.anim = self.setup(anim)

    if affects_speed_updaters:
        assert ChangeSpeed.is_changing_dt is False, (
            "Only one animation at a time can play that changes speed (dt) for ChangeSpeed updaters"
        )
        ChangeSpeed.is_changing_dt = True
        self.t = 0
    self.affects_speed_updaters = affects_speed_updaters

    self.rate_func = self.anim.rate_func if rate_func is None else rate_func

    # A function where, f(0) = 0, f'(0) = initial speed, f'( f-1(1) ) = final speed
    # Following function obtained when conditions applied to vertical parabola
    self.speed_modifier = lambda x, init_speed, final_speed: (
        (final_speed**2 - init_speed**2) * x**2 / 4 + init_speed * x
    )

    # f-1(1), returns x for which f(x) = 1 in `speed_modifier` function
    self.f_inv_1 = lambda init_speed, final_speed: 2 / (init_speed + final_speed)

    # if speed factors for the starting node (0) and the final node (1) are
    # not set, set them to 1 and the penultimate factor, respectively
    if 0 not in speedinfo:
        speedinfo[0] = 1
    if 1 not in speedinfo:
        speedinfo[1] = sorted(speedinfo.items())[-1][1]

    self.speedinfo = dict(sorted(speedinfo.items()))
    self.functions = []
    self.conditions = []

    # Get the time taken by amimation if `run_time` is assumed to be 1
    scaled_total_time = self.get_scaled_total_time()

    prevnode = 0
    init_speed = self.speedinfo[0]
    curr_time = 0
    for node, final_speed in list(self.speedinfo.items())[1:]:
        dur = node - prevnode

        def condition(
            t,
            curr_time=curr_time,
            init_speed=init_speed,
            final_speed=final_speed,
            dur=dur,
        ):
            lower_bound = curr_time / scaled_total_time
            upper_bound = (
                curr_time + self.f_inv_1(init_speed, final_speed) * dur
            ) / scaled_total_time
            return lower_bound &lt;= t &lt;= upper_bound

        self.conditions.append(condition)

        def function(
            t,
            curr_time=curr_time,
            init_speed=init_speed,
            final_speed=final_speed,
            dur=dur,
            prevnode=prevnode,
        ):
            return (
                self.speed_modifier(
                    (scaled_total_time * t - curr_time) / dur,
                    init_speed,
                    final_speed,
                )
                * dur
                + prevnode
            )

        self.functions.append(function)

        curr_time += self.f_inv_1(init_speed, final_speed) * dur
        prevnode = node
        init_speed = final_speed

    def func(t):
        if t == 1:
            ChangeSpeed.is_changing_dt = False
        new_t = piecewise(
            self.rate_func(t),
            [condition(self.rate_func(t)) for condition in self.conditions],
            self.functions,
        )
        if self.affects_speed_updaters:
            ChangeSpeed.dt = (new_t - self.t) * self.anim.run_time
            self.t = new_t
        return new_t

    self.anim.set_rate_func(func)

    super().__init__(
        self.anim.mobject,
        rate_func=self.rate_func,
        run_time=scaled_total_time * self.anim.run_time,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.424">def setup(self, anim):
    if type(anim) is Wait:
        anim.interpolate = types.MethodType(
            lambda self, alpha: self.rate_func(alpha), anim
        )
    return prepare_animation(anim)

</t>
<t tx="ekr.20250122151620.425">def get_scaled_total_time(self) -&gt; float:
    """The time taken by the animation under the assumption that the ``run_time`` is 1."""
    prevnode = 0
    init_speed = self.speedinfo[0]
    total_time = 0
    for node, final_speed in list(self.speedinfo.items())[1:]:
        dur = node - prevnode
        total_time += dur * self.f_inv_1(init_speed, final_speed)
        prevnode = node
        init_speed = final_speed
    return total_time

</t>
<t tx="ekr.20250122151620.426">@classmethod
def add_updater(
    cls,
    mobject: Mobject,
    update_function: Updater,
    index: int | None = None,
    call_updater: bool = False,
):
    """This static method can be used to apply speed change to updaters.

    This updater will follow speed and rate function of any :class:`.ChangeSpeed`
    animation that is playing with ``affects_speed_updaters=True``. By default,
    updater functions added via the usual :meth:`.Mobject.add_updater` method
    do not respect the change of animation speed.

    Parameters
    ----------
    mobject
        The mobject to which the updater should be attached.
    update_function
        The function that is called whenever a new frame is rendered.
    index
        The position in the list of the mobject's updaters at which the
        function should be inserted.
    call_updater
        If ``True``, calls the update function when attaching it to the
        mobject.

    See also
    --------
    :class:`.ChangeSpeed`
    :meth:`.Mobject.add_updater`
    """
    if "dt" in inspect.signature(update_function).parameters:
        mobject.add_updater(
            lambda mob, dt: update_function(
                mob, ChangeSpeed.dt if ChangeSpeed.is_changing_dt else dt
            ),
            index=index,
            call_updater=call_updater,
        )
    else:
        mobject.add_updater(update_function, index=index, call_updater=call_updater)

</t>
<t tx="ekr.20250122151620.427">def interpolate(self, alpha: float) -&gt; None:
    self.anim.interpolate(alpha)

</t>
<t tx="ekr.20250122151620.428">def update_mobjects(self, dt: float) -&gt; None:
    self.anim.update_mobjects(dt)

</t>
<t tx="ekr.20250122151620.429">def finish(self) -&gt; None:
    ChangeSpeed.is_changing_dt = False
    self.anim.finish()

</t>
<t tx="ekr.20250122151620.43"># helper type-checking methods
def _set_from_list(self, key: str, val: Any, values: list[Any]) -&gt; None:
    """Set ``key`` to ``val`` if ``val`` is contained in ``values``."""
    if val in values:
        self._d[key] = val
    else:
        raise ValueError(f"attempted to set {key} to {val}; must be in {values}")

</t>
<t tx="ekr.20250122151620.430">def begin(self) -&gt; None:
    self.anim.begin()

</t>
<t tx="ekr.20250122151620.431">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    self.anim.clean_up_from_scene(scene)

</t>
<t tx="ekr.20250122151620.432">def _setup_scene(self, scene) -&gt; None:
    self.anim._setup_scene(scene)
</t>
<t tx="ekr.20250122151620.433">"""Animations transforming one mobject into another."""

from __future__ import annotations

__all__ = [
    "Transform",
    "ReplacementTransform",
    "TransformFromCopy",
    "ClockwiseTransform",
    "CounterclockwiseTransform",
    "MoveToTarget",
    "ApplyMethod",
    "ApplyPointwiseFunction",
    "ApplyPointwiseFunctionToCenter",
    "FadeToColor",
    "FadeTransform",
    "FadeTransformPieces",
    "ScaleInPlace",
    "ShrinkToCenter",
    "Restore",
    "ApplyFunction",
    "ApplyMatrix",
    "ApplyComplexFunction",
    "CyclicReplace",
    "Swap",
    "TransformAnimations",
]

import inspect
import types
from collections.abc import Iterable, Sequence
from typing import TYPE_CHECKING, Any, Callable

import numpy as np

from manim.mobject.opengl.opengl_mobject import OpenGLGroup, OpenGLMobject

from .. import config
from ..animation.animation import Animation
from ..constants import (
    DEFAULT_POINTWISE_FUNCTION_RUN_TIME,
    DEGREES,
    ORIGIN,
    OUT,
    RendererType,
)
from ..mobject.mobject import Group, Mobject
from ..utils.paths import path_along_arc, path_along_circles
from ..utils.rate_functions import smooth, squish_rate_func

if TYPE_CHECKING:
    from ..scene.scene import Scene


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.434">class Transform(Animation):
    """A Transform transforms a Mobject into a target Mobject.

    Parameters
    ----------
    mobject
        The :class:`.Mobject` to be transformed. It will be mutated to become the ``target_mobject``.
    target_mobject
        The target of the transformation.
    path_func
        A function defining the path that the points of the ``mobject`` are being moved
        along until they match the points of the ``target_mobject``, see :mod:`.utils.paths`.
    path_arc
        The arc angle (in radians) that the points of ``mobject`` will follow to reach
        the points of the target if using a circular path arc, see ``path_arc_centers``.
        See also :func:`manim.utils.paths.path_along_arc`.
    path_arc_axis
        The axis to rotate along if using a circular path arc, see ``path_arc_centers``.
    path_arc_centers
        The center of the circular arcs along which the points of ``mobject`` are
        moved by the transformation.

        If this is set and ``path_func`` is not set, then a ``path_along_circles`` path will be generated
        using the ``path_arc`` parameters and stored in ``path_func``. If ``path_func`` is set, this and the
        other ``path_arc`` fields are set as attributes, but a ``path_func`` is not generated from it.
    replace_mobject_with_target_in_scene
        Controls which mobject is replaced when the transformation is complete.

        If set to True, ``mobject`` will be removed from the scene and ``target_mobject`` will
        replace it. Otherwise, ``target_mobject`` is never added and ``mobject`` just takes its shape.

    Examples
    --------

    .. manim :: TransformPathArc

        class TransformPathArc(Scene):
            def construct(self):
                def make_arc_path(start, end, arc_angle):
                    points = []
                    p_fn = path_along_arc(arc_angle)
                    # alpha animates between 0.0 and 1.0, where 0.0
                    # is the beginning of the animation and 1.0 is the end.
                    for alpha in range(0, 11):
                        points.append(p_fn(start, end, alpha / 10.0))
                    path = VMobject(stroke_color=YELLOW)
                    path.set_points_smoothly(points)
                    return path

                left = Circle(stroke_color=BLUE_E, fill_opacity=1.0, radius=0.5).move_to(LEFT * 2)
                colors = [TEAL_A, TEAL_B, TEAL_C, TEAL_D, TEAL_E, GREEN_A]
                # Positive angles move counter-clockwise, negative angles move clockwise.
                examples = [-90, 0, 30, 90, 180, 270]
                anims = []
                for idx, angle in enumerate(examples):
                    left_c = left.copy().shift((3 - idx) * UP)
                    left_c.fill_color = colors[idx]
                    right_c = left_c.copy().shift(4 * RIGHT)
                    path_arc = make_arc_path(left_c.get_center(), right_c.get_center(),
                                             arc_angle=angle * DEGREES)
                    desc = Text('%d°' % examples[idx]).next_to(left_c, LEFT)
                    # Make the circles in front of the text in front of the arcs.
                    self.add(
                        path_arc.set_z_index(1),
                        desc.set_z_index(2),
                        left_c.set_z_index(3),
                    )
                    anims.append(Transform(left_c, right_c, path_arc=angle * DEGREES))

                self.play(*anims, run_time=2)
                self.wait()
    """

    @others
</t>
<t tx="ekr.20250122151620.435">class ReplacementTransform(Transform):
    """Replaces and morphs a mobject into a target mobject.

    Parameters
    ----------
    mobject
        The starting :class:`~.Mobject`.
    target_mobject
        The target :class:`~.Mobject`.
    kwargs
        Further keyword arguments that are passed to :class:`Transform`.

    Examples
    --------

    .. manim:: ReplacementTransformOrTransform
        :quality: low

        class ReplacementTransformOrTransform(Scene):
            def construct(self):
                # set up the numbers
                r_transform = VGroup(*[Integer(i) for i in range(1,4)])
                text_1 = Text("ReplacementTransform", color=RED)
                r_transform.add(text_1)

                transform = VGroup(*[Integer(i) for i in range(4,7)])
                text_2 = Text("Transform", color=BLUE)
                transform.add(text_2)

                ints = VGroup(r_transform, transform)
                texts = VGroup(text_1, text_2).scale(0.75)
                r_transform.arrange(direction=UP, buff=1)
                transform.arrange(direction=UP, buff=1)

                ints.arrange(buff=2)
                self.add(ints, texts)

                # The mobs replace each other and none are left behind
                self.play(ReplacementTransform(r_transform[0], r_transform[1]))
                self.play(ReplacementTransform(r_transform[1], r_transform[2]))

                # The mobs linger after the Transform()
                self.play(Transform(transform[0], transform[1]))
                self.play(Transform(transform[1], transform[2]))
                self.wait()

    """

    @others
</t>
<t tx="ekr.20250122151620.436">class TransformFromCopy(Transform):
    """Performs a reversed Transform"""

    @others
</t>
<t tx="ekr.20250122151620.437">class ClockwiseTransform(Transform):
    """Transforms the points of a mobject along a clockwise oriented arc.

    See also
    --------
    :class:`.Transform`, :class:`.CounterclockwiseTransform`

    Examples
    --------

    .. manim:: ClockwiseExample

        class ClockwiseExample(Scene):
            def construct(self):
                dl, dr = Dot(), Dot()
                sl, sr = Square(), Square()

                VGroup(dl, sl).arrange(DOWN).shift(2*LEFT)
                VGroup(dr, sr).arrange(DOWN).shift(2*RIGHT)

                self.add(dl, dr)
                self.wait()
                self.play(
                    ClockwiseTransform(dl, sl),
                    Transform(dr, sr)
                )
                self.wait()

    """

    @others
</t>
<t tx="ekr.20250122151620.438">class CounterclockwiseTransform(Transform):
    """Transforms the points of a mobject along a counterclockwise oriented arc.

    See also
    --------
    :class:`.Transform`, :class:`.ClockwiseTransform`

    Examples
    --------

    .. manim:: CounterclockwiseTransform_vs_Transform

        class CounterclockwiseTransform_vs_Transform(Scene):
            def construct(self):
                # set up the numbers
                c_transform = VGroup(DecimalNumber(number=3.141, num_decimal_places=3), DecimalNumber(number=1.618, num_decimal_places=3))
                text_1 = Text("CounterclockwiseTransform", color=RED)
                c_transform.add(text_1)

                transform = VGroup(DecimalNumber(number=1.618, num_decimal_places=3), DecimalNumber(number=3.141, num_decimal_places=3))
                text_2 = Text("Transform", color=BLUE)
                transform.add(text_2)

                ints = VGroup(c_transform, transform)
                texts = VGroup(text_1, text_2).scale(0.75)
                c_transform.arrange(direction=UP, buff=1)
                transform.arrange(direction=UP, buff=1)

                ints.arrange(buff=2)
                self.add(ints, texts)

                # The mobs move in clockwise direction for ClockwiseTransform()
                self.play(CounterclockwiseTransform(c_transform[0], c_transform[1]))

                # The mobs move straight up for Transform()
                self.play(Transform(transform[0], transform[1]))

    """

    @others
</t>
<t tx="ekr.20250122151620.439">class MoveToTarget(Transform):
    """Transforms a mobject to the mobject stored in its ``target`` attribute.

    After calling the :meth:`~.Mobject.generate_target` method, the :attr:`target`
    attribute of the mobject is populated with a copy of it. After modifying the attribute,
    playing the :class:`.MoveToTarget` animation transforms the original mobject
    into the modified one stored in the :attr:`target` attribute.

    Examples
    --------

    .. manim:: MoveToTargetExample

        class MoveToTargetExample(Scene):
            def construct(self):
                c = Circle()

                c.generate_target()
                c.target.set_fill(color=GREEN, opacity=0.5)
                c.target.shift(2*RIGHT + UP).scale(0.5)

                self.add(c)
                self.play(MoveToTarget(c))

    """

    @others
</t>
<t tx="ekr.20250122151620.44">def _set_from_enum(self, key: str, enum_value: Any, enum_class: EnumMeta) -&gt; None:
    """Set ``key`` to the enum object with value ``enum_value`` in the given
    ``enum_class``.

    Tests::

        &gt;&gt;&gt; from enum import Enum
        &gt;&gt;&gt; class Fruit(Enum):
        ...     APPLE = 1
        ...     BANANA = 2
        ...     CANTALOUPE = 3
        &gt;&gt;&gt; test_config = ManimConfig()
        &gt;&gt;&gt; test_config._set_from_enum("fruit", 1, Fruit)
        &gt;&gt;&gt; test_config._d['fruit']
        &lt;Fruit.APPLE: 1&gt;
        &gt;&gt;&gt; test_config._set_from_enum("fruit", Fruit.BANANA, Fruit)
        &gt;&gt;&gt; test_config._d['fruit']
        &lt;Fruit.BANANA: 2&gt;
        &gt;&gt;&gt; test_config._set_from_enum("fruit", 42, Fruit)
        Traceback (most recent call last):
        ...
        ValueError: 42 is not a valid Fruit
    """
    self._d[key] = enum_class(enum_value)

</t>
<t tx="ekr.20250122151620.440">class _MethodAnimation(MoveToTarget):
    @others
</t>
<t tx="ekr.20250122151620.441">class ApplyMethod(Transform):
    """Animates a mobject by applying a method.

    Note that only the method needs to be passed to this animation,
    it is not required to pass the corresponding mobject. Furthermore,
    this animation class only works if the method returns the modified
    mobject.

    Parameters
    ----------
    method
        The method that will be applied in the animation.
    args
        Any positional arguments to be passed when applying the method.
    kwargs
        Any keyword arguments passed to :class:`~.Transform`.

    """

    @others
</t>
<t tx="ekr.20250122151620.442">class ApplyPointwiseFunction(ApplyMethod):
    """Animation that applies a pointwise function to a mobject.

    Examples
    --------

    .. manim:: WarpSquare
        :quality: low

        class WarpSquare(Scene):
            def construct(self):
                square = Square()
                self.play(
                    ApplyPointwiseFunction(
                        lambda point: complex_to_R3(np.exp(R3_to_complex(point))), square
                    )
                )
                self.wait()

    """

    @others
</t>
<t tx="ekr.20250122151620.443">class ApplyPointwiseFunctionToCenter(ApplyPointwiseFunction):
    @others
</t>
<t tx="ekr.20250122151620.444">class FadeToColor(ApplyMethod):
    """Animation that changes color of a mobject.

    Examples
    --------

    .. manim:: FadeToColorExample

        class FadeToColorExample(Scene):
            def construct(self):
                self.play(FadeToColor(Text("Hello World!"), color=RED))

    """

    @others
</t>
<t tx="ekr.20250122151620.445">class ScaleInPlace(ApplyMethod):
    """Animation that scales a mobject by a certain factor.

    Examples
    --------

    .. manim:: ScaleInPlaceExample

        class ScaleInPlaceExample(Scene):
            def construct(self):
                self.play(ScaleInPlace(Text("Hello World!"), 2))

    """

    @others
</t>
<t tx="ekr.20250122151620.446">class ShrinkToCenter(ScaleInPlace):
    """Animation that makes a mobject shrink to center.

    Examples
    --------

    .. manim:: ShrinkToCenterExample

        class ShrinkToCenterExample(Scene):
            def construct(self):
                self.play(ShrinkToCenter(Text("Hello World!")))

    """

    @others
</t>
<t tx="ekr.20250122151620.447">class Restore(ApplyMethod):
    """Transforms a mobject to its last saved state.

    To save the state of a mobject, use the :meth:`~.Mobject.save_state` method.

    Examples
    --------

    .. manim:: RestoreExample

        class RestoreExample(Scene):
            def construct(self):
                s = Square()
                s.save_state()
                self.play(FadeIn(s))
                self.play(s.animate.set_color(PURPLE).set_opacity(0.5).shift(2*LEFT).scale(3))
                self.play(s.animate.shift(5*DOWN).rotate(PI/4))
                self.wait()
                self.play(Restore(s), run_time=2)

    """

    @others
</t>
<t tx="ekr.20250122151620.448">class ApplyFunction(Transform):
    @others
</t>
<t tx="ekr.20250122151620.449">class ApplyMatrix(ApplyPointwiseFunction):
    """Applies a matrix transform to an mobject.

    Parameters
    ----------
    matrix
        The transformation matrix.
    mobject
        The :class:`~.Mobject`.
    about_point
        The origin point for the transform. Defaults to ``ORIGIN``.
    kwargs
        Further keyword arguments that are passed to :class:`ApplyPointwiseFunction`.

    Examples
    --------

    .. manim:: ApplyMatrixExample

        class ApplyMatrixExample(Scene):
            def construct(self):
                matrix = [[1, 1], [0, 2/3]]
                self.play(ApplyMatrix(matrix, Text("Hello World!")), ApplyMatrix(matrix, NumberPlane()))

    """

    @others
</t>
<t tx="ekr.20250122151620.45">def _set_boolean(self, key: str, val: Any) -&gt; None:
    """Set ``key`` to ``val`` if ``val`` is Boolean."""
    if val in [True, False]:
        self._d[key] = val
    else:
        raise ValueError(f"{key} must be boolean")

</t>
<t tx="ekr.20250122151620.450">class ApplyComplexFunction(ApplyMethod):
    @others
</t>
<t tx="ekr.20250122151620.451">###


class CyclicReplace(Transform):
    """An animation moving mobjects cyclically.

    In particular, this means: the first mobject takes the place
    of the second mobject, the second one takes the place of
    the third mobject, and so on. The last mobject takes the
    place of the first one.

    Parameters
    ----------
    mobjects
        List of mobjects to be transformed.
    path_arc
        The angle of the arc (in radians) that the mobjects will follow to reach
        their target.
    kwargs
        Further keyword arguments that are passed to :class:`.Transform`.

    Examples
    --------
    .. manim :: CyclicReplaceExample

        class CyclicReplaceExample(Scene):
            def construct(self):
                group = VGroup(Square(), Circle(), Triangle(), Star())
                group.arrange(RIGHT)
                self.add(group)

                for _ in range(4):
                    self.play(CyclicReplace(*group))
    """

    @others
</t>
<t tx="ekr.20250122151620.452">class Swap(CyclicReplace):
    pass  # Renaming, more understandable for two entries


</t>
<t tx="ekr.20250122151620.453"># TODO, this may be deprecated...worth reimplementing?
class TransformAnimations(Transform):
    @others
</t>
<t tx="ekr.20250122151620.454">class FadeTransform(Transform):
    """Fades one mobject into another.

    Parameters
    ----------
    mobject
        The starting :class:`~.Mobject`.
    target_mobject
        The target :class:`~.Mobject`.
    stretch
        Controls whether the target :class:`~.Mobject` is stretched during
        the animation. Default: ``True``.
    dim_to_match
        If the target mobject is not stretched automatically, this allows
        to adjust the initial scale of the target :class:`~.Mobject` while
        it is shifted in. Setting this to 0, 1, and 2, respectively,
        matches the length of the target with the length of the starting
        :class:`~.Mobject` in x, y, and z direction, respectively.
    kwargs
        Further keyword arguments are passed to the parent class.

    Examples
    --------

    .. manim:: DifferentFadeTransforms

        class DifferentFadeTransforms(Scene):
            def construct(self):
                starts = [Rectangle(width=4, height=1) for _ in range(3)]
                VGroup(*starts).arrange(DOWN, buff=1).shift(3*LEFT)
                targets = [Circle(fill_opacity=1).scale(0.25) for _ in range(3)]
                VGroup(*targets).arrange(DOWN, buff=1).shift(3*RIGHT)

                self.play(*[FadeIn(s) for s in starts])
                self.play(
                    FadeTransform(starts[0], targets[0], stretch=True),
                    FadeTransform(starts[1], targets[1], stretch=False, dim_to_match=0),
                    FadeTransform(starts[2], targets[2], stretch=False, dim_to_match=1)
                )

                self.play(*[FadeOut(mobj) for mobj in self.mobjects])

    """

    @others
</t>
<t tx="ekr.20250122151620.455">class FadeTransformPieces(FadeTransform):
    """Fades submobjects of one mobject into submobjects of another one.

    See also
    --------
    :class:`~.FadeTransform`

    Examples
    --------
    .. manim:: FadeTransformSubmobjects

        class FadeTransformSubmobjects(Scene):
            def construct(self):
                src = VGroup(Square(), Circle().shift(LEFT + UP))
                src.shift(3*LEFT + 2*UP)
                src_copy = src.copy().shift(4*DOWN)

                target = VGroup(Circle(), Triangle().shift(RIGHT + DOWN))
                target.shift(3*RIGHT + 2*UP)
                target_copy = target.copy().shift(4*DOWN)

                self.play(FadeIn(src), FadeIn(src_copy))
                self.play(
                    FadeTransform(src, target),
                    FadeTransformPieces(src_copy, target_copy)
                )
                self.play(*[FadeOut(mobj) for mobj in self.mobjects])

    """

    @others
</t>
<t tx="ekr.20250122151620.456">def __init__(
    self,
    mobject: Mobject | None,
    target_mobject: Mobject | None = None,
    path_func: Callable | None = None,
    path_arc: float = 0,
    path_arc_axis: np.ndarray = OUT,
    path_arc_centers: np.ndarray = None,
    replace_mobject_with_target_in_scene: bool = False,
    **kwargs,
) -&gt; None:
    self.path_arc_axis: np.ndarray = path_arc_axis
    self.path_arc_centers: np.ndarray = path_arc_centers
    self.path_arc: float = path_arc

    # path_func is a property a few lines below so it doesn't need to be set in any case
    if path_func is not None:
        self.path_func: Callable = path_func
    elif self.path_arc_centers is not None:
        self.path_func = path_along_circles(
            path_arc,
            self.path_arc_centers,
            self.path_arc_axis,
        )

    self.replace_mobject_with_target_in_scene: bool = (
        replace_mobject_with_target_in_scene
    )
    self.target_mobject: Mobject = (
        target_mobject if target_mobject is not None else Mobject()
    )
    super().__init__(mobject, **kwargs)

</t>
<t tx="ekr.20250122151620.457">@property
def path_arc(self) -&gt; float:
    return self._path_arc

</t>
<t tx="ekr.20250122151620.458">@path_arc.setter
def path_arc(self, path_arc: float) -&gt; None:
    self._path_arc = path_arc
    self._path_func = path_along_arc(
        arc_angle=self._path_arc,
        axis=self.path_arc_axis,
    )

</t>
<t tx="ekr.20250122151620.459">@property
def path_func(
    self,
) -&gt; Callable[
    [Iterable[np.ndarray], Iterable[np.ndarray], float],
    Iterable[np.ndarray],
</t>
<t tx="ekr.20250122151620.46">def _set_tuple(self, key: str, val: tuple[Any]) -&gt; None:
    if isinstance(val, tuple):
        self._d[key] = val
    else:
        raise ValueError(f"{key} must be tuple")

</t>
<t tx="ekr.20250122151620.460">]:
    return self._path_func

@path_func.setter
def path_func(
    self,
    path_func: Callable[
        [Iterable[np.ndarray], Iterable[np.ndarray], float],
        Iterable[np.ndarray],
    ],
) -&gt; None:
    if path_func is not None:
        self._path_func = path_func

</t>
<t tx="ekr.20250122151620.461">def begin(self) -&gt; None:
    # Use a copy of target_mobject for the align_data
    # call so that the actual target_mobject stays
    # preserved.
    self.target_mobject = self.create_target()
    self.target_copy = self.target_mobject.copy()
    # Note, this potentially changes the structure
    # of both mobject and target_mobject
    if config.renderer == RendererType.OPENGL:
        self.mobject.align_data_and_family(self.target_copy)
    else:
        self.mobject.align_data(self.target_copy)
    super().begin()

</t>
<t tx="ekr.20250122151620.462">def create_target(self) -&gt; Mobject:
    # Has no meaningful effect here, but may be useful
    # in subclasses
    return self.target_mobject

</t>
<t tx="ekr.20250122151620.463">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    super().clean_up_from_scene(scene)
    if self.replace_mobject_with_target_in_scene:
        scene.replace(self.mobject, self.target_mobject)

</t>
<t tx="ekr.20250122151620.464">def get_all_mobjects(self) -&gt; Sequence[Mobject]:
    return [
        self.mobject,
        self.starting_mobject,
        self.target_mobject,
        self.target_copy,
    ]

</t>
<t tx="ekr.20250122151620.465">def get_all_families_zipped(self) -&gt; Iterable[tuple]:  # more precise typing?
    mobs = [
        self.mobject,
        self.starting_mobject,
        self.target_copy,
    ]
    if config.renderer == RendererType.OPENGL:
        return zip(*(mob.get_family() for mob in mobs))
    return zip(*(mob.family_members_with_points() for mob in mobs))

</t>
<t tx="ekr.20250122151620.466">def interpolate_submobject(
    self,
    submobject: Mobject,
    starting_submobject: Mobject,
    target_copy: Mobject,
    alpha: float,
) -&gt; Transform:
    submobject.interpolate(starting_submobject, target_copy, alpha, self.path_func)
    return self


</t>
<t tx="ekr.20250122151620.467">def __init__(self, mobject: Mobject, target_mobject: Mobject, **kwargs) -&gt; None:
    super().__init__(
        mobject, target_mobject, replace_mobject_with_target_in_scene=True, **kwargs
    )


</t>
<t tx="ekr.20250122151620.468">def __init__(self, mobject: Mobject, target_mobject: Mobject, **kwargs) -&gt; None:
    super().__init__(target_mobject, mobject, **kwargs)

</t>
<t tx="ekr.20250122151620.469">def interpolate(self, alpha: float) -&gt; None:
    super().interpolate(1 - alpha)


</t>
<t tx="ekr.20250122151620.47">def _set_str(self, key: str, val: Any) -&gt; None:
    """Set ``key`` to ``val`` if ``val`` is a string."""
    if isinstance(val, str):
        self._d[key] = val
    elif not val:
        self._d[key] = ""
    else:
        raise ValueError(f"{key} must be str or falsy value")

</t>
<t tx="ekr.20250122151620.470">def __init__(
    self,
    mobject: Mobject,
    target_mobject: Mobject,
    path_arc: float = -np.pi,
    **kwargs,
) -&gt; None:
    super().__init__(mobject, target_mobject, path_arc=path_arc, **kwargs)


</t>
<t tx="ekr.20250122151620.471">def __init__(
    self,
    mobject: Mobject,
    target_mobject: Mobject,
    path_arc: float = np.pi,
    **kwargs,
) -&gt; None:
    super().__init__(mobject, target_mobject, path_arc=path_arc, **kwargs)


</t>
<t tx="ekr.20250122151620.472">def __init__(self, mobject: Mobject, **kwargs) -&gt; None:
    self.check_validity_of_input(mobject)
    super().__init__(mobject, mobject.target, **kwargs)

</t>
<t tx="ekr.20250122151620.473">def check_validity_of_input(self, mobject: Mobject) -&gt; None:
    if not hasattr(mobject, "target"):
        raise ValueError(
            "MoveToTarget called on mobjectwithout attribute 'target'",
        )


</t>
<t tx="ekr.20250122151620.474">def __init__(self, mobject, methods):
    self.methods = methods
    super().__init__(mobject)

</t>
<t tx="ekr.20250122151620.475">def finish(self) -&gt; None:
    for method, method_args, method_kwargs in self.methods:
        method.__func__(self.mobject, *method_args, **method_kwargs)
    super().finish()


</t>
<t tx="ekr.20250122151620.476">def __init__(
    self, method: Callable, *args, **kwargs
) -&gt; None:  # method typing (we want to specify Mobject method)? for args?
    self.check_validity_of_input(method)
    self.method = method
    self.method_args = args
    super().__init__(method.__self__, **kwargs)

</t>
<t tx="ekr.20250122151620.477">def check_validity_of_input(self, method: Callable) -&gt; None:
    if not inspect.ismethod(method):
        raise ValueError(
            "Whoops, looks like you accidentally invoked "
            "the method you want to animate",
        )
    assert isinstance(method.__self__, (Mobject, OpenGLMobject))

</t>
<t tx="ekr.20250122151620.478">def create_target(self) -&gt; Mobject:
    method = self.method
    # Make sure it's a list so that args.pop() works
    args = list(self.method_args)

    if len(args) &gt; 0 and isinstance(args[-1], dict):
        method_kwargs = args.pop()
    else:
        method_kwargs = {}
    target = method.__self__.copy()
    method.__func__(target, *args, **method_kwargs)
    return target


</t>
<t tx="ekr.20250122151620.479">def __init__(
    self,
    function: types.MethodType,
    mobject: Mobject,
    run_time: float = DEFAULT_POINTWISE_FUNCTION_RUN_TIME,
    **kwargs,
) -&gt; None:
    super().__init__(mobject.apply_function, function, run_time=run_time, **kwargs)


</t>
<t tx="ekr.20250122151620.48">def _set_between(self, key: str, val: float, lo: float, hi: float) -&gt; None:
    """Set ``key`` to ``val`` if lo &lt;= val &lt;= hi."""
    if lo &lt;= val &lt;= hi:
        self._d[key] = val
    else:
        raise ValueError(f"{key} must be {lo} &lt;= {key} &lt;= {hi}")

</t>
<t tx="ekr.20250122151620.480">def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -&gt; None:
    self.function = function
    super().__init__(mobject.move_to, **kwargs)

</t>
<t tx="ekr.20250122151620.481">def begin(self) -&gt; None:
    self.method_args = [self.function(self.mobject.get_center())]
    super().begin()


</t>
<t tx="ekr.20250122151620.482">def __init__(self, mobject: Mobject, color: str, **kwargs) -&gt; None:
    super().__init__(mobject.set_color, color, **kwargs)


</t>
<t tx="ekr.20250122151620.483">def __init__(self, mobject: Mobject, scale_factor: float, **kwargs) -&gt; None:
    super().__init__(mobject.scale, scale_factor, **kwargs)


</t>
<t tx="ekr.20250122151620.484">def __init__(self, mobject: Mobject, **kwargs) -&gt; None:
    super().__init__(mobject, 0, **kwargs)


</t>
<t tx="ekr.20250122151620.485">def __init__(self, mobject: Mobject, **kwargs) -&gt; None:
    super().__init__(mobject.restore, **kwargs)


</t>
<t tx="ekr.20250122151620.486">def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -&gt; None:
    self.function = function
    super().__init__(mobject, **kwargs)

</t>
<t tx="ekr.20250122151620.487">def create_target(self) -&gt; Any:
    target = self.function(self.mobject.copy())
    if not isinstance(target, (Mobject, OpenGLMobject)):
        raise TypeError(
            "Functions passed to ApplyFunction must return object of type Mobject",
        )
    return target


</t>
<t tx="ekr.20250122151620.488">def __init__(
    self,
    matrix: np.ndarray,
    mobject: Mobject,
    about_point: np.ndarray = ORIGIN,
    **kwargs,
) -&gt; None:
    matrix = self.initialize_matrix(matrix)

    def func(p):
        return np.dot(p - about_point, matrix.T) + about_point

    super().__init__(func, mobject, **kwargs)

</t>
<t tx="ekr.20250122151620.489">def initialize_matrix(self, matrix: np.ndarray) -&gt; np.ndarray:
    matrix = np.array(matrix)
    if matrix.shape == (2, 2):
        new_matrix = np.identity(3)
        new_matrix[:2, :2] = matrix
        matrix = new_matrix
    elif matrix.shape != (3, 3):
        raise ValueError("Matrix has bad dimensions")
    return matrix


</t>
<t tx="ekr.20250122151620.49">def _set_int_between(self, key: str, val: int, lo: int, hi: int) -&gt; None:
    """Set ``key`` to ``val`` if lo &lt;= val &lt;= hi."""
    if lo &lt;= val &lt;= hi:
        self._d[key] = val
    else:
        raise ValueError(
            f"{key} must be an integer such that {lo} &lt;= {key} &lt;= {hi}",
        )

</t>
<t tx="ekr.20250122151620.490">def __init__(self, function: types.MethodType, mobject: Mobject, **kwargs) -&gt; None:
    self.function = function
    method = mobject.apply_complex_function
    super().__init__(method, function, **kwargs)

</t>
<t tx="ekr.20250122151620.491">def _init_path_func(self) -&gt; None:
    func1 = self.function(complex(1))
    self.path_arc = np.log(func1).imag
    super()._init_path_func()


</t>
<t tx="ekr.20250122151620.492">def __init__(
    self, *mobjects: Mobject, path_arc: float = 90 * DEGREES, **kwargs
) -&gt; None:
    self.group = Group(*mobjects)
    super().__init__(self.group, path_arc=path_arc, **kwargs)

</t>
<t tx="ekr.20250122151620.493">def create_target(self) -&gt; Group:
    target = self.group.copy()
    cycled_targets = [target[-1], *target[:-1]]
    for m1, m2 in zip(cycled_targets, self.group):
        m1.move_to(m2)
    return target


</t>
<t tx="ekr.20250122151620.494">def __init__(
    self,
    start_anim: Animation,
    end_anim: Animation,
    rate_func: Callable = squish_rate_func(smooth),
    **kwargs,
</t>
<t tx="ekr.20250122151620.495">) -&gt; None:
    self.start_anim = start_anim
    self.end_anim = end_anim
    if "run_time" in kwargs:
        self.run_time = kwargs.pop("run_time")
    else:
        self.run_time = max(start_anim.run_time, end_anim.run_time)
    for anim in start_anim, end_anim:
        anim.set_run_time(self.run_time)
    if (
        start_anim.starting_mobject is not None
        and end_anim.starting_mobject is not None
        and start_anim.starting_mobject.get_num_points()
        != end_anim.starting_mobject.get_num_points()
    ):
        start_anim.starting_mobject.align_data(end_anim.starting_mobject)
        for anim in start_anim, end_anim:
            if isinstance(anim, Transform) and anim.starting_mobject is not None:
                anim.starting_mobject.align_data(anim.target_mobject)

    super().__init__(
        start_anim.mobject, end_anim.mobject, rate_func=rate_func, **kwargs
    )
    # Rewire starting and ending mobjects
    start_anim.mobject = self.starting_mobject
    end_anim.mobject = self.target_mobject

def interpolate(self, alpha: float) -&gt; None:
    self.start_anim.interpolate(alpha)
    self.end_anim.interpolate(alpha)
    super().interpolate(alpha)


</t>
<t tx="ekr.20250122151620.496">def __init__(self, mobject, target_mobject, stretch=True, dim_to_match=1, **kwargs):
    self.to_add_on_completion = target_mobject
    self.stretch = stretch
    self.dim_to_match = dim_to_match
    mobject.save_state()
    if config.renderer == RendererType.OPENGL:
        group = OpenGLGroup(mobject, target_mobject.copy())
    else:
        group = Group(mobject, target_mobject.copy())
    super().__init__(group, **kwargs)

</t>
<t tx="ekr.20250122151620.497">def begin(self):
    """Initial setup for the animation.

    The mobject to which this animation is bound is a group consisting of
    both the starting and the ending mobject. At the start, the ending
    mobject replaces the starting mobject (and is completely faded). In the
    end, it is set to be the other way around.
    """
    self.ending_mobject = self.mobject.copy()
    Animation.begin(self)
    # Both 'start' and 'end' consists of the source and target mobjects.
    # At the start, the target should be faded replacing the source,
    # and at the end it should be the other way around.
    start, end = self.starting_mobject, self.ending_mobject
    for m0, m1 in ((start[1], start[0]), (end[0], end[1])):
        self.ghost_to(m0, m1)

</t>
<t tx="ekr.20250122151620.498">def ghost_to(self, source, target):
    """Replaces the source by the target and sets the opacity to 0.

    If the provided target has no points, and thus a location of [0, 0, 0]
    the source will simply fade out where it currently is.
    """
    # mobject.replace() does not work if the target has no points.
    if target.get_num_points() or target.submobjects:
        source.replace(target, stretch=self.stretch, dim_to_match=self.dim_to_match)
    source.set_opacity(0)

</t>
<t tx="ekr.20250122151620.499">def get_all_mobjects(self) -&gt; Sequence[Mobject]:
    return [
        self.mobject,
        self.starting_mobject,
        self.ending_mobject,
    ]

</t>
<t tx="ekr.20250122151620.5">def show_splash(ctx: click.Context, param: click.Option, value: str | None) -&gt; None:
    """When giving a value by console, show an initial message with the Manim
    version before executing any other command: ``Manim Community vA.B.C``.

    Parameters
    ----------
    ctx
        The Click context.
    param
        A Click option.
    value
        A string value given by console, or None.
    """
    if value:
        console.print(f"Manim Community [green]v{__version__}[/green]\n")


</t>
<t tx="ekr.20250122151620.50">def _set_pos_number(self, key: str, val: int, allow_inf: bool) -&gt; None:
    """Set ``key`` to ``val`` if ``val`` is a positive integer."""
    if isinstance(val, int) and val &gt; -1:
        self._d[key] = val
    elif allow_inf and val in [-1, float("inf")]:
        self._d[key] = float("inf")
    else:
        raise ValueError(
            f"{key} must be a non-negative integer (use -1 for infinity)",
        )

</t>
<t tx="ekr.20250122151620.500">def get_all_families_zipped(self):
    return Animation.get_all_families_zipped(self)

</t>
<t tx="ekr.20250122151620.501">def clean_up_from_scene(self, scene):
    Animation.clean_up_from_scene(self, scene)
    scene.remove(self.mobject)
    self.mobject[0].restore()
    scene.add(self.to_add_on_completion)


</t>
<t tx="ekr.20250122151620.502">def begin(self):
    self.mobject[0].align_submobjects(self.mobject[1])
    super().begin()

</t>
<t tx="ekr.20250122151620.503">def ghost_to(self, source, target):
    """Replaces the source submobjects by the target submobjects and sets
    the opacity to 0.
    """
    for sm0, sm1 in zip(source.get_family(), target.get_family()):
        super().ghost_to(sm0, sm1)
</t>
<t tx="ekr.20250122151620.504">"""Animations that try to transform Mobjects while keeping track of identical parts."""

from __future__ import annotations

__all__ = ["TransformMatchingShapes", "TransformMatchingTex"]

from typing import TYPE_CHECKING

import numpy as np

from manim.mobject.opengl.opengl_mobject import OpenGLGroup, OpenGLMobject
from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVGroup, OpenGLVMobject

from .._config import config
from ..constants import RendererType
from ..mobject.mobject import Group, Mobject
from ..mobject.types.vectorized_mobject import VGroup, VMobject
from .composition import AnimationGroup
from .fading import FadeIn, FadeOut
from .transform import FadeTransformPieces, Transform

if TYPE_CHECKING:
    from ..scene.scene import Scene


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.505">class TransformMatchingAbstractBase(AnimationGroup):
    """Abstract base class for transformations that keep track of matching parts.

    Subclasses have to implement the two static methods
    :meth:`~.TransformMatchingAbstractBase.get_mobject_parts` and
    :meth:`~.TransformMatchingAbstractBase.get_mobject_key`.

    Basically, this transformation first maps all submobjects returned
    by the ``get_mobject_parts`` method to certain keys by applying the
    ``get_mobject_key`` method. Then, submobjects with matching keys
    are transformed into each other.

    Parameters
    ----------
    mobject
        The starting :class:`~.Mobject`.
    target_mobject
        The target :class:`~.Mobject`.
    transform_mismatches
        Controls whether submobjects without a matching key are transformed
        into each other by using :class:`~.Transform`. Default: ``False``.
    fade_transform_mismatches
        Controls whether submobjects without a matching key are transformed
        into each other by using :class:`~.FadeTransform`. Default: ``False``.
    key_map
        Optional. A dictionary mapping keys belonging to some of the starting mobject's
        submobjects (i.e., the return values of the ``get_mobject_key`` method)
        to some keys belonging to the target mobject's submobjects that should
        be transformed although the keys don't match.
    kwargs
        All further keyword arguments are passed to the submobject transformations.


    Note
    ----
    If neither ``transform_mismatches`` nor ``fade_transform_mismatches``
    are set to ``True``, submobjects without matching keys in the starting
    mobject are faded out in the direction of the unmatched submobjects in
    the target mobject, and unmatched submobjects in the target mobject
    are faded in from the direction of the unmatched submobjects in the
    start mobject.

    """

    @others
</t>
<t tx="ekr.20250122151620.506">class TransformMatchingShapes(TransformMatchingAbstractBase):
    """An animation trying to transform groups by matching the shape
    of their submobjects.

    Two submobjects match if the hash of their point coordinates after
    normalization (i.e., after translation to the origin, fixing the submobject
    height at 1 unit, and rounding the coordinates to three decimal places)
    matches.

    See also
    --------
    :class:`~.TransformMatchingAbstractBase`

    Examples
    --------

    .. manim:: Anagram

        class Anagram(Scene):
            def construct(self):
                src = Text("the morse code")
                tar = Text("here come dots")
                self.play(Write(src))
                self.wait(0.5)
                self.play(TransformMatchingShapes(src, tar, path_arc=PI/2))
                self.wait(0.5)

    """

    @others
</t>
<t tx="ekr.20250122151620.507">class TransformMatchingTex(TransformMatchingAbstractBase):
    """A transformation trying to transform rendered LaTeX strings.

    Two submobjects match if their ``tex_string`` matches.

    See also
    --------
    :class:`~.TransformMatchingAbstractBase`

    Examples
    --------

    .. manim:: MatchingEquationParts

        class MatchingEquationParts(Scene):
            def construct(self):
                variables = VGroup(MathTex("a"), MathTex("b"), MathTex("c")).arrange_submobjects().shift(UP)

                eq1 = MathTex("{{x}}^2", "+", "{{y}}^2", "=", "{{z}}^2")
                eq2 = MathTex("{{a}}^2", "+", "{{b}}^2", "=", "{{c}}^2")
                eq3 = MathTex("{{a}}^2", "=", "{{c}}^2", "-", "{{b}}^2")

                self.add(eq1)
                self.wait(0.5)
                self.play(TransformMatchingTex(Group(eq1, variables), eq2))
                self.wait(0.5)
                self.play(TransformMatchingTex(eq2, eq3))
                self.wait(0.5)

    """

    @others
</t>
<t tx="ekr.20250122151620.508">def __init__(
    self,
    mobject: Mobject,
    target_mobject: Mobject,
    transform_mismatches: bool = False,
    fade_transform_mismatches: bool = False,
    key_map: dict | None = None,
    **kwargs,
):
    if isinstance(mobject, OpenGLVMobject):
        group_type = OpenGLVGroup
    elif isinstance(mobject, OpenGLMobject):
        group_type = OpenGLGroup
    elif isinstance(mobject, VMobject):
        group_type = VGroup
    else:
        group_type = Group

    source_map = self.get_shape_map(mobject)
    target_map = self.get_shape_map(target_mobject)

    if key_map is None:
        key_map = {}

    # Create two mobjects whose submobjects all match each other
    # according to whatever keys are used for source_map and
    # target_map
    transform_source = group_type()
    transform_target = group_type()
    kwargs["final_alpha_value"] = 0
    for key in set(source_map).intersection(target_map):
        transform_source.add(source_map[key])
        transform_target.add(target_map[key])
    anims = [Transform(transform_source, transform_target, **kwargs)]
    # User can manually specify when one part should transform
    # into another despite not matching by using key_map
    key_mapped_source = group_type()
    key_mapped_target = group_type()
    for key1, key2 in key_map.items():
        if key1 in source_map and key2 in target_map:
            key_mapped_source.add(source_map[key1])
            key_mapped_target.add(target_map[key2])
            source_map.pop(key1, None)
            target_map.pop(key2, None)
    if len(key_mapped_source) &gt; 0:
        anims.append(
            FadeTransformPieces(key_mapped_source, key_mapped_target, **kwargs),
        )

    fade_source = group_type()
    fade_target = group_type()
    for key in set(source_map).difference(target_map):
        fade_source.add(source_map[key])
    for key in set(target_map).difference(source_map):
        fade_target.add(target_map[key])
    fade_target_copy = fade_target.copy()

    if transform_mismatches:
        if "replace_mobject_with_target_in_scene" not in kwargs:
            kwargs["replace_mobject_with_target_in_scene"] = True
        anims.append(Transform(fade_source, fade_target, **kwargs))
    elif fade_transform_mismatches:
        anims.append(FadeTransformPieces(fade_source, fade_target, **kwargs))
    else:
        anims.append(FadeOut(fade_source, target_position=fade_target, **kwargs))
        anims.append(
            FadeIn(fade_target_copy, target_position=fade_target, **kwargs),
        )

    super().__init__(*anims)

    self.to_remove = [mobject, fade_target_copy]
    self.to_add = target_mobject

</t>
<t tx="ekr.20250122151620.509">def get_shape_map(self, mobject: Mobject) -&gt; dict:
    shape_map = {}
    for sm in self.get_mobject_parts(mobject):
        key = self.get_mobject_key(sm)
        if key not in shape_map:
            if config["renderer"] == RendererType.OPENGL:
                shape_map[key] = OpenGLVGroup()
            else:
                shape_map[key] = VGroup()
        shape_map[key].add(sm)
    return shape_map

</t>
<t tx="ekr.20250122151620.51">def __repr__(self) -&gt; str:
    rep = ""
    for k, v in sorted(self._d.items(), key=lambda x: x[0]):
        rep += f"{k}: {v}, "
    return rep

</t>
<t tx="ekr.20250122151620.510">def clean_up_from_scene(self, scene: Scene) -&gt; None:
    # Interpolate all animations back to 0 to ensure source mobjects remain unchanged.
    for anim in self.animations:
        anim.interpolate(0)
    scene.remove(self.mobject)
    scene.remove(*self.to_remove)
    scene.add(self.to_add)

</t>
<t tx="ekr.20250122151620.511">@staticmethod
def get_mobject_parts(mobject: Mobject):
    raise NotImplementedError("To be implemented in subclass.")

</t>
<t tx="ekr.20250122151620.512">@staticmethod
def get_mobject_key(mobject: Mobject):
    raise NotImplementedError("To be implemented in subclass.")


</t>
<t tx="ekr.20250122151620.513">def __init__(
    self,
    mobject: Mobject,
    target_mobject: Mobject,
    transform_mismatches: bool = False,
    fade_transform_mismatches: bool = False,
    key_map: dict | None = None,
    **kwargs,
):
    super().__init__(
        mobject,
        target_mobject,
        transform_mismatches=transform_mismatches,
        fade_transform_mismatches=fade_transform_mismatches,
        key_map=key_map,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.514">@staticmethod
def get_mobject_parts(mobject: Mobject) -&gt; list[Mobject]:
    return mobject.family_members_with_points()

</t>
<t tx="ekr.20250122151620.515">@staticmethod
def get_mobject_key(mobject: Mobject) -&gt; int:
    mobject.save_state()
    mobject.center()
    mobject.set(height=1)
    result = hash(np.round(mobject.points, 3).tobytes())
    mobject.restore()
    return result


</t>
<t tx="ekr.20250122151620.516">def __init__(
    self,
    mobject: Mobject,
    target_mobject: Mobject,
    transform_mismatches: bool = False,
    fade_transform_mismatches: bool = False,
    key_map: dict | None = None,
    **kwargs,
):
    super().__init__(
        mobject,
        target_mobject,
        transform_mismatches=transform_mismatches,
        fade_transform_mismatches=fade_transform_mismatches,
        key_map=key_map,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151620.517">@staticmethod
def get_mobject_parts(mobject: Mobject) -&gt; list[Mobject]:
    if isinstance(mobject, (Group, VGroup, OpenGLGroup, OpenGLVGroup)):
        return [
            p
            for s in mobject.submobjects
            for p in TransformMatchingTex.get_mobject_parts(s)
        ]
    else:
        assert hasattr(mobject, "tex_string")
        return mobject.submobjects

</t>
<t tx="ekr.20250122151620.518">@staticmethod
def get_mobject_key(mobject: Mobject) -&gt; str:
    return mobject.tex_string
</t>
<t tx="ekr.20250122151620.519"></t>
<t tx="ekr.20250122151620.52"># builders
def digest_parser(self, parser: configparser.ConfigParser) -&gt; Self:
    """Process the config options present in a :class:`ConfigParser` object.

    This method processes arbitrary parsers, not only those read from a
    single file, whereas :meth:`~ManimConfig.digest_file` can only process one
    file at a time.

    Parameters
    ----------
    parser
        An object reflecting the contents of one or many ``.cfg`` files.  In
        particular, it may reflect the contents of multiple files that have
        been parsed in a cascading fashion.

    Returns
    -------
    self : :class:`ManimConfig`
        This object, after processing the contents of ``parser``.

    See Also
    --------
    :func:`make_config_parser`, :meth:`~.ManimConfig.digest_file`,
    :meth:`~.ManimConfig.digest_args`,

    Notes
    -----
    If there are multiple ``.cfg`` files to process, it is always more
    efficient to parse them into a single :class:`ConfigParser` object
    first, and then call this function once (instead of calling
    :meth:`~.ManimConfig.digest_file` multiple times).

    Examples
    --------
    To digest the config options set in two files, first create a
    ConfigParser and parse both files and then digest the parser:

    .. code-block:: python

        parser = configparser.ConfigParser()
        parser.read([file1, file2])
        config = ManimConfig().digest_parser(parser)

    In fact, the global ``config`` object is initialized like so:

    .. code-block:: python

        parser = make_config_parser()
        config = ManimConfig().digest_parser(parser)

    """
    self._parser = parser

    # boolean keys
    for key in [
        "notify_outdated_version",
        "write_to_movie",
        "save_last_frame",
        "write_all",
        "save_pngs",
        "save_as_gif",
        "save_sections",
        "preview",
        "show_in_file_browser",
        "log_to_file",
        "disable_caching",
        "disable_caching_warning",
        "flush_cache",
        "custom_folders",
        "enable_gui",
        "fullscreen",
        "use_projection_fill_shaders",
        "use_projection_stroke_shaders",
        "enable_wireframe",
        "force_window",
        "no_latex_cleanup",
    ]:
        setattr(self, key, parser["CLI"].getboolean(key, fallback=False))

    # int keys
    for key in [
        "from_animation_number",
        "upto_animation_number",
        "max_files_cached",
        # the next two must be set BEFORE digesting frame_width and frame_height
        "pixel_height",
        "pixel_width",
        "window_monitor",
        "zero_pad",
    ]:
        setattr(self, key, parser["CLI"].getint(key))

    # str keys
    for key in [
        "assets_dir",
        "verbosity",
        "media_dir",
        "log_dir",
        "video_dir",
        "sections_dir",
        "images_dir",
        "text_dir",
        "tex_dir",
        "partial_movie_dir",
        "input_file",
        "output_file",
        "movie_file_extension",
        "background_color",
        "renderer",
        "window_position",
    ]:
        setattr(self, key, parser["CLI"].get(key, fallback="", raw=True))

    # float keys
    for key in [
        "background_opacity",
        "frame_rate",
        # the next two are floats but have their own logic, applied later
        # "frame_width",
        # "frame_height",
    ]:
        setattr(self, key, parser["CLI"].getfloat(key))

    # tuple keys
    gui_location = tuple(
        map(int, re.split(r"[;,\-]", parser["CLI"]["gui_location"])),
    )
    self.gui_location = gui_location

    window_size = parser["CLI"][
        "window_size"
    ]  # if not "default", get a tuple of the position
    if window_size != "default":
        window_size = tuple(map(int, re.split(r"[;,\-]", window_size)))
    self.window_size = window_size

    # plugins
    plugins = parser["CLI"].get("plugins", fallback="", raw=True)
    plugins = [] if plugins == "" else plugins.split(",")
    self.plugins = plugins
    # the next two must be set AFTER digesting pixel_width and pixel_height
    self["frame_height"] = parser["CLI"].getfloat("frame_height", 8.0)
    width = parser["CLI"].getfloat("frame_width", None)
    if width is None:
        self["frame_width"] = self["frame_height"] * self["aspect_ratio"]
    else:
        self["frame_width"] = width

    # other logic
    val = parser["CLI"].get("tex_template_file")
    if val:
        self.tex_template_file = val

    val = parser["CLI"].get("progress_bar")
    if val:
        self.progress_bar = val

    val = parser["ffmpeg"].get("loglevel")
    if val:
        self.ffmpeg_loglevel = val

    try:
        val = parser["jupyter"].getboolean("media_embed")
    except ValueError:
        val = None
    self.media_embed = val

    val = parser["jupyter"].get("media_width")
    if val:
        self.media_width = val

    val = parser["CLI"].get("quality", fallback="", raw=True)
    if val:
        self.quality = _determine_quality(val)

    return self

</t>
<t tx="ekr.20250122151620.520">"""Animations and utility mobjects related to update functions.

Modules
=======

.. autosummary::
    :toctree: ../reference

    ~mobject_update_utils
    ~update
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.521">"""Utility functions for continuous animation of mobjects."""

from __future__ import annotations

__all__ = [
    "assert_is_mobject_method",
    "always",
    "f_always",
    "always_redraw",
    "always_shift",
    "always_rotate",
    "turn_animation_into_updater",
    "cycle_animation",
]


import inspect
from typing import TYPE_CHECKING, Callable

import numpy as np

from manim.constants import DEGREES, RIGHT
from manim.mobject.mobject import Mobject
from manim.opengl import OpenGLMobject
from manim.utils.space_ops import normalize

if TYPE_CHECKING:
    from manim.animation.animation import Animation


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.522">def assert_is_mobject_method(method: Callable) -&gt; None:
    assert inspect.ismethod(method)
    mobject = method.__self__
    assert isinstance(mobject, (Mobject, OpenGLMobject))


</t>
<t tx="ekr.20250122151620.523">def always(method: Callable, *args, **kwargs) -&gt; Mobject:
    assert_is_mobject_method(method)
    mobject = method.__self__
    func = method.__func__
    mobject.add_updater(lambda m: func(m, *args, **kwargs))
    return mobject


</t>
<t tx="ekr.20250122151620.524">def f_always(method: Callable[[Mobject], None], *arg_generators, **kwargs) -&gt; Mobject:
    """
    More functional version of always, where instead
    of taking in args, it takes in functions which output
    the relevant arguments.
    """
    assert_is_mobject_method(method)
    mobject = method.__self__
    func = method.__func__

    def updater(mob):
        args = [arg_generator() for arg_generator in arg_generators]
        func(mob, *args, **kwargs)

    mobject.add_updater(updater)
    return mobject


</t>
<t tx="ekr.20250122151620.525">def always_redraw(func: Callable[[], Mobject]) -&gt; Mobject:
    """Redraw the mobject constructed by a function every frame.

    This function returns a mobject with an attached updater that
    continuously regenerates the mobject according to the
    specified function.

    Parameters
    ----------
    func
        A function without (required) input arguments that returns
        a mobject.

    Examples
    --------

    .. manim:: TangentAnimation

        class TangentAnimation(Scene):
            def construct(self):
                ax = Axes()
                sine = ax.plot(np.sin, color=RED)
                alpha = ValueTracker(0)
                point = always_redraw(
                    lambda: Dot(
                        sine.point_from_proportion(alpha.get_value()),
                        color=BLUE
                    )
                )
                tangent = always_redraw(
                    lambda: TangentLine(
                        sine,
                        alpha=alpha.get_value(),
                        color=YELLOW,
                        length=4
                    )
                )
                self.add(ax, sine, point, tangent)
                self.play(alpha.animate.set_value(1), rate_func=linear, run_time=2)
    """
    mob = func()
    mob.add_updater(lambda _: mob.become(func()))
    return mob


</t>
<t tx="ekr.20250122151620.526">def always_shift(
    mobject: Mobject, direction: np.ndarray[np.float64] = RIGHT, rate: float = 0.1
) -&gt; Mobject:
    """A mobject which is continuously shifted along some direction
    at a certain rate.

    Parameters
    ----------
    mobject
        The mobject to shift.
    direction
        The direction to shift. The vector is normalized, the specified magnitude
        is not relevant.
    rate
        Length in Manim units which the mobject travels in one
        second along the specified direction.

    Examples
    --------

    .. manim:: ShiftingSquare

        class ShiftingSquare(Scene):
            def construct(self):
                sq = Square().set_fill(opacity=1)
                tri = Triangle()
                VGroup(sq, tri).arrange(LEFT)

                # construct a square which is continuously
                # shifted to the right
                always_shift(sq, RIGHT, rate=5)

                self.add(sq)
                self.play(tri.animate.set_fill(opacity=1))
    """
    mobject.add_updater(lambda m, dt: m.shift(dt * rate * normalize(direction)))
    return mobject


</t>
<t tx="ekr.20250122151620.527">def always_rotate(mobject: Mobject, rate: float = 20 * DEGREES, **kwargs) -&gt; Mobject:
    """A mobject which is continuously rotated at a certain rate.

    Parameters
    ----------
    mobject
        The mobject to be rotated.
    rate
        The angle which the mobject is rotated by
        over one second.
    kwags
        Further arguments to be passed to :meth:`.Mobject.rotate`.

    Examples
    --------

    .. manim:: SpinningTriangle

        class SpinningTriangle(Scene):
            def construct(self):
                tri = Triangle().set_fill(opacity=1).set_z_index(2)
                sq = Square().to_edge(LEFT)

                # will keep spinning while there is an animation going on
                always_rotate(tri, rate=2*PI, about_point=ORIGIN)

                self.add(tri, sq)
                self.play(sq.animate.to_edge(RIGHT), rate_func=linear, run_time=1)
    """
    mobject.add_updater(lambda m, dt: m.rotate(dt * rate, **kwargs))
    return mobject


</t>
<t tx="ekr.20250122151620.528">def turn_animation_into_updater(
    animation: Animation, cycle: bool = False, delay: float = 0, **kwargs
) -&gt; Mobject:
    """
    Add an updater to the animation's mobject which applies
    the interpolation and update functions of the animation

    If cycle is True, this repeats over and over.  Otherwise,
    the updater will be popped upon completion

    The ``delay`` parameter is the delay (in seconds) before the animation starts..

    Examples
    --------

    .. manim:: WelcomeToManim

        class WelcomeToManim(Scene):
            def construct(self):
                words = Text("Welcome to")
                banner = ManimBanner().scale(0.5)
                VGroup(words, banner).arrange(DOWN)

                turn_animation_into_updater(Write(words, run_time=0.9))
                self.add(words)
                self.wait(0.5)
                self.play(banner.expand(), run_time=0.5)
    """
    mobject = animation.mobject
    animation.suspend_mobject_updating = False
    animation.begin()
    animation.total_time = -delay

    def update(m: Mobject, dt: float):
        if animation.total_time &gt;= 0:
            run_time = animation.get_run_time()
            time_ratio = animation.total_time / run_time
            if cycle:
                alpha = time_ratio % 1
            else:
                alpha = np.clip(time_ratio, 0, 1)
                if alpha &gt;= 1:
                    animation.finish()
                    m.remove_updater(update)
                    return
            animation.interpolate(alpha)
            animation.update_mobjects(dt)
        animation.total_time += dt

    mobject.add_updater(update)
    return mobject


</t>
<t tx="ekr.20250122151620.529">def cycle_animation(animation: Animation, **kwargs) -&gt; Mobject:
    return turn_animation_into_updater(animation, cycle=True, **kwargs)
</t>
<t tx="ekr.20250122151620.53">def digest_args(self, args: argparse.Namespace) -&gt; Self:
    """Process the config options present in CLI arguments.

    Parameters
    ----------
    args
        An object returned by :func:`.main_utils.parse_args()`.

    Returns
    -------
    self : :class:`ManimConfig`
        This object, after processing the contents of ``parser``.

    See Also
    --------
    :func:`.main_utils.parse_args()`, :meth:`~.ManimConfig.digest_parser`,
    :meth:`~.ManimConfig.digest_file`

    Notes
    -----
    If ``args.config_file`` is a non-empty string, ``ManimConfig`` tries to digest the
    contents of said file with :meth:`~ManimConfig.digest_file` before
    digesting any other CLI arguments.

    """
    # if the input file is a config file, parse it properly
    if args.file.suffix == ".cfg":
        args.config_file = args.file

    # if args.file is `-`, the animation code has to be taken from STDIN, so the
    # input file path shouldn't be absolute, since that file won't be read.
    if str(args.file) == "-":
        self.input_file = args.file

    # if a config file has been passed, digest it first so that other CLI
    # flags supersede it
    if args.config_file:
        self.digest_file(args.config_file)

    # read input_file from the args if it wasn't set by the config file
    if not self.input_file:
        self.input_file = Path(args.file).absolute()

    self.scene_names = args.scene_names if args.scene_names is not None else []
    self.output_file = args.output_file

    for key in [
        "notify_outdated_version",
        "preview",
        "show_in_file_browser",
        "write_to_movie",
        "save_last_frame",
        "save_pngs",
        "save_as_gif",
        "save_sections",
        "write_all",
        "disable_caching",
        "format",
        "flush_cache",
        "progress_bar",
        "transparent",
        "scene_names",
        "verbosity",
        "renderer",
        "background_color",
        "enable_gui",
        "fullscreen",
        "use_projection_fill_shaders",
        "use_projection_stroke_shaders",
        "zero_pad",
        "enable_wireframe",
        "force_window",
        "dry_run",
        "no_latex_cleanup",
        "preview_command",
    ]:
        if hasattr(args, key):
            attr = getattr(args, key)
            # if attr is None, then no argument was passed and we should
            # not change the current config
            if attr is not None:
                self[key] = attr

    for key in [
        "media_dir",  # always set this one first
        "log_dir",
        "log_to_file",  # always set this one last
    ]:
        if hasattr(args, key):
            attr = getattr(args, key)
            # if attr is None, then no argument was passed and we should
            # not change the current config
            if attr is not None:
                self[key] = attr

    if self["save_last_frame"]:
        self["write_to_movie"] = False

    # Handle the -n flag.
    nflag = args.from_animation_number
    if nflag:
        self.from_animation_number = nflag[0]
        try:
            self.upto_animation_number = nflag[1]
        except Exception:
            logger.info(
                f"No end scene number specified in -n option. Rendering from {nflag[0]} onwards...",
            )

    # Handle the quality flags
    self.quality = _determine_quality(getattr(args, "quality", None))

    # Handle the -r flag.
    rflag = args.resolution
    if rflag:
        self.pixel_width = int(rflag[0])
        self.pixel_height = int(rflag[1])

    fps = args.frame_rate
    if fps:
        self.frame_rate = float(fps)

    # Handle --custom_folders
    if args.custom_folders:
        for opt in [
            "media_dir",
            "video_dir",
            "sections_dir",
            "images_dir",
            "text_dir",
            "tex_dir",
            "log_dir",
            "partial_movie_dir",
        ]:
            self[opt] = self._parser["custom_folders"].get(opt, raw=True)
        # --media_dir overrides the default.cfg file
        if hasattr(args, "media_dir") and args.media_dir:
            self.media_dir = args.media_dir

    # Handle --tex_template
    if args.tex_template:
        self.tex_template = TexTemplate.from_file(args.tex_template)

    if self.renderer == RendererType.OPENGL and args.write_to_movie is None:
        # --write_to_movie was not passed on the command line, so don't generate video.
        self["write_to_movie"] = False

    # Handle --gui_location flag.
    if args.gui_location is not None:
        self.gui_location = args.gui_location

    return self

</t>
<t tx="ekr.20250122151620.530">"""Animations that update mobjects."""

from __future__ import annotations

__all__ = ["UpdateFromFunc", "UpdateFromAlphaFunc", "MaintainPositionRelativeTo"]


import operator as op
import typing

from manim.animation.animation import Animation

if typing.TYPE_CHECKING:
    from manim.mobject.mobject import Mobject


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.531">class UpdateFromFunc(Animation):
    """
    update_function of the form func(mobject), presumably
    to be used when the state of one mobject is dependent
    on another simultaneously animated mobject
    """

    @others
</t>
<t tx="ekr.20250122151620.532">class UpdateFromAlphaFunc(UpdateFromFunc):
    @others
</t>
<t tx="ekr.20250122151620.533">class MaintainPositionRelativeTo(Animation):
    @others
</t>
<t tx="ekr.20250122151620.534">def __init__(
    self,
    mobject: Mobject,
    update_function: typing.Callable[[Mobject], typing.Any],
    suspend_mobject_updating: bool = False,
    **kwargs,
) -&gt; None:
    self.update_function = update_function
    super().__init__(
        mobject, suspend_mobject_updating=suspend_mobject_updating, **kwargs
    )

</t>
<t tx="ekr.20250122151620.535">def interpolate_mobject(self, alpha: float) -&gt; None:
    self.update_function(self.mobject)


</t>
<t tx="ekr.20250122151620.536">def interpolate_mobject(self, alpha: float) -&gt; None:
    self.update_function(self.mobject, self.rate_func(alpha))


</t>
<t tx="ekr.20250122151620.537">def __init__(self, mobject: Mobject, tracked_mobject: Mobject, **kwargs) -&gt; None:
    self.tracked_mobject = tracked_mobject
    self.diff = op.sub(
        mobject.get_center(),
        tracked_mobject.get_center(),
    )
    super().__init__(mobject, **kwargs)

</t>
<t tx="ekr.20250122151620.538">def interpolate_mobject(self, alpha: float) -&gt; None:
    target = self.tracked_mobject.get_center()
    location = self.mobject.get_center()
    self.mobject.shift(target - location + self.diff)
</t>
<t tx="ekr.20250122151620.539"></t>
<t tx="ekr.20250122151620.54">def digest_file(self, filename: StrPath) -&gt; Self:
    """Process the config options present in a ``.cfg`` file.

    This method processes a single ``.cfg`` file, whereas
    :meth:`~ManimConfig.digest_parser` can process arbitrary parsers, built
    perhaps from multiple ``.cfg`` files.

    Parameters
    ----------
    filename
        Path to the ``.cfg`` file.

    Returns
    -------
    self : :class:`ManimConfig`
        This object, after processing the contents of ``filename``.

    See Also
    --------
    :meth:`~ManimConfig.digest_file`, :meth:`~ManimConfig.digest_args`,
    :func:`make_config_parser`

    Notes
    -----
    If there are multiple ``.cfg`` files to process, it is always more
    efficient to parse them into a single :class:`ConfigParser` object
    first and digesting them with one call to
    :meth:`~ManimConfig.digest_parser`, instead of calling this method
    multiple times.

    """
    if not Path(filename).is_file():
        raise FileNotFoundError(
            errno.ENOENT,
            "Error: --config_file could not find a valid config file.",
            str(filename),
        )

    return self.digest_parser(make_config_parser(filename))

</t>
<t tx="ekr.20250122151620.540"></t>
<t tx="ekr.20250122151620.541">"""A camera converts the mobjects contained in a Scene into an array of pixels."""

from __future__ import annotations

__all__ = ["Camera", "BackgroundColoredVMobjectDisplayer"]

import copy
import itertools as it
import operator as op
import pathlib
from collections.abc import Iterable
from functools import reduce
from typing import Any, Callable

import cairo
import numpy as np
from PIL import Image
from scipy.spatial.distance import pdist

from .. import config, logger
from ..constants import *
from ..mobject.mobject import Mobject
from ..mobject.types.image_mobject import AbstractImageMobject
from ..mobject.types.point_cloud_mobject import PMobject
from ..mobject.types.vectorized_mobject import VMobject
from ..utils.color import ManimColor, ParsableManimColor, color_to_int_rgba
from ..utils.family import extract_mobject_family_members
from ..utils.images import get_full_raster_image_path
from ..utils.iterables import list_difference_update
from ..utils.space_ops import angle_of_vector

LINE_JOIN_MAP = {
    LineJointType.AUTO: None,  # TODO: this could be improved
    LineJointType.ROUND: cairo.LineJoin.ROUND,
    LineJointType.BEVEL: cairo.LineJoin.BEVEL,
    LineJointType.MITER: cairo.LineJoin.MITER,
}


CAP_STYLE_MAP = {
    CapStyleType.AUTO: None,  # TODO: this could be improved
    CapStyleType.ROUND: cairo.LineCap.ROUND,
    CapStyleType.BUTT: cairo.LineCap.BUTT,
    CapStyleType.SQUARE: cairo.LineCap.SQUARE,
}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.542">class Camera:
    """Base camera class.

    This is the object which takes care of what exactly is displayed
    on screen at any given moment.

    Parameters
    ----------
    background_image
        The path to an image that should be the background image.
        If not set, the background is filled with :attr:`self.background_color`
    background
        What :attr:`background` is set to. By default, ``None``.
    pixel_height
        The height of the scene in pixels.
    pixel_width
        The width of the scene in pixels.
    kwargs
        Additional arguments (``background_color``, ``background_opacity``)
        to be set.
    """

    @others
</t>
<t tx="ekr.20250122151620.543"># NOTE: The methods of the following class have not been mentioned outside of their definitions.
# Their DocStrings are not as detailed as preferred.
class BackgroundColoredVMobjectDisplayer:
    """Auxiliary class that handles displaying vectorized mobjects with
    a set background image.

    Parameters
    ----------
    camera
        Camera object to use.
    """

    @others
</t>
<t tx="ekr.20250122151620.544">def __init__(
    self,
    background_image: str | None = None,
    frame_center: np.ndarray = ORIGIN,
    image_mode: str = "RGBA",
    n_channels: int = 4,
    pixel_array_dtype: str = "uint8",
    cairo_line_width_multiple: float = 0.01,
    use_z_index: bool = True,
    background: np.ndarray | None = None,
    pixel_height: int | None = None,
    pixel_width: int | None = None,
    frame_height: float | None = None,
    frame_width: float | None = None,
    frame_rate: float | None = None,
    background_color: ParsableManimColor | None = None,
    background_opacity: float | None = None,
    **kwargs,
):
    self.background_image = background_image
    self.frame_center = frame_center
    self.image_mode = image_mode
    self.n_channels = n_channels
    self.pixel_array_dtype = pixel_array_dtype
    self.cairo_line_width_multiple = cairo_line_width_multiple
    self.use_z_index = use_z_index
    self.background = background

    if pixel_height is None:
        pixel_height = config["pixel_height"]
    self.pixel_height = pixel_height

    if pixel_width is None:
        pixel_width = config["pixel_width"]
    self.pixel_width = pixel_width

    if frame_height is None:
        frame_height = config["frame_height"]
    self.frame_height = frame_height

    if frame_width is None:
        frame_width = config["frame_width"]
    self.frame_width = frame_width

    if frame_rate is None:
        frame_rate = config["frame_rate"]
    self.frame_rate = frame_rate

    if background_color is None:
        self._background_color = ManimColor.parse(config["background_color"])
    else:
        self._background_color = ManimColor.parse(background_color)
    if background_opacity is None:
        self._background_opacity = config["background_opacity"]
    else:
        self._background_opacity = background_opacity

    # This one is in the same boat as the above, but it doesn't have the
    # same name as the corresponding key so it has to be handled on its own
    self.max_allowable_norm = config["frame_width"]

    self.rgb_max_val = np.iinfo(self.pixel_array_dtype).max
    self.pixel_array_to_cairo_context = {}

    # Contains the correct method to process a list of Mobjects of the
    # corresponding class.  If a Mobject is not an instance of a class in
    # this dict (or an instance of a class that inherits from a class in
    # this dict), then it cannot be rendered.

    self.init_background()
    self.resize_frame_shape()
    self.reset()

</t>
<t tx="ekr.20250122151620.545">def __deepcopy__(self, memo):
    # This is to address a strange bug where deepcopying
    # will result in a segfault, which is somehow related
    # to the aggdraw library
    self.canvas = None
    return copy.copy(self)

</t>
<t tx="ekr.20250122151620.546">@property
def background_color(self):
    return self._background_color

</t>
<t tx="ekr.20250122151620.547">@background_color.setter
def background_color(self, color):
    self._background_color = color
    self.init_background()

</t>
<t tx="ekr.20250122151620.548">@property
def background_opacity(self):
    return self._background_opacity

</t>
<t tx="ekr.20250122151620.549">@background_opacity.setter
def background_opacity(self, alpha):
    self._background_opacity = alpha
    self.init_background()

</t>
<t tx="ekr.20250122151620.55"># config options are properties

@property
def preview(self) -&gt; bool:
    """Whether to play the rendered movie (-p)."""
    return self._d["preview"] or self._d["enable_gui"]

</t>
<t tx="ekr.20250122151620.550">def type_or_raise(self, mobject: Mobject):
    """Return the type of mobject, if it is a type that can be rendered.

    If `mobject` is an instance of a class that inherits from a class that
    can be rendered, return the super class.  For example, an instance of a
    Square is also an instance of VMobject, and these can be rendered.
    Therefore, `type_or_raise(Square())` returns True.

    Parameters
    ----------
    mobject
        The object to take the type of.

    Notes
    -----
    For a list of classes that can currently be rendered, see :meth:`display_funcs`.

    Returns
    -------
    Type[:class:`~.Mobject`]
        The type of mobjects, if it can be rendered.

    Raises
    ------
    :exc:`TypeError`
        When mobject is not an instance of a class that can be rendered.
    """
    self.display_funcs = {
        VMobject: self.display_multiple_vectorized_mobjects,
        PMobject: self.display_multiple_point_cloud_mobjects,
        AbstractImageMobject: self.display_multiple_image_mobjects,
        Mobject: lambda batch, pa: batch,  # Do nothing
    }
    # We have to check each type in turn because we are dealing with
    # super classes.  For example, if square = Square(), then
    # type(square) != VMobject, but isinstance(square, VMobject) == True.
    for _type in self.display_funcs:
        if isinstance(mobject, _type):
            return _type
    raise TypeError(f"Displaying an object of class {_type} is not supported")

</t>
<t tx="ekr.20250122151620.551">def reset_pixel_shape(self, new_height: float, new_width: float):
    """This method resets the height and width
    of a single pixel to the passed new_height and new_width.

    Parameters
    ----------
    new_height
        The new height of the entire scene in pixels
    new_width
        The new width of the entire scene in pixels
    """
    self.pixel_width = new_width
    self.pixel_height = new_height
    self.init_background()
    self.resize_frame_shape()
    self.reset()

</t>
<t tx="ekr.20250122151620.552">def resize_frame_shape(self, fixed_dimension: int = 0):
    """
    Changes frame_shape to match the aspect ratio
    of the pixels, where fixed_dimension determines
    whether frame_height or frame_width
    remains fixed while the other changes accordingly.

    Parameters
    ----------
    fixed_dimension
        If 0, height is scaled with respect to width
        else, width is scaled with respect to height.
    """
    pixel_height = self.pixel_height
    pixel_width = self.pixel_width
    frame_height = self.frame_height
    frame_width = self.frame_width
    aspect_ratio = pixel_width / pixel_height
    if fixed_dimension == 0:
        frame_height = frame_width / aspect_ratio
    else:
        frame_width = aspect_ratio * frame_height
    self.frame_height = frame_height
    self.frame_width = frame_width

</t>
<t tx="ekr.20250122151620.553">def init_background(self):
    """Initialize the background.
    If self.background_image is the path of an image
    the image is set as background; else, the default
    background color fills the background.
    """
    height = self.pixel_height
    width = self.pixel_width
    if self.background_image is not None:
        path = get_full_raster_image_path(self.background_image)
        image = Image.open(path).convert(self.image_mode)
        # TODO, how to gracefully handle backgrounds
        # with different sizes?
        self.background = np.array(image)[:height, :width]
        self.background = self.background.astype(self.pixel_array_dtype)
    else:
        background_rgba = color_to_int_rgba(
            self.background_color,
            self.background_opacity,
        )
        self.background = np.zeros(
            (height, width, self.n_channels),
            dtype=self.pixel_array_dtype,
        )
        self.background[:, :] = background_rgba

</t>
<t tx="ekr.20250122151620.554">def get_image(self, pixel_array: np.ndarray | list | tuple | None = None):
    """Returns an image from the passed
    pixel array, or from the current frame
    if the passed pixel array is none.

    Parameters
    ----------
    pixel_array
        The pixel array from which to get an image, by default None

    Returns
    -------
    PIL.Image
        The PIL image of the array.
    """
    if pixel_array is None:
        pixel_array = self.pixel_array
    return Image.fromarray(pixel_array, mode=self.image_mode)

</t>
<t tx="ekr.20250122151620.555">def convert_pixel_array(
    self, pixel_array: np.ndarray | list | tuple, convert_from_floats: bool = False
):
    """Converts a pixel array from values that have floats in then
    to proper RGB values.

    Parameters
    ----------
    pixel_array
        Pixel array to convert.
    convert_from_floats
        Whether or not to convert float values to ints, by default False

    Returns
    -------
    np.array
        The new, converted pixel array.
    """
    retval = np.array(pixel_array)
    if convert_from_floats:
        retval = np.apply_along_axis(
            lambda f: (f * self.rgb_max_val).astype(self.pixel_array_dtype),
            2,
            retval,
        )
    return retval

</t>
<t tx="ekr.20250122151620.556">def set_pixel_array(
    self, pixel_array: np.ndarray | list | tuple, convert_from_floats: bool = False
):
    """Sets the pixel array of the camera to the passed pixel array.

    Parameters
    ----------
    pixel_array
        The pixel array to convert and then set as the camera's pixel array.
    convert_from_floats
        Whether or not to convert float values to proper RGB values, by default False
    """
    converted_array = self.convert_pixel_array(pixel_array, convert_from_floats)
    if not (
        hasattr(self, "pixel_array")
        and self.pixel_array.shape == converted_array.shape
    ):
        self.pixel_array = converted_array
    else:
        # Set in place
        self.pixel_array[:, :, :] = converted_array[:, :, :]

</t>
<t tx="ekr.20250122151620.557">def set_background(
    self, pixel_array: np.ndarray | list | tuple, convert_from_floats: bool = False
):
    """Sets the background to the passed pixel_array after converting
    to valid RGB values.

    Parameters
    ----------
    pixel_array
        The pixel array to set the background to.
    convert_from_floats
        Whether or not to convert floats values to proper RGB valid ones, by default False
    """
    self.background = self.convert_pixel_array(pixel_array, convert_from_floats)

</t>
<t tx="ekr.20250122151620.558"># TODO, this should live in utils, not as a method of Camera
def make_background_from_func(
    self, coords_to_colors_func: Callable[[np.ndarray], np.ndarray]
):
    """
    Makes a pixel array for the background by using coords_to_colors_func to determine each pixel's color. Each input
    pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not
    pixel coordinates), and each output is expected to be an RGBA array of 4 floats.

    Parameters
    ----------
    coords_to_colors_func
        The function whose input is an (x,y) pair of coordinates and
        whose return values must be the colors for that point

    Returns
    -------
    np.array
        The pixel array which can then be passed to set_background.
    """
    logger.info("Starting set_background")
    coords = self.get_coords_of_all_pixels()
    new_background = np.apply_along_axis(coords_to_colors_func, 2, coords)
    logger.info("Ending set_background")

    return self.convert_pixel_array(new_background, convert_from_floats=True)

</t>
<t tx="ekr.20250122151620.559">def set_background_from_func(
    self, coords_to_colors_func: Callable[[np.ndarray], np.ndarray]
):
    """
    Sets the background to a pixel array using coords_to_colors_func to determine each pixel's color. Each input
    pixel's color. Each input to coords_to_colors_func is an (x, y) pair in space (in ordinary space coordinates; not
    pixel coordinates), and each output is expected to be an RGBA array of 4 floats.

    Parameters
    ----------
    coords_to_colors_func
        The function whose input is an (x,y) pair of coordinates and
        whose return values must be the colors for that point
    """
    self.set_background(self.make_background_from_func(coords_to_colors_func))

</t>
<t tx="ekr.20250122151620.56">@preview.setter
def preview(self, value: bool) -&gt; None:
    self._set_boolean("preview", value)

</t>
<t tx="ekr.20250122151620.560">def reset(self):
    """Resets the camera's pixel array
    to that of the background

    Returns
    -------
    Camera
        The camera object after setting the pixel array.
    """
    self.set_pixel_array(self.background)
    return self

</t>
<t tx="ekr.20250122151620.561">def set_frame_to_background(self, background):
    self.set_pixel_array(background)

</t>
<t tx="ekr.20250122151620.562">####

def get_mobjects_to_display(
    self,
    mobjects: Iterable[Mobject],
    include_submobjects: bool = True,
    excluded_mobjects: list | None = None,
):
    """Used to get the list of mobjects to display
    with the camera.

    Parameters
    ----------
    mobjects
        The Mobjects
    include_submobjects
        Whether or not to include the submobjects of mobjects, by default True
    excluded_mobjects
        Any mobjects to exclude, by default None

    Returns
    -------
    list
        list of mobjects
    """
    if include_submobjects:
        mobjects = extract_mobject_family_members(
            mobjects,
            use_z_index=self.use_z_index,
            only_those_with_points=True,
        )
        if excluded_mobjects:
            all_excluded = extract_mobject_family_members(
                excluded_mobjects,
                use_z_index=self.use_z_index,
            )
            mobjects = list_difference_update(mobjects, all_excluded)
    return list(mobjects)

</t>
<t tx="ekr.20250122151620.563">def is_in_frame(self, mobject: Mobject):
    """Checks whether the passed mobject is in
    frame or not.

    Parameters
    ----------
    mobject
        The mobject for which the checking needs to be done.

    Returns
    -------
    bool
        True if in frame, False otherwise.
    """
    fc = self.frame_center
    fh = self.frame_height
    fw = self.frame_width
    return not reduce(
        op.or_,
        [
            mobject.get_right()[0] &lt; fc[0] - fw / 2,
            mobject.get_bottom()[1] &gt; fc[1] + fh / 2,
            mobject.get_left()[0] &gt; fc[0] + fw / 2,
            mobject.get_top()[1] &lt; fc[1] - fh / 2,
        ],
    )

</t>
<t tx="ekr.20250122151620.564">def capture_mobject(self, mobject: Mobject, **kwargs: Any):
    """Capture mobjects by storing it in :attr:`pixel_array`.

    This is a single-mobject version of :meth:`capture_mobjects`.

    Parameters
    ----------
    mobject
        Mobject to capture.

    kwargs
        Keyword arguments to be passed to :meth:`get_mobjects_to_display`.

    """
    return self.capture_mobjects([mobject], **kwargs)

</t>
<t tx="ekr.20250122151620.565">def capture_mobjects(self, mobjects: Iterable[Mobject], **kwargs):
    """Capture mobjects by printing them on :attr:`pixel_array`.

    This is the essential function that converts the contents of a Scene
    into an array, which is then converted to an image or video.

    Parameters
    ----------
    mobjects
        Mobjects to capture.

    kwargs
        Keyword arguments to be passed to :meth:`get_mobjects_to_display`.

    Notes
    -----
    For a list of classes that can currently be rendered, see :meth:`display_funcs`.

    """
    # The mobjects will be processed in batches (or runs) of mobjects of
    # the same type.  That is, if the list mobjects contains objects of
    # types [VMobject, VMobject, VMobject, PMobject, PMobject, VMobject],
    # then they will be captured in three batches: [VMobject, VMobject,
    # VMobject], [PMobject, PMobject], and [VMobject].  This must be done
    # without altering their order.  it.groupby computes exactly this
    # partition while at the same time preserving order.
    mobjects = self.get_mobjects_to_display(mobjects, **kwargs)
    for group_type, group in it.groupby(mobjects, self.type_or_raise):
        self.display_funcs[group_type](list(group), self.pixel_array)

</t>
<t tx="ekr.20250122151620.566"># Methods associated with svg rendering

# NOTE: None of the methods below have been mentioned outside of their definitions. Their DocStrings are not as
# detailed as possible.

def get_cached_cairo_context(self, pixel_array: np.ndarray):
    """Returns the cached cairo context of the passed
    pixel array if it exists, and None if it doesn't.

    Parameters
    ----------
    pixel_array
        The pixel array to check.

    Returns
    -------
    cairo.Context
        The cached cairo context.
    """
    return self.pixel_array_to_cairo_context.get(id(pixel_array), None)

</t>
<t tx="ekr.20250122151620.567">def cache_cairo_context(self, pixel_array: np.ndarray, ctx: cairo.Context):
    """Caches the passed Pixel array into a Cairo Context

    Parameters
    ----------
    pixel_array
        The pixel array to cache
    ctx
        The context to cache it into.
    """
    self.pixel_array_to_cairo_context[id(pixel_array)] = ctx

</t>
<t tx="ekr.20250122151620.568">def get_cairo_context(self, pixel_array: np.ndarray):
    """Returns the cairo context for a pixel array after
    caching it to self.pixel_array_to_cairo_context
    If that array has already been cached, it returns the
    cached version instead.

    Parameters
    ----------
    pixel_array
        The Pixel array to get the cairo context of.

    Returns
    -------
    cairo.Context
        The cairo context of the pixel array.
    """
    cached_ctx = self.get_cached_cairo_context(pixel_array)
    if cached_ctx:
        return cached_ctx
    pw = self.pixel_width
    ph = self.pixel_height
    fw = self.frame_width
    fh = self.frame_height
    fc = self.frame_center
    surface = cairo.ImageSurface.create_for_data(
        pixel_array,
        cairo.FORMAT_ARGB32,
        pw,
        ph,
    )
    ctx = cairo.Context(surface)
    ctx.scale(pw, ph)
    ctx.set_matrix(
        cairo.Matrix(
            (pw / fw),
            0,
            0,
            -(ph / fh),
            (pw / 2) - fc[0] * (pw / fw),
            (ph / 2) + fc[1] * (ph / fh),
        ),
    )
    self.cache_cairo_context(pixel_array, ctx)
    return ctx

</t>
<t tx="ekr.20250122151620.569">def display_multiple_vectorized_mobjects(
    self, vmobjects: list, pixel_array: np.ndarray
):
    """Displays multiple VMobjects in the pixel_array

    Parameters
    ----------
    vmobjects
        list of VMobjects to display
    pixel_array
        The pixel array
    """
    if len(vmobjects) == 0:
        return
    batch_image_pairs = it.groupby(vmobjects, lambda vm: vm.get_background_image())
    for image, batch in batch_image_pairs:
        if image:
            self.display_multiple_background_colored_vmobjects(batch, pixel_array)
        else:
            self.display_multiple_non_background_colored_vmobjects(
                batch,
                pixel_array,
            )

</t>
<t tx="ekr.20250122151620.57">@property
def show_in_file_browser(self) -&gt; bool:
    """Whether to show the output file in the file browser (-f)."""
    return self._d["show_in_file_browser"]

</t>
<t tx="ekr.20250122151620.570">def display_multiple_non_background_colored_vmobjects(
    self, vmobjects: list, pixel_array: np.ndarray
):
    """Displays multiple VMobjects in the cairo context, as long as they don't have
    background colors.

    Parameters
    ----------
    vmobjects
        list of the VMobjects
    pixel_array
        The Pixel array to add the VMobjects to.
    """
    ctx = self.get_cairo_context(pixel_array)
    for vmobject in vmobjects:
        self.display_vectorized(vmobject, ctx)

</t>
<t tx="ekr.20250122151620.571">def display_vectorized(self, vmobject: VMobject, ctx: cairo.Context):
    """Displays a VMobject in the cairo context

    Parameters
    ----------
    vmobject
        The Vectorized Mobject to display
    ctx
        The cairo context to use.

    Returns
    -------
    Camera
        The camera object
    """
    self.set_cairo_context_path(ctx, vmobject)
    self.apply_stroke(ctx, vmobject, background=True)
    self.apply_fill(ctx, vmobject)
    self.apply_stroke(ctx, vmobject)
    return self

</t>
<t tx="ekr.20250122151620.572">def set_cairo_context_path(self, ctx: cairo.Context, vmobject: VMobject):
    """Sets a path for the cairo context with the vmobject passed

    Parameters
    ----------
    ctx
        The cairo context
    vmobject
        The VMobject

    Returns
    -------
    Camera
        Camera object after setting cairo_context_path
    """
    points = self.transform_points_pre_display(vmobject, vmobject.points)
    # TODO, shouldn't this be handled in transform_points_pre_display?
    # points = points - self.get_frame_center()
    if len(points) == 0:
        return

    ctx.new_path()
    subpaths = vmobject.gen_subpaths_from_points_2d(points)
    for subpath in subpaths:
        quads = vmobject.gen_cubic_bezier_tuples_from_points(subpath)
        ctx.new_sub_path()
        start = subpath[0]
        ctx.move_to(*start[:2])
        for _p0, p1, p2, p3 in quads:
            ctx.curve_to(*p1[:2], *p2[:2], *p3[:2])
        if vmobject.consider_points_equals_2d(subpath[0], subpath[-1]):
            ctx.close_path()
    return self

</t>
<t tx="ekr.20250122151620.573">def set_cairo_context_color(
    self, ctx: cairo.Context, rgbas: np.ndarray, vmobject: VMobject
):
    """Sets the color of the cairo context

    Parameters
    ----------
    ctx
        The cairo context
    rgbas
        The RGBA array with which to color the context.
    vmobject
        The VMobject with which to set the color.

    Returns
    -------
    Camera
        The camera object
    """
    if len(rgbas) == 1:
        # Use reversed rgb because cairo surface is
        # encodes it in reverse order
        ctx.set_source_rgba(*rgbas[0][2::-1], rgbas[0][3])
    else:
        points = vmobject.get_gradient_start_and_end_points()
        points = self.transform_points_pre_display(vmobject, points)
        pat = cairo.LinearGradient(*it.chain(*(point[:2] for point in points)))
        step = 1.0 / (len(rgbas) - 1)
        offsets = np.arange(0, 1 + step, step)
        for rgba, offset in zip(rgbas, offsets):
            pat.add_color_stop_rgba(offset, *rgba[2::-1], rgba[3])
        ctx.set_source(pat)
    return self

</t>
<t tx="ekr.20250122151620.574">def apply_fill(self, ctx: cairo.Context, vmobject: VMobject):
    """Fills the cairo context

    Parameters
    ----------
    ctx
        The cairo context
    vmobject
        The VMobject

    Returns
    -------
    Camera
        The camera object.
    """
    self.set_cairo_context_color(ctx, self.get_fill_rgbas(vmobject), vmobject)
    ctx.fill_preserve()
    return self

</t>
<t tx="ekr.20250122151620.575">def apply_stroke(
    self, ctx: cairo.Context, vmobject: VMobject, background: bool = False
):
    """Applies a stroke to the VMobject in the cairo context.

    Parameters
    ----------
    ctx
        The cairo context
    vmobject
        The VMobject
    background
        Whether or not to consider the background when applying this
        stroke width, by default False

    Returns
    -------
    Camera
        The camera object with the stroke applied.
    """
    width = vmobject.get_stroke_width(background)
    if width == 0:
        return self
    self.set_cairo_context_color(
        ctx,
        self.get_stroke_rgbas(vmobject, background=background),
        vmobject,
    )
    ctx.set_line_width(
        width
        * self.cairo_line_width_multiple
        * (self.frame_width / self.frame_width),
        # This ensures lines have constant width as you zoom in on them.
    )
    if vmobject.joint_type != LineJointType.AUTO:
        ctx.set_line_join(LINE_JOIN_MAP[vmobject.joint_type])
    if vmobject.cap_style != CapStyleType.AUTO:
        ctx.set_line_cap(CAP_STYLE_MAP[vmobject.cap_style])
    ctx.stroke_preserve()
    return self

</t>
<t tx="ekr.20250122151620.576">def get_stroke_rgbas(self, vmobject: VMobject, background: bool = False):
    """Gets the RGBA array for the stroke of the passed
    VMobject.

    Parameters
    ----------
    vmobject
        The VMobject
    background
        Whether or not to consider the background when getting the stroke
        RGBAs, by default False

    Returns
    -------
    np.ndarray
        The RGBA array of the stroke.
    """
    return vmobject.get_stroke_rgbas(background)

</t>
<t tx="ekr.20250122151620.577">def get_fill_rgbas(self, vmobject: VMobject):
    """Returns the RGBA array of the fill of the passed VMobject

    Parameters
    ----------
    vmobject
        The VMobject

    Returns
    -------
    np.array
        The RGBA Array of the fill of the VMobject
    """
    return vmobject.get_fill_rgbas()

</t>
<t tx="ekr.20250122151620.578">def get_background_colored_vmobject_displayer(self):
    """Returns the background_colored_vmobject_displayer
    if it exists or makes one and returns it if not.

    Returns
    -------
    BackGroundColoredVMobjectDisplayer
        Object that displays VMobjects that have the same color
        as the background.
    """
    # Quite wordy to type out a bunch
    bcvd = "background_colored_vmobject_displayer"
    if not hasattr(self, bcvd):
        setattr(self, bcvd, BackgroundColoredVMobjectDisplayer(self))
    return getattr(self, bcvd)

</t>
<t tx="ekr.20250122151620.579">def display_multiple_background_colored_vmobjects(
    self, cvmobjects: list, pixel_array: np.ndarray
):
    """Displays multiple vmobjects that have the same color as the background.

    Parameters
    ----------
    cvmobjects
        List of Colored VMobjects
    pixel_array
        The pixel array.

    Returns
    -------
    Camera
        The camera object.
    """
    displayer = self.get_background_colored_vmobject_displayer()
    cvmobject_pixel_array = displayer.display(*cvmobjects)
    self.overlay_rgba_array(pixel_array, cvmobject_pixel_array)
    return self

</t>
<t tx="ekr.20250122151620.58">@show_in_file_browser.setter
def show_in_file_browser(self, value: bool) -&gt; None:
    self._set_boolean("show_in_file_browser", value)

</t>
<t tx="ekr.20250122151620.580"># Methods for other rendering

# NOTE: Out of the following methods, only `transform_points_pre_display` and `points_to_pixel_coords` have been mentioned outside of their definitions.
# As a result, the other methods do not have as detailed docstrings as would be preferred.

def display_multiple_point_cloud_mobjects(
    self, pmobjects: list, pixel_array: np.ndarray
):
    """Displays multiple PMobjects by modifying the passed pixel array.

    Parameters
    ----------
    pmobjects
        List of PMobjects
    pixel_array
        The pixel array to modify.
    """
    for pmobject in pmobjects:
        self.display_point_cloud(
            pmobject,
            pmobject.points,
            pmobject.rgbas,
            self.adjusted_thickness(pmobject.stroke_width),
            pixel_array,
        )

</t>
<t tx="ekr.20250122151620.581">def display_point_cloud(
    self,
    pmobject: PMobject,
    points: list,
    rgbas: np.ndarray,
    thickness: float,
    pixel_array: np.ndarray,
):
    """Displays a PMobject by modifying the pixel array suitably.

    TODO: Write a description for the rgbas argument.

    Parameters
    ----------
    pmobject
        Point Cloud Mobject
    points
        The points to display in the point cloud mobject
    rgbas

    thickness
        The thickness of each point of the PMobject
    pixel_array
        The pixel array to modify.

    """
    if len(points) == 0:
        return
    pixel_coords = self.points_to_pixel_coords(pmobject, points)
    pixel_coords = self.thickened_coordinates(pixel_coords, thickness)
    rgba_len = pixel_array.shape[2]

    rgbas = (self.rgb_max_val * rgbas).astype(self.pixel_array_dtype)
    target_len = len(pixel_coords)
    factor = target_len // len(rgbas)
    rgbas = np.array([rgbas] * factor).reshape((target_len, rgba_len))

    on_screen_indices = self.on_screen_pixels(pixel_coords)
    pixel_coords = pixel_coords[on_screen_indices]
    rgbas = rgbas[on_screen_indices]

    ph = self.pixel_height
    pw = self.pixel_width

    flattener = np.array([1, pw], dtype="int")
    flattener = flattener.reshape((2, 1))
    indices = np.dot(pixel_coords, flattener)[:, 0]
    indices = indices.astype("int")

    new_pa = pixel_array.reshape((ph * pw, rgba_len))
    new_pa[indices] = rgbas
    pixel_array[:, :] = new_pa.reshape((ph, pw, rgba_len))

</t>
<t tx="ekr.20250122151620.582">def display_multiple_image_mobjects(
    self, image_mobjects: list, pixel_array: np.ndarray
):
    """Displays multiple image mobjects by modifying the passed pixel_array.

    Parameters
    ----------
    image_mobjects
        list of ImageMobjects
    pixel_array
        The pixel array to modify.
    """
    for image_mobject in image_mobjects:
        self.display_image_mobject(image_mobject, pixel_array)

</t>
<t tx="ekr.20250122151620.583">def display_image_mobject(
    self, image_mobject: AbstractImageMobject, pixel_array: np.ndarray
):
    """Displays an ImageMobject by changing the pixel_array suitably.

    Parameters
    ----------
    image_mobject
        The imageMobject to display
    pixel_array
        The Pixel array to put the imagemobject in.
    """
    corner_coords = self.points_to_pixel_coords(image_mobject, image_mobject.points)
    ul_coords, ur_coords, dl_coords, _ = corner_coords
    right_vect = ur_coords - ul_coords
    down_vect = dl_coords - ul_coords
    center_coords = ul_coords + (right_vect + down_vect) / 2

    sub_image = Image.fromarray(image_mobject.get_pixel_array(), mode="RGBA")

    # Reshape
    pixel_width = max(int(pdist([ul_coords, ur_coords]).item()), 1)
    pixel_height = max(int(pdist([ul_coords, dl_coords]).item()), 1)
    sub_image = sub_image.resize(
        (pixel_width, pixel_height),
        resample=image_mobject.resampling_algorithm,
    )

    # Rotate
    angle = angle_of_vector(right_vect)
    adjusted_angle = -int(360 * angle / TAU)
    if adjusted_angle != 0:
        sub_image = sub_image.rotate(
            adjusted_angle,
            resample=image_mobject.resampling_algorithm,
            expand=1,
        )

    # TODO, there is no accounting for a shear...

    # Paste into an image as large as the camera's pixel array
    full_image = Image.fromarray(
        np.zeros((self.pixel_height, self.pixel_width)),
        mode="RGBA",
    )
    new_ul_coords = center_coords - np.array(sub_image.size) / 2
    new_ul_coords = new_ul_coords.astype(int)
    full_image.paste(
        sub_image,
        box=(
            new_ul_coords[0],
            new_ul_coords[1],
            new_ul_coords[0] + sub_image.size[0],
            new_ul_coords[1] + sub_image.size[1],
        ),
    )
    # Paint on top of existing pixel array
    self.overlay_PIL_image(pixel_array, full_image)

</t>
<t tx="ekr.20250122151620.584">def overlay_rgba_array(self, pixel_array: np.ndarray, new_array: np.ndarray):
    """Overlays an RGBA array on top of the given Pixel array.

    Parameters
    ----------
    pixel_array
        The original pixel array to modify.
    new_array
        The new pixel array to overlay.
    """
    self.overlay_PIL_image(pixel_array, self.get_image(new_array))

</t>
<t tx="ekr.20250122151620.585">def overlay_PIL_image(self, pixel_array: np.ndarray, image: Image):
    """Overlays a PIL image on the passed pixel array.

    Parameters
    ----------
    pixel_array
        The Pixel array
    image
        The Image to overlay.
    """
    pixel_array[:, :] = np.array(
        Image.alpha_composite(self.get_image(pixel_array), image),
        dtype="uint8",
    )

</t>
<t tx="ekr.20250122151620.586">def adjust_out_of_range_points(self, points: np.ndarray):
    """If any of the points in the passed array are out of
    the viable range, they are adjusted suitably.

    Parameters
    ----------
    points
        The points to adjust

    Returns
    -------
    np.array
        The adjusted points.
    """
    if not np.any(points &gt; self.max_allowable_norm):
        return points
    norms = np.apply_along_axis(np.linalg.norm, 1, points)
    violator_indices = norms &gt; self.max_allowable_norm
    violators = points[violator_indices, :]
    violator_norms = norms[violator_indices]
    reshaped_norms = np.repeat(
        violator_norms.reshape((len(violator_norms), 1)),
        points.shape[1],
        1,
    )
    rescaled = self.max_allowable_norm * violators / reshaped_norms
    points[violator_indices] = rescaled
    return points

</t>
<t tx="ekr.20250122151620.587">def transform_points_pre_display(
    self,
    mobject,
    points,
):  # TODO: Write more detailed docstrings for this method.
    # NOTE: There seems to be an unused argument `mobject`.

    # Subclasses (like ThreeDCamera) may want to
    # adjust points further before they're shown
    if not np.all(np.isfinite(points)):
        # TODO, print some kind of warning about
        # mobject having invalid points?
        points = np.zeros((1, 3))
    return points

</t>
<t tx="ekr.20250122151620.588">def points_to_pixel_coords(
    self,
    mobject,
    points,
):  # TODO: Write more detailed docstrings for this method.
    points = self.transform_points_pre_display(mobject, points)
    shifted_points = points - self.frame_center

    result = np.zeros((len(points), 2))
    pixel_height = self.pixel_height
    pixel_width = self.pixel_width
    frame_height = self.frame_height
    frame_width = self.frame_width
    width_mult = pixel_width / frame_width
    width_add = pixel_width / 2
    height_mult = pixel_height / frame_height
    height_add = pixel_height / 2
    # Flip on y-axis as you go
    height_mult *= -1

    result[:, 0] = shifted_points[:, 0] * width_mult + width_add
    result[:, 1] = shifted_points[:, 1] * height_mult + height_add
    return result.astype("int")

</t>
<t tx="ekr.20250122151620.589">def on_screen_pixels(self, pixel_coords: np.ndarray):
    """Returns array of pixels that are on the screen from a given
    array of pixel_coordinates

    Parameters
    ----------
    pixel_coords
        The pixel coords to check.

    Returns
    -------
    np.array
        The pixel coords on screen.
    """
    return reduce(
        op.and_,
        [
            pixel_coords[:, 0] &gt;= 0,
            pixel_coords[:, 0] &lt; self.pixel_width,
            pixel_coords[:, 1] &gt;= 0,
            pixel_coords[:, 1] &lt; self.pixel_height,
        ],
    )

</t>
<t tx="ekr.20250122151620.59">@property
def progress_bar(self) -&gt; str:
    """Whether to show progress bars while rendering animations."""
    return self._d["progress_bar"]

</t>
<t tx="ekr.20250122151620.590">def adjusted_thickness(self, thickness: float) -&gt; float:
    """Computes the adjusted stroke width for a zoomed camera.

    Parameters
    ----------
    thickness
        The stroke width of a mobject.

    Returns
    -------
    float
        The adjusted stroke width that reflects zooming in with
        the camera.
    """
    # TODO: This seems...unsystematic
    big_sum = op.add(config["pixel_height"], config["pixel_width"])
    this_sum = op.add(self.pixel_height, self.pixel_width)
    factor = big_sum / this_sum
    return 1 + (thickness - 1) * factor

</t>
<t tx="ekr.20250122151620.591">def get_thickening_nudges(self, thickness: float):
    """Determine a list of vectors used to nudge
    two-dimensional pixel coordinates.

    Parameters
    ----------
    thickness

    Returns
    -------
    np.array

    """
    thickness = int(thickness)
    _range = list(range(-thickness // 2 + 1, thickness // 2 + 1))
    return np.array(list(it.product(_range, _range)))

</t>
<t tx="ekr.20250122151620.592">def thickened_coordinates(self, pixel_coords: np.ndarray, thickness: float):
    """Returns thickened coordinates for a passed array of pixel coords and
    a thickness to thicken by.

    Parameters
    ----------
    pixel_coords
        Pixel coordinates
    thickness
        Thickness

    Returns
    -------
    np.array
        Array of thickened pixel coords.
    """
    nudges = self.get_thickening_nudges(thickness)
    pixel_coords = np.array([pixel_coords + nudge for nudge in nudges])
    size = pixel_coords.size
    return pixel_coords.reshape((size // 2, 2))

</t>
<t tx="ekr.20250122151620.593"># TODO, reimplement using cairo matrix
def get_coords_of_all_pixels(self):
    """Returns the cartesian coordinates of each pixel.

    Returns
    -------
    np.ndarray
        The array of cartesian coordinates.
    """
    # These are in x, y order, to help me keep things straight
    full_space_dims = np.array([self.frame_width, self.frame_height])
    full_pixel_dims = np.array([self.pixel_width, self.pixel_height])

    # These are addressed in the same y, x order as in pixel_array, but the values in them
    # are listed in x, y order
    uncentered_pixel_coords = np.indices([self.pixel_height, self.pixel_width])[
        ::-1
    ].transpose(1, 2, 0)
    uncentered_space_coords = (
        uncentered_pixel_coords * full_space_dims
    ) / full_pixel_dims
    # Could structure above line's computation slightly differently, but figured (without much
    # thought) multiplying by frame_shape first, THEN dividing by pixel_shape, is probably
    # better than the other order, for avoiding underflow quantization in the division (whereas
    # overflow is unlikely to be a problem)

    centered_space_coords = uncentered_space_coords - (full_space_dims / 2)

    # Have to also flip the y coordinates to account for pixel array being listed in
    # top-to-bottom order, opposite of screen coordinate convention
    centered_space_coords = centered_space_coords * (1, -1)

    return centered_space_coords


</t>
<t tx="ekr.20250122151620.594">def __init__(self, camera: Camera):
    self.camera = camera
    self.file_name_to_pixel_array_map = {}
    self.pixel_array = np.array(camera.pixel_array)
    self.reset_pixel_array()

</t>
<t tx="ekr.20250122151620.595">def reset_pixel_array(self):
    self.pixel_array[:, :] = 0

</t>
<t tx="ekr.20250122151620.596">def resize_background_array(
    self,
    background_array: np.ndarray,
    new_width: float,
    new_height: float,
    mode: str = "RGBA",
):
    """Resizes the pixel array representing the background.

    Parameters
    ----------
    background_array
        The pixel
    new_width
        The new width of the background
    new_height
        The new height of the background
    mode
        The PIL image mode, by default "RGBA"

    Returns
    -------
    np.array
        The numpy pixel array of the resized background.
    """
    image = Image.fromarray(background_array)
    image = image.convert(mode)
    resized_image = image.resize((new_width, new_height))
    return np.array(resized_image)

</t>
<t tx="ekr.20250122151620.597">def resize_background_array_to_match(
    self, background_array: np.ndarray, pixel_array: np.ndarray
):
    """Resizes the background array to match the passed pixel array.

    Parameters
    ----------
    background_array
        The prospective pixel array.
    pixel_array
        The pixel array whose width and height should be matched.

    Returns
    -------
    np.array
        The resized background array.
    """
    height, width = pixel_array.shape[:2]
    mode = "RGBA" if pixel_array.shape[2] == 4 else "RGB"
    return self.resize_background_array(background_array, width, height, mode)

</t>
<t tx="ekr.20250122151620.598">def get_background_array(self, image: Image.Image | pathlib.Path | str):
    """Gets the background array that has the passed file_name.

    Parameters
    ----------
    image
        The background image or its file name.

    Returns
    -------
    np.ndarray
        The pixel array of the image.
    """
    image_key = str(image)

    if image_key in self.file_name_to_pixel_array_map:
        return self.file_name_to_pixel_array_map[image_key]
    if isinstance(image, str):
        full_path = get_full_raster_image_path(image)
        image = Image.open(full_path)
    back_array = np.array(image)

    pixel_array = self.pixel_array
    if not np.all(pixel_array.shape == back_array.shape):
        back_array = self.resize_background_array_to_match(back_array, pixel_array)

    self.file_name_to_pixel_array_map[image_key] = back_array
    return back_array

</t>
<t tx="ekr.20250122151620.599">def display(self, *cvmobjects: VMobject):
    """Displays the colored VMobjects.

    Parameters
    ----------
    *cvmobjects
        The VMobjects

    Returns
    -------
    np.array
        The pixel array with the `cvmobjects` displayed.
    """
    batch_image_pairs = it.groupby(cvmobjects, lambda cv: cv.get_background_image())
    curr_array = None
    for image, batch in batch_image_pairs:
        background_array = self.get_background_array(image)
        pixel_array = self.pixel_array
        self.camera.display_multiple_non_background_colored_vmobjects(
            batch,
            pixel_array,
        )
        new_array = np.array(
            (background_array * pixel_array.astype("float") / 255),
            dtype=self.camera.pixel_array_dtype,
        )
        if curr_array is None:
            curr_array = new_array
        else:
            curr_array = np.maximum(curr_array, new_array)
        self.reset_pixel_array()
    return curr_array
</t>
<t tx="ekr.20250122151620.6">def print_version_and_exit(
    ctx: click.Context, param: click.Option, value: str | None
) -&gt; None:
    """Same as :func:`show_splash`, but also exit when giving a value by
    console.

    Parameters
    ----------
    ctx
        The Click context.
    param
        A Click option.
    value
        A string value given by console, or None.
    """
    show_splash(ctx, param, value)
    if value:
        ctx.exit()


</t>
<t tx="ekr.20250122151620.60">@progress_bar.setter
def progress_bar(self, value: str) -&gt; None:
    self._set_from_list("progress_bar", value, ["none", "display", "leave"])

</t>
<t tx="ekr.20250122151620.600">"""A camera that allows mapping between objects."""

from __future__ import annotations

__all__ = ["MappingCamera", "OldMultiCamera", "SplitScreenCamera"]

import math

import numpy as np

from ..camera.camera import Camera
from ..mobject.types.vectorized_mobject import VMobject
from ..utils.config_ops import DictAsObject

# TODO: Add an attribute to mobjects under which they can specify that they should just
# map their centers but remain otherwise undistorted (useful for labels, etc.)


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.601">class MappingCamera(Camera):
    """Camera object that allows mapping
    between objects.
    """

    @others
</t>
<t tx="ekr.20250122151620.602"># Note: This allows layering of multiple cameras onto the same portion of the pixel array,
# the later cameras overwriting the former
#
# TODO: Add optional separator borders between cameras (or perhaps peel this off into a
# CameraPlusOverlay class)


# TODO, the classes below should likely be deleted
class OldMultiCamera(Camera):
    @others
</t>
<t tx="ekr.20250122151620.603"># A OldMultiCamera which, when called with two full-size cameras, initializes itself
# as a split screen, also taking care to resize each individual camera within it


class SplitScreenCamera(OldMultiCamera):
    @others
</t>
<t tx="ekr.20250122151620.604">def __init__(
    self,
    mapping_func=lambda p: p,
    min_num_curves=50,
    allow_object_intrusion=False,
    **kwargs,
):
    self.mapping_func = mapping_func
    self.min_num_curves = min_num_curves
    self.allow_object_intrusion = allow_object_intrusion
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.605">def points_to_pixel_coords(self, mobject, points):
    return super().points_to_pixel_coords(
        mobject,
        np.apply_along_axis(self.mapping_func, 1, points),
    )

</t>
<t tx="ekr.20250122151620.606">def capture_mobjects(self, mobjects, **kwargs):
    mobjects = self.get_mobjects_to_display(mobjects, **kwargs)
    if self.allow_object_intrusion:
        mobject_copies = mobjects
    else:
        mobject_copies = [mobject.copy() for mobject in mobjects]
    for mobject in mobject_copies:
        if (
            isinstance(mobject, VMobject)
            and 0 &lt; mobject.get_num_curves() &lt; self.min_num_curves
        ):
            mobject.insert_n_curves(self.min_num_curves)
    super().capture_mobjects(
        mobject_copies,
        include_submobjects=False,
        excluded_mobjects=None,
    )


</t>
<t tx="ekr.20250122151620.607">def __init__(self, *cameras_with_start_positions, **kwargs):
    self.shifted_cameras = [
        DictAsObject(
            {
                "camera": camera_with_start_positions[0],
                "start_x": camera_with_start_positions[1][1],
                "start_y": camera_with_start_positions[1][0],
                "end_x": camera_with_start_positions[1][1]
                + camera_with_start_positions[0].pixel_width,
                "end_y": camera_with_start_positions[1][0]
                + camera_with_start_positions[0].pixel_height,
            },
        )
        for camera_with_start_positions in cameras_with_start_positions
    ]
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.608">def capture_mobjects(self, mobjects, **kwargs):
    for shifted_camera in self.shifted_cameras:
        shifted_camera.camera.capture_mobjects(mobjects, **kwargs)

        self.pixel_array[
            shifted_camera.start_y : shifted_camera.end_y,
            shifted_camera.start_x : shifted_camera.end_x,
        ] = shifted_camera.camera.pixel_array

</t>
<t tx="ekr.20250122151620.609">def set_background(self, pixel_array, **kwargs):
    for shifted_camera in self.shifted_cameras:
        shifted_camera.camera.set_background(
            pixel_array[
                shifted_camera.start_y : shifted_camera.end_y,
                shifted_camera.start_x : shifted_camera.end_x,
            ],
            **kwargs,
        )

</t>
<t tx="ekr.20250122151620.61">@property
def log_to_file(self) -&gt; bool:
    """Whether to save logs to a file."""
    return self._d["log_to_file"]

</t>
<t tx="ekr.20250122151620.610">def set_pixel_array(self, pixel_array, **kwargs):
    super().set_pixel_array(pixel_array, **kwargs)
    for shifted_camera in self.shifted_cameras:
        shifted_camera.camera.set_pixel_array(
            pixel_array[
                shifted_camera.start_y : shifted_camera.end_y,
                shifted_camera.start_x : shifted_camera.end_x,
            ],
            **kwargs,
        )

</t>
<t tx="ekr.20250122151620.611">def init_background(self):
    super().init_background()
    for shifted_camera in self.shifted_cameras:
        shifted_camera.camera.init_background()


</t>
<t tx="ekr.20250122151620.612">def __init__(self, left_camera, right_camera, **kwargs):
    Camera.__init__(self, **kwargs)  # to set attributes such as pixel_width
    self.left_camera = left_camera
    self.right_camera = right_camera

    half_width = math.ceil(self.pixel_width / 2)
    for camera in [self.left_camera, self.right_camera]:
        camera.reset_pixel_shape(camera.pixel_height, half_width)

    super().__init__(
        (left_camera, (0, 0)),
        (right_camera, (0, half_width)),
    )
</t>
<t tx="ekr.20250122151620.613">"""A camera able to move through a scene.

.. SEEALSO::

    :mod:`.moving_camera_scene`

"""

from __future__ import annotations

__all__ = ["MovingCamera"]

import numpy as np

from .. import config
from ..camera.camera import Camera
from ..constants import DOWN, LEFT, RIGHT, UP
from ..mobject.frame import ScreenRectangle
from ..mobject.mobject import Mobject
from ..utils.color import WHITE


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.614">class MovingCamera(Camera):
    """
    Stays in line with the height, width and position of it's 'frame', which is a Rectangle

    .. SEEALSO::

        :class:`.MovingCameraScene`

    """

    @others
</t>
<t tx="ekr.20250122151620.615">def __init__(
    self,
    frame=None,
    fixed_dimension=0,  # width
    default_frame_stroke_color=WHITE,
    default_frame_stroke_width=0,
    **kwargs,
):
    """
    Frame is a Mobject, (should almost certainly be a rectangle)
    determining which region of space the camera displays
    """
    self.fixed_dimension = fixed_dimension
    self.default_frame_stroke_color = default_frame_stroke_color
    self.default_frame_stroke_width = default_frame_stroke_width
    if frame is None:
        frame = ScreenRectangle(height=config["frame_height"])
        frame.set_stroke(
            self.default_frame_stroke_color,
            self.default_frame_stroke_width,
        )
    self.frame = frame
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.616"># TODO, make these work for a rotated frame
@property
def frame_height(self):
    """Returns the height of the frame.

    Returns
    -------
    float
        The height of the frame.
    """
    return self.frame.height

</t>
<t tx="ekr.20250122151620.617">@property
def frame_width(self):
    """Returns the width of the frame

    Returns
    -------
    float
        The width of the frame.
    """
    return self.frame.width

</t>
<t tx="ekr.20250122151620.618">@property
def frame_center(self):
    """Returns the centerpoint of the frame in cartesian coordinates.

    Returns
    -------
    np.array
        The cartesian coordinates of the center of the frame.
    """
    return self.frame.get_center()

</t>
<t tx="ekr.20250122151620.619">@frame_height.setter
def frame_height(self, frame_height: float):
    """Sets the height of the frame in MUnits.

    Parameters
    ----------
    frame_height
        The new frame_height.
    """
    self.frame.stretch_to_fit_height(frame_height)

</t>
<t tx="ekr.20250122151620.62">@log_to_file.setter
def log_to_file(self, value: bool) -&gt; None:
    self._set_boolean("log_to_file", value)

</t>
<t tx="ekr.20250122151620.620">@frame_width.setter
def frame_width(self, frame_width: float):
    """Sets the width of the frame in MUnits.

    Parameters
    ----------
    frame_width
        The new frame_width.
    """
    self.frame.stretch_to_fit_width(frame_width)

</t>
<t tx="ekr.20250122151620.621">@frame_center.setter
def frame_center(self, frame_center: np.ndarray | list | tuple | Mobject):
    """Sets the centerpoint of the frame.

    Parameters
    ----------
    frame_center
        The point to which the frame must be moved.
        If is of type mobject, the frame will be moved to
        the center of that mobject.
    """
    self.frame.move_to(frame_center)

</t>
<t tx="ekr.20250122151620.622">def capture_mobjects(self, mobjects, **kwargs):
    # self.reset_frame_center()
    # self.realign_frame_shape()
    super().capture_mobjects(mobjects, **kwargs)

</t>
<t tx="ekr.20250122151620.623"># Since the frame can be moving around, the cairo
# context used for updating should be regenerated
# at each frame.  So no caching.
def get_cached_cairo_context(self, pixel_array):
    """
    Since the frame can be moving around, the cairo
    context used for updating should be regenerated
    at each frame.  So no caching.
    """
    return None

</t>
<t tx="ekr.20250122151620.624">def cache_cairo_context(self, pixel_array, ctx):
    """
    Since the frame can be moving around, the cairo
    context used for updating should be regenerated
    at each frame.  So no caching.
    """
    pass

</t>
<t tx="ekr.20250122151620.625"># def reset_frame_center(self):
#     self.frame_center = self.frame.get_center()

# def realign_frame_shape(self):
#     height, width = self.frame_shape
#     if self.fixed_dimension == 0:
#         self.frame_shape = (height, self.frame.width
#     else:
#         self.frame_shape = (self.frame.height, width)
#     self.resize_frame_shape(fixed_dimension=self.fixed_dimension)

def get_mobjects_indicating_movement(self):
    """
    Returns all mobjects whose movement implies that the camera
    should think of all other mobjects on the screen as moving

    Returns
    -------
    list
    """
    return [self.frame]

</t>
<t tx="ekr.20250122151620.626">def auto_zoom(
    self,
    mobjects: list[Mobject],
    margin: float = 0,
    only_mobjects_in_frame: bool = False,
    animate: bool = True,
):
    """Zooms on to a given array of mobjects (or a singular mobject)
    and automatically resizes to frame all the mobjects.

    .. NOTE::

        This method only works when 2D-objects in the XY-plane are considered, it
        will not work correctly when the camera has been rotated.

    Parameters
    ----------
    mobjects
        The mobject or array of mobjects that the camera will focus on.

    margin
        The width of the margin that is added to the frame (optional, 0 by default).

    only_mobjects_in_frame
        If set to ``True``, only allows focusing on mobjects that are already in frame.

    animate
        If set to ``False``, applies the changes instead of returning the corresponding animation

    Returns
    -------
    Union[_AnimationBuilder, ScreenRectangle]
        _AnimationBuilder that zooms the camera view to a given list of mobjects
        or ScreenRectangle with position and size updated to zoomed position.

    """
    scene_critical_x_left = None
    scene_critical_x_right = None
    scene_critical_y_up = None
    scene_critical_y_down = None

    for m in mobjects:
        if (m == self.frame) or (
            only_mobjects_in_frame and not self.is_in_frame(m)
        ):
            # detected camera frame, should not be used to calculate final position of camera
            continue

        # initialize scene critical points with first mobjects critical points
        if scene_critical_x_left is None:
            scene_critical_x_left = m.get_critical_point(LEFT)[0]
            scene_critical_x_right = m.get_critical_point(RIGHT)[0]
            scene_critical_y_up = m.get_critical_point(UP)[1]
            scene_critical_y_down = m.get_critical_point(DOWN)[1]

        else:
            if m.get_critical_point(LEFT)[0] &lt; scene_critical_x_left:
                scene_critical_x_left = m.get_critical_point(LEFT)[0]

            if m.get_critical_point(RIGHT)[0] &gt; scene_critical_x_right:
                scene_critical_x_right = m.get_critical_point(RIGHT)[0]

            if m.get_critical_point(UP)[1] &gt; scene_critical_y_up:
                scene_critical_y_up = m.get_critical_point(UP)[1]

            if m.get_critical_point(DOWN)[1] &lt; scene_critical_y_down:
                scene_critical_y_down = m.get_critical_point(DOWN)[1]

    # calculate center x and y
    x = (scene_critical_x_left + scene_critical_x_right) / 2
    y = (scene_critical_y_up + scene_critical_y_down) / 2

    # calculate proposed width and height of zoomed scene
    new_width = abs(scene_critical_x_left - scene_critical_x_right)
    new_height = abs(scene_critical_y_up - scene_critical_y_down)

    m_target = self.frame.animate if animate else self.frame
    # zoom to fit all mobjects along the side that has the largest size
    if new_width / self.frame.width &gt; new_height / self.frame.height:
        return m_target.set_x(x).set_y(y).set(width=new_width + margin)
    else:
        return m_target.set_x(x).set_y(y).set(height=new_height + margin)
</t>
<t tx="ekr.20250122151620.627">"""A camera supporting multiple perspectives."""

from __future__ import annotations

__all__ = ["MultiCamera"]


from manim.mobject.types.image_mobject import ImageMobject

from ..camera.moving_camera import MovingCamera
from ..utils.iterables import list_difference_update


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.628">class MultiCamera(MovingCamera):
    """Camera Object that allows for multiple perspectives."""

    @others
</t>
<t tx="ekr.20250122151620.629">def __init__(
    self,
    image_mobjects_from_cameras: ImageMobject | None = None,
    allow_cameras_to_capture_their_own_display=False,
    **kwargs,
):
    """Initialises the MultiCamera

    Parameters
    ----------
    image_mobjects_from_cameras

    kwargs
        Any valid keyword arguments of MovingCamera.
    """
    self.image_mobjects_from_cameras = []
    if image_mobjects_from_cameras is not None:
        for imfc in image_mobjects_from_cameras:
            self.add_image_mobject_from_camera(imfc)
    self.allow_cameras_to_capture_their_own_display = (
        allow_cameras_to_capture_their_own_display
    )
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151620.63">@property
def notify_outdated_version(self) -&gt; bool:
    """Whether to notify if there is a version update available."""
    return self._d["notify_outdated_version"]

</t>
<t tx="ekr.20250122151620.630">def add_image_mobject_from_camera(self, image_mobject_from_camera: ImageMobject):
    """Adds an ImageMobject that's been obtained from the camera
    into the list ``self.image_mobject_from_cameras``

    Parameters
    ----------
    image_mobject_from_camera
        The ImageMobject to add to self.image_mobject_from_cameras
    """
    # A silly method to have right now, but maybe there are things
    # we want to guarantee about any imfc's added later.
    imfc = image_mobject_from_camera
    assert isinstance(imfc.camera, MovingCamera)
    self.image_mobjects_from_cameras.append(imfc)

</t>
<t tx="ekr.20250122151620.631">def update_sub_cameras(self):
    """Reshape sub_camera pixel_arrays"""
    for imfc in self.image_mobjects_from_cameras:
        pixel_height, pixel_width = self.pixel_array.shape[:2]
        imfc.camera.frame_shape = (
            imfc.camera.frame.height,
            imfc.camera.frame.width,
        )
        imfc.camera.reset_pixel_shape(
            int(pixel_height * imfc.height / self.frame_height),
            int(pixel_width * imfc.width / self.frame_width),
        )

</t>
<t tx="ekr.20250122151620.632">def reset(self):
    """Resets the MultiCamera.

    Returns
    -------
    MultiCamera
        The reset MultiCamera
    """
    for imfc in self.image_mobjects_from_cameras:
        imfc.camera.reset()
    super().reset()
    return self

</t>
<t tx="ekr.20250122151620.633">def capture_mobjects(self, mobjects, **kwargs):
    self.update_sub_cameras()
    for imfc in self.image_mobjects_from_cameras:
        to_add = list(mobjects)
        if not self.allow_cameras_to_capture_their_own_display:
            to_add = list_difference_update(to_add, imfc.get_family())
        imfc.camera.capture_mobjects(to_add, **kwargs)
    super().capture_mobjects(mobjects, **kwargs)

</t>
<t tx="ekr.20250122151620.634">def get_mobjects_indicating_movement(self):
    """Returns all mobjects whose movement implies that the camera
    should think of all other mobjects on the screen as moving

    Returns
    -------
    list
    """
    return [self.frame] + [
        imfc.camera.frame for imfc in self.image_mobjects_from_cameras
    ]
</t>
<t tx="ekr.20250122151620.635">"""A camera that can be positioned and oriented in three-dimensional space."""

from __future__ import annotations

__all__ = ["ThreeDCamera"]


from typing import Callable

import numpy as np

from manim.mobject.mobject import Mobject
from manim.mobject.three_d.three_d_utils import (
    get_3d_vmob_end_corner,
    get_3d_vmob_end_corner_unit_normal,
    get_3d_vmob_start_corner,
    get_3d_vmob_start_corner_unit_normal,
)
from manim.mobject.value_tracker import ValueTracker

from .. import config
from ..camera.camera import Camera
from ..constants import *
from ..mobject.types.point_cloud_mobject import Point
from ..utils.color import get_shaded_rgb
from ..utils.family import extract_mobject_family_members
from ..utils.space_ops import rotation_about_z, rotation_matrix


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.636">class ThreeDCamera(Camera):
    @others
</t>
<t tx="ekr.20250122151620.637">def __init__(
    self,
    focal_distance=20.0,
    shading_factor=0.2,
    default_distance=5.0,
    light_source_start_point=9 * DOWN + 7 * LEFT + 10 * OUT,
    should_apply_shading=True,
    exponential_projection=False,
    phi=0,
    theta=-90 * DEGREES,
    gamma=0,
    zoom=1,
    **kwargs,
):
    """Initializes the ThreeDCamera

    Parameters
    ----------
    *kwargs
        Any keyword argument of Camera.
    """
    self._frame_center = Point(kwargs.get("frame_center", ORIGIN), stroke_width=0)
    super().__init__(**kwargs)
    self.focal_distance = focal_distance
    self.phi = phi
    self.theta = theta
    self.gamma = gamma
    self.zoom = zoom
    self.shading_factor = shading_factor
    self.default_distance = default_distance
    self.light_source_start_point = light_source_start_point
    self.light_source = Point(self.light_source_start_point)
    self.should_apply_shading = should_apply_shading
    self.exponential_projection = exponential_projection
    self.max_allowable_norm = 3 * config["frame_width"]
    self.phi_tracker = ValueTracker(self.phi)
    self.theta_tracker = ValueTracker(self.theta)
    self.focal_distance_tracker = ValueTracker(self.focal_distance)
    self.gamma_tracker = ValueTracker(self.gamma)
    self.zoom_tracker = ValueTracker(self.zoom)
    self.fixed_orientation_mobjects = {}
    self.fixed_in_frame_mobjects = set()
    self.reset_rotation_matrix()

</t>
<t tx="ekr.20250122151620.638">@property
def frame_center(self):
    return self._frame_center.points[0]

</t>
<t tx="ekr.20250122151620.639">@frame_center.setter
def frame_center(self, point):
    self._frame_center.move_to(point)

</t>
<t tx="ekr.20250122151620.64">@notify_outdated_version.setter
def notify_outdated_version(self, value: bool) -&gt; None:
    self._set_boolean("notify_outdated_version", value)

</t>
<t tx="ekr.20250122151620.640">def capture_mobjects(self, mobjects, **kwargs):
    self.reset_rotation_matrix()
    super().capture_mobjects(mobjects, **kwargs)

</t>
<t tx="ekr.20250122151620.641">def get_value_trackers(self):
    """A list of :class:`ValueTrackers &lt;.ValueTracker&gt;` of phi, theta, focal_distance,
    gamma and zoom.

    Returns
    -------
    list
        list of ValueTracker objects
    """
    return [
        self.phi_tracker,
        self.theta_tracker,
        self.focal_distance_tracker,
        self.gamma_tracker,
        self.zoom_tracker,
    ]

</t>
<t tx="ekr.20250122151620.642">def modified_rgbas(self, vmobject, rgbas):
    if not self.should_apply_shading:
        return rgbas
    if vmobject.shade_in_3d and (vmobject.get_num_points() &gt; 0):
        light_source_point = self.light_source.points[0]
        if len(rgbas) &lt; 2:
            shaded_rgbas = rgbas.repeat(2, axis=0)
        else:
            shaded_rgbas = np.array(rgbas[:2])
        shaded_rgbas[0, :3] = get_shaded_rgb(
            shaded_rgbas[0, :3],
            get_3d_vmob_start_corner(vmobject),
            get_3d_vmob_start_corner_unit_normal(vmobject),
            light_source_point,
        )
        shaded_rgbas[1, :3] = get_shaded_rgb(
            shaded_rgbas[1, :3],
            get_3d_vmob_end_corner(vmobject),
            get_3d_vmob_end_corner_unit_normal(vmobject),
            light_source_point,
        )
        return shaded_rgbas
    return rgbas

</t>
<t tx="ekr.20250122151620.643">def get_stroke_rgbas(
    self,
    vmobject,
    background=False,
):  # NOTE : DocStrings From parent
    return self.modified_rgbas(vmobject, vmobject.get_stroke_rgbas(background))

</t>
<t tx="ekr.20250122151620.644">def get_fill_rgbas(self, vmobject):  # NOTE : DocStrings From parent
    return self.modified_rgbas(vmobject, vmobject.get_fill_rgbas())

</t>
<t tx="ekr.20250122151620.645">def get_mobjects_to_display(self, *args, **kwargs):  # NOTE : DocStrings From parent
    mobjects = super().get_mobjects_to_display(*args, **kwargs)
    rot_matrix = self.get_rotation_matrix()

    def z_key(mob):
        if not (hasattr(mob, "shade_in_3d") and mob.shade_in_3d):
            return np.inf
        # Assign a number to a three dimensional mobjects
        # based on how close it is to the camera
        return np.dot(mob.get_z_index_reference_point(), rot_matrix.T)[2]

    return sorted(mobjects, key=z_key)

</t>
<t tx="ekr.20250122151620.646">def get_phi(self):
    """Returns the Polar angle (the angle off Z_AXIS) phi.

    Returns
    -------
    float
        The Polar angle in radians.
    """
    return self.phi_tracker.get_value()

</t>
<t tx="ekr.20250122151620.647">def get_theta(self):
    """Returns the Azimuthal i.e the angle that spins the camera around the Z_AXIS.

    Returns
    -------
    float
        The Azimuthal angle in radians.
    """
    return self.theta_tracker.get_value()

</t>
<t tx="ekr.20250122151620.648">def get_focal_distance(self):
    """Returns focal_distance of the Camera.

    Returns
    -------
    float
        The focal_distance of the Camera in MUnits.
    """
    return self.focal_distance_tracker.get_value()

</t>
<t tx="ekr.20250122151620.649">def get_gamma(self):
    """Returns the rotation of the camera about the vector from the ORIGIN to the Camera.

    Returns
    -------
    float
        The angle of rotation of the camera about the vector
        from the ORIGIN to the Camera in radians
    """
    return self.gamma_tracker.get_value()

</t>
<t tx="ekr.20250122151620.65">@property
def write_to_movie(self) -&gt; bool:
    """Whether to render the scene to a movie file (-w)."""
    return self._d["write_to_movie"]

</t>
<t tx="ekr.20250122151620.650">def get_zoom(self):
    """Returns the zoom amount of the camera.

    Returns
    -------
    float
        The zoom amount of the camera.
    """
    return self.zoom_tracker.get_value()

</t>
<t tx="ekr.20250122151620.651">def set_phi(self, value: float):
    """Sets the polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.

    Parameters
    ----------
    value
        The new value of the polar angle in radians.
    """
    self.phi_tracker.set_value(value)

</t>
<t tx="ekr.20250122151620.652">def set_theta(self, value: float):
    """Sets the azimuthal angle i.e the angle that spins the camera around Z_AXIS in radians.

    Parameters
    ----------
    value
        The new value of the azimuthal angle in radians.
    """
    self.theta_tracker.set_value(value)

</t>
<t tx="ekr.20250122151620.653">def set_focal_distance(self, value: float):
    """Sets the focal_distance of the Camera.

    Parameters
    ----------
    value
        The focal_distance of the Camera.
    """
    self.focal_distance_tracker.set_value(value)

</t>
<t tx="ekr.20250122151620.654">def set_gamma(self, value: float):
    """Sets the angle of rotation of the camera about the vector from the ORIGIN to the Camera.

    Parameters
    ----------
    value
        The new angle of rotation of the camera.
    """
    self.gamma_tracker.set_value(value)

</t>
<t tx="ekr.20250122151620.655">def set_zoom(self, value: float):
    """Sets the zoom amount of the camera.

    Parameters
    ----------
    value
        The zoom amount of the camera.
    """
    self.zoom_tracker.set_value(value)

</t>
<t tx="ekr.20250122151620.656">def reset_rotation_matrix(self):
    """Sets the value of self.rotation_matrix to
    the matrix corresponding to the current position of the camera
    """
    self.rotation_matrix = self.generate_rotation_matrix()

</t>
<t tx="ekr.20250122151620.657">def get_rotation_matrix(self):
    """Returns the matrix corresponding to the current position of the camera.

    Returns
    -------
    np.array
        The matrix corresponding to the current position of the camera.
    """
    return self.rotation_matrix

</t>
<t tx="ekr.20250122151620.658">def generate_rotation_matrix(self):
    """Generates a rotation matrix based off the current position of the camera.

    Returns
    -------
    np.array
        The matrix corresponding to the current position of the camera.
    """
    phi = self.get_phi()
    theta = self.get_theta()
    gamma = self.get_gamma()
    matrices = [
        rotation_about_z(-theta - 90 * DEGREES),
        rotation_matrix(-phi, RIGHT),
        rotation_about_z(gamma),
    ]
    result = np.identity(3)
    for matrix in matrices:
        result = np.dot(matrix, result)
    return result

</t>
<t tx="ekr.20250122151620.659">def project_points(self, points: np.ndarray | list):
    """Applies the current rotation_matrix as a projection
    matrix to the passed array of points.

    Parameters
    ----------
    points
        The list of points to project.

    Returns
    -------
    np.array
        The points after projecting.
    """
    frame_center = self.frame_center
    focal_distance = self.get_focal_distance()
    zoom = self.get_zoom()
    rot_matrix = self.get_rotation_matrix()

    points = points - frame_center
    points = np.dot(points, rot_matrix.T)
    zs = points[:, 2]
    for i in 0, 1:
        if self.exponential_projection:
            # Proper projection would involve multiplying
            # x and y by d / (d-z).  But for points with high
            # z value that causes weird artifacts, and applying
            # the exponential helps smooth it out.
            factor = np.exp(zs / focal_distance)
            lt0 = zs &lt; 0
            factor[lt0] = focal_distance / (focal_distance - zs[lt0])
        else:
            factor = focal_distance / (focal_distance - zs)
            factor[(focal_distance - zs) &lt; 0] = 10**6
        points[:, i] *= factor * zoom
    return points

</t>
<t tx="ekr.20250122151620.66">@write_to_movie.setter
def write_to_movie(self, value: bool) -&gt; None:
    self._set_boolean("write_to_movie", value)

</t>
<t tx="ekr.20250122151620.660">def project_point(self, point: list | np.ndarray):
    """Applies the current rotation_matrix as a projection
    matrix to the passed point.

    Parameters
    ----------
    point
        The point to project.

    Returns
    -------
    np.array
        The point after projection.
    """
    return self.project_points(point.reshape((1, 3)))[0, :]

</t>
<t tx="ekr.20250122151620.661">def transform_points_pre_display(
    self,
    mobject,
    points,
):  # TODO: Write Docstrings for this Method.
    points = super().transform_points_pre_display(mobject, points)
    fixed_orientation = mobject in self.fixed_orientation_mobjects
    fixed_in_frame = mobject in self.fixed_in_frame_mobjects

    if fixed_in_frame:
        return points
    if fixed_orientation:
        center_func = self.fixed_orientation_mobjects[mobject]
        center = center_func()
        new_center = self.project_point(center)
        return points + (new_center - center)
    else:
        return self.project_points(points)

</t>
<t tx="ekr.20250122151620.662">def add_fixed_orientation_mobjects(
    self,
    *mobjects: Mobject,
    use_static_center_func: bool = False,
    center_func: Callable[[], np.ndarray] | None = None,
):
    """This method allows the mobject to have a fixed orientation,
    even when the camera moves around.
    E.G If it was passed through this method, facing the camera, it
    will continue to face the camera even as the camera moves.
    Highly useful when adding labels to graphs and the like.

    Parameters
    ----------
    *mobjects
        The mobject whose orientation must be fixed.
    use_static_center_func
        Whether or not to use the function that takes the mobject's
        center as centerpoint, by default False
    center_func
        The function which returns the centerpoint
        with respect to which the mobject will be oriented, by default None
    """

    # This prevents the computation of mobject.get_center
    # every single time a projection happens
    def get_static_center_func(mobject):
        point = mobject.get_center()
        return lambda: point

    for mobject in mobjects:
        if center_func:
            func = center_func
        elif use_static_center_func:
            func = get_static_center_func(mobject)
        else:
            func = mobject.get_center
        for submob in mobject.get_family():
            self.fixed_orientation_mobjects[submob] = func

</t>
<t tx="ekr.20250122151620.663">def add_fixed_in_frame_mobjects(self, *mobjects: Mobject):
    """This method allows the mobject to have a fixed position,
    even when the camera moves around.
    E.G If it was passed through this method, at the top of the frame, it
    will continue to be displayed at the top of the frame.

    Highly useful when displaying Titles or formulae or the like.

    Parameters
    ----------
    **mobjects
        The mobject to fix in frame.
    """
    for mobject in extract_mobject_family_members(mobjects):
        self.fixed_in_frame_mobjects.add(mobject)

</t>
<t tx="ekr.20250122151620.664">def remove_fixed_orientation_mobjects(self, *mobjects: Mobject):
    """If a mobject was fixed in its orientation by passing it through
    :meth:`.add_fixed_orientation_mobjects`, then this undoes that fixing.
    The Mobject will no longer have a fixed orientation.

    Parameters
    ----------
    mobjects
        The mobjects whose orientation need not be fixed any longer.
    """
    for mobject in extract_mobject_family_members(mobjects):
        if mobject in self.fixed_orientation_mobjects:
            del self.fixed_orientation_mobjects[mobject]

</t>
<t tx="ekr.20250122151620.665">def remove_fixed_in_frame_mobjects(self, *mobjects: Mobject):
    """If a mobject was fixed in frame by passing it through
    :meth:`.add_fixed_in_frame_mobjects`, then this undoes that fixing.
    The Mobject will no longer be fixed in frame.

    Parameters
    ----------
    mobjects
        The mobjects which need not be fixed in frame any longer.
    """
    for mobject in extract_mobject_family_members(mobjects):
        if mobject in self.fixed_in_frame_mobjects:
            self.fixed_in_frame_mobjects.remove(mobject)
</t>
<t tx="ekr.20250122151620.666"></t>
<t tx="ekr.20250122151620.667">"""The Manim CLI, and the available commands for ``manim``.

This page is a work in progress. Please run ``manim`` or ``manim --help`` in
your terminal to find more information on the following commands.

Available commands
------------------

.. autosummary::
   :toctree: ../reference

   cfg
   checkhealth
   init
   plugins
   render
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.668">"""``DefaultGroup`` allows a subcommand to act as the main command.

In particular, this class is what allows ``manim`` to act as ``manim render``.

.. note::
    This is a vendored version of https://github.com/click-contrib/click-default-group/
    under the BSD 3-Clause "New" or "Revised" License.

    This library isn't used as a dependency, as we need to inherit from
    :class:`cloup.Group` instead of :class:`click.Group`.
"""

from __future__ import annotations

import warnings
from typing import TYPE_CHECKING, Any, Callable

import cloup

from manim.utils.deprecation import deprecated

__all__ = ["DefaultGroup"]

if TYPE_CHECKING:
    from click import Command, Context


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.669">class DefaultGroup(cloup.Group):
    """Invokes a subcommand marked with ``default=True`` if any subcommand is not
    chosen.

    Parameters
    ----------
    *args
        Positional arguments to forward to :class:`cloup.Group`.
    **kwargs
        Keyword arguments to forward to :class:`cloup.Group`. The keyword
        ``ignore_unknown_options`` must be set to ``False``.

    Attributes
    ----------
    default_cmd_name : str | None
        The name of the default command, if specified through the ``default``
        keyword argument. Otherwise, this is set to ``None``.
    default_if_no_args : bool
        Whether to include or not the default command, if no command arguments
        are supplied. This can be specified through the ``default_if_no_args``
        keyword argument. Default is ``False``.
    """

    @others
</t>
<t tx="ekr.20250122151620.67">@property
def save_last_frame(self) -&gt; bool:
    """Whether to save the last frame of the scene as an image file (-s)."""
    return self._d["save_last_frame"]

</t>
<t tx="ekr.20250122151620.670">def __init__(self, *args: Any, **kwargs: Any):
    # To resolve as the default command.
    if not kwargs.get("ignore_unknown_options", True):
        raise ValueError("Default group accepts unknown options")
    self.ignore_unknown_options = True
    self.default_cmd_name: str | None = kwargs.pop("default", None)
    self.default_if_no_args: bool = kwargs.pop("default_if_no_args", False)
    super().__init__(*args, **kwargs)

</t>
<t tx="ekr.20250122151620.671">def set_default_command(self, command: Command) -&gt; None:
    """Sets a command function as the default command.

    Parameters
    ----------
    command
        The command to set as default.
    """
    cmd_name = command.name
    self.add_command(command)
    self.default_cmd_name = cmd_name

</t>
<t tx="ekr.20250122151620.672">def parse_args(self, ctx: Context, args: list[str]) -&gt; list[str]:
    """Parses the list of ``args`` by forwarding it to
    :meth:`cloup.Group.parse_args`. Before doing so, if
    :attr:`default_if_no_args` is set to ``True`` and ``args`` is empty,
    this function appends to it the name of the default command specified
    by :attr:`default_cmd_name`.

    Parameters
    ----------
    ctx
        The Click context.
    args
        A list of arguments. If it's empty and :attr:`default_if_no_args`
        is ``True``, append the name of the default command to it.

    Returns
    -------
    list[str]
        The parsed arguments.
    """
    if not args and self.default_if_no_args and self.default_cmd_name:
        args.insert(0, self.default_cmd_name)
    parsed_args: list[str] = super().parse_args(ctx, args)
    return parsed_args

</t>
<t tx="ekr.20250122151620.673">def get_command(self, ctx: Context, cmd_name: str) -&gt; Command | None:
    """Get a command function by its name, by forwarding the arguments to
    :meth:`cloup.Group.get_command`. If ``cmd_name`` does not match any of
    the command names in :attr:`commands`, attempt to get the default command
    instead.

    Parameters
    ----------
    ctx
        The Click context.
    cmd_name
        The name of the command to get.

    Returns
    -------
    :class:`click.Command` | None
        The command, if found. Otherwise, ``None``.
    """
    if cmd_name not in self.commands and self.default_cmd_name:
        # No command name matched.
        ctx.meta["arg0"] = cmd_name
        cmd_name = self.default_cmd_name
    return super().get_command(ctx, cmd_name)

</t>
<t tx="ekr.20250122151620.674">def resolve_command(
    self, ctx: Context, args: list[str]
) -&gt; tuple[str | None, Command | None, list[str]]:
    """Given a list of ``args`` given by a CLI, find a command which
    matches the first element, and return its name (``cmd_name``), the
    command function itself (``cmd``) and the rest of the arguments which
    shall be passed to the function (``cmd_args``). If not found, return
    ``None``, ``None`` and the rest of the arguments.

    After resolving the command, if the Click context given by ``ctx``
    contains an ``arg0`` attribute in its :attr:`click.Context.meta`
    dictionary, insert it as the first element of the returned
    ``cmd_args``.

    Parameters
    ----------
    ctx
        The Click context.
    cmd_name
        The name of the command to get.

    Returns
    -------
    cmd_name : str | None
        The command name, if found. Otherwise, ``None``.
    cmd : :class:`click.Command` | None
        The command, if found. Otherwise, ``None``.
    cmd_args : list[str]
        The rest of the arguments to be passed to ``cmd``.
    """
    cmd_name, cmd, args = super().resolve_command(ctx, args)
    if "arg0" in ctx.meta:
        args.insert(0, ctx.meta["arg0"])
        if cmd is not None:
            cmd_name = cmd.name
    return cmd_name, cmd, args

</t>
<t tx="ekr.20250122151620.675">@deprecated
def command(
    self, *args: Any, **kwargs: Any
) -&gt; Callable[[Callable[..., object]], Command]:
    """Return a decorator which converts any function into the default
    subcommand for this :class:`DefaultGroup`.

    .. warning::
        This method is deprecated. Use the ``default`` parameter of
        :class:`DefaultGroup` or :meth:`set_default_command` instead.

    Parameters
    ----------
    *args
        Positional arguments to pass to :meth:`cloup.Group.command`.
    **kwargs
        Keyword arguments to pass to :meth:`cloup.Group.command`.

    Returns
    -------
    Callable[[Callable[..., object]], click.Command]
        A decorator which transforms its input into this
        :class:`DefaultGroup`'s default subcommand.
    """
    default = kwargs.pop("default", False)
    decorator: Callable[[Callable[..., object]], Command] = super().command(
        *args, **kwargs
    )
    if not default:
        return decorator
    warnings.warn(
        "Use default param of DefaultGroup or set_default_command() instead",
        DeprecationWarning,
        stacklevel=1,
    )

    def _decorator(f: Callable) -&gt; Command:
        cmd = decorator(f)
        self.set_default_command(cmd)
        return cmd

    return _decorator
</t>
<t tx="ekr.20250122151620.676"></t>
<t tx="ekr.20250122151620.677"></t>
<t tx="ekr.20250122151620.678">"""Manim's cfg subcommand.

Manim's cfg subcommand is accessed in the command-line interface via ``manim
cfg``. Here you can specify options, subcommands, and subgroups for the cfg
group.

"""

from __future__ import annotations

import contextlib
from ast import literal_eval
from pathlib import Path
from typing import Any, cast

import cloup
from rich.errors import StyleSyntaxError
from rich.style import Style

from manim._config import cli_ctx_settings, console
from manim._config.utils import config_file_paths, make_config_parser
from manim.constants import EPILOG
from manim.utils.file_ops import guarantee_existence, open_file

RICH_COLOUR_INSTRUCTIONS: str = """
[red]The default colour is used by the input statement.
If left empty, the default colour will be used.[/red]
[magenta] For a full list of styles, visit[/magenta] [green]https://rich.readthedocs.io/en/latest/style.html[/green]
"""
RICH_NON_STYLE_ENTRIES: list[str] = ["log.width", "log.height", "log.timestamps"]

__all__ = [
    "value_from_string",
    "value_from_string",
    "is_valid_style",
    "replace_keys",
    "cfg",
    "write",
    "show",
    "export",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.679">def value_from_string(value: str) -&gt; str | int | bool:
    """Extract the literal of proper datatype from a ``value`` string.

    Parameters
    ----------
    value
        The value to check get the literal from.

    Returns
    -------
    :class:`str` | :class:`int` | :class:`bool`
        The literal of appropriate datatype.
    """
    with contextlib.suppress(SyntaxError, ValueError):
        value = literal_eval(value)
    return value


</t>
<t tx="ekr.20250122151620.68">@save_last_frame.setter
def save_last_frame(self, value: bool) -&gt; None:
    self._set_boolean("save_last_frame", value)

</t>
<t tx="ekr.20250122151620.680">def _is_expected_datatype(
    value: str, expected: str, validate_style: bool = False
) -&gt; bool:
    """Check whether the literal from ``value`` is the same datatype as the
    literal from ``expected``. If ``validate_style`` is ``True``, also check if
    the style given by ``value`` is valid, according to ``rich``.

    Parameters
    ----------
    value
        The string of the value to check, obtained from reading the user input.
    expected
        The string of the literal datatype which must be matched by ``value``.
        This is obtained from reading the ``cfg`` file.
    validate_style
        Whether or not to confirm if ``value`` is a valid style, according to
        ``rich``. Default is ``False``.

    Returns
    -------
    :class:`bool`
        Whether or not the literal from ``value`` matches the datatype of the
        literal from ``expected``.
    """
    value_literal = value_from_string(value)
    ExpectedLiteralType = type(value_from_string(expected))

    return isinstance(value_literal, ExpectedLiteralType) and (
        (isinstance(value_literal, str) and is_valid_style(value_literal))
        if validate_style
        else True
    )


</t>
<t tx="ekr.20250122151620.681">def is_valid_style(style: str) -&gt; bool:
    """Checks whether the entered color style is valid, according to ``rich``.

    Parameters
    ----------
    style
        The style to check whether it is valid.

    Returns
    -------
    :class:`bool`
        Whether the color style is valid or not, according to ``rich``.
    """
    try:
        Style.parse(style)
        return True
    except StyleSyntaxError:
        return False


</t>
<t tx="ekr.20250122151620.682">def replace_keys(default: dict[str, Any]) -&gt; dict[str, Any]:
    """Replace ``_`` with ``.`` and vice versa in a dictionary's keys for
    ``rich``.

    Parameters
    ----------
    default
        The dictionary whose keys will be checked and replaced.

    Returns
    -------
    :class:`dict`
        The dictionary whose keys are modified by replacing ``_`` with ``.``
        and vice versa.
    """
    for key in default:
        if "_" in key:
            temp = default[key]
            del default[key]
            key = key.replace("_", ".")
            default[key] = temp
        else:
            temp = default[key]
            del default[key]
            key = key.replace(".", "_")
            default[key] = temp
    return default


</t>
<t tx="ekr.20250122151620.683">@cloup.group(
    context_settings=cli_ctx_settings,
    invoke_without_command=True,
    no_args_is_help=True,
    epilog=EPILOG,
    help="Manages Manim configuration files.",
)
@cloup.pass_context
def cfg(ctx: cloup.Context) -&gt; None:
    """Responsible for the cfg subcommand."""
    pass


</t>
<t tx="ekr.20250122151620.684">@cfg.command(context_settings=cli_ctx_settings, no_args_is_help=True)
@cloup.option(
    "-l",
    "--level",
    type=cloup.Choice(["user", "cwd"], case_sensitive=False),
    default="cwd",
    help="Specify if this config is for user or the working directory.",
)
@cloup.option("-o", "--open", "openfile", is_flag=True)
def write(level: str | None = None, openfile: bool = False) -&gt; None:
    config_paths = config_file_paths()
    console.print(
        "[yellow bold]Manim Configuration File Writer[/yellow bold]",
        justify="center",
    )

    USER_CONFIG_MSG = f"""A configuration file at [yellow]{config_paths[1]}[/yellow] has been created with your required changes.
This will be used when running the manim command. If you want to override this config,
you will have to create a manim.cfg in the local directory, where you want those changes to be overridden."""

    CWD_CONFIG_MSG = f"""A configuration file at [yellow]{config_paths[2]}[/yellow] has been created.
To save your config please save that file and place it in your current working directory, from where you run the manim command."""

    parser = make_config_parser()
    if not openfile:
        action = "save this as"
        for category in parser:
            console.print(f"{category}", style="bold green underline")
            default = cast(dict[str, Any], parser[category])
            if category == "logger":
                console.print(RICH_COLOUR_INSTRUCTIONS)
                default = replace_keys(default)

            for key in default:
                # All the cfg entries for logger need to be validated as styles,
                # as long as they aren't setting the log width or height etc
                if category == "logger" and key not in RICH_NON_STYLE_ENTRIES:
                    desc = "style"
                    style = default[key]
                else:
                    desc = "value"
                    style = None

                console.print(f"Enter the {desc} for {key} ", style=style, end="")
                if category != "logger" or key in RICH_NON_STYLE_ENTRIES:
                    defaultval = (
                        repr(default[key])
                        if isinstance(value_from_string(default[key]), str)
                        else default[key]
                    )
                    console.print(f"(defaults to {defaultval}) :", end="")
                try:
                    temp = input()
                except EOFError:
                    raise Exception(
                        """Not enough values in input.
You may have added a new entry to default.cfg, in which case you will have to
modify write_cfg_subcmd_input to account for it.""",
                    ) from None
                if temp:
                    while temp and not _is_expected_datatype(
                        temp,
                        default[key],
                        bool(style),
                    ):
                        console.print(
                            f"[red bold]Invalid {desc}. Try again.[/red bold]",
                        )
                        console.print(
                            f"Enter the {desc} for {key}:",
                            style=style,
                            end="",
                        )
                        temp = input()

                    default[key] = temp.replace("%", "%%")

            default = replace_keys(default) if category == "logger" else default

            parser[category] = {
                i: v.replace("%", "%%") for i, v in dict(default).items()
            }

    else:
        action = "open"

    if level is None:
        console.print(
            f"Do you want to {action} the default config for this User?(y/n)[[n]]",
            style="dim purple",
            end="",
        )
        action_to_userpath = input()
    else:
        action_to_userpath = ""

    if action_to_userpath.lower() == "y" or level == "user":
        cfg_file_path = config_paths[1]
        guarantee_existence(config_paths[1].parents[0])
        console.print(USER_CONFIG_MSG)
    else:
        cfg_file_path = config_paths[2]
        guarantee_existence(config_paths[2].parents[0])
        console.print(CWD_CONFIG_MSG)
    with cfg_file_path.open("w") as fp:
        parser.write(fp)
    if openfile:
        open_file(cfg_file_path)


</t>
<t tx="ekr.20250122151620.685">@cfg.command(context_settings=cli_ctx_settings)
def show() -&gt; None:
    parser = make_config_parser()
    rich_non_style_entries = [a.replace(".", "_") for a in RICH_NON_STYLE_ENTRIES]
    for category in parser:
        console.print(f"{category}", style="bold green underline")
        for entry in parser[category]:
            if category == "logger" and entry not in rich_non_style_entries:
                console.print(f"{entry} :", end="")
                console.print(
                    f" {parser[category][entry]}",
                    style=parser[category][entry],
                )
            else:
                console.print(f"{entry} : {parser[category][entry]}")
        console.print("\n")


</t>
<t tx="ekr.20250122151620.686">@cfg.command(context_settings=cli_ctx_settings)
@cloup.option("-d", "--directory", default=Path.cwd())
@cloup.pass_context
def export(ctx: cloup.Context, directory: str) -&gt; None:
    directory_path = Path(directory)
    if directory_path.absolute == Path.cwd().absolute:
        console.print(
            """You are reading the config from the same directory you are exporting to.
This means that the exported config will overwrite the config for this directory.
Are you sure you want to continue? (y/n)""",
            style="red bold",
            end="",
        )
        proceed = input().lower() == "y"
    else:
        proceed = True
    if proceed:
        if not directory_path.is_dir():
            console.print(f"Creating folder: {directory}.", style="red bold")
            directory_path.mkdir(parents=True)

        ctx.invoke(write)
        from_path = Path.cwd() / "manim.cfg"
        to_path = directory_path / "manim.cfg"

        console.print(f"Exported final Config at {from_path} to {to_path}.")
    else:
        console.print("Aborted...", style="red bold")
</t>
<t tx="ekr.20250122151620.687"></t>
<t tx="ekr.20250122151620.688"></t>
<t tx="ekr.20250122151620.689">"""Auxiliary module for the checkhealth subcommand, contains
the actual check implementations.
"""

from __future__ import annotations

import os
import shutil
from typing import Callable, Protocol, cast

__all__ = ["HEALTH_CHECKS"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.69">@property
def write_all(self) -&gt; bool:
    """Whether to render all scenes in the input file (-a)."""
    return self._d["write_all"]

</t>
<t tx="ekr.20250122151620.690">class HealthCheckFunction(Protocol):
    @others
</t>
<t tx="ekr.20250122151620.691">HEALTH_CHECKS: list[HealthCheckFunction] = []


def healthcheck(
    description: str,
    recommendation: str,
    skip_on_failed: list[HealthCheckFunction | str] | None = None,
    post_fail_fix_hook: Callable[..., object] | None = None,
) -&gt; Callable[[Callable[[], bool]], HealthCheckFunction]:
    """Decorator used for declaring health checks.

    This decorator attaches some data to a function, which is then added to a
    a list containing all checks.

    Parameters
    ----------
    description
        A brief description of this check, displayed when the ``checkhealth``
        subcommand is run.
    recommendation
        Help text which is displayed in case the check fails.
    skip_on_failed
        A list of check functions which, if they fail, cause the current check
        to be skipped.
    post_fail_fix_hook
        A function that is meant to (interactively) help to fix the detected
        problem, if possible. This is only called upon explicit confirmation of
        the user.

    Returns
    -------
    Callable[Callable[[], bool], :class:`HealthCheckFunction`]
        A decorator which converts a function into a health check function, as
        required by the ``checkhealth`` subcommand.
    """
    new_skip_on_failed: list[str]
    if skip_on_failed is None:
        new_skip_on_failed = []
    else:
        new_skip_on_failed = [
            skip.__name__ if callable(skip) else skip for skip in skip_on_failed
        ]

    def wrapper(func: Callable[[], bool]) -&gt; HealthCheckFunction:
        health_func = cast(HealthCheckFunction, func)
        health_func.description = description
        health_func.recommendation = recommendation
        health_func.skip_on_failed = new_skip_on_failed
        health_func.post_fail_fix_hook = post_fail_fix_hook
        HEALTH_CHECKS.append(health_func)
        return health_func

    return wrapper


</t>
<t tx="ekr.20250122151620.692">@healthcheck(
    description="Checking whether manim is on your PATH",
    recommendation=(
        "The command &lt;manim&gt; is currently not on your system's PATH.\n\n"
        "You can work around this by calling the manim module directly "
        "via &lt;python -m manim&gt; instead of just &lt;manim&gt;.\n\n"
        "To fix the PATH issue properly: "
        "Usually, the Python package installer pip issues a warning "
        "during the installation which contains more information. "
        "Consider reinstalling manim via &lt;pip uninstall manim&gt; "
        "followed by &lt;pip install manim&gt; to see the warning again, "
        "then consult the internet on how to modify your system's "
        "PATH variable."
    ),
)
def is_manim_on_path() -&gt; bool:
    """Check whether ``manim`` is in ``PATH``.

    Returns
    -------
    :class:`bool`
        Whether ``manim`` is in ``PATH`` or not.
    """
    path_to_manim = shutil.which("manim")
    return path_to_manim is not None


</t>
<t tx="ekr.20250122151620.693">@healthcheck(
    description="Checking whether the executable belongs to manim",
    recommendation=(
        "The command &lt;manim&gt; does not belong to your installed version "
        "of this library, it likely belongs to manimgl / manimlib.\n\n"
        "Run manim via &lt;python -m manim&gt; or via &lt;manimce&gt;, or uninstall "
        "and reinstall manim via &lt;pip install --upgrade "
        "--force-reinstall manim&gt; to fix this."
    ),
    skip_on_failed=[is_manim_on_path],
)
def is_manim_executable_associated_to_this_library() -&gt; bool:
    """Check whether the ``manim`` executable in ``PATH`` is associated to this
    library. To verify this, the executable should look like this:

    .. code-block:: python

        #!&lt;MANIM_PATH&gt;/.../python
        import sys
        from manim.__main__ import main

        if __name__ == "__main__":
            sys.exit(main())


    Returns
    -------
    :class:`bool`
        Whether the ``manim`` executable in ``PATH`` is associated to this
        library or not.
    """
    path_to_manim = shutil.which("manim")
    assert path_to_manim is not None
    with open(path_to_manim, "rb") as manim_binary:
        manim_exec = manim_binary.read()

    # first condition below corresponds to the executable being
    # some sort of python script. second condition happens when
    # the executable is actually a Windows batch file.
    return b"manim.__main__" in manim_exec or b'"%~dp0\\manim"' in manim_exec


</t>
<t tx="ekr.20250122151620.694">@healthcheck(
    description="Checking whether latex is available",
    recommendation=(
        "Manim cannot find &lt;latex&gt; on your system's PATH. "
        "You will not be able to use Tex and MathTex mobjects "
        "in your scenes.\n\n"
        "Consult our installation instructions "
        "at https://docs.manim.community/en/stable/installation.html "
        "or search the web for instructions on how to install a "
        "LaTeX distribution on your operating system."
    ),
)
def is_latex_available() -&gt; bool:
    """Check whether ``latex`` is in ``PATH`` and can be executed.

    Returns
    -------
    :class:`bool`
        Whether ``latex`` is in ``PATH`` and can be executed or not.
    """
    path_to_latex = shutil.which("latex")
    return path_to_latex is not None and os.access(path_to_latex, os.X_OK)


</t>
<t tx="ekr.20250122151620.695">@healthcheck(
    description="Checking whether dvisvgm is available",
    recommendation=(
        "Manim could find &lt;latex&gt;, but not &lt;dvisvgm&gt; on your system's "
        "PATH. Make sure your installed LaTeX distribution comes with "
        "dvisvgm and consider installing a larger distribution if it "
        "does not."
    ),
    skip_on_failed=[is_latex_available],
)
def is_dvisvgm_available() -&gt; bool:
    """Check whether ``dvisvgm`` is in ``PATH`` and can be executed.

    Returns
    -------
    :class:`bool`
        Whether ``dvisvgm`` is in ``PATH`` and can be executed or not.
    """
    path_to_dvisvgm = shutil.which("dvisvgm")
    return path_to_dvisvgm is not None and os.access(path_to_dvisvgm, os.X_OK)
</t>
<t tx="ekr.20250122151620.696">description: str
recommendation: str
skip_on_failed: list[str]
post_fail_fix_hook: Callable[..., object] | None
__name__: str

def __call__(self) -&gt; bool: ...


</t>
<t tx="ekr.20250122151620.697">"""A CLI utility helping to diagnose problems with
your Manim installation.

"""

from __future__ import annotations

import sys
import timeit

import click
import cloup

from manim.cli.checkhealth.checks import HEALTH_CHECKS, HealthCheckFunction

__all__ = ["checkhealth"]


@cloup.command(
    context_settings=None,
)
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.698">def checkhealth() -&gt; None:
    @others
            with mn.tempconfig({"preview": True, "disable_caching": True}):
                scene = CheckHealthDemo()
                scene.render()

                click.echo(f"Scene rendered in {scene.execution_time:.2f} seconds.")
</t>
<t tx="ekr.20250122151620.699">"""This subcommand checks whether Manim is installed correctly
and has access to its required (and optional) system dependencies.
"""
click.echo(f"Python executable: {sys.executable}\n")
click.echo("Checking whether your installation of Manim Community is healthy...")
failed_checks: list[HealthCheckFunction] = []

for check in HEALTH_CHECKS:
    click.echo(f"- {check.description} ... ", nl=False)
    if any(
        failed_check.__name__ in check.skip_on_failed
        for failed_check in failed_checks
    ):
        click.secho("SKIPPED", fg="blue")
        continue
    check_result = check()
    if check_result:
        click.secho("PASSED", fg="green")
    else:
        click.secho("FAILED", fg="red")
        failed_checks.append(check)

click.echo()

if failed_checks:
    click.echo(
        "There are problems with your installation, "
        "here are some recommendations to fix them:"
    )
    for ind, failed_check in enumerate(failed_checks):
        click.echo(failed_check.recommendation)
        if ind + 1 &lt; len(failed_checks):
            click.confirm("Continue with next recommendation?")

else:  # no problems detected!
    click.echo("No problems detected, your installation seems healthy!")
    render_test_scene = click.confirm(
        "Would you like to render and preview a test scene?"
    )
    if render_test_scene:
        import manim as mn

        class CheckHealthDemo(mn.Scene):
            @others
</t>
<t tx="ekr.20250122151620.7">@cloup.group(
    context_settings=cli_ctx_settings,
    cls=DefaultGroup,
    default="render",
    no_args_is_help=True,
    help="Animation engine for explanatory math videos.",
    epilog="See 'manim &lt;command&gt;' to read about a specific subcommand.\n\n"
    "Note: the subcommand 'manim render' is called if no other subcommand "
    "is specified. Run 'manim render --help' if you would like to know what the "
    f"'-ql' or '-p' flags do, for example.\n\n{EPILOG}",
)
@cloup.option(
    "--version",
    is_flag=True,
    help="Show version and exit.",
    callback=print_version_and_exit,
    is_eager=True,
    expose_value=False,
)
@click.option(
    "--show-splash/--hide-splash",
    is_flag=True,
    default=True,
    help="Print splash message with version information.",
    callback=show_splash,
    is_eager=True,
    expose_value=False,
)
@cloup.pass_context
def main(ctx: click.Context) -&gt; None:
    """The entry point for Manim.

    Parameters
    ----------
    ctx
        The Click context.
    """
    pass


</t>
<t tx="ekr.20250122151620.70">@write_all.setter
def write_all(self, value: bool) -&gt; None:
    self._set_boolean("write_all", value)

</t>
<t tx="ekr.20250122151620.700">def _inner_construct(self) -&gt; None:
    banner = mn.ManimBanner().shift(mn.UP * 0.5)
    self.play(banner.create())
    self.wait(0.5)
    self.play(banner.expand())
    self.wait(0.5)
    text_left = mn.Text("All systems operational!")
    formula_right = mn.MathTex(r"\oint_{\gamma} f(z)~dz = 0")
    text_tex_group = mn.VGroup(text_left, formula_right)
    text_tex_group.arrange(mn.RIGHT, buff=1).next_to(banner, mn.DOWN)
    self.play(mn.Write(text_tex_group))
    self.wait(0.5)
    self.play(
        mn.FadeOut(banner, shift=mn.UP),
        mn.FadeOut(text_tex_group, shift=mn.DOWN),
    )

</t>
<t tx="ekr.20250122151620.701">def construct(self) -&gt; None:
    self.execution_time = timeit.timeit(self._inner_construct, number=1)

</t>
<t tx="ekr.20250122151620.702"></t>
<t tx="ekr.20250122151620.703"></t>
<t tx="ekr.20250122151620.704">"""Manim's init subcommand.

Manim's init subcommand is accessed in the command-line interface via ``manim
init``. Here you can specify options, subcommands, and subgroups for the init
group.

"""

from __future__ import annotations

import configparser
from pathlib import Path
from typing import Any

import click
import cloup

from manim._config import console
from manim.constants import CONTEXT_SETTINGS, EPILOG, QUALITIES
from manim.utils.file_ops import (
    add_import_statement,
    copy_template_files,
    get_template_names,
    get_template_path,
)

CFG_DEFAULTS = {
    "frame_rate": 30,
    "background_color": "BLACK",
    "background_opacity": 1,
    "scene_names": "Default",
    "resolution": (854, 480),
}

__all__ = ["select_resolution", "update_cfg", "project", "scene"]


@others
init.add_command(project)
init.add_command(scene)
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.705">def select_resolution() -&gt; tuple[int, int]:
    """Prompts input of type click.Choice from user. Presents options from QUALITIES constant.

    Returns
    -------
    tuple[int, int]
        Tuple containing height and width.
    """
    resolution_options: list[tuple[int, int]] = []
    for quality in QUALITIES.items():
        resolution_options.append(
            (quality[1]["pixel_height"], quality[1]["pixel_width"]),
        )
    resolution_options.pop()
    choice = click.prompt(
        "\nSelect resolution:\n",
        type=cloup.Choice([f"{i[0]}p" for i in resolution_options]),
        show_default=False,
        default="480p",
    )
    matches = [res for res in resolution_options if f"{res[0]}p" == choice]
    return matches[0]


</t>
<t tx="ekr.20250122151620.706">def update_cfg(cfg_dict: dict[str, Any], project_cfg_path: Path) -&gt; None:
    """Update the ``manim.cfg`` file after reading it from the specified
    ``project_cfg_path``.

    Parameters
    ----------
    cfg_dict
        Values used to update ``manim.cfg`` which is found in
        ``project_cfg_path``.
    project_cfg_path
        Path of the ``manim.cfg`` file.
    """
    config = configparser.ConfigParser()
    config.read(project_cfg_path)
    cli_config = config["CLI"]
    for key, value in cfg_dict.items():
        if key == "resolution":
            cli_config["pixel_height"] = str(value[0])
            cli_config["pixel_width"] = str(value[1])
        else:
            cli_config[key] = str(value)

    with project_cfg_path.open("w") as conf:
        config.write(conf)


</t>
<t tx="ekr.20250122151620.707">@cloup.command(
    context_settings=CONTEXT_SETTINGS,
    epilog=EPILOG,
)
@cloup.argument("project_name", type=cloup.Path(path_type=Path), required=False)
@cloup.option(
    "-d",
    "--default",
    "default_settings",
    is_flag=True,
    help="Default settings for project creation.",
    nargs=1,
)
def project(default_settings: bool, **kwargs: Any) -&gt; None:
    """Creates a new project.

    PROJECT_NAME is the name of the folder in which the new project will be initialized.
    """
    project_name: Path
    if kwargs["project_name"]:
        project_name = kwargs["project_name"]
    else:
        project_name = click.prompt("Project Name", type=Path)

    # in the future when implementing a full template system. Choices are going to be saved in some sort of config file for templates
    template_name = click.prompt(
        "Template",
        type=click.Choice(get_template_names(), False),
        default="Default",
    )

    if project_name.is_dir():
        console.print(
            f"\nFolder [red]{project_name}[/red] exists. Please type another name\n",
        )
    else:
        project_name.mkdir()
        new_cfg: dict[str, Any] = {}
        new_cfg_path = Path.resolve(project_name / "manim.cfg")

        if not default_settings:
            for key, value in CFG_DEFAULTS.items():
                if key == "scene_names":
                    new_cfg[key] = template_name + "Template"
                elif key == "resolution":
                    new_cfg[key] = select_resolution()
                else:
                    new_cfg[key] = click.prompt(f"\n{key}", default=value)

            console.print("\n", new_cfg)
            if click.confirm("Do you want to continue?", default=True, abort=True):
                copy_template_files(project_name, template_name)
                update_cfg(new_cfg, new_cfg_path)
        else:
            copy_template_files(project_name, template_name)
            update_cfg(CFG_DEFAULTS, new_cfg_path)


</t>
<t tx="ekr.20250122151620.708">@cloup.command(
    context_settings=CONTEXT_SETTINGS,
    no_args_is_help=True,
    epilog=EPILOG,
)
@cloup.argument("scene_name", type=str, required=True)
@cloup.argument("file_name", type=str, required=False)
def scene(**kwargs: Any) -&gt; None:
    """Inserts a SCENE to an existing FILE or creates a new FILE.

    SCENE is the name of the scene that will be inserted.

    FILE is the name of file in which the SCENE will be inserted.
    """
    template_name: str = click.prompt(
        "template",
        type=click.Choice(get_template_names(), False),
        default="Default",
    )
    scene = (get_template_path() / f"{template_name}.mtp").resolve().read_text()
    scene = scene.replace(template_name + "Template", kwargs["scene_name"], 1)

    if kwargs["file_name"]:
        file_name = Path(kwargs["file_name"])

        if file_name.suffix != ".py":
            file_name = file_name.with_suffix(file_name.suffix + ".py")

        if file_name.is_file():
            # file exists so we are going to append new scene to that file
            with file_name.open("a") as f:
                f.write("\n\n\n" + scene)
        else:
            # file does not exist so we create a new file, append the scene and prepend the import statement
            file_name.write_text("\n\n\n" + scene)

            add_import_statement(file_name)
    else:
        # file name is not provided so we assume it is main.py
        # if main.py does not exist we do not continue
        with Path("main.py").open("a") as f:
            f.write("\n\n\n" + scene)


</t>
<t tx="ekr.20250122151620.709">@cloup.group(
    context_settings=CONTEXT_SETTINGS,
    invoke_without_command=True,
    no_args_is_help=True,
    epilog=EPILOG,
    help="Create a new project or insert a new scene.",
)
@cloup.pass_context
def init(ctx: cloup.Context) -&gt; None:
    pass


</t>
<t tx="ekr.20250122151620.71">@property
def save_pngs(self) -&gt; bool:
    """Whether to save all frames in the scene as images files (-g)."""
    return self._d["save_pngs"]

</t>
<t tx="ekr.20250122151620.710"></t>
<t tx="ekr.20250122151620.711"></t>
<t tx="ekr.20250122151620.712">"""Manim's plugin subcommand.

Manim's plugin subcommand is accessed in the command-line interface via ``manim
plugin``. Here you can specify options, subcommands, and subgroups for the plugin
group.

"""

from __future__ import annotations

import cloup

from manim.constants import CONTEXT_SETTINGS, EPILOG
from manim.plugins.plugins_flags import list_plugins

__all__ = ["plugins"]


@cloup.command(
    context_settings=CONTEXT_SETTINGS,
    no_args_is_help=True,
    epilog=EPILOG,
    help="Manages Manim plugins.",
)
@cloup.option(
    "-l",
    "--list",
    "list_available",
    is_flag=True,
    help="List available plugins.",
)
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.713">def plugins(list_available: bool) -&gt; None:
    """Print a list of all available plugins when calling ``manim plugins -l``
    or ``manim plugins --list``.

    Parameters
    ----------
    list_available
        If the ``-l`` or ``-list`` option is passed to ``manim plugins``, this
        parameter will be set to ``True``, which will print a list of all
        available plugins.
    """
    if list_available:
        list_plugins()
</t>
<t tx="ekr.20250122151620.714"></t>
<t tx="ekr.20250122151620.715"></t>
<t tx="ekr.20250122151620.716">"""Manim's default subcommand, render.

Manim's render subcommand is accessed in the command-line interface via
``manim``, but can be more explicitly accessed with ``manim render``. Here you
can specify options, and arguments for the render command.

"""

from __future__ import annotations

import http.client
import json
import sys
import urllib.error
import urllib.request
from argparse import Namespace
from pathlib import Path
from typing import Any, cast

import cloup

from manim import __version__
from manim._config import (
    config,
    console,
    error_console,
    logger,
    tempconfig,
)
from manim.cli.render.ease_of_access_options import ease_of_access_options
from manim.cli.render.global_options import global_options
from manim.cli.render.output_options import output_options
from manim.cli.render.render_options import render_options
from manim.constants import EPILOG, RendererType
from manim.utils.module_ops import scene_classes_from_file

__all__ = ["render"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.717">class ClickArgs(Namespace):
    @others
</t>
<t tx="ekr.20250122151620.718">@cloup.command(
    context_settings=None,
    no_args_is_help=True,
    epilog=EPILOG,
)
@cloup.argument("file", type=cloup.Path(path_type=Path), required=True)
@cloup.argument("scene_names", required=False, nargs=-1)
@global_options
@output_options
@render_options
@ease_of_access_options
def render(**kwargs: Any) -&gt; ClickArgs | dict[str, Any]:
    """Render SCENE(S) from the input FILE.

    FILE is the file path of the script or a config file.

    SCENES is an optional list of scenes in the file.
    """
    if kwargs["save_as_gif"]:
        logger.warning("--save_as_gif is deprecated, please use --format=gif instead!")
        kwargs["format"] = "gif"

    if kwargs["save_pngs"]:
        logger.warning("--save_pngs is deprecated, please use --format=png instead!")
        kwargs["format"] = "png"

    if kwargs["show_in_file_browser"]:
        logger.warning(
            "The short form of show_in_file_browser is deprecated and will be moved to support --format.",
        )

    click_args = ClickArgs(kwargs)
    if kwargs["jupyter"]:
        return click_args

    config.digest_args(click_args)
    file = Path(config.input_file)
    if config.renderer == RendererType.OPENGL:
        from manim.renderer.opengl_renderer import OpenGLRenderer

        try:
            renderer = OpenGLRenderer()
            keep_running = True
            while keep_running:
                for SceneClass in scene_classes_from_file(file):
                    with tempconfig({}):
                        scene = SceneClass(renderer)
                        rerun = scene.render()
                    if rerun or config["write_all"]:
                        renderer.num_plays = 0
                        continue
                    else:
                        keep_running = False
                        break
                if config["write_all"]:
                    keep_running = False

        except Exception:
            error_console.print_exception()
            sys.exit(1)
    else:
        for SceneClass in scene_classes_from_file(file):
            try:
                with tempconfig({}):
                    scene = SceneClass()
                    scene.render()
            except Exception:
                error_console.print_exception()
                sys.exit(1)

    if config.notify_outdated_version:
        manim_info_url = "https://pypi.org/pypi/manim/json"
        warn_prompt = "Cannot check if latest release of manim is installed"

        try:
            with urllib.request.urlopen(
                urllib.request.Request(manim_info_url),
                timeout=10,
            ) as response:
                response = cast(http.client.HTTPResponse, response)
                json_data = json.loads(response.read())
        except urllib.error.HTTPError:
            logger.debug("HTTP Error: %s", warn_prompt)
        except urllib.error.URLError:
            logger.debug("URL Error: %s", warn_prompt)
        except json.JSONDecodeError:
            logger.debug(
                "Error while decoding JSON from %r: %s", manim_info_url, warn_prompt
            )
        except Exception:
            logger.debug("Something went wrong: %s", warn_prompt)
        else:
            stable = json_data["info"]["version"]
            if stable != __version__:
                console.print(
                    f"You are using manim version [red]v{__version__}[/red], but version [green]v{stable}[/green] is available.",
                )
                console.print(
                    "You should consider upgrading via [yellow]pip install -U manim[/yellow]",
                )

    return kwargs
</t>
<t tx="ekr.20250122151620.719">def __init__(self, args: dict[str, Any]) -&gt; None:
    for name in args:
        setattr(self, name, args[name])

</t>
<t tx="ekr.20250122151620.72">@save_pngs.setter
def save_pngs(self, value: bool) -&gt; None:
    self._set_boolean("save_pngs", value)

</t>
<t tx="ekr.20250122151620.720">def _get_kwargs(self) -&gt; list[tuple[str, Any]]:
    return list(self.__dict__.items())

</t>
<t tx="ekr.20250122151620.721">def __eq__(self, other: object) -&gt; bool:
    if not isinstance(other, ClickArgs):
        return NotImplemented
    return vars(self) == vars(other)

</t>
<t tx="ekr.20250122151620.722">def __contains__(self, key: str) -&gt; bool:
    return key in self.__dict__

</t>
<t tx="ekr.20250122151620.723">def __repr__(self) -&gt; str:
    return str(self.__dict__)


</t>
<t tx="ekr.20250122151620.724">from __future__ import annotations

from cloup import Choice, option, option_group

__all__ = ["ease_of_access_options"]

ease_of_access_options = option_group(
    "Ease of access options",
    option(
        "--progress_bar",
        default=None,
        show_default=False,
        type=Choice(
            ["display", "leave", "none"],
            case_sensitive=False,
        ),
        help="Display progress bars and/or keep them displayed.",
    ),
    option(
        "-p",
        "--preview",
        is_flag=True,
        help="Preview the Scene's animation. OpenGL does a live preview in a "
        "popup window. Cairo opens the rendered video file in the system "
        "default media player.",
        default=None,
    ),
    option(
        "-f",
        "--show_in_file_browser",
        is_flag=True,
        help="Show the output file in the file browser.",
        default=None,
    ),
    option(
        "--jupyter",
        is_flag=True,
        help="Using jupyter notebook magic.",
        default=None,
    ),
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.725">from __future__ import annotations

import logging
import re
import sys
from typing import TYPE_CHECKING

from cloup import Choice, option, option_group

if TYPE_CHECKING:
    from click import Context, Option

__all__ = ["global_options"]

logger = logging.getLogger("manim")


@others
global_options = option_group(
    "Global options",
    option(
        "-c",
        "--config_file",
        help="Specify the configuration file to use for render settings.",
        default=None,
    ),
    option(
        "--custom_folders",
        is_flag=True,
        default=None,
        help="Use the folders defined in the [custom_folders] section of the "
        "config file to define the output folder structure.",
    ),
    option(
        "--disable_caching",
        is_flag=True,
        default=None,
        help="Disable the use of the cache (still generates cache files).",
    ),
    option(
        "--flush_cache",
        is_flag=True,
        help="Remove cached partial movie files.",
        default=None,
    ),
    option("--tex_template", help="Specify a custom TeX template file.", default=None),
    option(
        "-v",
        "--verbosity",
        type=Choice(
            ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
            case_sensitive=False,
        ),
        help="Verbosity of CLI output. Changes ffmpeg log level unless 5+.",
        default=None,
    ),
    option(
        "--notify_outdated_version/--silent",
        is_flag=True,
        default=None,
        help="Display warnings for outdated installation.",
    ),
    option(
        "--enable_gui",
        is_flag=True,
        help="Enable GUI interaction.",
        default=None,
    ),
    option(
        "--gui_location",
        default=None,
        callback=validate_gui_location,
        help="Starting location for the GUI.",
    ),
    option(
        "--fullscreen",
        is_flag=True,
        help="Expand the window to its maximum possible size.",
        default=None,
    ),
    option(
        "--enable_wireframe",
        is_flag=True,
        help="Enable wireframe debugging mode in opengl.",
        default=None,
    ),
    option(
        "--force_window",
        is_flag=True,
        help="Force window to open when using the opengl renderer, intended for debugging as it may impact performance",
        default=False,
    ),
    option(
        "--dry_run",
        is_flag=True,
        help="Renders animations without outputting image or video files and disables the window",
        default=False,
    ),
    option(
        "--no_latex_cleanup",
        is_flag=True,
        help="Prevents deletion of .aux, .dvi, and .log files produced by Tex and MathTex.",
        default=False,
    ),
    option(
        "--preview_command",
        help="The command used to preview the output file (for example vlc for video files)",
        default="",
    ),
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.726">def validate_gui_location(
    ctx: Context, param: Option, value: str | None
) -&gt; tuple[int, int] | None:
    """If the ``value`` string is given, extract from it the GUI location,
    which should be in any of these formats: 'x;y', 'x,y' or 'x-y'.

    Parameters
    ----------
    ctx
        The Click context.
    param
        A Click option.
    value
        The optional string which will be parsed.

    Returns
    -------
    tuple[int, int] | None
        If ``value`` is ``None``, the return value is ``None``. Otherwise, it's
        the ``(x, y)`` location for the GUI.

    Raises
    ------
    ValueError
        If ``value`` has an invalid format.
    """
    if value is None:
        return None

    try:
        x_offset, y_offset = map(int, re.split(r"[;,\-]", value))
    except Exception:
        logger.error("GUI location option is invalid.")
        sys.exit()

    return (x_offset, y_offset)


</t>
<t tx="ekr.20250122151620.727">from __future__ import annotations

from cloup import IntRange, Path, option, option_group

__all__ = ["output_options"]

output_options = option_group(
    "Output options",
    option(
        "-o",
        "--output_file",
        type=str,
        default=None,
        help="Specify the filename(s) of the rendered scene(s).",
    ),
    option(
        "-0",
        "--zero_pad",
        type=IntRange(0, 9),
        default=None,
        help="Zero padding for PNG file names.",
    ),
    option(
        "--write_to_movie",
        is_flag=True,
        default=None,
        help="Write the video rendered with opengl to a file.",
    ),
    option(
        "--media_dir",
        type=Path(),
        default=None,
        help="Path to store rendered videos and latex.",
    ),
    option(
        "--log_dir",
        type=Path(),
        help="Path to store render logs.",
        default=None,
    ),
    option(
        "--log_to_file",
        is_flag=True,
        default=None,
        help="Log terminal output to file.",
    ),
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.728">from __future__ import annotations

import logging
import re
import sys
from typing import TYPE_CHECKING

from cloup import Choice, option, option_group

from manim.constants import QUALITIES, RendererType

if TYPE_CHECKING:
    from click import Context, Option

__all__ = ["render_options"]

logger = logging.getLogger("manim")


@others
render_options = option_group(
    "Render Options",
    option(
        "-n",
        "--from_animation_number",
        callback=validate_scene_range,
        help="Start rendering from n_0 until n_1. If n_1 is left unspecified, "
        "renders all scenes after n_0.",
        default=None,
    ),
    option(
        "-a",
        "--write_all",
        is_flag=True,
        help="Render all scenes in the input file.",
        default=None,
    ),
    option(
        "--format",
        type=Choice(["png", "gif", "mp4", "webm", "mov"], case_sensitive=False),
        default=None,
    ),
    option(
        "-s",
        "--save_last_frame",
        default=None,
        is_flag=True,
        help="Render and save only the last frame of a scene as a PNG image.",
    ),
    option(
        "-q",
        "--quality",
        default=None,
        type=Choice(
            list(reversed([q["flag"] for q in QUALITIES.values() if q["flag"]])),
            case_sensitive=False,
        ),
        help="Render quality at the follow resolution framerates, respectively: "
        + ", ".join(
            reversed(
                [
                    f"{q['pixel_width']}x{q['pixel_height']} {q['frame_rate']}FPS"
                    for q in QUALITIES.values()
                    if q["flag"]
                ]
            )
        ),
    ),
    option(
        "-r",
        "--resolution",
        callback=validate_resolution,
        default=None,
        help='Resolution in "W,H" for when 16:9 aspect ratio isn\'t possible.',
    ),
    option(
        "--fps",
        "--frame_rate",
        "frame_rate",
        type=float,
        default=None,
        help="Render at this frame rate.",
    ),
    option(
        "--renderer",
        type=Choice(
            [renderer_type.value for renderer_type in RendererType],
            case_sensitive=False,
        ),
        help="Select a renderer for your Scene.",
        default="cairo",
    ),
    option(
        "-g",
        "--save_pngs",
        is_flag=True,
        default=None,
        help="Save each frame as png (Deprecated).",
    ),
    option(
        "-i",
        "--save_as_gif",
        default=None,
        is_flag=True,
        help="Save as a gif (Deprecated).",
    ),
    option(
        "--save_sections",
        default=None,
        is_flag=True,
        help="Save section videos in addition to movie file.",
    ),
    option(
        "-t",
        "--transparent",
        is_flag=True,
        help="Render scenes with alpha channel.",
    ),
    option(
        "--use_projection_fill_shaders",
        is_flag=True,
        help="Use shaders for OpenGLVMobject fill which are compatible with transformation matrices.",
        default=None,
    ),
    option(
        "--use_projection_stroke_shaders",
        is_flag=True,
        help="Use shaders for OpenGLVMobject stroke which are compatible with transformation matrices.",
        default=None,
    ),
)
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.729">def validate_scene_range(
    ctx: Context, param: Option, value: str | None
) -&gt; tuple[int] | tuple[int, int] | None:
    """If the ``value`` string is given, extract from it the scene range, which
    should be in any of these formats: 'start', 'start;end', 'start,end' or
    'start-end'. Otherwise, return ``None``.

    Parameters
    ----------
    ctx
        The Click context.
    param
        A Click option.
    value
        The optional string which will be parsed.

    Returns
    -------
    tuple[int] | tuple[int, int] | None
        If ``value`` is ``None``, the return value is ``None``. Otherwise, it's
        the scene range, given by a tuple which may contain a single value
        ``start`` or two values ``start`` and ``end``.

    Raises
    ------
    ValueError
        If ``value`` has an invalid format.
    """
    if value is None:
        return None

    try:
        start = int(value)
        return (start,)
    except Exception:
        pass

    try:
        start, end = map(int, re.split(r"[;,\-]", value))
    except Exception:
        logger.error("Couldn't determine a range for -n option.")
        sys.exit()

    return start, end


</t>
<t tx="ekr.20250122151620.73">@property
def save_as_gif(self) -&gt; bool:
    """Whether to save the rendered scene in .gif format (-i)."""
    return self._d["save_as_gif"]

</t>
<t tx="ekr.20250122151620.730">def validate_resolution(
    ctx: Context, param: Option, value: str | None
) -&gt; tuple[int, int] | None:
    """If the ``value`` string is given, extract from it the resolution, which
    should be in any of these formats: 'W;H', 'W,H' or 'W-H'. Otherwise, return
    ``None``.

    Parameters
    ----------
    ctx
        The Click context.
    param
        A Click option.
    value
        The optional string which will be parsed.

    Returns
    -------
    tuple[int, int] | None
        If ``value`` is ``None``, the return value is ``None``. Otherwise, it's
        the resolution as a ``(W, H)`` tuple.

    Raises
    ------
    ValueError
        If ``value`` has an invalid format.
    """
    if value is None:
        return None

    try:
        width, height = map(int, re.split(r"[;,\-]", value))
    except Exception:
        logger.error("Resolution option is invalid.")
        sys.exit()

    return width, height


</t>
<t tx="ekr.20250122151620.731"></t>
<t tx="ekr.20250122151620.732"></t>
<t tx="ekr.20250122151620.733">from __future__ import annotations

from pathlib import Path

try:
    import dearpygui.dearpygui as dpg

    dearpygui_imported = True
except ImportError:
    dearpygui_imported = False


from .. import __version__, config
from ..utils.module_ops import scene_classes_from_file

__all__ = ["configure_pygui"]

if dearpygui_imported:
    dpg.create_context()
    window = dpg.generate_uuid()


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.734">def configure_pygui(renderer, widgets, update=True):
    if not dearpygui_imported:
        raise RuntimeError("Attempted to use DearPyGUI when it isn't imported.")
    if update:
        dpg.delete_item(window)
    else:
        dpg.create_viewport()
        dpg.setup_dearpygui()
        dpg.show_viewport()

    dpg.set_viewport_title(title=f"Manim Community v{__version__}")
    dpg.set_viewport_width(1015)
    dpg.set_viewport_height(540)

    def rerun_callback(sender, data):
        renderer.scene.queue.put(("rerun_gui", [], {}))

    def continue_callback(sender, data):
        renderer.scene.queue.put(("exit_gui", [], {}))

    def scene_selection_callback(sender, data):
        config["scene_names"] = (dpg.get_value(sender),)
        renderer.scene.queue.put(("rerun_gui", [], {}))

    scene_classes = scene_classes_from_file(Path(config["input_file"]), full_list=True)
    scene_names = [scene_class.__name__ for scene_class in scene_classes]

    with dpg.window(
        id=window,
        label="Manim GUI",
        pos=[config["gui_location"][0], config["gui_location"][1]],
        width=1000,
        height=500,
    ):
        dpg.set_global_font_scale(2)
        dpg.add_button(label="Rerun", callback=rerun_callback)
        dpg.add_button(label="Continue", callback=continue_callback)
        dpg.add_combo(
            label="Selected scene",
            items=scene_names,
            callback=scene_selection_callback,
            default_value=config["scene_names"][0],
        )
        dpg.add_separator()
        if len(widgets) != 0:
            with dpg.collapsing_header(
                label=f"{config['scene_names'][0]} widgets",
                default_open=True,
            ):
                for widget_config in widgets:
                    widget_config_copy = widget_config.copy()
                    name = widget_config_copy["name"]
                    widget = widget_config_copy["widget"]
                    if widget != "separator":
                        del widget_config_copy["name"]
                        del widget_config_copy["widget"]
                        getattr(dpg, f"add_{widget}")(label=name, **widget_config_copy)
                    else:
                        dpg.add_separator()

    if not update:
        dpg.start_dearpygui()
</t>
<t tx="ekr.20250122151620.735"></t>
<t tx="ekr.20250122151620.736"></t>
<t tx="ekr.20250122151620.737">"""Special rectangles."""

from __future__ import annotations

__all__ = [
    "ScreenRectangle",
    "FullScreenRectangle",
]


from manim.mobject.geometry.polygram import Rectangle

from .. import config


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.738">class ScreenRectangle(Rectangle):
    @others
</t>
<t tx="ekr.20250122151620.739">class FullScreenRectangle(ScreenRectangle):
    @others
</t>
<t tx="ekr.20250122151620.74">@save_as_gif.setter
def save_as_gif(self, value: bool) -&gt; None:
    self._set_boolean("save_as_gif", value)

</t>
<t tx="ekr.20250122151620.740">def __init__(self, aspect_ratio=16.0 / 9.0, height=4, **kwargs):
    super().__init__(width=aspect_ratio * height, height=height, **kwargs)

</t>
<t tx="ekr.20250122151620.741">@property
def aspect_ratio(self):
    """The aspect ratio.

    When set, the width is stretched to accommodate
    the new aspect ratio.
    """
    return self.width / self.height

</t>
<t tx="ekr.20250122151620.742">@aspect_ratio.setter
def aspect_ratio(self, value):
    self.stretch_to_fit_width(value * self.height)


</t>
<t tx="ekr.20250122151620.743">def __init__(self, **kwargs):
    super().__init__(**kwargs)
    self.height = config["frame_height"]
</t>
<t tx="ekr.20250122151620.744">"""Mobjects used to represent mathematical graphs (think graph theory, not plotting)."""

from __future__ import annotations

__all__ = [
    "Graph",
    "DiGraph",
]

import itertools as it
from collections.abc import Hashable, Iterable, Sequence
from copy import copy
from typing import TYPE_CHECKING, Any, Literal, Protocol, cast

import networkx as nx
import numpy as np

if TYPE_CHECKING:
    from typing_extensions import TypeAlias

    from manim.scene.scene import Scene
    from manim.typing import Point3D, Point3DLike

    NxGraph: TypeAlias = nx.classes.graph.Graph | nx.classes.digraph.DiGraph

from manim.animation.composition import AnimationGroup
from manim.animation.creation import Create, Uncreate
from manim.mobject.geometry.arc import Dot, LabeledDot
from manim.mobject.geometry.line import Line
from manim.mobject.mobject import Mobject, override_animate
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.mobject.text.tex_mobject import MathTex
from manim.mobject.types.vectorized_mobject import VMobject
from manim.utils.color import BLACK


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.745">class LayoutFunction(Protocol):
    """A protocol for automatic layout functions that compute a layout for a graph to be used in :meth:`~.Graph.change_layout`.

    .. note:: The layout function must be a pure function, i.e., it must not modify the graph passed to it.

    Examples
    --------

    Here is an example that arranges nodes in an n x m grid in sorted order.

    .. manim:: CustomLayoutExample
        :save_last_frame:

        class CustomLayoutExample(Scene):
            def construct(self):
                import numpy as np
                import networkx as nx

                # create custom layout
                def custom_layout(
                    graph: nx.Graph,
                    scale: float | tuple[float, float, float] = 2,
                    n: int | None = None,
                    *args: Any,
                    **kwargs: Any,
                ):
                    nodes = sorted(list(graph))
                    height = len(nodes) // n
                    return {
                        node: (scale * np.array([
                            (i % n) - (n-1)/2,
                            -(i // n) + height/2,
                            0
                        ])) for i, node in enumerate(graph)
                    }

                # draw graph
                n = 4
                graph = Graph(
                    [i for i in range(4 * 2 - 1)],
                    [(0, 1), (0, 4), (1, 2), (1, 5), (2, 3), (2, 6), (4, 5), (5, 6)],
                    labels=True,
                    layout=custom_layout,
                    layout_config={'n': n}
                )
                self.add(graph)

    Several automatic layouts are provided by manim, and can be used by passing their name as the ``layout`` parameter to :meth:`~.Graph.change_layout`.
    Alternatively, a custom layout function can be passed to :meth:`~.Graph.change_layout` as the ``layout`` parameter. Such a function must adhere to the :class:`~.LayoutFunction` protocol.

    The :class:`~.LayoutFunction` s provided by manim are illustrated below:

    - Circular Layout: places the vertices on a circle

    .. manim:: CircularLayout
        :save_last_frame:

        class CircularLayout(Scene):
            def construct(self):
                graph = Graph(
                    [1, 2, 3, 4, 5, 6],
                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
                    layout="circular",
                    labels=True
                )
                self.add(graph)

    - Kamada Kawai Layout: tries to place the vertices such that the given distances between them are respected

    .. manim:: KamadaKawaiLayout
        :save_last_frame:

        class KamadaKawaiLayout(Scene):
            def construct(self):
                from collections import defaultdict
                distances: dict[int, dict[int, float]] = defaultdict(dict)

                # set desired distances
                distances[1][2] = 1  # distance between vertices 1 and 2 is 1
                distances[2][3] = 1  # distance between vertices 2 and 3 is 1
                distances[3][4] = 2  # etc
                distances[4][5] = 3
                distances[5][6] = 5
                distances[6][1] = 8

                graph = Graph(
                    [1, 2, 3, 4, 5, 6],
                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1)],
                    layout="kamada_kawai",
                    layout_config={"dist": distances},
                    layout_scale=4,
                    labels=True
                )
                self.add(graph)

    - Partite Layout: places vertices into distinct partitions

    .. manim:: PartiteLayout
        :save_last_frame:

        class PartiteLayout(Scene):
            def construct(self):
                graph = Graph(
                    [1, 2, 3, 4, 5, 6],
                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
                    layout="partite",
                    layout_config={"partitions": [[1,2],[3,4],[5,6]]},
                    labels=True
                )
                self.add(graph)

    - Planar Layout: places vertices such that edges do not cross

    .. manim:: PlanarLayout
        :save_last_frame:

        class PlanarLayout(Scene):
            def construct(self):
                graph = Graph(
                    [1, 2, 3, 4, 5, 6],
                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
                    layout="planar",
                    layout_scale=4,
                    labels=True
                )
                self.add(graph)

    - Random Layout: randomly places vertices

    .. manim:: RandomLayout
        :save_last_frame:

        class RandomLayout(Scene):
            def construct(self):
                graph = Graph(
                    [1, 2, 3, 4, 5, 6],
                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
                    layout="random",
                    labels=True
                )
                self.add(graph)

    - Shell Layout: places vertices in concentric circles

    .. manim:: ShellLayout
        :save_last_frame:

        class ShellLayout(Scene):
            def construct(self):
                nlist = [[1, 2, 3], [4, 5, 6, 7, 8, 9]]
                graph = Graph(
                    [1, 2, 3, 4, 5, 6, 7, 8, 9],
                    [(1, 2), (2, 3), (3, 1), (4, 1), (4, 2), (5, 2), (6, 2), (6, 3), (7, 3), (8, 3), (8, 1), (9, 1)],
                    layout="shell",
                    layout_config={"nlist": nlist},
                    labels=True
                )
                self.add(graph)

    - Spectral Layout: places vertices using the eigenvectors of the graph Laplacian (clusters nodes which are an approximation of the ratio cut)

    .. manim:: SpectralLayout
        :save_last_frame:

        class SpectralLayout(Scene):
            def construct(self):
                graph = Graph(
                    [1, 2, 3, 4, 5, 6],
                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
                    layout="spectral",
                    labels=True
                )
                self.add(graph)

    - Sprial Layout: places vertices in a spiraling pattern

    .. manim:: SpiralLayout
        :save_last_frame:

        class SpiralLayout(Scene):
            def construct(self):
                graph = Graph(
                    [1, 2, 3, 4, 5, 6],
                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
                    layout="spiral",
                    labels=True
                )
                self.add(graph)

    - Spring Layout: places nodes according to the Fruchterman-Reingold force-directed algorithm (attempts to minimize edge length while maximizing node separation)

    .. manim:: SpringLayout
        :save_last_frame:

        class SpringLayout(Scene):
            def construct(self):
                graph = Graph(
                    [1, 2, 3, 4, 5, 6],
                    [(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 1), (5, 1), (1, 3), (3, 5)],
                    layout="spring",
                    labels=True
                )
                self.add(graph)

    - Tree Layout: places vertices into a tree with a root node and branches (can only be used with legal trees)

    .. manim:: TreeLayout
        :save_last_frame:

        class TreeLayout(Scene):
            def construct(self):
                graph = Graph(
                    [1, 2, 3, 4, 5, 6, 7],
                    [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)],
                    layout="tree",
                    layout_config={"root_vertex": 1},
                    labels=True
                )
                self.add(graph)

    """

    @others
</t>
<t tx="ekr.20250122151620.746">def _partite_layout(
    nx_graph: NxGraph,
    scale: float = 2,
    partitions: Sequence[Sequence[Hashable]] | None = None,
    **kwargs: Any,
) -&gt; dict[Hashable, Point3D]:
    if partitions is None or len(partitions) == 0:
        raise ValueError(
            "The partite layout requires partitions parameter to contain the partition of the vertices",
        )
    partition_count = len(partitions)
    for i in range(partition_count):
        for v in partitions[i]:
            if nx_graph.nodes[v] is None:
                raise ValueError(
                    "The partition must contain arrays of vertices in the graph",
                )
            nx_graph.nodes[v]["subset"] = i
    # Add missing vertices to their own side
    for v in nx_graph.nodes:
        if "subset" not in nx_graph.nodes[v]:
            nx_graph.nodes[v]["subset"] = partition_count

    return nx.layout.multipartite_layout(nx_graph, scale=scale, **kwargs)


</t>
<t tx="ekr.20250122151620.747">def _random_layout(nx_graph: NxGraph, scale: float = 2, **kwargs: Any):
    # the random layout places coordinates in [0, 1)
    # we need to rescale manually afterwards...
    auto_layout = nx.layout.random_layout(nx_graph, **kwargs)
    for k, v in auto_layout.items():
        auto_layout[k] = 2 * scale * (v - np.array([0.5, 0.5]))
    return {k: np.append(v, [0]) for k, v in auto_layout.items()}


</t>
<t tx="ekr.20250122151620.748">def _tree_layout(
    T: NxGraph,
    root_vertex: Hashable | None = None,
    scale: float | tuple | None = 2,
    vertex_spacing: tuple | None = None,
    orientation: str = "down",
):
    if root_vertex is None:
        raise ValueError("The tree layout requires the root_vertex parameter")
    if not nx.is_tree(T):
        raise ValueError("The tree layout must be used with trees")

    children = {root_vertex: list(T.neighbors(root_vertex))}
    # The following code is SageMath's tree layout implementation, taken from
    # https://github.com/sagemath/sage/blob/cc60cfebc4576fed8b01f0fc487271bdee3cefed/src/sage/graphs/graph_plot.py#L1447

    # Always make a copy of the children because they get eaten
    stack = [list(children[root_vertex]).copy()]
    stick = [root_vertex]
    parent = {u: root_vertex for u in children[root_vertex]}
    pos = {}
    obstruction = [0.0] * len(T)
    o = -1 if orientation == "down" else 1

    def slide(v, dx):
        """
        Shift the vertex v and its descendants to the right by dx.
        Precondition: v and its descendents have already had their
        positions computed.
        """
        level = [v]
        while level:
            nextlevel = []
            for u in level:
                x, y = pos[u]
                x += dx
                obstruction[y] = max(x + 1, obstruction[y])
                pos[u] = x, y
                nextlevel += children[u]
            level = nextlevel

    while stack:
        C = stack[-1]
        if not C:
            p = stick.pop()
            stack.pop()
            cp = children[p]
            y = o * len(stack)
            if not cp:
                x = obstruction[y]
                pos[p] = x, y
            else:
                x = sum(pos[c][0] for c in cp) / float(len(cp))
                pos[p] = x, y
                ox = obstruction[y]
                if x &lt; ox:
                    slide(p, ox - x)
                    x = ox
            obstruction[y] = x + 1
            continue

        t = C.pop()
        pt = parent[t]

        ct = [u for u in list(T.neighbors(t)) if u != pt]
        for c in ct:
            parent[c] = t
        children[t] = copy(ct)

        stack.append(ct)
        stick.append(t)

    # the resulting layout is then rescaled again to fit on Manim's canvas

    x_min = min(pos.values(), key=lambda t: t[0])[0]
    x_max = max(pos.values(), key=lambda t: t[0])[0]
    y_min = min(pos.values(), key=lambda t: t[1])[1]
    y_max = max(pos.values(), key=lambda t: t[1])[1]
    center = np.array([x_min + x_max, y_min + y_max, 0]) / 2
    height = y_max - y_min
    width = x_max - x_min
    if vertex_spacing is None:
        if isinstance(scale, (float, int)) and (width &gt; 0 or height &gt; 0):
            sf = 2 * scale / max(width, height)
        elif isinstance(scale, tuple):
            sw = 2 * scale[0] / width if scale[0] is not None and width &gt; 0 else 1

            sh = 2 * scale[1] / height if scale[1] is not None and height &gt; 0 else 1

            sf = np.array([sw, sh, 0])
        else:
            sf = 1
    else:
        sx, sy = vertex_spacing
        sf = np.array([sx, sy, 0])
    return {v: (np.array([x, y, 0]) - center) * sf for v, (x, y) in pos.items()}


</t>
<t tx="ekr.20250122151620.749">LayoutName = Literal[
    "circular",
    "kamada_kawai",
    "partite",
    "planar",
    "random",
    "shell",
    "spectral",
    "spiral",
    "spring",
    "tree",
]

_layouts: dict[LayoutName, LayoutFunction] = {
    "circular": cast(LayoutFunction, nx.layout.circular_layout),
    "kamada_kawai": cast(LayoutFunction, nx.layout.kamada_kawai_layout),
    "partite": cast(LayoutFunction, _partite_layout),
    "planar": cast(LayoutFunction, nx.layout.planar_layout),
    "random": cast(LayoutFunction, _random_layout),
    "shell": cast(LayoutFunction, nx.layout.shell_layout),
    "spectral": cast(LayoutFunction, nx.layout.spectral_layout),
    "spiral": cast(LayoutFunction, nx.layout.spiral_layout),
    "spring": cast(LayoutFunction, nx.layout.spring_layout),
    "tree": cast(LayoutFunction, _tree_layout),
}


def _determine_graph_layout(
    nx_graph: nx.classes.graph.Graph | nx.classes.digraph.DiGraph,
    layout: LayoutName | dict[Hashable, Point3DLike] | LayoutFunction = "spring",
    layout_scale: float | tuple[float, float, float] = 2,
    layout_config: dict[str, Any] | None = None,
) -&gt; dict[Hashable, Point3DLike]:
    if layout_config is None:
        layout_config = {}

    if isinstance(layout, dict):
        return layout
    elif layout in _layouts:
        auto_layout = _layouts[layout](nx_graph, scale=layout_scale, **layout_config)
        # NetworkX returns a dictionary of 3D points if the dimension
        # is specified to be 3. Otherwise, it returns a dictionary of
        # 2D points, so adjusting is required.
        if (
            layout_config.get("dim") == 3
            or auto_layout[next(auto_layout.__iter__())].shape[0] == 3
        ):
            return auto_layout
        else:
            return {k: np.append(v, [0]) for k, v in auto_layout.items()}
    else:
        try:
            return cast(LayoutFunction, layout)(
                nx_graph, scale=layout_scale, **layout_config
            )
        except TypeError as e:
            raise ValueError(
                f"The layout '{layout}' is neither a recognized layout, a layout function,"
                "nor a vertex placement dictionary.",
            ) from e


</t>
<t tx="ekr.20250122151620.75">@property
def save_sections(self) -&gt; bool:
    """Whether to save single videos for each section in addition to the movie file."""
    return self._d["save_sections"]

</t>
<t tx="ekr.20250122151620.750">class GenericGraph(VMobject, metaclass=ConvertToOpenGL):
    """Abstract base class for graphs (that is, a collection of vertices
    connected with edges).

    Graphs can be instantiated by passing both a list of (distinct, hashable)
    vertex names, together with list of edges (as tuples of vertex names). See
    the examples for concrete implementations of this class for details.

    .. note::

        This implementation uses updaters to make the edges move with
        the vertices.


    See also
    --------

    :class:`.Graph`
    :class:`.DiGraph`


    Parameters
    ----------

    vertices
        A list of vertices. Must be hashable elements.
    edges
        A list of edges, specified as tuples ``(u, v)`` where both ``u``
        and ``v`` are vertices.
    labels
        Controls whether or not vertices are labeled. If ``False`` (the default),
        the vertices are not labeled; if ``True`` they are labeled using their
        names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,
        custom labels can be specified by passing a dictionary whose keys are
        the vertices, and whose values are the corresponding vertex labels
        (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).
    label_fill_color
        Sets the fill color of the default labels generated when ``labels``
        is set to ``True``. Has no effect for other values of ``labels``.
    layout
        Either one of ``"spring"`` (the default), ``"circular"``, ``"kamada_kawai"``,
        ``"planar"``, ``"random"``, ``"shell"``, ``"spectral"``, ``"spiral"``, ``"tree"``, and ``"partite"``
        for automatic vertex positioning primarily using ``networkx``
        (see `their documentation &lt;https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout&gt;`_
        for more details), a dictionary specifying a coordinate (value)
        for each vertex (key) for manual positioning, or a .:class:`~.LayoutFunction` with a user-defined automatic layout.
    layout_config
        Only for automatic layouts. A dictionary whose entries
        are passed as keyword arguments to the named layout or automatic layout function
        specified via ``layout``.
        The ``tree`` layout also accepts a special parameter ``vertex_spacing``
        passed as a keyword argument inside the ``layout_config`` dictionary.
        Passing a tuple ``(space_x, space_y)`` as this argument overrides
        the value of ``layout_scale`` and ensures that vertices are arranged
        in a way such that the centers of siblings in the same layer are
        at least ``space_x`` units apart horizontally, and neighboring layers
        are spaced ``space_y`` units vertically.
    layout_scale
        The scale of automatically generated layouts: the vertices will
        be arranged such that the coordinates are located within the
        interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``
        causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,
        and the second in ``[-scale_y, scale_y]``. Default: 2.
    vertex_type
        The mobject class used for displaying vertices in the scene.
    vertex_config
        Either a dictionary containing keyword arguments to be passed to
        the class specified via ``vertex_type``, or a dictionary whose keys
        are the vertices, and whose values are dictionaries containing keyword
        arguments for the mobject related to the corresponding vertex.
    vertex_mobjects
        A dictionary whose keys are the vertices, and whose values are
        mobjects to be used as vertices. Passing vertices here overrides
        all other configuration options for a vertex.
    edge_type
        The mobject class used for displaying edges in the scene.
        Must be a subclass of :class:`~.Line` for default updaters to work.
    edge_config
        Either a dictionary containing keyword arguments to be passed
        to the class specified via ``edge_type``, or a dictionary whose
        keys are the edges, and whose values are dictionaries containing
        keyword arguments for the mobject related to the corresponding edge.
    """

    @others
</t>
<t tx="ekr.20250122151620.751">class Graph(GenericGraph):
    """An undirected graph (vertices connected with edges).

    The graph comes with an updater which makes the edges stick to
    the vertices when moved around. See :class:`.DiGraph` for
    a version with directed edges.

    See also
    --------

    :class:`.GenericGraph`

    Parameters
    ----------

    vertices
        A list of vertices. Must be hashable elements.
    edges
        A list of edges, specified as tuples ``(u, v)`` where both ``u``
        and ``v`` are vertices. The vertex order is irrelevant.
    labels
        Controls whether or not vertices are labeled. If ``False`` (the default),
        the vertices are not labeled; if ``True`` they are labeled using their
        names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,
        custom labels can be specified by passing a dictionary whose keys are
        the vertices, and whose values are the corresponding vertex labels
        (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).
    label_fill_color
        Sets the fill color of the default labels generated when ``labels``
        is set to ``True``. Has no effect for other values of ``labels``.
    layout
        Either one of ``"spring"`` (the default), ``"circular"``, ``"kamada_kawai"``,
        ``"planar"``, ``"random"``, ``"shell"``, ``"spectral"``, ``"spiral"``, ``"tree"``, and ``"partite"``
        for automatic vertex positioning using ``networkx``
        (see `their documentation &lt;https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout&gt;`_
        for more details), or a dictionary specifying a coordinate (value)
        for each vertex (key) for manual positioning.
    layout_config
        Only for automatically generated layouts. A dictionary whose entries
        are passed as keyword arguments to the automatic layout algorithm
        specified via ``layout`` of ``networkx``.
        The ``tree`` layout also accepts a special parameter ``vertex_spacing``
        passed as a keyword argument inside the ``layout_config`` dictionary.
        Passing a tuple ``(space_x, space_y)`` as this argument overrides
        the value of ``layout_scale`` and ensures that vertices are arranged
        in a way such that the centers of siblings in the same layer are
        at least ``space_x`` units apart horizontally, and neighboring layers
        are spaced ``space_y`` units vertically.
    layout_scale
        The scale of automatically generated layouts: the vertices will
        be arranged such that the coordinates are located within the
        interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``
        causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,
        and the second in ``[-scale_y, scale_y]``. Default: 2.
    vertex_type
        The mobject class used for displaying vertices in the scene.
    vertex_config
        Either a dictionary containing keyword arguments to be passed to
        the class specified via ``vertex_type``, or a dictionary whose keys
        are the vertices, and whose values are dictionaries containing keyword
        arguments for the mobject related to the corresponding vertex.
    vertex_mobjects
        A dictionary whose keys are the vertices, and whose values are
        mobjects to be used as vertices. Passing vertices here overrides
        all other configuration options for a vertex.
    edge_type
        The mobject class used for displaying edges in the scene.
    edge_config
        Either a dictionary containing keyword arguments to be passed
        to the class specified via ``edge_type``, or a dictionary whose
        keys are the edges, and whose values are dictionaries containing
        keyword arguments for the mobject related to the corresponding edge.


    Examples
    --------

    First, we create a small graph and demonstrate that the edges move
    together with the vertices.

    .. manim:: MovingVertices

        class MovingVertices(Scene):
            def construct(self):
                vertices = [1, 2, 3, 4]
                edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]
                g = Graph(vertices, edges)
                self.play(Create(g))
                self.wait()
                self.play(g[1].animate.move_to([1, 1, 0]),
                          g[2].animate.move_to([-1, 1, 0]),
                          g[3].animate.move_to([1, -1, 0]),
                          g[4].animate.move_to([-1, -1, 0]))
                self.wait()

    There are several automatic positioning algorithms to choose from:

    .. manim:: GraphAutoPosition
        :save_last_frame:

        class GraphAutoPosition(Scene):
            def construct(self):
                vertices = [1, 2, 3, 4, 5, 6, 7, 8]
                edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
                         (2, 8), (3, 4), (6, 1), (6, 2),
                         (6, 3), (7, 2), (7, 4)]
                autolayouts = ["spring", "circular", "kamada_kawai",
                               "planar", "random", "shell",
                               "spectral", "spiral"]
                graphs = [Graph(vertices, edges, layout=lt).scale(0.5)
                          for lt in autolayouts]
                r1 = VGroup(*graphs[:3]).arrange()
                r2 = VGroup(*graphs[3:6]).arrange()
                r3 = VGroup(*graphs[6:]).arrange()
                self.add(VGroup(r1, r2, r3).arrange(direction=DOWN))

    Vertices can also be positioned manually:

    .. manim:: GraphManualPosition
        :save_last_frame:

        class GraphManualPosition(Scene):
            def construct(self):
                vertices = [1, 2, 3, 4]
                edges = [(1, 2), (2, 3), (3, 4), (4, 1)]
                lt = {1: [0, 0, 0], 2: [1, 1, 0], 3: [1, -1, 0], 4: [-1, 0, 0]}
                G = Graph(vertices, edges, layout=lt)
                self.add(G)

    The vertices in graphs can be labeled, and configurations for vertices
    and edges can be modified both by default and for specific vertices and
    edges.

    .. note::

        In ``edge_config``, edges can be passed in both directions: if
        ``(u, v)`` is an edge in the graph, both ``(u, v)`` as well
        as ``(v, u)`` can be used as keys in the dictionary.

    .. manim:: LabeledModifiedGraph
        :save_last_frame:

        class LabeledModifiedGraph(Scene):
            def construct(self):
                vertices = [1, 2, 3, 4, 5, 6, 7, 8]
                edges = [(1, 7), (1, 8), (2, 3), (2, 4), (2, 5),
                         (2, 8), (3, 4), (6, 1), (6, 2),
                         (6, 3), (7, 2), (7, 4)]
                g = Graph(vertices, edges, layout="circular", layout_scale=3,
                          labels=True, vertex_config={7: {"fill_color": RED}},
                          edge_config={(1, 7): {"stroke_color": RED},
                                       (2, 7): {"stroke_color": RED},
                                       (4, 7): {"stroke_color": RED}})
                self.add(g)

    You can also lay out a partite graph on columns by specifying
    a list of the vertices on each side and choosing the partite layout.

    .. note::

        All vertices in your graph which are not listed in any of the partitions
        are collected in their own partition and rendered in the rightmost column.

    .. manim:: PartiteGraph
        :save_last_frame:

        import networkx as nx

        class PartiteGraph(Scene):
            def construct(self):
                G = nx.Graph()
                G.add_nodes_from([0, 1, 2, 3])
                G.add_edges_from([(0, 2), (0,3), (1, 2)])
                graph = Graph(list(G.nodes), list(G.edges), layout="partite", partitions=[[0, 1]])
                self.play(Create(graph))

    The representation of a linear artificial neural network is facilitated
    by the use of the partite layout and defining partitions for each layer.

    .. manim:: LinearNN
        :save_last_frame:

        class LinearNN(Scene):
            def construct(self):
                edges = []
                partitions = []
                c = 0
                layers = [2, 3, 3, 2]  # the number of neurons in each layer

                for i in layers:
                    partitions.append(list(range(c + 1, c + i + 1)))
                    c += i
                for i, v in enumerate(layers[1:]):
                        last = sum(layers[:i+1])
                        for j in range(v):
                            for k in range(last - layers[i], last):
                                edges.append((k + 1, j + last + 1))

                vertices = np.arange(1, sum(layers) + 1)

                graph = Graph(
                    vertices,
                    edges,
                    layout='partite',
                    partitions=partitions,
                    layout_scale=3,
                    vertex_config={'radius': 0.20},
                )
                self.add(graph)

    The custom tree layout can be used to show the graph
    by distance from the root vertex. You must pass the root vertex
    of the tree.

    .. manim:: Tree

        import networkx as nx

        class Tree(Scene):
            def construct(self):
                G = nx.Graph()

                G.add_node("ROOT")

                for i in range(5):
                    G.add_node("Child_%i" % i)
                    G.add_node("Grandchild_%i" % i)
                    G.add_node("Greatgrandchild_%i" % i)

                    G.add_edge("ROOT", "Child_%i" % i)
                    G.add_edge("Child_%i" % i, "Grandchild_%i" % i)
                    G.add_edge("Grandchild_%i" % i, "Greatgrandchild_%i" % i)

                self.play(Create(
                    Graph(list(G.nodes), list(G.edges), layout="tree", root_vertex="ROOT")))

    The following code sample illustrates the use of the ``vertex_spacing``
    layout parameter specific to the ``"tree"`` layout. As mentioned
    above, setting ``vertex_spacing`` overrides the specified value
    for ``layout_scale``, and as such it is harder to control the size
    of the mobject. However, we can adjust the captured frame and
    zoom out by using a :class:`.MovingCameraScene`::

        class LargeTreeGeneration(MovingCameraScene):
            DEPTH = 4
            CHILDREN_PER_VERTEX = 3
            LAYOUT_CONFIG = {"vertex_spacing": (0.5, 1)}
            VERTEX_CONF = {"radius": 0.25, "color": BLUE_B, "fill_opacity": 1}

            def expand_vertex(self, g, vertex_id: str, depth: int):
                new_vertices = [
                    f"{vertex_id}/{i}" for i in range(self.CHILDREN_PER_VERTEX)
                ]
                new_edges = [(vertex_id, child_id) for child_id in new_vertices]
                g.add_edges(
                    *new_edges,
                    vertex_config=self.VERTEX_CONF,
                    positions={
                        k: g.vertices[vertex_id].get_center() + 0.1 * DOWN
                        for k in new_vertices
                    },
                )
                if depth &lt; self.DEPTH:
                    for child_id in new_vertices:
                        self.expand_vertex(g, child_id, depth + 1)

                return g

            def construct(self):
                g = Graph(["ROOT"], [], vertex_config=self.VERTEX_CONF)
                g = self.expand_vertex(g, "ROOT", 1)
                self.add(g)

                self.play(
                    g.animate.change_layout(
                        "tree",
                        root_vertex="ROOT",
                        layout_config=self.LAYOUT_CONFIG,
                    )
                )
                self.play(self.camera.auto_zoom(g, margin=1), run_time=0.5)
    """

    @others
</t>
<t tx="ekr.20250122151620.752">class DiGraph(GenericGraph):
    """A directed graph.

    .. note::

        In contrast to undirected graphs, the order in which vertices in a given
        edge are specified is relevant here.

    See also
    --------

    :class:`.GenericGraph`

    Parameters
    ----------

    vertices
        A list of vertices. Must be hashable elements.
    edges
        A list of edges, specified as tuples ``(u, v)`` where both ``u``
        and ``v`` are vertices. The edge is directed from ``u`` to ``v``.
    labels
        Controls whether or not vertices are labeled. If ``False`` (the default),
        the vertices are not labeled; if ``True`` they are labeled using their
        names (as specified in ``vertices``) via :class:`~.MathTex`. Alternatively,
        custom labels can be specified by passing a dictionary whose keys are
        the vertices, and whose values are the corresponding vertex labels
        (rendered via, e.g., :class:`~.Text` or :class:`~.Tex`).
    label_fill_color
        Sets the fill color of the default labels generated when ``labels``
        is set to ``True``. Has no effect for other values of ``labels``.
    layout
        Either one of ``"spring"`` (the default), ``"circular"``, ``"kamada_kawai"``,
        ``"planar"``, ``"random"``, ``"shell"``, ``"spectral"``, ``"spiral"``, ``"tree"``, and ``"partite"``
        for automatic vertex positioning using ``networkx``
        (see `their documentation &lt;https://networkx.org/documentation/stable/reference/drawing.html#module-networkx.drawing.layout&gt;`_
        for more details), or a dictionary specifying a coordinate (value)
        for each vertex (key) for manual positioning.
    layout_config
        Only for automatically generated layouts. A dictionary whose entries
        are passed as keyword arguments to the automatic layout algorithm
        specified via ``layout`` of ``networkx``.
        The ``tree`` layout also accepts a special parameter ``vertex_spacing``
        passed as a keyword argument inside the ``layout_config`` dictionary.
        Passing a tuple ``(space_x, space_y)`` as this argument overrides
        the value of ``layout_scale`` and ensures that vertices are arranged
        in a way such that the centers of siblings in the same layer are
        at least ``space_x`` units apart horizontally, and neighboring layers
        are spaced ``space_y`` units vertically.
    layout_scale
        The scale of automatically generated layouts: the vertices will
        be arranged such that the coordinates are located within the
        interval ``[-scale, scale]``. Some layouts accept a tuple ``(scale_x, scale_y)``
        causing the first coordinate to be in the interval ``[-scale_x, scale_x]``,
        and the second in ``[-scale_y, scale_y]``. Default: 2.
    vertex_type
        The mobject class used for displaying vertices in the scene.
    vertex_config
        Either a dictionary containing keyword arguments to be passed to
        the class specified via ``vertex_type``, or a dictionary whose keys
        are the vertices, and whose values are dictionaries containing keyword
        arguments for the mobject related to the corresponding vertex.
    vertex_mobjects
        A dictionary whose keys are the vertices, and whose values are
        mobjects to be used as vertices. Passing vertices here overrides
        all other configuration options for a vertex.
    edge_type
        The mobject class used for displaying edges in the scene.
    edge_config
        Either a dictionary containing keyword arguments to be passed
        to the class specified via ``edge_type``, or a dictionary whose
        keys are the edges, and whose values are dictionaries containing
        keyword arguments for the mobject related to the corresponding edge.
        You can further customize the tip by adding a ``tip_config`` dictionary
        for global styling, or by adding the dict to a specific ``edge_config``.

    Examples
    --------

    .. manim:: MovingDiGraph

        class MovingDiGraph(Scene):
            def construct(self):
                vertices = [1, 2, 3, 4]
                edges = [(1, 2), (2, 3), (3, 4), (1, 3), (1, 4)]

                g = DiGraph(vertices, edges)

                self.add(g)
                self.play(
                    g[1].animate.move_to([1, 1, 1]),
                    g[2].animate.move_to([-1, 1, 2]),
                    g[3].animate.move_to([1, -1, -1]),
                    g[4].animate.move_to([-1, -1, 0]),
                )
                self.wait()

    You can customize the edges and arrow tips globally or locally.

    .. manim:: CustomDiGraph

        class CustomDiGraph(Scene):
            def construct(self):
                vertices = [i for i in range(5)]
                edges = [
                    (0, 1),
                    (1, 2),
                    (3, 2),
                    (3, 4),
                ]

                edge_config = {
                    "stroke_width": 2,
                    "tip_config": {
                        "tip_shape": ArrowSquareTip,
                        "tip_length": 0.15,
                    },
                    (3, 4): {
                        "color": RED,
                        "tip_config": {"tip_length": 0.25, "tip_width": 0.25}
                    },
                }

                g = DiGraph(
                    vertices,
                    edges,
                    labels=True,
                    layout="circular",
                    edge_config=edge_config,
                ).scale(1.4)

                self.play(Create(g))
                self.wait()

    Since this implementation respects the labels boundary you can also use
    it for an undirected moving graph with labels.

    .. manim:: UndirectedMovingDiGraph

        class UndirectedMovingDiGraph(Scene):
            def construct(self):
                vertices = [i for i in range(5)]
                edges = [
                    (0, 1),
                    (1, 2),
                    (3, 2),
                    (3, 4),
                ]

                edge_config = {
                    "stroke_width": 2,
                    "tip_config": {"tip_length": 0, "tip_width": 0},
                    (3, 4): {"color": RED},
                }

                g = DiGraph(
                    vertices,
                    edges,
                    labels=True,
                    layout="circular",
                    edge_config=edge_config,
                ).scale(1.4)

                self.play(Create(g))
                self.wait()

                self.play(
                    g[1].animate.move_to([1, 1, 1]),
                    g[2].animate.move_to([-1, 1, 2]),
                    g[3].animate.move_to([-1.5, -1.5, -1]),
                    g[4].animate.move_to([1, -2, -1]),
                )
                self.wait()

    """

    @others
</t>
<t tx="ekr.20250122151620.753">def __call__(
    self,
    graph: NxGraph,
    scale: float | tuple[float, float, float] = 2,
    *args: Any,
    **kwargs: Any,
) -&gt; dict[Hashable, Point3D]:
    """Given a graph and a scale, return a dictionary of coordinates.

    Parameters
    ----------
    graph
        The underlying NetworkX graph to be laid out. DO NOT MODIFY.
    scale
        Either a single float value, or a tuple of three float values specifying the scale along each axis.

    Returns
    -------
    dict[Hashable, Point3D]
        A dictionary mapping vertices to their positions.
    """
    ...


</t>
<t tx="ekr.20250122151620.754">def __init__(
    self,
    vertices: Sequence[Hashable],
    edges: Sequence[tuple[Hashable, Hashable]],
    labels: bool | dict = False,
    label_fill_color: str = BLACK,
    layout: LayoutName | dict[Hashable, Point3DLike] | LayoutFunction = "spring",
    layout_scale: float | tuple[float, float, float] = 2,
    layout_config: dict | None = None,
    vertex_type: type[Mobject] = Dot,
    vertex_config: dict | None = None,
    vertex_mobjects: dict | None = None,
    edge_type: type[Mobject] = Line,
    partitions: Sequence[Sequence[Hashable]] | None = None,
    root_vertex: Hashable | None = None,
    edge_config: dict | None = None,
) -&gt; None:
    super().__init__()

    nx_graph = self._empty_networkx_graph()
    nx_graph.add_nodes_from(vertices)
    nx_graph.add_edges_from(edges)
    self._graph = nx_graph

    if isinstance(labels, dict):
        self._labels = labels
    elif isinstance(labels, bool):
        if labels:
            self._labels = {
                v: MathTex(v, fill_color=label_fill_color) for v in vertices
            }
        else:
            self._labels = {}

    if self._labels and vertex_type is Dot:
        vertex_type = LabeledDot

    if vertex_mobjects is None:
        vertex_mobjects = {}

    # build vertex_config
    if vertex_config is None:
        vertex_config = {}
    default_vertex_config = {}
    if vertex_config:
        default_vertex_config = {
            k: v for k, v in vertex_config.items() if k not in vertices
        }
    self._vertex_config = {
        v: vertex_config.get(v, copy(default_vertex_config)) for v in vertices
    }
    self.default_vertex_config = default_vertex_config
    for v, label in self._labels.items():
        self._vertex_config[v]["label"] = label

    self.vertices = {v: vertex_type(**self._vertex_config[v]) for v in vertices}
    self.vertices.update(vertex_mobjects)

    self.change_layout(
        layout=layout,
        layout_scale=layout_scale,
        layout_config=layout_config,
        partitions=partitions,
        root_vertex=root_vertex,
    )

    # build edge_config
    if edge_config is None:
        edge_config = {}
    default_tip_config = {}
    default_edge_config = {}
    if edge_config:
        default_tip_config = edge_config.pop("tip_config", {})
        default_edge_config = {
            k: v
            for k, v in edge_config.items()
            if not isinstance(
                k, tuple
            )  # everything that is not an edge is an option
        }
    self._edge_config = {}
    self._tip_config = {}
    for e in edges:
        if e in edge_config:
            self._tip_config[e] = edge_config[e].pop(
                "tip_config", copy(default_tip_config)
            )
            self._edge_config[e] = edge_config[e]
        else:
            self._tip_config[e] = copy(default_tip_config)
            self._edge_config[e] = copy(default_edge_config)

    self.default_edge_config = default_edge_config
    self._populate_edge_dict(edges, edge_type)

    self.add(*self.vertices.values())
    self.add(*self.edges.values())

    self.add_updater(self.update_edges)

</t>
<t tx="ekr.20250122151620.755">@staticmethod
def _empty_networkx_graph() -&gt; nx.classes.graph.Graph:
    """Return an empty networkx graph for the given graph type."""
    raise NotImplementedError("To be implemented in concrete subclasses")

</t>
<t tx="ekr.20250122151620.756">def _populate_edge_dict(
    self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]
):
    """Helper method for populating the edges of the graph."""
    raise NotImplementedError("To be implemented in concrete subclasses")

</t>
<t tx="ekr.20250122151620.757">def __getitem__(self: Graph, v: Hashable) -&gt; Mobject:
    return self.vertices[v]

</t>
<t tx="ekr.20250122151620.758">def _create_vertex(
    self,
    vertex: Hashable,
    position: Point3DLike | None = None,
    label: bool = False,
    label_fill_color: str = BLACK,
    vertex_type: type[Mobject] = Dot,
    vertex_config: dict | None = None,
    vertex_mobject: dict | None = None,
) -&gt; tuple[Hashable, Point3D, dict, Mobject]:
    np_position: Point3D = (
        self.get_center() if position is None else np.asarray(position)
    )

    if vertex_config is None:
        vertex_config = {}

    if vertex in self.vertices:
        raise ValueError(
            f"Vertex identifier '{vertex}' is already used for a vertex in this graph.",
        )

    if label is True:
        label = MathTex(vertex, fill_color=label_fill_color)
    elif vertex in self._labels:
        label = self._labels[vertex]
    elif not isinstance(label, (Mobject, OpenGLMobject)):
        label = None

    base_vertex_config = copy(self.default_vertex_config)
    base_vertex_config.update(vertex_config)
    vertex_config = base_vertex_config

    if label is not None:
        vertex_config["label"] = label
        if vertex_type is Dot:
            vertex_type = LabeledDot

    if vertex_mobject is None:
        vertex_mobject = vertex_type(**vertex_config)

    vertex_mobject.move_to(np_position)

    return (vertex, np_position, vertex_config, vertex_mobject)

</t>
<t tx="ekr.20250122151620.759">def _add_created_vertex(
    self,
    vertex: Hashable,
    position: Point3DLike,
    vertex_config: dict,
    vertex_mobject: Mobject,
) -&gt; Mobject:
    if vertex in self.vertices:
        raise ValueError(
            f"Vertex identifier '{vertex}' is already used for a vertex in this graph.",
        )

    self._graph.add_node(vertex)
    self._layout[vertex] = position

    if "label" in vertex_config:
        self._labels[vertex] = vertex_config["label"]

    self._vertex_config[vertex] = vertex_config

    self.vertices[vertex] = vertex_mobject
    self.vertices[vertex].move_to(position)
    self.add(self.vertices[vertex])

    return self.vertices[vertex]

</t>
<t tx="ekr.20250122151620.76">@save_sections.setter
def save_sections(self, value: bool) -&gt; None:
    self._set_boolean("save_sections", value)

</t>
<t tx="ekr.20250122151620.760">def _add_vertex(
    self,
    vertex: Hashable,
    position: Point3DLike | None = None,
    label: bool = False,
    label_fill_color: str = BLACK,
    vertex_type: type[Mobject] = Dot,
    vertex_config: dict | None = None,
    vertex_mobject: dict | None = None,
) -&gt; Mobject:
    """Add a vertex to the graph.

    Parameters
    ----------

    vertex
        A hashable vertex identifier.
    position
        The coordinates where the new vertex should be added. If ``None``, the center
        of the graph is used.
    label
        Controls whether or not the vertex is labeled. If ``False`` (the default),
        the vertex is not labeled; if ``True`` it is labeled using its
        names (as specified in ``vertex``) via :class:`~.MathTex`. Alternatively,
        any :class:`~.Mobject` can be passed to be used as the label.
    label_fill_color
        Sets the fill color of the default labels generated when ``labels``
        is set to ``True``. Has no effect for other values of ``label``.
    vertex_type
        The mobject class used for displaying vertices in the scene.
    vertex_config
        A dictionary containing keyword arguments to be passed to
        the class specified via ``vertex_type``.
    vertex_mobject
        The mobject to be used as the vertex. Overrides all other
        vertex customization options.
    """
    return self._add_created_vertex(
        *self._create_vertex(
            vertex=vertex,
            position=position,
            label=label,
            label_fill_color=label_fill_color,
            vertex_type=vertex_type,
            vertex_config=vertex_config,
            vertex_mobject=vertex_mobject,
        )
    )

</t>
<t tx="ekr.20250122151620.761">def _create_vertices(
    self: Graph,
    *vertices: Hashable,
    positions: dict | None = None,
    labels: bool = False,
    label_fill_color: str = BLACK,
    vertex_type: type[Mobject] = Dot,
    vertex_config: dict | None = None,
    vertex_mobjects: dict | None = None,
) -&gt; Iterable[tuple[Hashable, Point3D, dict, Mobject]]:
    if positions is None:
        positions = {}
    if vertex_mobjects is None:
        vertex_mobjects = {}

    graph_center = self.get_center()
    base_positions = {v: graph_center for v in vertices}
    base_positions.update(positions)
    positions = base_positions

    if isinstance(labels, bool):
        labels = {v: labels for v in vertices}
    else:
        assert isinstance(labels, dict)
        base_labels = dict.fromkeys(vertices, False)
        base_labels.update(labels)
        labels = base_labels

    if vertex_config is None:
        vertex_config = copy(self.default_vertex_config)

    assert isinstance(vertex_config, dict)
    base_vertex_config = copy(self.default_vertex_config)
    base_vertex_config.update(
        {key: val for key, val in vertex_config.items() if key not in vertices},
    )
    vertex_config = {
        v: (vertex_config[v] if v in vertex_config else copy(base_vertex_config))
        for v in vertices
    }

    return [
        self._create_vertex(
            v,
            position=positions[v],
            label=labels[v],
            label_fill_color=label_fill_color,
            vertex_type=vertex_type,
            vertex_config=vertex_config[v],
            vertex_mobject=vertex_mobjects.get(v),
        )
        for v in vertices
    ]

</t>
<t tx="ekr.20250122151620.762">def add_vertices(
    self: Graph,
    *vertices: Hashable,
    positions: dict | None = None,
    labels: bool = False,
    label_fill_color: str = BLACK,
    vertex_type: type[Mobject] = Dot,
    vertex_config: dict | None = None,
    vertex_mobjects: dict | None = None,
):
    """Add a list of vertices to the graph.

    Parameters
    ----------

    vertices
        Hashable vertex identifiers.
    positions
        A dictionary specifying the coordinates where the new vertices should be added.
        If ``None``, all vertices are created at the center of the graph.
    labels
        Controls whether or not the vertex is labeled. If ``False`` (the default),
        the vertex is not labeled; if ``True`` it is labeled using its
        names (as specified in ``vertex``) via :class:`~.MathTex`. Alternatively,
        any :class:`~.Mobject` can be passed to be used as the label.
    label_fill_color
        Sets the fill color of the default labels generated when ``labels``
        is set to ``True``. Has no effect for other values of ``labels``.
    vertex_type
        The mobject class used for displaying vertices in the scene.
    vertex_config
        A dictionary containing keyword arguments to be passed to
        the class specified via ``vertex_type``.
    vertex_mobjects
        A dictionary whose keys are the vertex identifiers, and whose
        values are mobjects that should be used as vertices. Overrides
        all other vertex customization options.
    """
    return [
        self._add_created_vertex(*v)
        for v in self._create_vertices(
            *vertices,
            positions=positions,
            labels=labels,
            label_fill_color=label_fill_color,
            vertex_type=vertex_type,
            vertex_config=vertex_config,
            vertex_mobjects=vertex_mobjects,
        )
    ]

</t>
<t tx="ekr.20250122151620.763">@override_animate(add_vertices)
def _add_vertices_animation(self, *args, anim_args=None, **kwargs):
    if anim_args is None:
        anim_args = {}

    animation = anim_args.pop("animation", Create)

    vertex_mobjects = self._create_vertices(*args, **kwargs)

    def on_finish(scene: Scene):
        for v in vertex_mobjects:
            scene.remove(v[-1])
            self._add_created_vertex(*v)

    return AnimationGroup(
        *(animation(v[-1], **anim_args) for v in vertex_mobjects),
        group=self,
        _on_finish=on_finish,
    )

</t>
<t tx="ekr.20250122151620.764">def _remove_vertex(self, vertex):
    """Remove a vertex (as well as all incident edges) from the graph.

    Parameters
    ----------

    vertex
        The identifier of a vertex to be removed.

    Returns
    -------

    Group
        A mobject containing all removed objects.

    """
    if vertex not in self.vertices:
        raise ValueError(
            f"The graph does not contain a vertex with identifier '{vertex}'",
        )

    self._graph.remove_node(vertex)
    self._layout.pop(vertex)
    if vertex in self._labels:
        self._labels.pop(vertex)
    self._vertex_config.pop(vertex)

    edge_tuples = [e for e in self.edges if vertex in e]
    for e in edge_tuples:
        self._edge_config.pop(e)
    to_remove = [self.edges.pop(e) for e in edge_tuples]
    to_remove.append(self.vertices.pop(vertex))

    self.remove(*to_remove)
    return self.get_group_class()(*to_remove)

</t>
<t tx="ekr.20250122151620.765">def remove_vertices(self, *vertices):
    """Remove several vertices from the graph.

    Parameters
    ----------

    vertices
        Vertices to be removed from the graph.

    Examples
    --------
    ::

        &gt;&gt;&gt; G = Graph([1, 2, 3], [(1, 2), (2, 3)])
        &gt;&gt;&gt; removed = G.remove_vertices(2, 3); removed
        VGroup(Line, Line, Dot, Dot)
        &gt;&gt;&gt; G
        Undirected graph on 1 vertices and 0 edges

    """
    mobjects = []
    for v in vertices:
        mobjects.extend(self._remove_vertex(v).submobjects)
    return self.get_group_class()(*mobjects)

</t>
<t tx="ekr.20250122151620.766">@override_animate(remove_vertices)
def _remove_vertices_animation(self, *vertices, anim_args=None):
    if anim_args is None:
        anim_args = {}

    animation = anim_args.pop("animation", Uncreate)

    mobjects = self.remove_vertices(*vertices)
    return AnimationGroup(
        *(animation(mobj, **anim_args) for mobj in mobjects), group=self
    )

</t>
<t tx="ekr.20250122151620.767">def _add_edge(
    self,
    edge: tuple[Hashable, Hashable],
    edge_type: type[Mobject] = Line,
    edge_config: dict | None = None,
):
    """Add a new edge to the graph.

    Parameters
    ----------

    edge
        The edge (as a tuple of vertex identifiers) to be added. If a non-existing
        vertex is passed, a new vertex with default settings will be created. Create
        new vertices yourself beforehand to customize them.
    edge_type
        The mobject class used for displaying edges in the scene.
    edge_config
        A dictionary containing keyword arguments to be passed
        to the class specified via ``edge_type``.

    Returns
    -------
    Group
        A group containing all newly added vertices and edges.

    """
    if edge_config is None:
        edge_config = self.default_edge_config.copy()
    added_mobjects = []
    for v in edge:
        if v not in self.vertices:
            added_mobjects.append(self._add_vertex(v))
    u, v = edge

    self._graph.add_edge(u, v)

    base_edge_config = self.default_edge_config.copy()
    base_edge_config.update(edge_config)
    edge_config = base_edge_config
    self._edge_config[(u, v)] = edge_config

    edge_mobject = edge_type(
        self[u].get_center(), self[v].get_center(), z_index=-1, **edge_config
    )
    self.edges[(u, v)] = edge_mobject

    self.add(edge_mobject)
    added_mobjects.append(edge_mobject)
    return self.get_group_class()(*added_mobjects)

</t>
<t tx="ekr.20250122151620.768">def add_edges(
    self,
    *edges: tuple[Hashable, Hashable],
    edge_type: type[Mobject] = Line,
    edge_config: dict | None = None,
    **kwargs,
):
    """Add new edges to the graph.

    Parameters
    ----------

    edges
        Edges (as tuples of vertex identifiers) to be added. If a non-existing
        vertex is passed, a new vertex with default settings will be created. Create
        new vertices yourself beforehand to customize them.
    edge_type
        The mobject class used for displaying edges in the scene.
    edge_config
        A dictionary either containing keyword arguments to be passed
        to the class specified via ``edge_type``, or a dictionary
        whose keys are the edge tuples, and whose values are dictionaries
        containing keyword arguments to be passed for the construction
        of the corresponding edge.
    kwargs
        Any further keyword arguments are passed to :meth:`.add_vertices`
        which is used to create new vertices in the passed edges.

    Returns
    -------
    Group
        A group containing all newly added vertices and edges.

    """
    if edge_config is None:
        edge_config = {}
    non_edge_settings = {k: v for (k, v) in edge_config.items() if k not in edges}
    base_edge_config = self.default_edge_config.copy()
    base_edge_config.update(non_edge_settings)
    base_edge_config = {e: base_edge_config.copy() for e in edges}
    for e in edges:
        base_edge_config[e].update(edge_config.get(e, {}))
    edge_config = base_edge_config

    edge_vertices = set(it.chain(*edges))
    new_vertices = [v for v in edge_vertices if v not in self.vertices]
    added_vertices = self.add_vertices(*new_vertices, **kwargs)

    added_mobjects = sum(
        (
            self._add_edge(
                edge,
                edge_type=edge_type,
                edge_config=edge_config[edge],
            ).submobjects
            for edge in edges
        ),
        added_vertices,
    )
    return self.get_group_class()(*added_mobjects)

</t>
<t tx="ekr.20250122151620.769">@override_animate(add_edges)
def _add_edges_animation(self, *args, anim_args=None, **kwargs):
    if anim_args is None:
        anim_args = {}
    animation = anim_args.pop("animation", Create)

    mobjects = self.add_edges(*args, **kwargs)
    return AnimationGroup(
        *(animation(mobj, **anim_args) for mobj in mobjects), group=self
    )

</t>
<t tx="ekr.20250122151620.77">@property
def enable_wireframe(self) -&gt; bool:
    """Whether to enable wireframe debugging mode in opengl."""
    return self._d["enable_wireframe"]

</t>
<t tx="ekr.20250122151620.770">def _remove_edge(self, edge: tuple[Hashable]):
    """Remove an edge from the graph.

    Parameters
    ----------

    edge
        The edge (i.e., a tuple of vertex identifiers) to be removed from the graph.

    Returns
    -------

    Mobject
        The removed edge.

    """
    if edge not in self.edges:
        raise ValueError(f"The graph does not contain a edge '{edge}'")

    edge_mobject = self.edges.pop(edge)

    self._graph.remove_edge(*edge)
    self._edge_config.pop(edge, None)

    self.remove(edge_mobject)
    return edge_mobject

</t>
<t tx="ekr.20250122151620.771">def remove_edges(self, *edges: tuple[Hashable]):
    """Remove several edges from the graph.

    Parameters
    ----------
    edges
        Edges to be removed from the graph.

    Returns
    -------
    Group
        A group containing all removed edges.

    """
    edge_mobjects = [self._remove_edge(edge) for edge in edges]
    return self.get_group_class()(*edge_mobjects)

</t>
<t tx="ekr.20250122151620.772">@override_animate(remove_edges)
def _remove_edges_animation(self, *edges, anim_args=None):
    if anim_args is None:
        anim_args = {}

    animation = anim_args.pop("animation", Uncreate)

    mobjects = self.remove_edges(*edges)
    return AnimationGroup(*(animation(mobj, **anim_args) for mobj in mobjects))

</t>
<t tx="ekr.20250122151620.773">@classmethod
def from_networkx(
    cls, nxgraph: nx.classes.graph.Graph | nx.classes.digraph.DiGraph, **kwargs
):
    """Build a :class:`~.Graph` or :class:`~.DiGraph` from a
    given ``networkx`` graph.

    Parameters
    ----------

    nxgraph
        A ``networkx`` graph or digraph.
    **kwargs
        Keywords to be passed to the constructor of :class:`~.Graph`.

    Examples
    --------

    .. manim:: ImportNetworkxGraph

        import networkx as nx

        nxgraph = nx.erdos_renyi_graph(14, 0.5)

        class ImportNetworkxGraph(Scene):
            def construct(self):
                G = Graph.from_networkx(nxgraph, layout="spring", layout_scale=3.5)
                self.play(Create(G))
                self.play(*[G[v].animate.move_to(5*RIGHT*np.cos(ind/7 * PI) +
                                                 3*UP*np.sin(ind/7 * PI))
                            for ind, v in enumerate(G.vertices)])
                self.play(Uncreate(G))

    """
    return cls(list(nxgraph.nodes), list(nxgraph.edges), **kwargs)

</t>
<t tx="ekr.20250122151620.774">def change_layout(
    self,
    layout: LayoutName | dict[Hashable, Point3DLike] | LayoutFunction = "spring",
    layout_scale: float | tuple[float, float, float] = 2,
    layout_config: dict[str, Any] | None = None,
    partitions: list[list[Hashable]] | None = None,
    root_vertex: Hashable | None = None,
) -&gt; Graph:
    """Change the layout of this graph.

    See the documentation of :class:`~.Graph` for details about the
    keyword arguments.

    Examples
    --------

    .. manim:: ChangeGraphLayout

        class ChangeGraphLayout(Scene):
            def construct(self):
                G = Graph([1, 2, 3, 4, 5], [(1, 2), (2, 3), (3, 4), (4, 5)],
                          layout={1: [-2, 0, 0], 2: [-1, 0, 0], 3: [0, 0, 0],
                                  4: [1, 0, 0], 5: [2, 0, 0]}
                          )
                self.play(Create(G))
                self.play(G.animate.change_layout("circular"))
                self.wait()
    """
    layout_config = {} if layout_config is None else layout_config
    if partitions is not None and "partitions" not in layout_config:
        layout_config["partitions"] = partitions
    if root_vertex is not None and "root_vertex" not in layout_config:
        layout_config["root_vertex"] = root_vertex

    self._layout = _determine_graph_layout(
        self._graph,
        layout=layout,
        layout_scale=layout_scale,
        layout_config=layout_config,
    )

    for v in self.vertices:
        self[v].move_to(self._layout[v])
    return self


</t>
<t tx="ekr.20250122151620.775">@staticmethod
def _empty_networkx_graph() -&gt; nx.Graph:
    return nx.Graph()

</t>
<t tx="ekr.20250122151620.776">def _populate_edge_dict(
    self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]
):
    self.edges = {
        (u, v): edge_type(
            self[u].get_center(),
            self[v].get_center(),
            z_index=-1,
            **self._edge_config[(u, v)],
        )
        for (u, v) in edges
    }

</t>
<t tx="ekr.20250122151620.777">def update_edges(self, graph):
    for (u, v), edge in graph.edges.items():
        # Undirected graph has a Line edge
        edge.set_points_by_ends(
            graph[u].get_center(),
            graph[v].get_center(),
            buff=self._edge_config.get("buff", 0),
            path_arc=self._edge_config.get("path_arc", 0),
        )

</t>
<t tx="ekr.20250122151620.778">def __repr__(self: Graph) -&gt; str:
    return f"Undirected graph on {len(self.vertices)} vertices and {len(self.edges)} edges"


</t>
<t tx="ekr.20250122151620.779">@staticmethod
def _empty_networkx_graph() -&gt; nx.DiGraph:
    return nx.DiGraph()

</t>
<t tx="ekr.20250122151620.78">@enable_wireframe.setter
def enable_wireframe(self, value: bool) -&gt; None:
    self._set_boolean("enable_wireframe", value)

</t>
<t tx="ekr.20250122151620.780">def _populate_edge_dict(
    self, edges: list[tuple[Hashable, Hashable]], edge_type: type[Mobject]
):
    self.edges = {
        (u, v): edge_type(
            self[u],
            self[v],
            z_index=-1,
            **self._edge_config[(u, v)],
        )
        for (u, v) in edges
    }

    for (u, v), edge in self.edges.items():
        edge.add_tip(**self._tip_config[(u, v)])

</t>
<t tx="ekr.20250122151620.781">def update_edges(self, graph):
    """Updates the edges to stick at their corresponding vertices.

    Arrow tips need to be repositioned since otherwise they can be
    deformed.
    """
    for (u, v), edge in graph.edges.items():
        tip = edge.pop_tips()[0]
        # Passing the Mobject instead of the vertex makes the tip
        # stop on the bounding box of the vertex.
        edge.set_points_by_ends(
            graph[u],
            graph[v],
            buff=self._edge_config.get("buff", 0),
            path_arc=self._edge_config.get("path_arc", 0),
        )
        edge.add_tip(tip)

</t>
<t tx="ekr.20250122151620.782">def __repr__(self: DiGraph) -&gt; str:
    return f"Directed graph on {len(self.vertices)} vertices and {len(self.edges)} edges"
</t>
<t tx="ekr.20250122151620.783">"""Utilities for Manim's logo and banner."""

from __future__ import annotations

__all__ = ["ManimBanner"]

import svgelements as se

from manim.animation.updaters.update import UpdateFromAlphaFunc
from manim.mobject.geometry.arc import Circle
from manim.mobject.geometry.polygram import Square, Triangle

from .. import constants as cst
from ..animation.animation import override_animation
from ..animation.composition import AnimationGroup, Succession
from ..animation.creation import Create, SpiralIn
from ..animation.fading import FadeIn
from ..mobject.svg.svg_mobject import VMobjectFromSVGPath
from ..mobject.types.vectorized_mobject import VGroup
from ..utils.rate_functions import ease_in_out_cubic, smooth

MANIM_SVG_PATHS: list[se.Path] = [
    se.Path(  # double stroke letter M
        "M4.64259-2.092154L2.739726-6.625156C2.660025-6.824408 2.650062-6.824408 "
        "2.381071-6.824408H.52802C.348692-6.824408 .199253-6.824408 .199253-6.645"
        "081C.199253-6.475716 .37858-6.475716 .428394-6.475716C.547945-6.475716 ."
        "816936-6.455791 1.036115-6.37609V-1.05604C1.036115-.846824 1.036115-.408"
        "468 .358655-.348692C.169365-.328767 .169365-.18929 .169365-.179328C.1693"
        "65 0 .328767 0 .508095 0H2.052304C2.231631 0 2.381071 0 2.381071-.179328"
        "C2.381071-.268991 2.30137-.33873 2.221669-.348692C1.454545-.408468 1.454"
        "545-.826899 1.454545-1.05604V-6.017435L1.464508-6.027397L3.895392-.20921"
        "5C3.975093-.029888 4.044832 0 4.104608 0C4.224159 0 4.254047-.079701 4.3"
        "03861-.199253L6.744707-6.027397L6.75467-6.017435V-1.05604C6.75467-.84682"
        "4 6.75467-.408468 6.07721-.348692C5.88792-.328767 5.88792-.18929 5.88792"
        "-.179328C5.88792 0 6.047323 0 6.22665 0H8.886675C9.066002 0 9.215442 0 9"
        ".215442-.179328C9.215442-.268991 9.135741-.33873 9.05604-.348692C8.28891"
        "7-.408468 8.288917-.826899 8.288917-1.05604V-5.768369C8.288917-5.977584 "
        "8.288917-6.41594 8.966376-6.475716C9.066002-6.485679 9.155666-6.535492 9"
        ".155666-6.645081C9.155666-6.824408 9.006227-6.824408 8.826899-6.824408H6"
        ".90411C6.645081-6.824408 6.625156-6.824408 6.535492-6.615193L4.64259-2.0"
        "92154ZM4.343711-1.912827C4.423412-1.743462 4.433375-1.733499 4.552927-1."
        "693649L4.11457-.637609H4.094645L1.823163-6.057285C1.77335-6.1868 1.69364"
        "9-6.356164 1.554172-6.475716H2.420922L4.343711-1.912827ZM1.334994-.34869"
        "2H1.165629C1.185554-.37858 1.205479-.408468 1.225405-.428394C1.235367-.4"
        "38356 1.235367-.448319 1.24533-.458281L1.334994-.348692ZM7.103362-6.4757"
        "16H8.159402C7.940224-6.22665 7.940224-5.967621 7.940224-5.788294V-1.0361"
        "15C7.940224-.856787 7.940224-.597758 8.169365-.348692H6.884184C7.103362-"
        ".597758 7.103362-.856787 7.103362-1.036115V-6.475716Z"
    ),
    se.Path(  # letter a
        "M1.464508-4.024907C1.464508-4.234122 1.743462-4.393524 2.092154-4.393524"
        "C2.669988-4.393524 2.929016-4.124533 2.929016-3.516812V-2.789539C1.77335"
        "-2.440847 .249066-2.042341 .249066-.916563C.249066-.308842 .71731 .13947"
        "7 1.354919 .139477C1.92279 .139477 2.381071-.059776 2.929016-.557908C3.0"
        "38605-.049813 3.257783 .139477 3.745953 .139477C4.174346 .139477 4.48318"
        "8-.019925 4.861768-.428394L4.712329-.637609L4.612702-.537983C4.582814-.5"
        "08095 4.552927-.498132 4.503113-.498132C4.363636-.498132 4.293898-.58779"
        "6 4.293898-.747198V-3.347447C4.293898-4.184309 3.536737-4.712329 2.32129"
        "5-4.712329C1.195517-4.712329 .438356-4.204234 .438356-3.457036C.438356-3"
        ".048568 .67746-2.799502 1.085928-2.799502C1.484433-2.799502 1.763387-3.0"
        "38605 1.763387-3.377335C1.763387-3.676214 1.464508-3.88543 1.464508-4.02"
        "4907ZM2.919054-.996264C2.650062-.687422 2.450809-.56787 2.211706-.56787C"
        "1.912827-.56787 1.703611-.836862 1.703611-1.235367C1.703611-1.8132 2.122"
        "042-2.231631 2.919054-2.440847V-.996264Z"
    ),
    se.Path(  # letter n
        "M2.948941-4.044832C3.297634-4.044832 3.466999-3.775841 3.466999-3.217933"
        "V-.806974C3.466999-.438356 3.337484-.278954 2.998755-.239103V0H5.339975V"
        "-.239103C4.951432-.268991 4.851806-.388543 4.851806-.806974V-3.307597C4."
        "851806-4.164384 4.323786-4.712329 3.506849-4.712329C2.909091-4.712329 2."
        "450809-4.433375 2.082192-3.845579V-4.592777H.179328V-4.353674C.617684-4."
        "283935 .707347-4.184309 .707347-3.765878V-.836862C.707347-.418431 .62764"
        "6-.328767 .179328-.239103V0H2.580324V-.239103C2.211706-.288917 2.092154-"
        ".438356 2.092154-.806974V-3.466999C2.092154-3.576588 2.530511-4.044832 2"
        ".948941-4.044832Z"
    ),
    se.Path(  # letter i
        "M2.15193-4.592777H.239103V-4.353674C.67746-4.26401 .767123-4.174346 .767"
        "123-3.765878V-.836862C.767123-.428394 .697385-.348692 .239103-.239103V0H"
        "2.6401V-.239103C2.291407-.288917 2.15193-.428394 2.15193-.806974V-4.5927"
        "77ZM1.454545-6.884184C1.026152-6.884184 .67746-6.535492 .67746-6.117061C"
        ".67746-5.668742 1.006227-5.339975 1.444583-5.339975S2.221669-5.668742 2."
        "221669-6.107098C2.221669-6.535492 1.882939-6.884184 1.454545-6.884184Z"
    ),
    se.Path(  # letter m
        "M2.929016-4.044832C3.317559-4.044832 3.466999-3.815691 3.466999-3.217933"
        "V-.806974C3.466999-.398506 3.35741-.268991 2.988792-.239103V0H5.32005V-."
        "239103C4.971357-.278954 4.851806-.428394 4.851806-.806974V-3.466999C4.85"
        "1806-3.576588 5.310087-4.044832 5.69863-4.044832C6.07721-4.044832 6.2266"
        "5-3.805729 6.22665-3.217933V-.806974C6.22665-.388543 6.117061-.268991 5."
        "738481-.239103V0H8.109589V-.239103C7.721046-.259029 7.611457-.37858 7.61"
        "1457-.806974V-3.307597C7.611457-4.164384 7.083437-4.712329 6.266501-4.71"
        "2329C5.69863-4.712329 5.32005-4.483188 4.801993-3.845579C4.503113-4.4732"
        "25 4.154421-4.712329 3.526775-4.712329S2.440847-4.443337 2.062267-3.8455"
        "79V-4.592777H.179328V-4.353674C.617684-4.293898 .707347-4.174346 .707347"
        "-3.765878V-.836862C.707347-.428394 .617684-.318804 .179328-.239103V0H2.5"
        "50436V-.239103C2.201743-.288917 2.092154-.428394 2.092154-.806974V-3.466"
        "999C2.092154-3.58655 2.530511-4.044832 2.929016-4.044832Z"
    ),
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.784">class ManimBanner(VGroup):
    @others
</t>
<t tx="ekr.20250122151620.785">r"""Convenience class representing Manim's banner.

Can be animated using custom methods.

Parameters
----------
dark_theme
    If ``True`` (the default), the dark theme version of the logo
    (with light text font) will be rendered. Otherwise, if ``False``,
    the light theme version (with dark text font) is used.

Examples
--------
.. manim:: DarkThemeBanner

    class DarkThemeBanner(Scene):
        def construct(self):
            banner = ManimBanner()
            self.play(banner.create())
            self.play(banner.expand())
            self.wait()
            self.play(Unwrite(banner))

.. manim:: LightThemeBanner

    class LightThemeBanner(Scene):
        def construct(self):
            self.camera.background_color = "#ece6e2"
            banner = ManimBanner(dark_theme=False)
            self.play(banner.create())
            self.play(banner.expand())
            self.wait()
            self.play(Unwrite(banner))

"""

def __init__(self, dark_theme: bool = True):
    super().__init__()

    logo_green = "#81b29a"
    logo_blue = "#454866"
    logo_red = "#e07a5f"
    m_height_over_anim_height = 0.75748

    self.font_color = "#ece6e2" if dark_theme else "#343434"
    self.scale_factor = 1

    self.M = VMobjectFromSVGPath(MANIM_SVG_PATHS[0]).flip(cst.RIGHT).center()
    self.M.set(stroke_width=0).scale(
        7 * cst.DEFAULT_FONT_SIZE * cst.SCALE_FACTOR_PER_FONT_POINT
    )
    self.M.set_fill(color=self.font_color, opacity=1).shift(
        2.25 * cst.LEFT + 1.5 * cst.UP
    )

    self.circle = Circle(color=logo_green, fill_opacity=1).shift(cst.LEFT)
    self.square = Square(color=logo_blue, fill_opacity=1).shift(cst.UP)
    self.triangle = Triangle(color=logo_red, fill_opacity=1).shift(cst.RIGHT)
    self.shapes = VGroup(self.triangle, self.square, self.circle)
    self.add(self.shapes, self.M)
    self.move_to(cst.ORIGIN)

    anim = VGroup()
    for ind, path in enumerate(MANIM_SVG_PATHS[1:]):
        tex = VMobjectFromSVGPath(path).flip(cst.RIGHT).center()
        tex.set(stroke_width=0).scale(
            cst.DEFAULT_FONT_SIZE * cst.SCALE_FACTOR_PER_FONT_POINT
        )
        if ind &gt; 0:
            tex.next_to(anim, buff=0.01)
        tex.align_to(self.M, cst.DOWN)
        anim.add(tex)
    anim.set_fill(color=self.font_color, opacity=1)
    anim.height = m_height_over_anim_height * self.M.height

    # Note: "anim" is only shown in the expanded state
    # and thus not yet added to the submobjects of self.
    self.anim = anim

</t>
<t tx="ekr.20250122151620.786">def scale(self, scale_factor: float, **kwargs) -&gt; ManimBanner:
    """Scale the banner by the specified scale factor.

    Parameters
    ----------
    scale_factor
        The factor used for scaling the banner.

    Returns
    -------
    :class:`~.ManimBanner`
        The scaled banner.
    """
    self.scale_factor *= scale_factor
    # Note: self.anim is only added to self after expand()
    if self.anim not in self.submobjects:
        self.anim.scale(scale_factor, **kwargs)
    return super().scale(scale_factor, **kwargs)

</t>
<t tx="ekr.20250122151620.787">@override_animation(Create)
def create(self, run_time: float = 2) -&gt; AnimationGroup:
    """The creation animation for Manim's logo.

    Parameters
    ----------
    run_time
        The run time of the animation.

    Returns
    -------
    :class:`~.AnimationGroup`
        An animation to be used in a :meth:`.Scene.play` call.
    """
    return AnimationGroup(
        SpiralIn(self.shapes, run_time=run_time),
        FadeIn(self.M, run_time=run_time / 2),
        lag_ratio=0.1,
    )

</t>
<t tx="ekr.20250122151620.788">def expand(self, run_time: float = 1.5, direction="center") -&gt; Succession:
    """An animation that expands Manim's logo into its banner.

    The returned animation transforms the banner from its initial
    state (representing Manim's logo with just the icons) to its
    expanded state (showing the full name together with the icons).

    See the class documentation for how to use this.

    .. note::

        Before calling this method, the text "anim" is not a
        submobject of the banner object. After the expansion,
        it is added as a submobject so subsequent animations
        to the banner object apply to the text "anim" as well.

    Parameters
    ----------
    run_time
        The run time of the animation.
    direction
        The direction in which the logo is expanded.

    Returns
    -------
    :class:`~.Succession`
        An animation to be used in a :meth:`.Scene.play` call.

    Examples
    --------
    .. manim:: ExpandDirections

        class ExpandDirections(Scene):
            def construct(self):
                banners = [ManimBanner().scale(0.5).shift(UP*x) for x in [-2, 0, 2]]
                self.play(
                    banners[0].expand(direction="right"),
                    banners[1].expand(direction="center"),
                    banners[2].expand(direction="left"),
                )

    """
    if direction not in ["left", "right", "center"]:
        raise ValueError("direction must be 'left', 'right' or 'center'.")

    m_shape_offset = 6.25 * self.scale_factor
    shape_sliding_overshoot = self.scale_factor * 0.8
    m_anim_buff = 0.06
    self.anim.next_to(self.M, buff=m_anim_buff).align_to(self.M, cst.DOWN)
    self.anim.set_opacity(0)
    self.shapes.save_state()
    m_clone = self.anim[-1].copy()
    self.add(m_clone)
    m_clone.move_to(self.shapes)

    self.M.save_state()
    left_group = VGroup(self.M, self.anim, m_clone)

    def shift(vector):
        self.shapes.restore()
        left_group.align_to(self.M.saved_state, cst.LEFT)
        if direction == "right":
            self.shapes.shift(vector)
        elif direction == "center":
            self.shapes.shift(vector / 2)
            left_group.shift(-vector / 2)
        elif direction == "left":
            left_group.shift(-vector)

    def slide_and_uncover(mob, alpha):
        shift(alpha * (m_shape_offset + shape_sliding_overshoot) * cst.RIGHT)

        # Add letters when they are covered
        for letter in mob.anim:
            if mob.square.get_center()[0] &gt; letter.get_center()[0]:
                letter.set_opacity(1)
                self.add_to_back(letter)

        # Finish animation
        if alpha == 1:
            self.remove(*[self.anim])
            self.add_to_back(self.anim)
            mob.shapes.set_z_index(0)
            mob.shapes.save_state()
            mob.M.save_state()

    def slide_back(mob, alpha):
        if alpha == 0:
            m_clone.set_opacity(1)
            m_clone.move_to(mob.anim[-1])
            mob.anim.set_opacity(1)

        shift(alpha * shape_sliding_overshoot * cst.LEFT)

        if alpha == 1:
            mob.remove(m_clone)
            mob.add_to_back(mob.shapes)

    return Succession(
        UpdateFromAlphaFunc(
            self,
            slide_and_uncover,
            run_time=run_time * 2 / 3,
            rate_func=ease_in_out_cubic,
        ),
        UpdateFromAlphaFunc(
            self,
            slide_back,
            run_time=run_time * 1 / 3,
            rate_func=smooth,
        ),
    )
</t>
<t tx="ekr.20250122151620.789">r"""Mobjects representing matrices.

Examples
--------

.. manim:: MatrixExamples
    :save_last_frame:

    class MatrixExamples(Scene):
        def construct(self):
            m0 = Matrix([["\\pi", 0], [-1, 1]])
            m1 = IntegerMatrix([[1.5, 0.], [12, -1.3]],
                left_bracket="(",
                right_bracket=")")
            m2 = DecimalMatrix(
                [[3.456, 2.122], [33.2244, 12.33]],
                element_to_mobject_config={"num_decimal_places": 2},
                left_bracket=r"\{",
                right_bracket=r"\}")
            m3 = MobjectMatrix(
                [[Circle().scale(0.3), Square().scale(0.3)],
                [MathTex("\\pi").scale(2), Star().scale(0.3)]],
                left_bracket="\\langle",
                right_bracket="\\rangle")
            g = Group(m0, m1, m2, m3).arrange_in_grid(buff=2)
            self.add(g)
"""

from __future__ import annotations

__all__ = [
    "Matrix",
    "DecimalMatrix",
    "IntegerMatrix",
    "MobjectMatrix",
    "matrix_to_tex_string",
    "matrix_to_mobject",
    "get_det_text",
]


import itertools as it
from collections.abc import Iterable, Sequence

import numpy as np

from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.text.numbers import DecimalNumber, Integer
from manim.mobject.text.tex_mobject import MathTex, Tex

from ..constants import *
from ..mobject.types.vectorized_mobject import VGroup, VMobject

# TO DO : The following two functions are not used in this file.
#         Not sure if we should keep it or not.


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.79">@property
def force_window(self) -&gt; bool:
    """Whether to force window when using the opengl renderer."""
    return self._d["force_window"]

</t>
<t tx="ekr.20250122151620.790">def matrix_to_tex_string(matrix):
    matrix = np.array(matrix).astype("str")
    if matrix.ndim == 1:
        matrix = matrix.reshape((matrix.size, 1))
    n_rows, n_cols = matrix.shape
    prefix = "\\left[ \\begin{array}{%s}" % ("c" * n_cols)
    suffix = "\\end{array} \\right]"
    rows = [" &amp; ".join(row) for row in matrix]
    return prefix + " \\\\ ".join(rows) + suffix


</t>
<t tx="ekr.20250122151620.791">def matrix_to_mobject(matrix):
    return MathTex(matrix_to_tex_string(matrix))


</t>
<t tx="ekr.20250122151620.792">class Matrix(VMobject, metaclass=ConvertToOpenGL):
    @others
</t>
<t tx="ekr.20250122151620.793">class DecimalMatrix(Matrix):
    @others
</t>
<t tx="ekr.20250122151620.794">class IntegerMatrix(Matrix):
    """A mobject that displays a matrix with integer entries on the screen.

    Examples
    --------

    .. manim:: IntegerMatrixExample
        :save_last_frame:

        class IntegerMatrixExample(Scene):
            def construct(self):
                m0 = IntegerMatrix(
                    [[3.7, 2], [42.2, 12]],
                    left_bracket="(",
                    right_bracket=")")
                self.add(m0)
    """

    @others
</t>
<t tx="ekr.20250122151620.795">class MobjectMatrix(Matrix):
    @others
</t>
<t tx="ekr.20250122151620.796">def get_det_text(
    matrix: Matrix,
    determinant: int | str | None = None,
    background_rect: bool = False,
    initial_scale_factor: float = 2,
):
    r"""Helper function to create determinant.

    Parameters
    ----------
    matrix
        The matrix whose determinant is to be created

    determinant
        The value of the determinant of the matrix

    background_rect
        The background rectangle

    initial_scale_factor
        The scale of the text `det` w.r.t the matrix

    Returns
    --------
    :class:`~.VGroup`
        A VGroup containing the determinant

    Examples
    --------

    .. manim:: DeterminantOfAMatrix
        :save_last_frame:

        class DeterminantOfAMatrix(Scene):
            def construct(self):
                matrix = Matrix([
                    [2, 0],
                    [-1, 1]
                ])

                # scaling down the `det` string
                det = get_det_text(matrix,
                            determinant=3,
                            initial_scale_factor=1)

                # must add the matrix
                self.add(matrix)
                self.add(det)
    """
    parens = MathTex("(", ")")
    parens.scale(initial_scale_factor)
    parens.stretch_to_fit_height(matrix.height)
    l_paren, r_paren = parens.split()
    l_paren.next_to(matrix, LEFT, buff=0.1)
    r_paren.next_to(matrix, RIGHT, buff=0.1)
    det = Tex("det")
    det.scale(initial_scale_factor)
    det.next_to(l_paren, LEFT, buff=0.1)
    if background_rect:
        det.add_background_rectangle()
    det_text = VGroup(det, l_paren, r_paren)
    if determinant is not None:
        eq = MathTex("=")
        eq.next_to(r_paren, RIGHT, buff=0.1)
        result = MathTex(str(determinant))
        result.next_to(eq, RIGHT, buff=0.2)
        det_text.add(eq, result)
    return det_text
</t>
<t tx="ekr.20250122151620.797">r"""A mobject that displays a matrix on the screen.

Parameters
----------
matrix
    A numpy 2d array or list of lists.
v_buff
    Vertical distance between elements, by default 0.8.
h_buff
    Horizontal distance between elements, by default 1.3.
bracket_h_buff
    Distance of the brackets from the matrix, by default ``MED_SMALL_BUFF``.
bracket_v_buff
    Height of the brackets, by default ``MED_SMALL_BUFF``.
add_background_rectangles_to_entries
    ``True`` if should add backgraound rectangles to entries, by default ``False``.
include_background_rectangle
    ``True`` if should include background rectangle, by default ``False``.
element_to_mobject
    The mobject class used to construct the elements, by default :class:`~.MathTex`.
element_to_mobject_config
    Additional arguments to be passed to the constructor in ``element_to_mobject``,
    by default ``{}``.
element_alignment_corner
    The corner to which elements are aligned, by default ``DR``.
left_bracket
    The left bracket type, by default ``"["``.
right_bracket
    The right bracket type, by default ``"]"``.
stretch_brackets
    ``True`` if should stretch the brackets to fit the height of matrix contents, by default ``True``.
bracket_config
    Additional arguments to be passed to :class:`~.MathTex` when constructing
    the brackets.

Examples
--------
The first example shows a variety of uses of this module while the second example
exlpains the use of the options `add_background_rectangles_to_entries` and
`include_background_rectangle`.

.. manim:: MatrixExamples
    :save_last_frame:

    class MatrixExamples(Scene):
        def construct(self):
            m0 = Matrix([[2, r"\pi"], [-1, 1]])
            m1 = Matrix([[2, 0, 4], [-1, 1, 5]],
                v_buff=1.3,
                h_buff=0.8,
                bracket_h_buff=SMALL_BUFF,
                bracket_v_buff=SMALL_BUFF,
                left_bracket=r"\{",
                right_bracket=r"\}")
            m1.add(SurroundingRectangle(m1.get_columns()[1]))
            m2 = Matrix([[2, 1], [-1, 3]],
                element_alignment_corner=UL,
                left_bracket="(",
                right_bracket=")")
            m3 = Matrix([[2, 1], [-1, 3]],
                left_bracket=r"\langle",
                right_bracket=r"\rangle")
            m4 = Matrix([[2, 1], [-1, 3]],
            ).set_column_colors(RED, GREEN)
            m5 = Matrix([[2, 1], [-1, 3]],
            ).set_row_colors(RED, GREEN)
            g = Group(
                m0,m1,m2,m3,m4,m5
            ).arrange_in_grid(buff=2)
            self.add(g)

.. manim:: BackgroundRectanglesExample
    :save_last_frame:

    class BackgroundRectanglesExample(Scene):
        def construct(self):
            background= Rectangle().scale(3.2)
            background.set_fill(opacity=.5)
            background.set_color([TEAL, RED, YELLOW])
            self.add(background)
            m0 = Matrix([[12, -30], [-1, 15]],
                add_background_rectangles_to_entries=True)
            m1 = Matrix([[2, 0], [-1, 1]],
                include_background_rectangle=True)
            m2 = Matrix([[12, -30], [-1, 15]])
            g = Group(m0, m1, m2).arrange(buff=2)
            self.add(g)
"""

def __init__(
    self,
    matrix: Iterable,
    v_buff: float = 0.8,
    h_buff: float = 1.3,
    bracket_h_buff: float = MED_SMALL_BUFF,
    bracket_v_buff: float = MED_SMALL_BUFF,
    add_background_rectangles_to_entries: bool = False,
    include_background_rectangle: bool = False,
    element_to_mobject: type[MathTex] = MathTex,
    element_to_mobject_config: dict = {},
    element_alignment_corner: Sequence[float] = DR,
    left_bracket: str = "[",
    right_bracket: str = "]",
    stretch_brackets: bool = True,
    bracket_config: dict = {},
    **kwargs,
):
    self.v_buff = v_buff
    self.h_buff = h_buff
    self.bracket_h_buff = bracket_h_buff
    self.bracket_v_buff = bracket_v_buff
    self.add_background_rectangles_to_entries = add_background_rectangles_to_entries
    self.include_background_rectangle = include_background_rectangle
    self.element_to_mobject = element_to_mobject
    self.element_to_mobject_config = element_to_mobject_config
    self.element_alignment_corner = element_alignment_corner
    self.left_bracket = left_bracket
    self.right_bracket = right_bracket
    self.stretch_brackets = stretch_brackets
    super().__init__(**kwargs)
    mob_matrix = self._matrix_to_mob_matrix(matrix)
    self._organize_mob_matrix(mob_matrix)
    self.elements = VGroup(*it.chain(*mob_matrix))
    self.add(self.elements)
    self._add_brackets(self.left_bracket, self.right_bracket, **bracket_config)
    self.center()
    self.mob_matrix = mob_matrix
    if self.add_background_rectangles_to_entries:
        for mob in self.elements:
            mob.add_background_rectangle()
    if self.include_background_rectangle:
        self.add_background_rectangle()

</t>
<t tx="ekr.20250122151620.798">def _matrix_to_mob_matrix(self, matrix):
    return [
        [
            self.element_to_mobject(item, **self.element_to_mobject_config)
            for item in row
        ]
        for row in matrix
    ]

</t>
<t tx="ekr.20250122151620.799">def _organize_mob_matrix(self, matrix):
    for i, row in enumerate(matrix):
        for j, _ in enumerate(row):
            mob = matrix[i][j]
            mob.move_to(
                i * self.v_buff * DOWN + j * self.h_buff * RIGHT,
                self.element_alignment_corner,
            )
    return self

</t>
<t tx="ekr.20250122151620.8">"""Constant definitions."""

from __future__ import annotations

from enum import Enum
from typing import TypedDict

import numpy as np
from cloup import Context
from PIL.Image import Resampling

from manim.typing import Vector3D

__all__ = [
    "SCENE_NOT_FOUND_MESSAGE",
    "CHOOSE_NUMBER_MESSAGE",
    "INVALID_NUMBER_MESSAGE",
    "NO_SCENE_MESSAGE",
    "NORMAL",
    "ITALIC",
    "OBLIQUE",
    "BOLD",
    "THIN",
    "ULTRALIGHT",
    "LIGHT",
    "SEMILIGHT",
    "BOOK",
    "MEDIUM",
    "SEMIBOLD",
    "ULTRABOLD",
    "HEAVY",
    "ULTRAHEAVY",
    "RESAMPLING_ALGORITHMS",
    "ORIGIN",
    "UP",
    "DOWN",
    "RIGHT",
    "LEFT",
    "IN",
    "OUT",
    "X_AXIS",
    "Y_AXIS",
    "Z_AXIS",
    "UL",
    "UR",
    "DL",
    "DR",
    "START_X",
    "START_Y",
    "DEFAULT_DOT_RADIUS",
    "DEFAULT_SMALL_DOT_RADIUS",
    "DEFAULT_DASH_LENGTH",
    "DEFAULT_ARROW_TIP_LENGTH",
    "SMALL_BUFF",
    "MED_SMALL_BUFF",
    "MED_LARGE_BUFF",
    "LARGE_BUFF",
    "DEFAULT_MOBJECT_TO_EDGE_BUFFER",
    "DEFAULT_MOBJECT_TO_MOBJECT_BUFFER",
    "DEFAULT_POINTWISE_FUNCTION_RUN_TIME",
    "DEFAULT_WAIT_TIME",
    "DEFAULT_POINT_DENSITY_2D",
    "DEFAULT_POINT_DENSITY_1D",
    "DEFAULT_STROKE_WIDTH",
    "DEFAULT_FONT_SIZE",
    "SCALE_FACTOR_PER_FONT_POINT",
    "PI",
    "TAU",
    "DEGREES",
    "QUALITIES",
    "DEFAULT_QUALITY",
    "EPILOG",
    "CONTEXT_SETTINGS",
    "SHIFT_VALUE",
    "CTRL_VALUE",
    "RendererType",
    "LineJointType",
    "CapStyleType",
]
# Messages

SCENE_NOT_FOUND_MESSAGE = """
   {} is not in the script
"""
CHOOSE_NUMBER_MESSAGE = """
Choose number corresponding to desired scene/arguments.
(Use comma separated list for multiple entries)
Choice(s): """
INVALID_NUMBER_MESSAGE = "Invalid scene numbers have been specified. Aborting."
NO_SCENE_MESSAGE = """
   There are no scenes inside that module
"""

# Pango stuff
NORMAL = "NORMAL"
ITALIC = "ITALIC"
OBLIQUE = "OBLIQUE"
BOLD = "BOLD"
# Only for Pango from below
THIN = "THIN"
ULTRALIGHT = "ULTRALIGHT"
LIGHT = "LIGHT"
SEMILIGHT = "SEMILIGHT"
BOOK = "BOOK"
MEDIUM = "MEDIUM"
SEMIBOLD = "SEMIBOLD"
ULTRABOLD = "ULTRABOLD"
HEAVY = "HEAVY"
ULTRAHEAVY = "ULTRAHEAVY"

RESAMPLING_ALGORITHMS = {
    "nearest": Resampling.NEAREST,
    "none": Resampling.NEAREST,
    "lanczos": Resampling.LANCZOS,
    "antialias": Resampling.LANCZOS,
    "bilinear": Resampling.BILINEAR,
    "linear": Resampling.BILINEAR,
    "bicubic": Resampling.BICUBIC,
    "cubic": Resampling.BICUBIC,
    "box": Resampling.BOX,
    "hamming": Resampling.HAMMING,
}

# Geometry: directions
ORIGIN: Vector3D = np.array((0.0, 0.0, 0.0))
"""The center of the coordinate system."""

UP: Vector3D = np.array((0.0, 1.0, 0.0))
"""One unit step in the positive Y direction."""

DOWN: Vector3D = np.array((0.0, -1.0, 0.0))
"""One unit step in the negative Y direction."""

RIGHT: Vector3D = np.array((1.0, 0.0, 0.0))
"""One unit step in the positive X direction."""

LEFT: Vector3D = np.array((-1.0, 0.0, 0.0))
"""One unit step in the negative X direction."""

IN: Vector3D = np.array((0.0, 0.0, -1.0))
"""One unit step in the negative Z direction."""

OUT: Vector3D = np.array((0.0, 0.0, 1.0))
"""One unit step in the positive Z direction."""

# Geometry: axes
X_AXIS: Vector3D = np.array((1.0, 0.0, 0.0))
Y_AXIS: Vector3D = np.array((0.0, 1.0, 0.0))
Z_AXIS: Vector3D = np.array((0.0, 0.0, 1.0))

# Geometry: useful abbreviations for diagonals
UL: Vector3D = UP + LEFT
"""One step up plus one step left."""

UR: Vector3D = UP + RIGHT
"""One step up plus one step right."""

DL: Vector3D = DOWN + LEFT
"""One step down plus one step left."""

DR: Vector3D = DOWN + RIGHT
"""One step down plus one step right."""

# Geometry
START_X = 30
START_Y = 20
DEFAULT_DOT_RADIUS = 0.08
DEFAULT_SMALL_DOT_RADIUS = 0.04
DEFAULT_DASH_LENGTH = 0.05
DEFAULT_ARROW_TIP_LENGTH = 0.35

# Default buffers (padding)
SMALL_BUFF = 0.1
MED_SMALL_BUFF = 0.25
MED_LARGE_BUFF = 0.5
LARGE_BUFF = 1
DEFAULT_MOBJECT_TO_EDGE_BUFFER = MED_LARGE_BUFF
DEFAULT_MOBJECT_TO_MOBJECT_BUFFER = MED_SMALL_BUFF

# Times in seconds
DEFAULT_POINTWISE_FUNCTION_RUN_TIME = 3.0
DEFAULT_WAIT_TIME = 1.0

# Misc
DEFAULT_POINT_DENSITY_2D = 25
DEFAULT_POINT_DENSITY_1D = 10
DEFAULT_STROKE_WIDTH = 4
DEFAULT_FONT_SIZE = 48
SCALE_FACTOR_PER_FONT_POINT = 1 / 960

# Mathematical constants
PI = np.pi
"""The ratio of the circumference of a circle to its diameter."""

TAU = 2 * PI
"""The ratio of the circumference of a circle to its radius."""

DEGREES = TAU / 360
"""The exchange rate between radians and degrees."""


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.80">@force_window.setter
def force_window(self, value: bool) -&gt; None:
    self._set_boolean("force_window", value)

</t>
<t tx="ekr.20250122151620.800">def _add_brackets(self, left: str = "[", right: str = "]", **kwargs):
    """Adds the brackets to the Matrix mobject.

    See Latex document for various bracket types.

    Parameters
    ----------
    left
        the left bracket, by default "["
    right
        the right bracket, by default "]"

    Returns
    -------
    :class:`Matrix`
        The current matrix object (self).
    """
    # Height per row of LaTeX array with default settings
    BRACKET_HEIGHT = 0.5977

    n = int((self.height) / BRACKET_HEIGHT) + 1
    empty_tex_array = "".join(
        [
            r"\begin{array}{c}",
            *n * [r"\quad \\"],
            r"\end{array}",
        ]
    )
    tex_left = "".join(
        [
            r"\left" + left,
            empty_tex_array,
            r"\right.",
        ]
    )
    tex_right = "".join(
        [
            r"\left.",
            empty_tex_array,
            r"\right" + right,
        ]
    )
    l_bracket = MathTex(tex_left, **kwargs)
    r_bracket = MathTex(tex_right, **kwargs)

    bracket_pair = VGroup(l_bracket, r_bracket)
    if self.stretch_brackets:
        bracket_pair.stretch_to_fit_height(self.height + 2 * self.bracket_v_buff)
    l_bracket.next_to(self, LEFT, self.bracket_h_buff)
    r_bracket.next_to(self, RIGHT, self.bracket_h_buff)
    self.brackets = bracket_pair
    self.add(l_bracket, r_bracket)
    return self

</t>
<t tx="ekr.20250122151620.801">def get_columns(self):
    r"""Return columns of the matrix as VGroups.

    Returns
    --------
    List[:class:`~.VGroup`]
        Each VGroup contains a column of the matrix.

    Examples
    --------

    .. manim:: GetColumnsExample
        :save_last_frame:

        class GetColumnsExample(Scene):
            def construct(self):
                m0 = Matrix([[r"\pi", 3], [1, 5]])
                m0.add(SurroundingRectangle(m0.get_columns()[1]))
                self.add(m0)
    """
    return VGroup(
        *(
            VGroup(*(row[i] for row in self.mob_matrix))
            for i in range(len(self.mob_matrix[0]))
        )
    )

</t>
<t tx="ekr.20250122151620.802">def set_column_colors(self, *colors: str):
    r"""Set individual colors for each columns of the matrix.

    Parameters
    ----------
    colors
        The list of colors; each color specified corresponds to a column.

    Returns
    -------
    :class:`Matrix`
        The current matrix object (self).

    Examples
    --------

    .. manim:: SetColumnColorsExample
        :save_last_frame:

        class SetColumnColorsExample(Scene):
            def construct(self):
                m0 = Matrix([["\\pi", 1], [-1, 3]],
                ).set_column_colors([RED,BLUE], GREEN)
                self.add(m0)
    """
    columns = self.get_columns()
    for color, column in zip(colors, columns):
        column.set_color(color)
    return self

</t>
<t tx="ekr.20250122151620.803">def get_rows(self):
    r"""Return rows of the matrix as VGroups.

    Returns
    --------
    List[:class:`~.VGroup`]
        Each VGroup contains a row of the matrix.

    Examples
    --------

    .. manim:: GetRowsExample
        :save_last_frame:

        class GetRowsExample(Scene):
            def construct(self):
                m0 = Matrix([["\\pi", 3], [1, 5]])
                m0.add(SurroundingRectangle(m0.get_rows()[1]))
                self.add(m0)
    """
    return VGroup(*(VGroup(*row) for row in self.mob_matrix))

</t>
<t tx="ekr.20250122151620.804">def set_row_colors(self, *colors: str):
    r"""Set individual colors for each row of the matrix.

    Parameters
    ----------
    colors
        The list of colors; each color specified corresponds to a row.

    Returns
    -------
    :class:`Matrix`
        The current matrix object (self).

    Examples
    --------

    .. manim:: SetRowColorsExample
        :save_last_frame:

        class SetRowColorsExample(Scene):
            def construct(self):
                m0 = Matrix([["\\pi", 1], [-1, 3]],
                ).set_row_colors([RED,BLUE], GREEN)
                self.add(m0)
    """
    rows = self.get_rows()
    for color, row in zip(colors, rows):
        row.set_color(color)
    return self

</t>
<t tx="ekr.20250122151620.805">def add_background_to_entries(self):
    """Add a black background rectangle to the matrix,
    see above for an example.

    Returns
    -------
    :class:`Matrix`
        The current matrix object (self).
    """
    for mob in self.get_entries():
        mob.add_background_rectangle()
    return self

</t>
<t tx="ekr.20250122151620.806">def get_mob_matrix(self):
    """Return the underlying mob matrix mobjects.

    Returns
    --------
    List[:class:`~.VGroup`]
        Each VGroup contains a row of the matrix.
    """
    return self.mob_matrix

</t>
<t tx="ekr.20250122151620.807">def get_entries(self):
    """Return the individual entries of the matrix.

    Returns
    --------
    :class:`~.VGroup`
        VGroup containing entries of the matrix.

    Examples
    --------

    .. manim:: GetEntriesExample
        :save_last_frame:

        class GetEntriesExample(Scene):
            def construct(self):
                m0 = Matrix([[2, 3], [1, 5]])
                ent = m0.get_entries()
                colors = [BLUE, GREEN, YELLOW, RED]
                for k in range(len(colors)):
                    ent[k].set_color(colors[k])
                self.add(m0)
    """
    return self.elements

</t>
<t tx="ekr.20250122151620.808">def get_brackets(self):
    r"""Return the bracket mobjects.

    Returns
    --------
    List[:class:`~.VGroup`]
        Each VGroup contains a bracket

    Examples
    --------

    .. manim:: GetBracketsExample
        :save_last_frame:

        class GetBracketsExample(Scene):
            def construct(self):
                m0 = Matrix([["\\pi", 3], [1, 5]])
                bra = m0.get_brackets()
                colors = [BLUE, GREEN]
                for k in range(len(colors)):
                    bra[k].set_color(colors[k])
                self.add(m0)
    """
    return self.brackets


</t>
<t tx="ekr.20250122151620.809">r"""A mobject that displays a matrix with decimal entries on the screen.

Examples
--------

.. manim:: DecimalMatrixExample
    :save_last_frame:

    class DecimalMatrixExample(Scene):
        def construct(self):
            m0 = DecimalMatrix(
                [[3.456, 2.122], [33.2244, 12]],
                element_to_mobject_config={"num_decimal_places": 2},
                left_bracket="\\{",
                right_bracket="\\}")
            self.add(m0)
"""

def __init__(
    self,
    matrix: Iterable,
    element_to_mobject: Mobject = DecimalNumber,
    element_to_mobject_config: dict[str, Mobject] = {"num_decimal_places": 1},
    **kwargs,
):
    """
    Will round/truncate the decimal places as per the provided config.

    Parameters
    ----------
    matrix
        A numpy 2d array or list of lists
    element_to_mobject
        Mobject to use, by default DecimalNumber
    element_to_mobject_config
        Config for the desired mobject, by default {"num_decimal_places": 1}
    """
    super().__init__(
        matrix,
        element_to_mobject=element_to_mobject,
        element_to_mobject_config=element_to_mobject_config,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151620.81">@property
def no_latex_cleanup(self) -&gt; bool:
    """Prevents deletion of .aux, .dvi, and .log files produced by Tex and MathTex."""
    return self._d["no_latex_cleanup"]

</t>
<t tx="ekr.20250122151620.810">def __init__(
    self, matrix: Iterable, element_to_mobject: Mobject = Integer, **kwargs
):
    """
    Will round if there are decimal entries in the matrix.

    Parameters
    ----------
    matrix
        A numpy 2d array or list of lists
    element_to_mobject
        Mobject to use, by default Integer
    """
    super().__init__(matrix, element_to_mobject=element_to_mobject, **kwargs)


</t>
<t tx="ekr.20250122151620.811">r"""A mobject that displays a matrix of mobject entries on the screen.

Examples
--------

.. manim:: MobjectMatrixExample
    :save_last_frame:

    class MobjectMatrixExample(Scene):
        def construct(self):
            a = Circle().scale(0.3)
            b = Square().scale(0.3)
            c = MathTex("\\pi").scale(2)
            d = Star().scale(0.3)
            m0 = MobjectMatrix([[a, b], [c, d]])
            self.add(m0)
"""

def __init__(self, matrix, element_to_mobject=lambda m: m, **kwargs):
    super().__init__(matrix, element_to_mobject=element_to_mobject, **kwargs)


</t>
<t tx="ekr.20250122151620.812">"""Base classes for objects that can be displayed."""

from __future__ import annotations

__all__ = ["Mobject", "Group", "override_animate"]


import copy
import inspect
import itertools as it
import math
import operator as op
import random
import sys
import types
import warnings
from collections.abc import Iterable
from functools import partialmethod, reduce
from pathlib import Path
from typing import TYPE_CHECKING

import numpy as np

from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL

from .. import config, logger
from ..constants import *
from ..utils.color import (
    BLACK,
    WHITE,
    YELLOW_C,
    ManimColor,
    ParsableManimColor,
    color_gradient,
    interpolate_color,
)
from ..utils.exceptions import MultiAnimationOverrideException
from ..utils.iterables import list_update, remove_list_redundancies
from ..utils.paths import straight_path
from ..utils.space_ops import angle_between_vectors, normalize, rotation_matrix

if TYPE_CHECKING:
    from typing import Any, Callable, Literal

    from typing_extensions import Self, TypeAlias

    from manim.typing import (
        FunctionOverride,
        MappingFunction,
        MultiMappingFunction,
        PathFuncType,
        PixelArray,
        Point3D,
        Point3DLike,
        Point3DLike_Array,
        Vector3D,
    )

    from ..animation.animation import Animation

    TimeBasedUpdater: TypeAlias = Callable[["Mobject", float], object]
    NonTimeBasedUpdater: TypeAlias = Callable[["Mobject"], object]
    Updater: TypeAlias = NonTimeBasedUpdater | TimeBasedUpdater


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151620.813">class Mobject:
    """Mathematical Object: base class for objects that can be displayed on screen.

    There is a compatibility layer that allows for
    getting and setting generic attributes with ``get_*``
    and ``set_*`` methods. See :meth:`set` for more details.

    Attributes
    ----------
    submobjects : List[:class:`Mobject`]
        The contained objects.
    points : :class:`numpy.ndarray`
        The points of the objects.

        .. seealso::

            :class:`~.VMobject`

    """

    @others
</t>
<t tx="ekr.20250122151620.814">class Group(Mobject, metaclass=ConvertToOpenGL):
    """Groups together multiple :class:`Mobjects &lt;.Mobject&gt;`.

    Notes
    -----
    When adding the same mobject more than once, repetitions are ignored.
    Use :meth:`.Mobject.copy` to create a separate copy which can then
    be added to the group.
    """

    @others
</t>
<t tx="ekr.20250122151620.815">class _AnimationBuilder:
    @others
</t>
<t tx="ekr.20250122151620.816">def override_animate(method) -&gt; types.FunctionType:
    r"""Decorator for overriding method animations.

    This allows to specify a method (returning an :class:`~.Animation`)
    which is called when the decorated method is used with the ``.animate`` syntax
    for animating the application of a method.

    .. seealso::

        :attr:`Mobject.animate`

    .. note::

        Overridden methods cannot be combined with normal or other overridden
        methods using method chaining with the ``.animate`` syntax.


    Examples
    --------

    .. manim:: AnimationOverrideExample

        class CircleWithContent(VGroup):
            def __init__(self, content):
                super().__init__()
                self.circle = Circle()
                self.content = content
                self.add(self.circle, content)
                content.move_to(self.circle.get_center())

            def clear_content(self):
                self.remove(self.content)
                self.content = None

            @override_animate(clear_content)
            def _clear_content_animation(self, anim_args=None):
                if anim_args is None:
                    anim_args = {}
                anim = Uncreate(self.content, **anim_args)
                self.clear_content()
                return anim

        class AnimationOverrideExample(Scene):
            def construct(self):
                t = Text("hello!")
                my_mobject = CircleWithContent(t)
                self.play(Create(my_mobject))
                self.play(my_mobject.animate.clear_content())
                self.wait()

    """

    def decorator(animation_method):
        method._override_animate = animation_method
        return animation_method

    return decorator
</t>
<t tx="ekr.20250122151620.817">animation_overrides = {}

@classmethod
def __init_subclass__(cls, **kwargs) -&gt; None:
    super().__init_subclass__(**kwargs)

    cls.animation_overrides: dict[
        type[Animation],
        FunctionOverride,
    ] = {}
    cls._add_intrinsic_animation_overrides()
    cls._original__init__ = cls.__init__

</t>
<t tx="ekr.20250122151620.818">def __init__(
    self,
    color: ParsableManimColor | list[ParsableManimColor] = WHITE,
    name: str | None = None,
    dim: int = 3,
    target=None,
    z_index: float = 0,
) -&gt; None:
    self.name = self.__class__.__name__ if name is None else name
    self.dim = dim
    self.target = target
    self.z_index = z_index
    self.point_hash = None
    self.submobjects = []
    self.updaters: list[Updater] = []
    self.updating_suspended = False
    self.color = ManimColor.parse(color)

    self.reset_points()
    self.generate_points()
    self.init_colors()

</t>
<t tx="ekr.20250122151620.819">def _assert_valid_submobjects(self, submobjects: Iterable[Mobject]) -&gt; Self:
    """Check that all submobjects are actually instances of
    :class:`Mobject`, and that none of them is ``self`` (a
    :class:`Mobject` cannot contain itself).

    This is an auxiliary function called when adding Mobjects to the
    :attr:`submobjects` list.

    This function is intended to be overridden by subclasses such as
    :class:`VMobject`, which should assert that only other VMobjects
    may be added into it.

    Parameters
    ----------
    submobjects
        The list containing values to validate.

    Returns
    -------
    :class:`Mobject`
        The Mobject itself.

    Raises
    ------
    TypeError
        If any of the values in `submobjects` is not a :class:`Mobject`.
    ValueError
        If there was an attempt to add a :class:`Mobject` as its own
        submobject.
    """
    return self._assert_valid_submobjects_internal(submobjects, Mobject)

</t>
<t tx="ekr.20250122151620.82">@no_latex_cleanup.setter
def no_latex_cleanup(self, value: bool) -&gt; None:
    self._set_boolean("no_latex_cleanup", value)

</t>
<t tx="ekr.20250122151620.820">def _assert_valid_submobjects_internal(
    self, submobjects: list[Mobject], mob_class: type[Mobject]
) -&gt; Self:
    for i, submob in enumerate(submobjects):
        if not isinstance(submob, mob_class):
            error_message = (
                f"Only values of type {mob_class.__name__} can be added "
                f"as submobjects of {type(self).__name__}, but the value "
                f"{submob} (at index {i}) is of type "
                f"{type(submob).__name__}."
            )
            # Intended for subclasses such as VMobject, which
            # cannot have regular Mobjects as submobjects
            if isinstance(submob, Mobject):
                error_message += (
                    " You can try adding this value into a Group instead."
                )
            raise TypeError(error_message)
        if submob is self:
            raise ValueError(
                f"Cannot add {type(self).__name__} as a submobject of "
                f"itself (at index {i})."
            )
    return self

</t>
<t tx="ekr.20250122151620.821">@classmethod
def animation_override_for(
    cls,
    animation_class: type[Animation],
) -&gt; FunctionOverride | None:
    """Returns the function defining a specific animation override for this class.

    Parameters
    ----------
    animation_class
        The animation class for which the override function should be returned.

    Returns
    -------
    Optional[Callable[[Mobject, ...], Animation]]
        The function returning the override animation or ``None`` if no such animation
        override is defined.
    """
    if animation_class in cls.animation_overrides:
        return cls.animation_overrides[animation_class]

    return None

</t>
<t tx="ekr.20250122151620.822">@classmethod
def _add_intrinsic_animation_overrides(cls) -&gt; None:
    """Initializes animation overrides marked with the :func:`~.override_animation`
    decorator.
    """
    for method_name in dir(cls):
        # Ignore dunder methods
        if method_name.startswith("__"):
            continue

        method = getattr(cls, method_name)
        if hasattr(method, "_override_animation"):
            animation_class = method._override_animation
            cls.add_animation_override(animation_class, method)

</t>
<t tx="ekr.20250122151620.823">@classmethod
def add_animation_override(
    cls,
    animation_class: type[Animation],
    override_func: FunctionOverride,
) -&gt; None:
    """Add an animation override.

    This does not apply to subclasses.

    Parameters
    ----------
    animation_class
        The animation type to be overridden
    override_func
        The function returning an animation replacing the default animation. It gets
        passed the parameters given to the animation constructor.

    Raises
    ------
    MultiAnimationOverrideException
        If the overridden animation was already overridden.
    """
    if animation_class not in cls.animation_overrides:
        cls.animation_overrides[animation_class] = override_func
    else:
        raise MultiAnimationOverrideException(
            f"The animation {animation_class.__name__} for "
            f"{cls.__name__} is overridden by more than one method: "
            f"{cls.animation_overrides[animation_class].__qualname__} and "
            f"{override_func.__qualname__}.",
        )

</t>
<t tx="ekr.20250122151620.824">@classmethod
def set_default(cls, **kwargs) -&gt; None:
    """Sets the default values of keyword arguments.

    If this method is called without any additional keyword
    arguments, the original default values of the initialization
    method of this class are restored.

    Parameters
    ----------

    kwargs
        Passing any keyword argument will update the default
        values of the keyword arguments of the initialization
        function of this class.

    Examples
    --------

    ::

        &gt;&gt;&gt; from manim import Square, GREEN
        &gt;&gt;&gt; Square.set_default(color=GREEN, fill_opacity=0.25)
        &gt;&gt;&gt; s = Square(); s.color, s.fill_opacity
        (ManimColor('#83C167'), 0.25)
        &gt;&gt;&gt; Square.set_default()
        &gt;&gt;&gt; s = Square(); s.color, s.fill_opacity
        (ManimColor('#FFFFFF'), 0.0)

    .. manim:: ChangedDefaultTextcolor
        :save_last_frame:

        config.background_color = WHITE

        class ChangedDefaultTextcolor(Scene):
            def construct(self):
                Text.set_default(color=BLACK)
                self.add(Text("Changing default values is easy!"))

                # we revert the colour back to the default to prevent a bug in the docs.
                Text.set_default(color=WHITE)

    """
    if kwargs:
        cls.__init__ = partialmethod(cls.__init__, **kwargs)
    else:
        cls.__init__ = cls._original__init__

</t>
<t tx="ekr.20250122151620.825">@property
def animate(self) -&gt; _AnimationBuilder | Self:
    """Used to animate the application of any method of :code:`self`.

    Any method called on :code:`animate` is converted to an animation of applying
    that method on the mobject itself.

    For example, :code:`square.set_fill(WHITE)` sets the fill color of a square,
    while :code:`square.animate.set_fill(WHITE)` animates this action.

    Multiple methods can be put in a single animation once via chaining:

    ::

        self.play(my_mobject.animate.shift(RIGHT).rotate(PI))

    .. warning::

        Passing multiple animations for the same :class:`Mobject` in one
        call to :meth:`~.Scene.play` is discouraged and will most likely
        not work properly. Instead of writing an animation like

        ::

            self.play(
                my_mobject.animate.shift(RIGHT), my_mobject.animate.rotate(PI)
            )

        make use of method chaining.

    Keyword arguments that can be passed to :meth:`.Scene.play` can be passed
    directly after accessing ``.animate``, like so::

        self.play(my_mobject.animate(rate_func=linear).shift(RIGHT))

    This is especially useful when animating simultaneous ``.animate`` calls that
    you want to behave differently::

        self.play(
            mobject1.animate(run_time=2).rotate(PI),
            mobject2.animate(rate_func=there_and_back).shift(RIGHT),
        )

    .. seealso::

        :func:`override_animate`


    Examples
    --------

    .. manim:: AnimateExample

        class AnimateExample(Scene):
            def construct(self):
                s = Square()
                self.play(Create(s))
                self.play(s.animate.shift(RIGHT))
                self.play(s.animate.scale(2))
                self.play(s.animate.rotate(PI / 2))
                self.play(Uncreate(s))


    .. manim:: AnimateChainExample

        class AnimateChainExample(Scene):
            def construct(self):
                s = Square()
                self.play(Create(s))
                self.play(s.animate.shift(RIGHT).scale(2).rotate(PI / 2))
                self.play(Uncreate(s))

    .. manim:: AnimateWithArgsExample

        class AnimateWithArgsExample(Scene):
            def construct(self):
                s = Square()
                c = Circle()

                VGroup(s, c).arrange(RIGHT, buff=2)
                self.add(s, c)

                self.play(
                    s.animate(run_time=2).rotate(PI / 2),
                    c.animate(rate_func=there_and_back).shift(RIGHT),
                )

    .. warning::

        ``.animate``
         will interpolate the :class:`~.Mobject` between its points prior to
         ``.animate`` and its points after applying ``.animate`` to it. This may
         result in unexpected behavior when attempting to interpolate along paths,
         or rotations.
         If you want animations to consider the points between, consider using
         :class:`~.ValueTracker` with updaters instead.

    """
    return _AnimationBuilder(self)

</t>
<t tx="ekr.20250122151620.826">def __deepcopy__(self, clone_from_id) -&gt; Self:
    cls = self.__class__
    result = cls.__new__(cls)
    clone_from_id[id(self)] = result
    for k, v in self.__dict__.items():
        setattr(result, k, copy.deepcopy(v, clone_from_id))
    result.original_id = str(id(self))
    return result

</t>
<t tx="ekr.20250122151620.827">def __repr__(self) -&gt; str:
    return str(self.name)

</t>
<t tx="ekr.20250122151620.828">def reset_points(self) -&gt; None:
    """Sets :attr:`points` to be an empty array."""
    self.points = np.zeros((0, self.dim))

</t>
<t tx="ekr.20250122151620.829">def init_colors(self) -&gt; object:
    """Initializes the colors.

    Gets called upon creation. This is an empty method that can be implemented by
    subclasses.
    """

</t>
<t tx="ekr.20250122151620.83">@property
def preview_command(self) -&gt; str:
    return self._d["preview_command"]

</t>
<t tx="ekr.20250122151620.830">def generate_points(self) -&gt; object:
    """Initializes :attr:`points` and therefore the shape.

    Gets called upon creation. This is an empty method that can be implemented by
    subclasses.
    """

</t>
<t tx="ekr.20250122151620.831">def add(self, *mobjects: Mobject) -&gt; Self:
    """Add mobjects as submobjects.

    The mobjects are added to :attr:`submobjects`.

    Subclasses of mobject may implement ``+`` and ``+=`` dunder methods.

    Parameters
    ----------
    mobjects
        The mobjects to add.

    Returns
    -------
    :class:`Mobject`
        ``self``

    Raises
    ------
    :class:`ValueError`
        When a mobject tries to add itself.
    :class:`TypeError`
        When trying to add an object that is not an instance of :class:`Mobject`.


    Notes
    -----
    A mobject cannot contain itself, and it cannot contain a submobject
    more than once.  If the parent mobject is displayed, the newly-added
    submobjects will also be displayed (i.e. they are automatically added
    to the parent Scene).

    See Also
    --------
    :meth:`remove`
    :meth:`add_to_back`

    Examples
    --------
    ::

        &gt;&gt;&gt; outer = Mobject()
        &gt;&gt;&gt; inner = Mobject()
        &gt;&gt;&gt; outer = outer.add(inner)

    Duplicates are not added again::

        &gt;&gt;&gt; outer = outer.add(inner)
        &gt;&gt;&gt; len(outer.submobjects)
        1

    Only Mobjects can be added::

        &gt;&gt;&gt; outer.add(3)
        Traceback (most recent call last):
        ...
        TypeError: Only values of type Mobject can be added as submobjects of Mobject, but the value 3 (at index 0) is of type int.

    Adding an object to itself raises an error::

        &gt;&gt;&gt; outer.add(outer)
        Traceback (most recent call last):
        ...
        ValueError: Cannot add Mobject as a submobject of itself (at index 0).

    A given mobject cannot be added as a submobject
    twice to some parent::

        &gt;&gt;&gt; parent = Mobject(name="parent")
        &gt;&gt;&gt; child = Mobject(name="child")
        &gt;&gt;&gt; parent.add(child, child)
        [...] WARNING  ...
        parent
        &gt;&gt;&gt; parent.submobjects
        [child]

    """
    self._assert_valid_submobjects(mobjects)
    unique_mobjects = remove_list_redundancies(mobjects)
    if len(mobjects) != len(unique_mobjects):
        logger.warning(
            "Attempted adding some Mobject as a child more than once, "
            "this is not possible. Repetitions are ignored.",
        )

    self.submobjects = list_update(self.submobjects, unique_mobjects)
    return self

</t>
<t tx="ekr.20250122151620.832">def insert(self, index: int, mobject: Mobject) -&gt; None:
    """Inserts a mobject at a specific position into self.submobjects

    Effectively just calls  ``self.submobjects.insert(index, mobject)``,
    where ``self.submobjects`` is a list.

    Highly adapted from ``Mobject.add``.

    Parameters
    ----------
    index
        The index at which
    mobject
        The mobject to be inserted.
    """
    self._assert_valid_submobjects([mobject])
    self.submobjects.insert(index, mobject)

</t>
<t tx="ekr.20250122151620.833">def __add__(self, mobject: Mobject):
    raise NotImplementedError

</t>
<t tx="ekr.20250122151620.834">def __iadd__(self, mobject: Mobject):
    raise NotImplementedError

</t>
<t tx="ekr.20250122151620.835">def add_to_back(self, *mobjects: Mobject) -&gt; Self:
    """Add all passed mobjects to the back of the submobjects.

    If :attr:`submobjects` already contains the given mobjects, they just get moved
    to the back instead.

    Parameters
    ----------
    mobjects
        The mobjects to add.

    Returns
    -------
    :class:`Mobject`
        ``self``


    .. note::

        Technically, this is done by adding (or moving) the mobjects to
        the head of :attr:`submobjects`. The head of this list is rendered
        first, which places the corresponding mobjects behind the
        subsequent list members.

    Raises
    ------
    :class:`ValueError`
        When a mobject tries to add itself.
    :class:`TypeError`
        When trying to add an object that is not an instance of :class:`Mobject`.

    Notes
    -----
    A mobject cannot contain itself, and it cannot contain a submobject
    more than once.  If the parent mobject is displayed, the newly-added
    submobjects will also be displayed (i.e. they are automatically added
    to the parent Scene).

    See Also
    --------
    :meth:`remove`
    :meth:`add`

    """
    self._assert_valid_submobjects(mobjects)
    self.remove(*mobjects)
    # dict.fromkeys() removes duplicates while maintaining order
    self.submobjects = list(dict.fromkeys(mobjects)) + self.submobjects
    return self

</t>
<t tx="ekr.20250122151620.836">def remove(self, *mobjects: Mobject) -&gt; Self:
    """Remove :attr:`submobjects`.

    The mobjects are removed from :attr:`submobjects`, if they exist.

    Subclasses of mobject may implement ``-`` and ``-=`` dunder methods.

    Parameters
    ----------
    mobjects
        The mobjects to remove.

    Returns
    -------
    :class:`Mobject`
        ``self``

    See Also
    --------
    :meth:`add`

    """
    for mobject in mobjects:
        if mobject in self.submobjects:
            self.submobjects.remove(mobject)
    return self

</t>
<t tx="ekr.20250122151620.837">def __sub__(self, other):
    raise NotImplementedError

</t>
<t tx="ekr.20250122151620.838">def __isub__(self, other):
    raise NotImplementedError

</t>
<t tx="ekr.20250122151620.839">def set(self, **kwargs) -&gt; Self:
    """Sets attributes.

    I.e. ``my_mobject.set(foo=1)`` applies ``my_mobject.foo = 1``.

    This is a convenience to be used along with :attr:`animate` to
    animate setting attributes.

    In addition to this method, there is a compatibility
    layer that allows ``get_*`` and ``set_*`` methods to
    get and set generic attributes. For instance::

        &gt;&gt;&gt; mob = Mobject()
        &gt;&gt;&gt; mob.set_foo(0)
        Mobject
        &gt;&gt;&gt; mob.get_foo()
        0
        &gt;&gt;&gt; mob.foo
        0

    This compatibility layer does not interfere with any
    ``get_*`` or ``set_*`` methods that are explicitly
    defined.

    .. warning::

        This compatibility layer is for backwards compatibility
        and is not guaranteed to stay around. Where applicable,
        please prefer getting/setting attributes normally or with
        the :meth:`set` method.

    Parameters
    ----------
    **kwargs
        The attributes and corresponding values to set.

    Returns
    -------
    :class:`Mobject`
        ``self``

    Examples
    --------
    ::

        &gt;&gt;&gt; mob = Mobject()
        &gt;&gt;&gt; mob.set(foo=0)
        Mobject
        &gt;&gt;&gt; mob.foo
        0
    """
    for attr, value in kwargs.items():
        setattr(self, attr, value)

    return self

</t>
<t tx="ekr.20250122151620.84">@preview_command.setter
def preview_command(self, value: str) -&gt; None:
    self._set_str("preview_command", value)

</t>
<t tx="ekr.20250122151620.840">def __getattr__(self, attr: str) -&gt; types.MethodType:
    # Add automatic compatibility layer
    # between properties and get_* and set_*
    # methods.
    #
    # In python 3.9+ we could change this
    # logic to use str.remove_prefix instead.

    if attr.startswith("get_"):
        # Remove the "get_" prefix
        to_get = attr[4:]

        def getter(self):
            warnings.warn(
                "This method is not guaranteed to stay around. Please prefer "
                "getting the attribute normally.",
                DeprecationWarning,
                stacklevel=2,
            )

            return getattr(self, to_get)

        # Return a bound method
        return types.MethodType(getter, self)

    if attr.startswith("set_"):
        # Remove the "set_" prefix
        to_set = attr[4:]

        def setter(self, value):
            warnings.warn(
                "This method is not guaranteed to stay around. Please prefer "
                "setting the attribute normally or with Mobject.set().",
                DeprecationWarning,
                stacklevel=2,
            )

            setattr(self, to_set, value)

            return self

        # Return a bound method
        return types.MethodType(setter, self)

    # Unhandled attribute, therefore error
    raise AttributeError(f"{type(self).__name__} object has no attribute '{attr}'")

</t>
<t tx="ekr.20250122151620.841">@property
def width(self) -&gt; float:
    """The width of the mobject.

    Returns
    -------
    :class:`float`

    Examples
    --------
    .. manim:: WidthExample

        class WidthExample(Scene):
            def construct(self):
                decimal = DecimalNumber().to_edge(UP)
                rect = Rectangle(color=BLUE)
                rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

                decimal.add_updater(lambda d: d.set_value(rect.width))

                self.add(rect_copy, rect, decimal)
                self.play(rect.animate.set(width=7))
                self.wait()

    See also
    --------
    :meth:`length_over_dim`

    """
    # Get the length across the X dimension
    return self.length_over_dim(0)

</t>
<t tx="ekr.20250122151620.842">@width.setter
def width(self, value: float):
    self.scale_to_fit_width(value)

</t>
<t tx="ekr.20250122151620.843">@property
def height(self) -&gt; float:
    """The height of the mobject.

    Returns
    -------
    :class:`float`

    Examples
    --------
    .. manim:: HeightExample

        class HeightExample(Scene):
            def construct(self):
                decimal = DecimalNumber().to_edge(UP)
                rect = Rectangle(color=BLUE)
                rect_copy = rect.copy().set_stroke(GRAY, opacity=0.5)

                decimal.add_updater(lambda d: d.set_value(rect.height))

                self.add(rect_copy, rect, decimal)
                self.play(rect.animate.set(height=5))
                self.wait()

    See also
    --------
    :meth:`length_over_dim`

    """
    # Get the length across the Y dimension
    return self.length_over_dim(1)

</t>
<t tx="ekr.20250122151620.844">@height.setter
def height(self, value: float):
    self.scale_to_fit_height(value)

</t>
<t tx="ekr.20250122151620.845">@property
def depth(self) -&gt; float:
    """The depth of the mobject.

    Returns
    -------
    :class:`float`

    See also
    --------
    :meth:`length_over_dim`

    """
    # Get the length across the Z dimension
    return self.length_over_dim(2)

</t>
<t tx="ekr.20250122151620.846">@depth.setter
def depth(self, value: float):
    self.scale_to_fit_depth(value)

</t>
<t tx="ekr.20250122151620.847"># Can't be staticmethod because of point_cloud_mobject.py
def get_array_attrs(self) -&gt; list[Literal["points"]]:
    return ["points"]

</t>
<t tx="ekr.20250122151620.848">def apply_over_attr_arrays(self, func: MultiMappingFunction) -&gt; Self:
    for attr in self.get_array_attrs():
        setattr(self, attr, func(getattr(self, attr)))
    return self

</t>
<t tx="ekr.20250122151620.849"># Displaying

def get_image(self, camera=None) -&gt; PixelArray:
    if camera is None:
        from ..camera.camera import Camera

        camera = Camera()
    camera.capture_mobject(self)
    return camera.get_image()

</t>
<t tx="ekr.20250122151620.85">@property
def verbosity(self) -&gt; str:
    """Logger verbosity; "DEBUG", "INFO", "WARNING", "ERROR", or "CRITICAL" (-v)."""
    return self._d["verbosity"]

</t>
<t tx="ekr.20250122151620.850">def show(self, camera=None) -&gt; None:
    self.get_image(camera=camera).show()

</t>
<t tx="ekr.20250122151620.851">def save_image(self, name: str | None = None) -&gt; None:
    """Saves an image of only this :class:`Mobject` at its position to a png
    file.
    """
    self.get_image().save(
        Path(config.get_dir("video_dir")).joinpath((name or str(self)) + ".png"),
    )

</t>
<t tx="ekr.20250122151620.852">def copy(self) -&gt; Self:
    """Create and return an identical copy of the :class:`Mobject` including all
    :attr:`submobjects`.

    Returns
    -------
    :class:`Mobject`
        The copy.

    Note
    ----
    The clone is initially not visible in the Scene, even if the original was.
    """
    return copy.deepcopy(self)

</t>
<t tx="ekr.20250122151620.853">def generate_target(self, use_deepcopy: bool = False) -&gt; Self:
    self.target = None  # Prevent unbounded linear recursion
    if use_deepcopy:
        self.target = copy.deepcopy(self)
    else:
        self.target = self.copy()
    return self.target

</t>
<t tx="ekr.20250122151620.854"># Updating

def update(self, dt: float = 0, recursive: bool = True) -&gt; Self:
    """Apply all updaters.

    Does nothing if updating is suspended.

    Parameters
    ----------
    dt
        The parameter ``dt`` to pass to the update functions. Usually this is the
        time in seconds since the last call of ``update``.
    recursive
        Whether to recursively update all submobjects.

    Returns
    -------
    :class:`Mobject`
        ``self``

    See Also
    --------
    :meth:`add_updater`
    :meth:`get_updaters`

    """
    if self.updating_suspended:
        return self
    for updater in self.updaters:
        if "dt" in inspect.signature(updater).parameters:
            updater(self, dt)
        else:
            updater(self)
    if recursive:
        for submob in self.submobjects:
            submob.update(dt, recursive)
    return self

</t>
<t tx="ekr.20250122151620.855">def get_time_based_updaters(self) -&gt; list[TimeBasedUpdater]:
    """Return all updaters using the ``dt`` parameter.

    The updaters use this parameter as the input for difference in time.

    Returns
    -------
    List[:class:`Callable`]
        The list of time based updaters.

    See Also
    --------
    :meth:`get_updaters`
    :meth:`has_time_based_updater`

    """
    return [
        updater
        for updater in self.updaters
        if "dt" in inspect.signature(updater).parameters
    ]

</t>
<t tx="ekr.20250122151620.856">def has_time_based_updater(self) -&gt; bool:
    """Test if ``self`` has a time based updater.

    Returns
    -------
    :class:`bool`
        ``True`` if at least one updater uses the ``dt`` parameter, ``False``
        otherwise.

    See Also
    --------
    :meth:`get_time_based_updaters`

    """
    return any(
        "dt" in inspect.signature(updater).parameters for updater in self.updaters
    )

</t>
<t tx="ekr.20250122151620.857">def get_updaters(self) -&gt; list[Updater]:
    """Return all updaters.

    Returns
    -------
    List[:class:`Callable`]
        The list of updaters.

    See Also
    --------
    :meth:`add_updater`
    :meth:`get_time_based_updaters`

    """
    return self.updaters

</t>
<t tx="ekr.20250122151620.858">def get_family_updaters(self) -&gt; list[Updater]:
    return list(it.chain(*(sm.get_updaters() for sm in self.get_family())))

</t>
<t tx="ekr.20250122151620.859">def add_updater(
    self,
    update_function: Updater,
    index: int | None = None,
    call_updater: bool = False,
) -&gt; Self:
    """Add an update function to this mobject.

    Update functions, or updaters in short, are functions that are applied to the
    Mobject in every frame.

    Parameters
    ----------
    update_function
        The update function to be added.
        Whenever :meth:`update` is called, this update function gets called using
        ``self`` as the first parameter.
        The updater can have a second parameter ``dt``. If it uses this parameter,
        it gets called using a second value ``dt``, usually representing the time
        in seconds since the last call of :meth:`update`.
    index
        The index at which the new updater should be added in ``self.updaters``.
        In case ``index`` is ``None`` the updater will be added at the end.
    call_updater
        Whether or not to call the updater initially. If ``True``, the updater will
        be called using ``dt=0``.

    Returns
    -------
    :class:`Mobject`
        ``self``

    Examples
    --------
    .. manim:: NextToUpdater

        class NextToUpdater(Scene):
            def construct(self):
                def dot_position(mobject):
                    mobject.set_value(dot.get_center()[0])
                    mobject.next_to(dot)

                dot = Dot(RIGHT*3)
                label = DecimalNumber()
                label.add_updater(dot_position)
                self.add(dot, label)

                self.play(Rotating(dot, about_point=ORIGIN, angle=TAU, run_time=TAU, rate_func=linear))

    .. manim:: DtUpdater

        class DtUpdater(Scene):
            def construct(self):
                square = Square()

                #Let the square rotate 90° per second
                square.add_updater(lambda mobject, dt: mobject.rotate(dt*90*DEGREES))
                self.add(square)
                self.wait(2)

    See also
    --------
    :meth:`get_updaters`
    :meth:`remove_updater`
    :class:`~.UpdateFromFunc`
    """
    if index is None:
        self.updaters.append(update_function)
    else:
        self.updaters.insert(index, update_function)
    if call_updater:
        parameters = inspect.signature(update_function).parameters
        if "dt" in parameters:
            update_function(self, 0)
        else:
            update_function(self)
    return self

</t>
<t tx="ekr.20250122151620.86">@verbosity.setter
def verbosity(self, val: str) -&gt; None:
    self._set_from_list(
        "verbosity",
        val,
        ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
    )
    logger.setLevel(val)

</t>
<t tx="ekr.20250122151620.860">def remove_updater(self, update_function: Updater) -&gt; Self:
    """Remove an updater.

    If the same updater is applied multiple times, every instance gets removed.

    Parameters
    ----------
    update_function
        The update function to be removed.


    Returns
    -------
    :class:`Mobject`
        ``self``

    See also
    --------
    :meth:`clear_updaters`
    :meth:`add_updater`
    :meth:`get_updaters`

    """
    while update_function in self.updaters:
        self.updaters.remove(update_function)
    return self

</t>
<t tx="ekr.20250122151620.861">def clear_updaters(self, recursive: bool = True) -&gt; Self:
    """Remove every updater.

    Parameters
    ----------
    recursive
        Whether to recursively call ``clear_updaters`` on all submobjects.

    Returns
    -------
    :class:`Mobject`
        ``self``

    See also
    --------
    :meth:`remove_updater`
    :meth:`add_updater`
    :meth:`get_updaters`

    """
    self.updaters = []
    if recursive:
        for submob in self.submobjects:
            submob.clear_updaters()
    return self

</t>
<t tx="ekr.20250122151620.862">def match_updaters(self, mobject: Mobject) -&gt; Self:
    """Match the updaters of the given mobject.

    Parameters
    ----------
    mobject
        The mobject whose updaters get matched.

    Returns
    -------
    :class:`Mobject`
        ``self``

    Note
    ----
    All updaters from submobjects are removed, but only updaters of the given
    mobject are matched, not those of it's submobjects.

    See also
    --------
    :meth:`add_updater`
    :meth:`clear_updaters`

    """
    self.clear_updaters()
    for updater in mobject.get_updaters():
        self.add_updater(updater)
    return self

</t>
<t tx="ekr.20250122151620.863">def suspend_updating(self, recursive: bool = True) -&gt; Self:
    """Disable updating from updaters and animations.


    Parameters
    ----------
    recursive
        Whether to recursively suspend updating on all submobjects.

    Returns
    -------
    :class:`Mobject`
        ``self``

    See also
    --------
    :meth:`resume_updating`
    :meth:`add_updater`

    """
    self.updating_suspended = True
    if recursive:
        for submob in self.submobjects:
            submob.suspend_updating(recursive)
    return self

</t>
<t tx="ekr.20250122151620.864">def resume_updating(self, recursive: bool = True) -&gt; Self:
    """Enable updating from updaters and animations.

    Parameters
    ----------
    recursive
        Whether to recursively enable updating on all submobjects.

    Returns
    -------
    :class:`Mobject`
        ``self``

    See also
    --------
    :meth:`suspend_updating`
    :meth:`add_updater`

    """
    self.updating_suspended = False
    if recursive:
        for submob in self.submobjects:
            submob.resume_updating(recursive)
    self.update(dt=0, recursive=recursive)
    return self

</t>
<t tx="ekr.20250122151620.865"># Transforming operations

def apply_to_family(self, func: Callable[[Mobject], None]) -&gt; None:
    """Apply a function to ``self`` and every submobject with points recursively.

    Parameters
    ----------
    func
        The function to apply to each mobject. ``func`` gets passed the respective
        (sub)mobject as parameter.

    Returns
    -------
    :class:`Mobject`
        ``self``

    See also
    --------
    :meth:`family_members_with_points`

    """
    for mob in self.family_members_with_points():
        func(mob)

</t>
<t tx="ekr.20250122151620.866">def shift(self, *vectors: Vector3D) -&gt; Self:
    """Shift by the given vectors.

    Parameters
    ----------
    vectors
        Vectors to shift by. If multiple vectors are given, they are added
        together.

    Returns
    -------
    :class:`Mobject`
        ``self``

    See also
    --------
    :meth:`move_to`
    """
    total_vector = reduce(op.add, vectors)
    for mob in self.family_members_with_points():
        mob.points = mob.points.astype("float")
        mob.points += total_vector

    return self

</t>
<t tx="ekr.20250122151620.867">def scale(self, scale_factor: float, **kwargs) -&gt; Self:
    r"""Scale the size by a factor.

    Default behavior is to scale about the center of the mobject.

    Parameters
    ----------
    scale_factor
        The scaling factor :math:`\alpha`. If :math:`0 &lt; |\alpha| &lt; 1`, the mobject
        will shrink, and for :math:`|\alpha| &gt; 1` it will grow. Furthermore,
        if :math:`\alpha &lt; 0`, the mobject is also flipped.
    kwargs
        Additional keyword arguments passed to
        :meth:`apply_points_function_about_point`.

    Returns
    -------
    :class:`Mobject`
        ``self``

    Examples
    --------

    .. manim:: MobjectScaleExample
        :save_last_frame:

        class MobjectScaleExample(Scene):
            def construct(self):
                f1 = Text("F")
                f2 = Text("F").scale(2)
                f3 = Text("F").scale(0.5)
                f4 = Text("F").scale(-1)

                vgroup = VGroup(f1, f2, f3, f4).arrange(6 * RIGHT)
                self.add(vgroup)

    See also
    --------
    :meth:`move_to`

    """
    self.apply_points_function_about_point(
        lambda points: scale_factor * points, **kwargs
    )
    return self

</t>
<t tx="ekr.20250122151620.868">def rotate_about_origin(self, angle: float, axis: Vector3D = OUT, axes=[]) -&gt; Self:
    """Rotates the :class:`~.Mobject` about the ORIGIN, which is at [0,0,0]."""
    return self.rotate(angle, axis, about_point=ORIGIN)

</t>
<t tx="ekr.20250122151620.869">def rotate(
    self,
    angle: float,
    axis: Vector3D = OUT,
    about_point: Point3DLike | None = None,
    **kwargs,
) -&gt; Self:
    """Rotates the :class:`~.Mobject` about a certain point."""
    rot_matrix = rotation_matrix(angle, axis)
    self.apply_points_function_about_point(
        lambda points: np.dot(points, rot_matrix.T), about_point, **kwargs
    )
    return self

</t>
<t tx="ekr.20250122151620.87">@property
def format(self) -&gt; str:
    """File format; "png", "gif", "mp4", "webm" or "mov"."""
    return self._d["format"]

</t>
<t tx="ekr.20250122151620.870">def flip(self, axis: Vector3D = UP, **kwargs) -&gt; Self:
    """Flips/Mirrors an mobject about its center.

    Examples
    --------

    .. manim:: FlipExample
        :save_last_frame:

        class FlipExample(Scene):
            def construct(self):
                s= Line(LEFT, RIGHT+UP).shift(4*LEFT)
                self.add(s)
                s2= s.copy().flip()
                self.add(s2)

    """
    return self.rotate(TAU / 2, axis, **kwargs)

</t>
<t tx="ekr.20250122151620.871">def stretch(self, factor: float, dim: int, **kwargs) -&gt; Self:
    def func(points: Point3D_Array) -&gt; Point3D_Array:
        points[:, dim] *= factor
        return points

    self.apply_points_function_about_point(func, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.872">def apply_function(self, function: MappingFunction, **kwargs) -&gt; Self:
    # Default to applying matrix about the origin, not mobjects center
    if len(kwargs) == 0:
        kwargs["about_point"] = ORIGIN

    def multi_mapping_function(points: Point3D_Array) -&gt; Point3D_Array:
        result: Point3D_Array = np.apply_along_axis(function, 1, points)
        return result

    self.apply_points_function_about_point(multi_mapping_function, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.873">def apply_function_to_position(self, function: MappingFunction) -&gt; Self:
    self.move_to(function(self.get_center()))
    return self

</t>
<t tx="ekr.20250122151620.874">def apply_function_to_submobject_positions(self, function: MappingFunction) -&gt; Self:
    for submob in self.submobjects:
        submob.apply_function_to_position(function)
    return self

</t>
<t tx="ekr.20250122151620.875">def apply_matrix(self, matrix, **kwargs) -&gt; Self:
    # Default to applying matrix about the origin, not mobjects center
    if ("about_point" not in kwargs) and ("about_edge" not in kwargs):
        kwargs["about_point"] = ORIGIN
    full_matrix = np.identity(self.dim)
    matrix = np.array(matrix)
    full_matrix[: matrix.shape[0], : matrix.shape[1]] = matrix
    self.apply_points_function_about_point(
        lambda points: np.dot(points, full_matrix.T), **kwargs
    )
    return self

</t>
<t tx="ekr.20250122151620.876">def apply_complex_function(
    self, function: Callable[[complex], complex], **kwargs
) -&gt; Self:
    """Applies a complex function to a :class:`Mobject`.
    The x and y Point3Ds correspond to the real and imaginary parts respectively.

    Example
    -------

    .. manim:: ApplyFuncExample

        class ApplyFuncExample(Scene):
            def construct(self):
                circ = Circle().scale(1.5)
                circ_ref = circ.copy()
                circ.apply_complex_function(
                    lambda x: np.exp(x*1j)
                )
                t = ValueTracker(0)
                circ.add_updater(
                    lambda x: x.become(circ_ref.copy().apply_complex_function(
                        lambda x: np.exp(x+t.get_value()*1j)
                    )).set_color(BLUE)
                )
                self.add(circ_ref)
                self.play(TransformFromCopy(circ_ref, circ))
                self.play(t.animate.set_value(TAU), run_time=3)
    """

    def R3_func(point):
        x, y, z = point
        xy_complex = function(complex(x, y))
        return [xy_complex.real, xy_complex.imag, z]

    return self.apply_function(R3_func)

</t>
<t tx="ekr.20250122151620.877">def reverse_points(self) -&gt; Self:
    for mob in self.family_members_with_points():
        mob.apply_over_attr_arrays(lambda arr: np.array(list(reversed(arr))))
    return self

</t>
<t tx="ekr.20250122151620.878">def repeat(self, count: int) -&gt; Self:
    """This can make transition animations nicer"""

    def repeat_array(array):
        return reduce(lambda a1, a2: np.append(a1, a2, axis=0), [array] * count)

    for mob in self.family_members_with_points():
        mob.apply_over_attr_arrays(repeat_array)
    return self

</t>
<t tx="ekr.20250122151620.879"># In place operations.
# Note, much of these are now redundant with default behavior of
# above methods

# TODO: name is inconsistent with OpenGLMobject.apply_points_function()
def apply_points_function_about_point(
    self,
    func: MultiMappingFunction,
    about_point: Point3DLike | None = None,
    about_edge: Vector3D | None = None,
) -&gt; Self:
    if about_point is None:
        if about_edge is None:
            about_edge = ORIGIN
        about_point = self.get_critical_point(about_edge)
    for mob in self.family_members_with_points():
        mob.points -= about_point
        mob.points = func(mob.points)
        mob.points += about_point
    return self

</t>
<t tx="ekr.20250122151620.88">@format.setter
def format(self, val: str) -&gt; None:
    self._set_from_list(
        "format",
        val,
        [None, "png", "gif", "mp4", "mov", "webm"],
    )
    self.resolve_movie_file_extension(self.transparent)
    if self.format == "webm":
        logger.warning(
            "Output format set as webm, this can be slower than other formats",
        )

</t>
<t tx="ekr.20250122151620.880">def pose_at_angle(self, **kwargs):
    self.rotate(TAU / 14, RIGHT + UP, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.881"># Positioning methods

def center(self) -&gt; Self:
    """Moves the center of the mobject to the center of the scene.

    Returns
    -------
    :class:`.Mobject`
        The centered mobject.
    """
    self.shift(-self.get_center())
    return self

</t>
<t tx="ekr.20250122151620.882">def align_on_border(
    self, direction: Vector3D, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER
) -&gt; Self:
    """Direction just needs to be a vector pointing towards side or
    corner in the 2d plane.
    """
    target_point = np.sign(direction) * (
        config["frame_x_radius"],
        config["frame_y_radius"],
        0,
    )
    point_to_align = self.get_critical_point(direction)
    shift_val = target_point - point_to_align - buff * np.array(direction)
    shift_val = shift_val * abs(np.sign(direction))
    self.shift(shift_val)
    return self

</t>
<t tx="ekr.20250122151620.883">def to_corner(
    self, corner: Vector3D = DL, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER
) -&gt; Self:
    """Moves this :class:`~.Mobject` to the given corner of the screen.

    Returns
    -------
    :class:`.Mobject`
        The newly positioned mobject.

    Examples
    --------

    .. manim:: ToCornerExample
        :save_last_frame:

        class ToCornerExample(Scene):
            def construct(self):
                c = Circle()
                c.to_corner(UR)
                t = Tex("To the corner!")
                t2 = MathTex("x^3").shift(DOWN)
                self.add(c,t,t2)
                t.to_corner(DL, buff=0)
                t2.to_corner(UL, buff=1.5)
    """
    return self.align_on_border(corner, buff)

</t>
<t tx="ekr.20250122151620.884">def to_edge(
    self, edge: Vector3D = LEFT, buff: float = DEFAULT_MOBJECT_TO_EDGE_BUFFER
) -&gt; Self:
    """Moves this :class:`~.Mobject` to the given edge of the screen,
    without affecting its position in the other dimension.

    Returns
    -------
    :class:`.Mobject`
        The newly positioned mobject.

    Examples
    --------

    .. manim:: ToEdgeExample
        :save_last_frame:

        class ToEdgeExample(Scene):
            def construct(self):
                tex_top = Tex("I am at the top!")
                tex_top.to_edge(UP)
                tex_side = Tex("I am moving to the side!")
                c = Circle().shift(2*DOWN)
                self.add(tex_top, tex_side, c)
                tex_side.to_edge(LEFT)
                c.to_edge(RIGHT, buff=0)

    """
    return self.align_on_border(edge, buff)

</t>
<t tx="ekr.20250122151620.885">def next_to(
    self,
    mobject_or_point: Mobject | Point3DLike,
    direction: Vector3D = RIGHT,
    buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,
    aligned_edge: Vector3D = ORIGIN,
    submobject_to_align: Mobject | None = None,
    index_of_submobject_to_align: int | None = None,
    coor_mask: Vector3D = np.array([1, 1, 1]),
</t>
<t tx="ekr.20250122151620.886">) -&gt; Self:
    """Move this :class:`~.Mobject` next to another's :class:`~.Mobject` or Point3D.

    Examples
    --------

    .. manim:: GeometricShapes
        :save_last_frame:

        class GeometricShapes(Scene):
            def construct(self):
                d = Dot()
                c = Circle()
                s = Square()
                t = Triangle()
                d.next_to(c, RIGHT)
                s.next_to(c, LEFT)
                t.next_to(c, DOWN)
                self.add(d, c, s, t)

    """
    if isinstance(mobject_or_point, Mobject):
        mob = mobject_or_point
        if index_of_submobject_to_align is not None:
            target_aligner = mob[index_of_submobject_to_align]
        else:
            target_aligner = mob
        target_point = target_aligner.get_critical_point(aligned_edge + direction)
    else:
        target_point = mobject_or_point
    if submobject_to_align is not None:
        aligner = submobject_to_align
    elif index_of_submobject_to_align is not None:
        aligner = self[index_of_submobject_to_align]
    else:
        aligner = self
    point_to_align = aligner.get_critical_point(aligned_edge - direction)
    self.shift((target_point - point_to_align + buff * direction) * coor_mask)
    return self

def shift_onto_screen(self, **kwargs) -&gt; Self:
    space_lengths = [config["frame_x_radius"], config["frame_y_radius"]]
    for vect in UP, DOWN, LEFT, RIGHT:
        dim = np.argmax(np.abs(vect))
        buff = kwargs.get("buff", DEFAULT_MOBJECT_TO_EDGE_BUFFER)
        max_val = space_lengths[dim] - buff
        edge_center = self.get_edge_center(vect)
        if np.dot(edge_center, vect) &gt; max_val:
            self.to_edge(vect, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.887">def is_off_screen(self):
    if self.get_left()[0] &gt; config["frame_x_radius"]:
        return True
    if self.get_right()[0] &lt; -config["frame_x_radius"]:
        return True
    if self.get_bottom()[1] &gt; config["frame_y_radius"]:
        return True
    return self.get_top()[1] &lt; -config["frame_y_radius"]

</t>
<t tx="ekr.20250122151620.888">def stretch_about_point(self, factor: float, dim: int, point: Point3DLike) -&gt; Self:
    return self.stretch(factor, dim, about_point=point)

</t>
<t tx="ekr.20250122151620.889">def rescale_to_fit(
    self, length: float, dim: int, stretch: bool = False, **kwargs
) -&gt; Self:
    old_length = self.length_over_dim(dim)
    if old_length == 0:
        return self
    if stretch:
        self.stretch(length / old_length, dim, **kwargs)
    else:
        self.scale(length / old_length, **kwargs)
    return self

</t>
<t tx="ekr.20250122151620.89">@property
def ffmpeg_loglevel(self) -&gt; str:
    """Verbosity level of ffmpeg (no flag)."""
    return self._d["ffmpeg_loglevel"]

</t>
<t tx="ekr.20250122151620.890">def scale_to_fit_width(self, width: float, **kwargs) -&gt; Self:
    """Scales the :class:`~.Mobject` to fit a width while keeping height/depth proportional.

    Returns
    -------
    :class:`Mobject`
        ``self``

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import *
        &gt;&gt;&gt; sq = Square()
        &gt;&gt;&gt; sq.height
        np.float64(2.0)
        &gt;&gt;&gt; sq.scale_to_fit_width(5)
        Square
        &gt;&gt;&gt; sq.width
        np.float64(5.0)
        &gt;&gt;&gt; sq.height
        np.float64(5.0)
    """
    return self.rescale_to_fit(width, 0, stretch=False, **kwargs)

</t>
<t tx="ekr.20250122151620.891">def stretch_to_fit_width(self, width: float, **kwargs) -&gt; Self:
    """Stretches the :class:`~.Mobject` to fit a width, not keeping height/depth proportional.

    Returns
    -------
    :class:`Mobject`
        ``self``

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import *
        &gt;&gt;&gt; sq = Square()
        &gt;&gt;&gt; sq.height
        np.float64(2.0)
        &gt;&gt;&gt; sq.stretch_to_fit_width(5)
        Square
        &gt;&gt;&gt; sq.width
        np.float64(5.0)
        &gt;&gt;&gt; sq.height
        np.float64(2.0)
    """
    return self.rescale_to_fit(width, 0, stretch=True, **kwargs)

</t>
<t tx="ekr.20250122151620.892">def scale_to_fit_height(self, height: float, **kwargs) -&gt; Self:
    """Scales the :class:`~.Mobject` to fit a height while keeping width/depth proportional.

    Returns
    -------
    :class:`Mobject`
        ``self``

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import *
        &gt;&gt;&gt; sq = Square()
        &gt;&gt;&gt; sq.width
        np.float64(2.0)
        &gt;&gt;&gt; sq.scale_to_fit_height(5)
        Square
        &gt;&gt;&gt; sq.height
        np.float64(5.0)
        &gt;&gt;&gt; sq.width
        np.float64(5.0)
    """
    return self.rescale_to_fit(height, 1, stretch=False, **kwargs)

</t>
<t tx="ekr.20250122151620.893">def stretch_to_fit_height(self, height: float, **kwargs) -&gt; Self:
    """Stretches the :class:`~.Mobject` to fit a height, not keeping width/depth proportional.

    Returns
    -------
    :class:`Mobject`
        ``self``

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import *
        &gt;&gt;&gt; sq = Square()
        &gt;&gt;&gt; sq.width
        np.float64(2.0)
        &gt;&gt;&gt; sq.stretch_to_fit_height(5)
        Square
        &gt;&gt;&gt; sq.height
        np.float64(5.0)
        &gt;&gt;&gt; sq.width
        np.float64(2.0)
    """
    return self.rescale_to_fit(height, 1, stretch=True, **kwargs)

</t>
<t tx="ekr.20250122151620.894">def scale_to_fit_depth(self, depth: float, **kwargs) -&gt; Self:
    """Scales the :class:`~.Mobject` to fit a depth while keeping width/height proportional."""
    return self.rescale_to_fit(depth, 2, stretch=False, **kwargs)

</t>
<t tx="ekr.20250122151620.895">def stretch_to_fit_depth(self, depth: float, **kwargs) -&gt; Self:
    """Stretches the :class:`~.Mobject` to fit a depth, not keeping width/height proportional."""
    return self.rescale_to_fit(depth, 2, stretch=True, **kwargs)

</t>
<t tx="ekr.20250122151620.896">def set_coord(self, value, dim: int, direction: Vector3D = ORIGIN) -&gt; Self:
    curr = self.get_coord(dim, direction)
    shift_vect = np.zeros(self.dim)
    shift_vect[dim] = value - curr
    self.shift(shift_vect)
    return self

</t>
<t tx="ekr.20250122151620.897">def set_x(self, x: float, direction: Vector3D = ORIGIN) -&gt; Self:
    """Set x value of the center of the :class:`~.Mobject` (``int`` or ``float``)"""
    return self.set_coord(x, 0, direction)

</t>
<t tx="ekr.20250122151620.898">def set_y(self, y: float, direction: Vector3D = ORIGIN) -&gt; Self:
    """Set y value of the center of the :class:`~.Mobject` (``int`` or ``float``)"""
    return self.set_coord(y, 1, direction)

</t>
<t tx="ekr.20250122151620.899">def set_z(self, z: float, direction: Vector3D = ORIGIN) -&gt; Self:
    """Set z value of the center of the :class:`~.Mobject` (``int`` or ``float``)"""
    return self.set_coord(z, 2, direction)

</t>
<t tx="ekr.20250122151620.9">class QualityDict(TypedDict):
    flag: str | None
    pixel_height: int
    pixel_width: int
    frame_rate: int


</t>
<t tx="ekr.20250122151620.90">@ffmpeg_loglevel.setter
def ffmpeg_loglevel(self, val: str) -&gt; None:
    self._set_from_list(
        "ffmpeg_loglevel",
        val,
        ["DEBUG", "INFO", "WARNING", "ERROR", "CRITICAL"],
    )
    logging.getLogger("libav").setLevel(self.ffmpeg_loglevel)

</t>
<t tx="ekr.20250122151620.900">def space_out_submobjects(self, factor: float = 1.5, **kwargs) -&gt; Self:
    self.scale(factor, **kwargs)
    for submob in self.submobjects:
        submob.scale(1.0 / factor)
    return self

</t>
<t tx="ekr.20250122151620.901">def move_to(
    self,
    point_or_mobject: Point3DLike | Mobject,
    aligned_edge: Vector3D = ORIGIN,
    coor_mask: Vector3D = np.array([1, 1, 1]),
</t>
<t tx="ekr.20250122151620.902">) -&gt; Self:
    """Move center of the :class:`~.Mobject` to certain Point3D."""
    if isinstance(point_or_mobject, Mobject):
        target = point_or_mobject.get_critical_point(aligned_edge)
    else:
        target = point_or_mobject
    point_to_align = self.get_critical_point(aligned_edge)
    self.shift((target - point_to_align) * coor_mask)
    return self

def replace(
    self, mobject: Mobject, dim_to_match: int = 0, stretch: bool = False
) -&gt; Self:
    if not mobject.get_num_points() and not mobject.submobjects:
        raise Warning("Attempting to replace mobject with no points")
    if stretch:
        self.stretch_to_fit_width(mobject.width)
        self.stretch_to_fit_height(mobject.height)
    else:
        self.rescale_to_fit(
            mobject.length_over_dim(dim_to_match),
            dim_to_match,
            stretch=False,
        )
    self.shift(mobject.get_center() - self.get_center())
    return self

</t>
<t tx="ekr.20250122151620.903">def surround(
    self,
    mobject: Mobject,
    dim_to_match: int = 0,
    stretch: bool = False,
    buff: float = MED_SMALL_BUFF,
) -&gt; Self:
    self.replace(mobject, dim_to_match, stretch)
    length = mobject.length_over_dim(dim_to_match)
    self.scale((length + buff) / length)
    return self

</t>
<t tx="ekr.20250122151620.904">def put_start_and_end_on(self, start: Point3DLike, end: Point3DLike) -&gt; Self:
    curr_start, curr_end = self.get_start_and_end()
    curr_vect = curr_end - curr_start
    if np.all(curr_vect == 0):
        # TODO: this looks broken. It makes self.points a Point3D instead
        # of a Point3D_Array. However, modifying this breaks some tests
        # where this is currently expected.
        self.points = np.array(start)
        return self
    target_vect = np.asarray(end) - np.asarray(start)
    axis = (
        normalize(np.cross(curr_vect, target_vect))
        if np.linalg.norm(np.cross(curr_vect, target_vect)) != 0
        else OUT
    )
    self.scale(
        np.linalg.norm(target_vect) / np.linalg.norm(curr_vect),
        about_point=curr_start,
    )
    self.rotate(
        angle_between_vectors(curr_vect, target_vect),
        about_point=curr_start,
        axis=axis,
    )
    self.shift(start - curr_start)
    return self

</t>
<t tx="ekr.20250122151620.905"># Background rectangle
def add_background_rectangle(
    self, color: ParsableManimColor | None = None, opacity: float = 0.75, **kwargs
) -&gt; Self:
    """Add a BackgroundRectangle as submobject.

    The BackgroundRectangle is added behind other submobjects.

    This can be used to increase the mobjects visibility in front of a noisy background.

    Parameters
    ----------
    color
        The color of the BackgroundRectangle
    opacity
        The opacity of the BackgroundRectangle
    kwargs
        Additional keyword arguments passed to the BackgroundRectangle constructor


    Returns
    -------
    :class:`Mobject`
        ``self``

    See Also
    --------
    :meth:`add_to_back`
    :class:`~.BackgroundRectangle`

    """
    # TODO, this does not behave well when the mobject has points,
    # since it gets displayed on top
    from manim.mobject.geometry.shape_matchers import BackgroundRectangle

    self.background_rectangle = BackgroundRectangle(
        self, color=color, fill_opacity=opacity, **kwargs
    )
    self.add_to_back(self.background_rectangle)
    return self

</t>
<t tx="ekr.20250122151620.906">def add_background_rectangle_to_submobjects(self, **kwargs) -&gt; Self:
    for submobject in self.submobjects:
        submobject.add_background_rectangle(**kwargs)
    return self

</t>
<t tx="ekr.20250122151620.907">def add_background_rectangle_to_family_members_with_points(self, **kwargs) -&gt; Self:
    for mob in self.family_members_with_points():
        mob.add_background_rectangle(**kwargs)
    return self

</t>
<t tx="ekr.20250122151620.908"># Color functions

def set_color(
    self, color: ParsableManimColor = YELLOW_C, family: bool = True
) -&gt; Self:
    """Condition is function which takes in one arguments, (x, y, z).
    Here it just recurses to submobjects, but in subclasses this
    should be further implemented based on the the inner workings
    of color
    """
    if family:
        for submob in self.submobjects:
            submob.set_color(color, family=family)

    self.color = ManimColor.parse(color)
    return self

</t>
<t tx="ekr.20250122151620.909">def set_color_by_gradient(self, *colors: ParsableManimColor) -&gt; Self:
    """
    Parameters
    ----------
    colors
        The colors to use for the gradient. Use like `set_color_by_gradient(RED, BLUE, GREEN)`.

    self.color = ManimColor.parse(color)
    return self
    """
    self.set_submobject_colors_by_gradient(*colors)
    return self

</t>
<t tx="ekr.20250122151620.91">@property
def media_embed(self) -&gt; bool:
    """Whether to embed videos in Jupyter notebook."""
    return self._d["media_embed"]

</t>
<t tx="ekr.20250122151620.910">def set_colors_by_radial_gradient(
    self,
    center: Point3DLike | None = None,
    radius: float = 1,
    inner_color: ParsableManimColor = WHITE,
    outer_color: ParsableManimColor = BLACK,
) -&gt; Self:
    self.set_submobject_colors_by_radial_gradient(
        center,
        radius,
        inner_color,
        outer_color,
    )
    return self

</t>
<t tx="ekr.20250122151620.911">def set_submobject_colors_by_gradient(self, *colors: Iterable[ParsableManimColor]):
    if len(colors) == 0:
        raise ValueError("Need at least one color")
    elif len(colors) == 1:
        return self.set_color(*colors)

    mobs = self.family_members_with_points()
    new_colors = color_gradient(colors, len(mobs))

    for mob, color in zip(mobs, new_colors):
        mob.set_color(color, family=False)
    return self

</t>
<t tx="ekr.20250122151620.912">def set_submobject_colors_by_radial_gradient(
    self,
    center: Point3DLike | None = None,
    radius: float = 1,
    inner_color: ParsableManimColor = WHITE,
    outer_color: ParsableManimColor = BLACK,
) -&gt; Self:
    if center is None:
        center = self.get_center()

    for mob in self.family_members_with_points():
        t = np.linalg.norm(mob.get_center() - center) / radius
        t = min(t, 1)
        mob_color = interpolate_color(inner_color, outer_color, t)
        mob.set_color(mob_color, family=False)

    return self

</t>
<t tx="ekr.20250122151620.913">def to_original_color(self) -&gt; Self:
    self.set_color(self.color)
    return self

</t>
<t tx="ekr.20250122151620.914">def fade_to(
    self, color: ParsableManimColor, alpha: float, family: bool = True
) -&gt; Self:
    if self.get_num_points() &gt; 0:
        new_color = interpolate_color(self.get_color(), color, alpha)
        self.set_color(new_color, family=False)
    if family:
        for submob in self.submobjects:
            submob.fade_to(color, alpha)
    return self

</t>
<t tx="ekr.20250122151620.915">def fade(self, darkness: float = 0.5, family: bool = True) -&gt; Self:
    if family:
        for submob in self.submobjects:
            submob.fade(darkness, family)
    return self

</t>
<t tx="ekr.20250122151620.916">def get_color(self) -&gt; ManimColor:
    """Returns the color of the :class:`~.Mobject`

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import Square, RED
        &gt;&gt;&gt; Square(color=RED).get_color() == RED
        True

    """
    return self.color

</t>
<t tx="ekr.20250122151620.917">##

def save_state(self) -&gt; Self:
    """Save the current state (position, color &amp; size). Can be restored with :meth:`~.Mobject.restore`."""
    if hasattr(self, "saved_state"):
        # Prevent exponential growth of data
        self.saved_state = None
    self.saved_state = self.copy()

    return self

</t>
<t tx="ekr.20250122151620.918">def restore(self) -&gt; Self:
    """Restores the state that was previously saved with :meth:`~.Mobject.save_state`."""
    if not hasattr(self, "saved_state") or self.save_state is None:
        raise Exception("Trying to restore without having saved")
    self.become(self.saved_state)
    return self

</t>
<t tx="ekr.20250122151620.919">def reduce_across_dimension(self, reduce_func: Callable, dim: int):
    """Find the min or max value from a dimension across all points in this and submobjects."""
    assert dim &gt;= 0
    assert dim &lt;= 2
    if len(self.submobjects) == 0 and len(self.points) == 0:
        # If we have no points and no submobjects, return 0 (e.g. center)
        return 0

    # If we do not have points (but do have submobjects)
    # use only the points from those.
    if len(self.points) == 0:  # noqa: SIM108
        rv = None
    else:
        # Otherwise, be sure to include our own points
        rv = reduce_func(self.points[:, dim])
    # Recursively ask submobjects (if any) for the biggest/
    # smallest dimension they have and compare it to the return value.
    for mobj in self.submobjects:
        value = mobj.reduce_across_dimension(reduce_func, dim)
        rv = value if rv is None else reduce_func([value, rv])
    return rv

</t>
<t tx="ekr.20250122151620.92">@media_embed.setter
def media_embed(self, value: bool) -&gt; None:
    self._set_boolean("media_embed", value)

</t>
<t tx="ekr.20250122151620.920">def nonempty_submobjects(self) -&gt; list[Self]:
    return [
        submob
        for submob in self.submobjects
        if len(submob.submobjects) != 0 or len(submob.points) != 0
    ]

</t>
<t tx="ekr.20250122151620.921">def get_merged_array(self, array_attr: str) -&gt; np.ndarray:
    """Return all of a given attribute from this mobject and all submobjects.

    May contain duplicates; the order is in a depth-first (pre-order)
    traversal of the submobjects.
    """
    result = getattr(self, array_attr)
    for submob in self.submobjects:
        result = np.append(result, submob.get_merged_array(array_attr), axis=0)
    return result

</t>
<t tx="ekr.20250122151620.922">def get_all_points(self) -&gt; Point3D_Array:
    """Return all points from this mobject and all submobjects.

    May contain duplicates; the order is in a depth-first (pre-order)
    traversal of the submobjects.
    """
    return self.get_merged_array("points")

</t>
<t tx="ekr.20250122151620.923"># Getters

def get_points_defining_boundary(self) -&gt; Point3D_Array:
    return self.get_all_points()

</t>
<t tx="ekr.20250122151620.924">def get_num_points(self) -&gt; int:
    return len(self.points)

</t>
<t tx="ekr.20250122151620.925">def get_extremum_along_dim(
    self, points: Point3DLike_Array | None = None, dim: int = 0, key: int = 0
) -&gt; float:
    np_points: Point3D_Array = (
        self.get_points_defining_boundary()
        if points is None
        else np.asarray(points)
    )
    values = np_points[:, dim]
    if key &lt; 0:
        return np.min(values)
    elif key == 0:
        return (np.min(values) + np.max(values)) / 2
    else:
        return np.max(values)

</t>
<t tx="ekr.20250122151620.926">def get_critical_point(self, direction: Vector3D) -&gt; Point3D:
    """Picture a box bounding the :class:`~.Mobject`.  Such a box has
    9 'critical points': 4 corners, 4 edge center, the
    center. This returns one of them, along the given direction.

    ::

        sample = Arc(start_angle=PI / 7, angle=PI / 5)

        # These are all equivalent
        max_y_1 = sample.get_top()[1]
        max_y_2 = sample.get_critical_point(UP)[1]
        max_y_3 = sample.get_extremum_along_dim(dim=1, key=1)

    """
    result = np.zeros(self.dim)
    all_points = self.get_points_defining_boundary()
    if len(all_points) == 0:
        return result
    for dim in range(self.dim):
        result[dim] = self.get_extremum_along_dim(
            all_points,
            dim=dim,
            key=direction[dim],
        )
    return result

</t>
<t tx="ekr.20250122151620.927"># Pseudonyms for more general get_critical_point method

def get_edge_center(self, direction: Vector3D) -&gt; Point3D:
    """Get edge Point3Ds for certain direction."""
    return self.get_critical_point(direction)

</t>
<t tx="ekr.20250122151620.928">def get_corner(self, direction: Vector3D) -&gt; Point3D:
    """Get corner Point3Ds for certain direction."""
    return self.get_critical_point(direction)

</t>
<t tx="ekr.20250122151620.929">def get_center(self) -&gt; Point3D:
    """Get center Point3Ds"""
    return self.get_critical_point(np.zeros(self.dim))

</t>
<t tx="ekr.20250122151620.93">@property
def media_width(self) -&gt; str:
    """Media width in Jupyter notebook."""
    return self._d["media_width"]

</t>
<t tx="ekr.20250122151620.930">def get_center_of_mass(self) -&gt; Point3D:
    return np.apply_along_axis(np.mean, 0, self.get_all_points())

</t>
<t tx="ekr.20250122151620.931">def get_boundary_point(self, direction: Vector3D) -&gt; Point3D:
    all_points = self.get_points_defining_boundary()
    index = np.argmax(np.dot(all_points, np.array(direction).T))
    return all_points[index]

</t>
<t tx="ekr.20250122151620.932">def get_midpoint(self) -&gt; Point3D:
    """Get Point3Ds of the middle of the path that forms the  :class:`~.Mobject`.

    Examples
    --------

    .. manim:: AngleMidPoint
        :save_last_frame:

        class AngleMidPoint(Scene):
            def construct(self):
                line1 = Line(ORIGIN, 2*RIGHT)
                line2 = Line(ORIGIN, 2*RIGHT).rotate_about_origin(80*DEGREES)

                a = Angle(line1, line2, radius=1.5, other_angle=False)
                d = Dot(a.get_midpoint()).set_color(RED)

                self.add(line1, line2, a, d)
                self.wait()

    """
    return self.point_from_proportion(0.5)

</t>
<t tx="ekr.20250122151620.933">def get_top(self) -&gt; Point3D:
    """Get top Point3Ds of a box bounding the :class:`~.Mobject`"""
    return self.get_edge_center(UP)

</t>
<t tx="ekr.20250122151620.934">def get_bottom(self) -&gt; Point3D:
    """Get bottom Point3Ds of a box bounding the :class:`~.Mobject`"""
    return self.get_edge_center(DOWN)

</t>
<t tx="ekr.20250122151620.935">def get_right(self) -&gt; Point3D:
    """Get right Point3Ds of a box bounding the :class:`~.Mobject`"""
    return self.get_edge_center(RIGHT)

</t>
<t tx="ekr.20250122151620.936">def get_left(self) -&gt; Point3D:
    """Get left Point3Ds of a box bounding the :class:`~.Mobject`"""
    return self.get_edge_center(LEFT)

</t>
<t tx="ekr.20250122151620.937">def get_zenith(self) -&gt; Point3D:
    """Get zenith Point3Ds of a box bounding a 3D :class:`~.Mobject`."""
    return self.get_edge_center(OUT)

</t>
<t tx="ekr.20250122151620.938">def get_nadir(self) -&gt; Point3D:
    """Get nadir (opposite the zenith) Point3Ds of a box bounding a 3D :class:`~.Mobject`."""
    return self.get_edge_center(IN)

</t>
<t tx="ekr.20250122151620.939">def length_over_dim(self, dim: int) -&gt; float:
    """Measure the length of an :class:`~.Mobject` in a certain direction."""
    return self.reduce_across_dimension(
        max,
        dim,
    ) - self.reduce_across_dimension(min, dim)

</t>
<t tx="ekr.20250122151620.94">@media_width.setter
def media_width(self, value: str) -&gt; None:
    self._set_str("media_width", value)

</t>
<t tx="ekr.20250122151620.940">def get_coord(self, dim: int, direction: Vector3D = ORIGIN):
    """Meant to generalize ``get_x``, ``get_y`` and ``get_z``"""
    return self.get_extremum_along_dim(dim=dim, key=direction[dim])

</t>
<t tx="ekr.20250122151620.941">def get_x(self, direction: Vector3D = ORIGIN) -&gt; float:
    """Returns x Point3D of the center of the :class:`~.Mobject` as ``float``"""
    return self.get_coord(0, direction)

</t>
<t tx="ekr.20250122151620.942">def get_y(self, direction: Vector3D = ORIGIN) -&gt; float:
    """Returns y Point3D of the center of the :class:`~.Mobject` as ``float``"""
    return self.get_coord(1, direction)

</t>
<t tx="ekr.20250122151620.943">def get_z(self, direction: Vector3D = ORIGIN) -&gt; float:
    """Returns z Point3D of the center of the :class:`~.Mobject` as ``float``"""
    return self.get_coord(2, direction)

</t>
<t tx="ekr.20250122151620.944">def get_start(self) -&gt; Point3D:
    """Returns the point, where the stroke that surrounds the :class:`~.Mobject` starts."""
    self.throw_error_if_no_points()
    return np.array(self.points[0])

</t>
<t tx="ekr.20250122151620.945">def get_end(self) -&gt; Point3D:
    """Returns the point, where the stroke that surrounds the :class:`~.Mobject` ends."""
    self.throw_error_if_no_points()
    return np.array(self.points[-1])

</t>
<t tx="ekr.20250122151620.946">def get_start_and_end(self) -&gt; tuple[Point3D, Point3D]:
    """Returns starting and ending point of a stroke as a ``tuple``."""
    return self.get_start(), self.get_end()

</t>
<t tx="ekr.20250122151620.947">def point_from_proportion(self, alpha: float) -&gt; Point3D:
    raise NotImplementedError("Please override in a child class.")

</t>
<t tx="ekr.20250122151620.948">def proportion_from_point(self, point: Point3DLike) -&gt; float:
    raise NotImplementedError("Please override in a child class.")

</t>
<t tx="ekr.20250122151620.949">def get_pieces(self, n_pieces: float) -&gt; Group:
    template = self.copy()
    template.submobjects = []
    alphas = np.linspace(0, 1, n_pieces + 1)
    return Group(
        *(
            template.copy().pointwise_become_partial(self, a1, a2)
            for a1, a2 in zip(alphas[:-1], alphas[1:])
        )
    )

</t>
<t tx="ekr.20250122151620.95">@property
def pixel_width(self) -&gt; int:
    """Frame width in pixels (--resolution, -r)."""
    return self._d["pixel_width"]

</t>
<t tx="ekr.20250122151620.950">def get_z_index_reference_point(self) -&gt; Point3D:
    # TODO, better place to define default z_index_group?
    z_index_group = getattr(self, "z_index_group", self)
    return z_index_group.get_center()

</t>
<t tx="ekr.20250122151620.951">def has_points(self) -&gt; bool:
    """Check if :class:`~.Mobject` contains points."""
    return len(self.points) &gt; 0

</t>
<t tx="ekr.20250122151620.952">def has_no_points(self) -&gt; bool:
    """Check if :class:`~.Mobject` *does not* contains points."""
    return not self.has_points()

</t>
<t tx="ekr.20250122151620.953"># Match other mobject properties

def match_color(self, mobject: Mobject) -&gt; Self:
    """Match the color with the color of another :class:`~.Mobject`."""
    return self.set_color(mobject.get_color())

</t>
<t tx="ekr.20250122151620.954">def match_dim_size(self, mobject: Mobject, dim: int, **kwargs) -&gt; Self:
    """Match the specified dimension with the dimension of another :class:`~.Mobject`."""
    return self.rescale_to_fit(mobject.length_over_dim(dim), dim, **kwargs)

</t>
<t tx="ekr.20250122151620.955">def match_width(self, mobject: Mobject, **kwargs) -&gt; Self:
    """Match the width with the width of another :class:`~.Mobject`."""
    return self.match_dim_size(mobject, 0, **kwargs)

</t>
<t tx="ekr.20250122151620.956">def match_height(self, mobject: Mobject, **kwargs) -&gt; Self:
    """Match the height with the height of another :class:`~.Mobject`."""
    return self.match_dim_size(mobject, 1, **kwargs)

</t>
<t tx="ekr.20250122151620.957">def match_depth(self, mobject: Mobject, **kwargs) -&gt; Self:
    """Match the depth with the depth of another :class:`~.Mobject`."""
    return self.match_dim_size(mobject, 2, **kwargs)

</t>
<t tx="ekr.20250122151620.958">def match_coord(
    self, mobject: Mobject, dim: int, direction: Vector3D = ORIGIN
) -&gt; Self:
    """Match the Point3Ds with the Point3Ds of another :class:`~.Mobject`."""
    return self.set_coord(
        mobject.get_coord(dim, direction),
        dim=dim,
        direction=direction,
    )

</t>
<t tx="ekr.20250122151620.959">def match_x(self, mobject: Mobject, direction=ORIGIN) -&gt; Self:
    """Match x coord. to the x coord. of another :class:`~.Mobject`."""
    return self.match_coord(mobject, 0, direction)

</t>
<t tx="ekr.20250122151620.96">@pixel_width.setter
def pixel_width(self, value: int) -&gt; None:
    self._set_pos_number("pixel_width", value, False)

</t>
<t tx="ekr.20250122151620.960">def match_y(self, mobject: Mobject, direction=ORIGIN) -&gt; Self:
    """Match y coord. to the x coord. of another :class:`~.Mobject`."""
    return self.match_coord(mobject, 1, direction)

</t>
<t tx="ekr.20250122151620.961">def match_z(self, mobject: Mobject, direction=ORIGIN) -&gt; Self:
    """Match z coord. to the x coord. of another :class:`~.Mobject`."""
    return self.match_coord(mobject, 2, direction)

</t>
<t tx="ekr.20250122151620.962">def align_to(
    self,
    mobject_or_point: Mobject | Point3DLike,
    direction: Vector3D = ORIGIN,
) -&gt; Self:
    """Aligns mobject to another :class:`~.Mobject` in a certain direction.

    Examples:
    mob1.align_to(mob2, UP) moves mob1 vertically so that its
    top edge lines ups with mob2's top edge.
    """
    if isinstance(mobject_or_point, Mobject):
        point = mobject_or_point.get_critical_point(direction)
    else:
        point = mobject_or_point

    for dim in range(self.dim):
        if direction[dim] != 0:
            self.set_coord(point[dim], dim, direction)
    return self

</t>
<t tx="ekr.20250122151620.963"># Family matters

def __getitem__(self, value):
    self_list = self.split()
    if isinstance(value, slice):
        GroupClass = self.get_group_class()
        return GroupClass(*self_list.__getitem__(value))
    return self_list.__getitem__(value)

</t>
<t tx="ekr.20250122151620.964">def __iter__(self):
    return iter(self.split())

</t>
<t tx="ekr.20250122151620.965">def __len__(self):
    return len(self.split())

</t>
<t tx="ekr.20250122151620.966">def get_group_class(self) -&gt; type[Group]:
    return Group

</t>
<t tx="ekr.20250122151620.967">@staticmethod
def get_mobject_type_class() -&gt; type[Mobject]:
    """Return the base class of this mobject type."""
    return Mobject

</t>
<t tx="ekr.20250122151620.968">def split(self) -&gt; list[Self]:
    result = [self] if len(self.points) &gt; 0 else []
    return result + self.submobjects

</t>
<t tx="ekr.20250122151620.969">def get_family(self, recurse: bool = True) -&gt; list[Self]:
    sub_families = [x.get_family() for x in self.submobjects]
    all_mobjects = [self] + list(it.chain(*sub_families))
    return remove_list_redundancies(all_mobjects)

</t>
<t tx="ekr.20250122151620.97">@property
def pixel_height(self) -&gt; int:
    """Frame height in pixels (--resolution, -r)."""
    return self._d["pixel_height"]

</t>
<t tx="ekr.20250122151620.970">def family_members_with_points(self) -&gt; list[Self]:
    return [m for m in self.get_family() if m.get_num_points() &gt; 0]

</t>
<t tx="ekr.20250122151620.971">def arrange(
    self,
    direction: Vector3D = RIGHT,
    buff: float = DEFAULT_MOBJECT_TO_MOBJECT_BUFFER,
    center: bool = True,
    **kwargs,
) -&gt; Self:
    """Sorts :class:`~.Mobject` next to each other on screen.

    Examples
    --------

    .. manim:: Example
        :save_last_frame:

        class Example(Scene):
            def construct(self):
                s1 = Square()
                s2 = Square()
                s3 = Square()
                s4 = Square()
                x = VGroup(s1, s2, s3, s4).set_x(0).arrange(buff=1.0)
                self.add(x)
    """
    for m1, m2 in zip(self.submobjects, self.submobjects[1:]):
        m2.next_to(m1, direction, buff, **kwargs)
    if center:
        self.center()
    return self

</t>
<t tx="ekr.20250122151620.972">def arrange_in_grid(
    self,
    rows: int | None = None,
    cols: int | None = None,
    buff: float | tuple[float, float] = MED_SMALL_BUFF,
    cell_alignment: Vector3D = ORIGIN,
    row_alignments: str | None = None,  # "ucd"
    col_alignments: str | None = None,  # "lcr"
    row_heights: Iterable[float | None] | None = None,
    col_widths: Iterable[float | None] | None = None,
    flow_order: str = "rd",
    **kwargs,
) -&gt; Self:
    """Arrange submobjects in a grid.

    Parameters
    ----------
    rows
        The number of rows in the grid.
    cols
        The number of columns in the grid.
    buff
        The gap between grid cells. To specify a different buffer in the horizontal and
        vertical directions, a tuple of two values can be given - ``(row, col)``.
    cell_alignment
        The way each submobject is aligned in its grid cell.
    row_alignments
        The vertical alignment for each row (top to bottom). Accepts the following characters: ``"u"`` -
        up, ``"c"`` - center, ``"d"`` - down.
    col_alignments
        The horizontal alignment for each column (left to right). Accepts the following characters ``"l"`` - left,
        ``"c"`` - center, ``"r"`` - right.
    row_heights
        Defines a list of heights for certain rows (top to bottom). If the list contains
        ``None``, the corresponding row will fit its height automatically based
        on the highest element in that row.
    col_widths
        Defines a list of widths for certain columns (left to right). If the list contains ``None``, the
        corresponding column will fit its width automatically based on the widest element in that column.
    flow_order
        The order in which submobjects fill the grid. Can be one of the following values:
        "rd", "dr", "ld", "dl", "ru", "ur", "lu", "ul". ("rd" -&gt; fill rightwards then downwards)

    Returns
    -------
    :class:`Mobject`
        ``self``

    Raises
    ------
    ValueError
        If ``rows`` and ``cols`` are too small to fit all submobjects.
    ValueError
        If :code:`cols`, :code:`col_alignments` and :code:`col_widths` or :code:`rows`,
        :code:`row_alignments` and :code:`row_heights` have mismatching sizes.

    Notes
    -----
    If only one of ``cols`` and ``rows`` is set implicitly, the other one will be chosen big
    enough to fit all submobjects. If neither is set, they will be chosen to be about the same,
    tending towards ``cols`` &gt; ``rows`` (simply because videos are wider than they are high).

    If both ``cell_alignment`` and ``row_alignments`` / ``col_alignments`` are
    defined, the latter has higher priority.

    Examples
    --------
    .. manim:: ExampleBoxes
        :save_last_frame:

        class ExampleBoxes(Scene):
            def construct(self):
                boxes=VGroup(*[Square() for s in range(0,6)])
                boxes.arrange_in_grid(rows=2, buff=0.1)
                self.add(boxes)


    .. manim:: ArrangeInGrid
        :save_last_frame:

        class ArrangeInGrid(Scene):
            def construct(self):
                boxes = VGroup(*[
                    Rectangle(WHITE, 0.5, 0.5).add(Text(str(i+1)).scale(0.5))
                    for i in range(24)
                ])
                self.add(boxes)

                boxes.arrange_in_grid(
                    buff=(0.25,0.5),
                    col_alignments="lccccr",
                    row_alignments="uccd",
                    col_widths=[1, *[None]*4, 1],
                    row_heights=[1, None, None, 1],
                    flow_order="dr"
                )


    """
    from manim.mobject.geometry.line import Line

    mobs = self.submobjects.copy()
    start_pos = self.get_center()

    # get cols / rows values if given (implicitly)
    def init_size(num, alignments, sizes):
        if num is not None:
            return num
        if alignments is not None:
            return len(alignments)
        if sizes is not None:
            return len(sizes)

    cols = init_size(cols, col_alignments, col_widths)
    rows = init_size(rows, row_alignments, row_heights)

    # calculate rows cols
    if rows is None and cols is None:
        cols = math.ceil(math.sqrt(len(mobs)))
        # make the grid as close to quadratic as possible.
        # choosing cols first can results in cols&gt;rows.
        # This is favored over rows&gt;cols since in general
        # the sceene is wider than high.
    if rows is None:
        rows = math.ceil(len(mobs) / cols)
    if cols is None:
        cols = math.ceil(len(mobs) / rows)
    if rows * cols &lt; len(mobs):
        raise ValueError("Too few rows and columns to fit all submobjetcs.")
    # rows and cols are now finally valid.

    if isinstance(buff, tuple):
        buff_x = buff[0]
        buff_y = buff[1]
    else:
        buff_x = buff_y = buff

    # Initialize alignments correctly
    def init_alignments(alignments, num, mapping, name, dir_):
        if alignments is None:
            # Use cell_alignment as fallback
            return [cell_alignment * dir_] * num
        if len(alignments) != num:
            raise ValueError(f"{name}_alignments has a mismatching size.")
        alignments = list(alignments)
        for i in range(num):
            alignments[i] = mapping[alignments[i]]
        return alignments

    row_alignments = init_alignments(
        row_alignments,
        rows,
        {"u": UP, "c": ORIGIN, "d": DOWN},
        "row",
        RIGHT,
    )
    col_alignments = init_alignments(
        col_alignments,
        cols,
        {"l": LEFT, "c": ORIGIN, "r": RIGHT},
        "col",
        UP,
    )
    # Now row_alignment[r] + col_alignment[c] is the alignment in cell [r][c]

    mapper = {
        "dr": lambda r, c: (rows - r - 1) + c * rows,
        "dl": lambda r, c: (rows - r - 1) + (cols - c - 1) * rows,
        "ur": lambda r, c: r + c * rows,
        "ul": lambda r, c: r + (cols - c - 1) * rows,
        "rd": lambda r, c: (rows - r - 1) * cols + c,
        "ld": lambda r, c: (rows - r - 1) * cols + (cols - c - 1),
        "ru": lambda r, c: r * cols + c,
        "lu": lambda r, c: r * cols + (cols - c - 1),
    }
    if flow_order not in mapper:
        raise ValueError(
            'flow_order must be one of the following values: "dr", "rd", "ld" "dl", "ru", "ur", "lu", "ul".',
        )
    flow_order = mapper[flow_order]

    # Reverse row_alignments and row_heights. Necessary since the
    # grid filling is handled bottom up for simplicity reasons.
    def reverse(maybe_list):
        if maybe_list is not None:
            maybe_list = list(maybe_list)
            maybe_list.reverse()
            return maybe_list

    row_alignments = reverse(row_alignments)
    row_heights = reverse(row_heights)

    placeholder = Mobject()
    # Used to fill up the grid temporarily, doesn't get added to the scene.
    # In this case a Mobject is better than None since it has width and height
    # properties of 0.

    mobs.extend([placeholder] * (rows * cols - len(mobs)))
    grid = [[mobs[flow_order(r, c)] for c in range(cols)] for r in range(rows)]

    measured_heigths = [
        max(grid[r][c].height for c in range(cols)) for r in range(rows)
    ]
    measured_widths = [
        max(grid[r][c].width for r in range(rows)) for c in range(cols)
    ]

    # Initialize row_heights / col_widths correctly using measurements as fallback
    def init_sizes(sizes, num, measures, name):
        if sizes is None:
            sizes = [None] * num
        if len(sizes) != num:
            raise ValueError(f"{name} has a mismatching size.")
        return [
            sizes[i] if sizes[i] is not None else measures[i] for i in range(num)
        ]

    heights = init_sizes(row_heights, rows, measured_heigths, "row_heights")
    widths = init_sizes(col_widths, cols, measured_widths, "col_widths")

    x, y = 0, 0
    for r in range(rows):
        x = 0
        for c in range(cols):
            if grid[r][c] is not placeholder:
                alignment = row_alignments[r] + col_alignments[c]
                line = Line(
                    x * RIGHT + y * UP,
                    (x + widths[c]) * RIGHT + (y + heights[r]) * UP,
                )
                # Use a mobject to avoid rewriting align inside
                # box code that Mobject.move_to(Mobject) already
                # includes.

                grid[r][c].move_to(line, alignment)
            x += widths[c] + buff_x
        y += heights[r] + buff_y

    self.move_to(start_pos)
    return self

</t>
<t tx="ekr.20250122151620.973">def sort(
    self,
    point_to_num_func: Callable[[Point3DLike], float] = lambda p: p[0],
    submob_func: Callable[[Mobject], Any] | None = None,
) -&gt; Self:
    """Sorts the list of :attr:`submobjects` by a function defined by ``submob_func``."""
    if submob_func is None:

        def submob_func(m: Mobject) -&gt; float:
            return point_to_num_func(m.get_center())

    self.submobjects.sort(key=submob_func)
    return self

</t>
<t tx="ekr.20250122151620.974">def shuffle(self, recursive: bool = False) -&gt; None:
    """Shuffles the list of :attr:`submobjects`."""
    if recursive:
        for submob in self.submobjects:
            submob.shuffle(recursive=True)
    random.shuffle(self.submobjects)

</t>
<t tx="ekr.20250122151620.975">def invert(self, recursive: bool = False) -&gt; None:
    """Inverts the list of :attr:`submobjects`.

    Parameters
    ----------
    recursive
        If ``True``, all submobject lists of this mobject's family are inverted.

    Examples
    --------

    .. manim:: InvertSumobjectsExample

        class InvertSumobjectsExample(Scene):
            def construct(self):
                s = VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
                s2 = s.copy()
                s2.invert()
                s2.shift(DOWN)
                self.play(Write(s), Write(s2))
    """
    if recursive:
        for submob in self.submobjects:
            submob.invert(recursive=True)
    self.submobjects.reverse()

</t>
<t tx="ekr.20250122151620.976"># Just here to keep from breaking old scenes.
def arrange_submobjects(self, *args, **kwargs) -&gt; Self:
    """Arrange the position of :attr:`submobjects` with a small buffer.

    Examples
    --------

    .. manim:: ArrangeSumobjectsExample
        :save_last_frame:

        class ArrangeSumobjectsExample(Scene):
            def construct(self):
                s= VGroup(*[Dot().shift(i*0.1*RIGHT*np.random.uniform(-1,1)+UP*np.random.uniform(-1,1)) for i in range(0,15)])
                s.shift(UP).set_color(BLUE)
                s2= s.copy().set_color(RED)
                s2.arrange_submobjects()
                s2.shift(DOWN)
                self.add(s,s2)

    """
    return self.arrange(*args, **kwargs)

</t>
<t tx="ekr.20250122151620.977">def sort_submobjects(self, *args, **kwargs) -&gt; Self:
    """Sort the :attr:`submobjects`"""
    return self.sort(*args, **kwargs)

</t>
<t tx="ekr.20250122151620.978">def shuffle_submobjects(self, *args, **kwargs) -&gt; None:
    """Shuffles the order of :attr:`submobjects`

    Examples
    --------

    .. manim:: ShuffleSubmobjectsExample

        class ShuffleSubmobjectsExample(Scene):
            def construct(self):
                s= VGroup(*[Dot().shift(i*0.1*RIGHT) for i in range(-20,20)])
                s2= s.copy()
                s2.shuffle_submobjects()
                s2.shift(DOWN)
                self.play(Write(s), Write(s2))
    """
    return self.shuffle(*args, **kwargs)

</t>
<t tx="ekr.20250122151620.979"># Alignment
def align_data(self, mobject: Mobject, skip_point_alignment: bool = False) -&gt; None:
    """Aligns the data of this mobject with another mobject.

    Afterwards, the two mobjects will have the same number of submobjects
    (see :meth:`.align_submobjects`), the same parent structure (see
    :meth:`.null_point_align`). If ``skip_point_alignment`` is false,
    they will also have the same number of points (see :meth:`.align_points`).

    Parameters
    ----------
    mobject
        The other mobject this mobject should be aligned to.
    skip_point_alignment
        Controls whether or not the computationally expensive
        point alignment is skipped (default: False).
    """
    self.null_point_align(mobject)
    self.align_submobjects(mobject)
    if not skip_point_alignment:
        self.align_points(mobject)
    # Recurse
    for m1, m2 in zip(self.submobjects, mobject.submobjects):
        m1.align_data(m2)

</t>
<t tx="ekr.20250122151620.98">@pixel_height.setter
def pixel_height(self, value: int) -&gt; None:
    self._set_pos_number("pixel_height", value, False)

</t>
<t tx="ekr.20250122151620.980">def get_point_mobject(self, center=None):
    """The simplest :class:`~.Mobject` to be transformed to or from self.
    Should by a point of the appropriate type
    """
    msg = f"get_point_mobject not implemented for {self.__class__.__name__}"
    raise NotImplementedError(msg)

</t>
<t tx="ekr.20250122151620.981">def align_points(self, mobject: Mobject) -&gt; Self:
    count1 = self.get_num_points()
    count2 = mobject.get_num_points()
    if count1 &lt; count2:
        self.align_points_with_larger(mobject)
    elif count2 &lt; count1:
        mobject.align_points_with_larger(self)
    return self

</t>
<t tx="ekr.20250122151620.982">def align_points_with_larger(self, larger_mobject: Mobject):
    raise NotImplementedError("Please override in a child class.")

</t>
<t tx="ekr.20250122151620.983">def align_submobjects(self, mobject: Mobject) -&gt; Self:
    mob1 = self
    mob2 = mobject
    n1 = len(mob1.submobjects)
    n2 = len(mob2.submobjects)
    mob1.add_n_more_submobjects(max(0, n2 - n1))
    mob2.add_n_more_submobjects(max(0, n1 - n2))
    return self

</t>
<t tx="ekr.20250122151620.984">def null_point_align(self, mobject: Mobject):
    """If a :class:`~.Mobject` with points is being aligned to
    one without, treat both as groups, and push
    the one with points into its own submobjects
    list.

    Returns
    -------
    :class:`Mobject`
        ``self``
    """
    for m1, m2 in (self, mobject), (mobject, self):
        if m1.has_no_points() and m2.has_points():
            m2.push_self_into_submobjects()
    return self

</t>
<t tx="ekr.20250122151620.985">def push_self_into_submobjects(self) -&gt; Self:
    copy = self.copy()
    copy.submobjects = []
    self.reset_points()
    self.add(copy)
    return self

</t>
<t tx="ekr.20250122151620.986">def add_n_more_submobjects(self, n: int) -&gt; Self | None:
    if n == 0:
        return None

    curr = len(self.submobjects)
    if curr == 0:
        # If empty, simply add n point mobjects
        self.submobjects = [self.get_point_mobject() for k in range(n)]
        return None

    target = curr + n
    # TODO, factor this out to utils so as to reuse
    # with VMobject.insert_n_curves
    repeat_indices = (np.arange(target) * curr) // target
    split_factors = [sum(repeat_indices == i) for i in range(curr)]
    new_submobs = []
    for submob, sf in zip(self.submobjects, split_factors):
        new_submobs.append(submob)
        for _ in range(1, sf):
            new_submobs.append(submob.copy().fade(1))
    self.submobjects = new_submobs
    return self

</t>
<t tx="ekr.20250122151620.987">def repeat_submobject(self, submob: Mobject) -&gt; Self:
    return submob.copy()

</t>
<t tx="ekr.20250122151620.988">def interpolate(
    self,
    mobject1: Mobject,
    mobject2: Mobject,
    alpha: float,
    path_func: PathFuncType = straight_path(),
</t>
<t tx="ekr.20250122151620.989">) -&gt; Self:
    """Turns this :class:`~.Mobject` into an interpolation between ``mobject1``
    and ``mobject2``.

    Examples
    --------

    .. manim:: DotInterpolation
        :save_last_frame:

        class DotInterpolation(Scene):
            def construct(self):
                dotR = Dot(color=DARK_GREY)
                dotR.shift(2 * RIGHT)
                dotL = Dot(color=WHITE)
                dotL.shift(2 * LEFT)

                dotMiddle = VMobject().interpolate(dotL, dotR, alpha=0.3)

                self.add(dotL, dotR, dotMiddle)
    """
    self.points = path_func(mobject1.points, mobject2.points, alpha)
    self.interpolate_color(mobject1, mobject2, alpha)
    return self

def interpolate_color(self, mobject1: Mobject, mobject2: Mobject, alpha: float):
    raise NotImplementedError("Please override in a child class.")

</t>
<t tx="ekr.20250122151620.99">@property
def aspect_ratio(self) -&gt; int:
    """Aspect ratio (width / height) in pixels (--resolution, -r)."""
    return self._d["pixel_width"] / self._d["pixel_height"]

</t>
<t tx="ekr.20250122151620.990">def become(
    self,
    mobject: Mobject,
    match_height: bool = False,
    match_width: bool = False,
    match_depth: bool = False,
    match_center: bool = False,
    stretch: bool = False,
) -&gt; Self:
    """Edit points, colors and submobjects to be identical
    to another :class:`~.Mobject`

    .. note::

        If both match_height and match_width are ``True`` then the transformed :class:`~.Mobject`
        will match the height first and then the width.

    Parameters
    ----------
    match_height
        Whether or not to preserve the height of the original
        :class:`~.Mobject`.
    match_width
        Whether or not to preserve the width of the original
        :class:`~.Mobject`.
    match_depth
        Whether or not to preserve the depth of the original
        :class:`~.Mobject`.
    match_center
        Whether or not to preserve the center of the original
        :class:`~.Mobject`.
    stretch
        Whether or not to stretch the target mobject to match the
        the proportions of the original :class:`~.Mobject`.

    Examples
    --------
    .. manim:: BecomeScene

        class BecomeScene(Scene):
            def construct(self):
                circ = Circle(fill_color=RED, fill_opacity=0.8)
                square = Square(fill_color=BLUE, fill_opacity=0.2)
                self.add(circ)
                self.wait(0.5)
                circ.become(square)
                self.wait(0.5)


    The following examples illustrate how mobject measurements
    change when using the ``match_...`` and ``stretch`` arguments.
    We start with a rectangle that is 2 units high and 4 units wide,
    which we want to turn into a circle of radius 3::

        &gt;&gt;&gt; from manim import Rectangle, Circle
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; rect = Rectangle(height=2, width=4)
        &gt;&gt;&gt; circ = Circle(radius=3)

    With ``stretch=True``, the target circle is deformed to match
    the proportions of the rectangle, which results in the target
    mobject being an ellipse with height 2 and width 4. We can
    check that the resulting points satisfy the ellipse equation
    :math:`x^2/a^2 + y^2/b^2 = 1` with :math:`a = 4/2` and :math:`b = 2/2`
    being the semi-axes::

        &gt;&gt;&gt; result = rect.copy().become(circ, stretch=True)
        &gt;&gt;&gt; result.height, result.width
        (np.float64(2.0), np.float64(4.0))
        &gt;&gt;&gt; ellipse_points = np.array(result.get_anchors())
        &gt;&gt;&gt; ellipse_eq = np.sum(ellipse_points**2 * [1/4, 1, 0], axis=1)
        &gt;&gt;&gt; np.allclose(ellipse_eq, 1)
        True

    With ``match_height=True`` and ``match_width=True`` the circle is
    scaled such that the height or the width of the rectangle will
    be preserved, respectively.
    The points of the resulting mobject satisfy the circle equation
    :math:`x^2 + y^2 = r^2` for the corresponding radius :math:`r`::

        &gt;&gt;&gt; result = rect.copy().become(circ, match_height=True)
        &gt;&gt;&gt; result.height, result.width
        (np.float64(2.0), np.float64(2.0))
        &gt;&gt;&gt; circle_points = np.array(result.get_anchors())
        &gt;&gt;&gt; circle_eq = np.sum(circle_points**2, axis=1)
        &gt;&gt;&gt; np.allclose(circle_eq, 1)
        True
        &gt;&gt;&gt; result = rect.copy().become(circ, match_width=True)
        &gt;&gt;&gt; result.height, result.width
        (np.float64(4.0), np.float64(4.0))
        &gt;&gt;&gt; circle_points = np.array(result.get_anchors())
        &gt;&gt;&gt; circle_eq = np.sum(circle_points**2, axis=1)
        &gt;&gt;&gt; np.allclose(circle_eq, 2**2)
        True

    With ``match_center=True``, the resulting mobject is moved such that
    its center is the same as the center of the original mobject::

        &gt;&gt;&gt; rect = rect.shift(np.array([0, 1, 0]))
        &gt;&gt;&gt; np.allclose(rect.get_center(), circ.get_center())
        False
        &gt;&gt;&gt; result = rect.copy().become(circ, match_center=True)
        &gt;&gt;&gt; np.allclose(rect.get_center(), result.get_center())
        True
    """
    mobject = mobject.copy()
    if stretch:
        mobject.stretch_to_fit_height(self.height)
        mobject.stretch_to_fit_width(self.width)
        mobject.stretch_to_fit_depth(self.depth)
    else:
        if match_height:
            mobject.match_height(self)
        if match_width:
            mobject.match_width(self)
        if match_depth:
            mobject.match_depth(self)

    if match_center:
        mobject.move_to(self.get_center())

    self.align_data(mobject, skip_point_alignment=True)
    for sm1, sm2 in zip(self.get_family(), mobject.get_family()):
        sm1.points = np.array(sm2.points)
        sm1.interpolate_color(sm1, sm2, 1)
    return self

</t>
<t tx="ekr.20250122151620.991">def match_points(self, mobject: Mobject, copy_submobjects: bool = True) -&gt; Self:
    """Edit points, positions, and submobjects to be identical
    to another :class:`~.Mobject`, while keeping the style unchanged.

    Examples
    --------
    .. manim:: MatchPointsScene

        class MatchPointsScene(Scene):
            def construct(self):
                circ = Circle(fill_color=RED, fill_opacity=0.8)
                square = Square(fill_color=BLUE, fill_opacity=0.2)
                self.add(circ)
                self.wait(0.5)
                self.play(circ.animate.match_points(square))
                self.wait(0.5)
    """
    for sm1, sm2 in zip(self.get_family(), mobject.get_family()):
        sm1.points = np.array(sm2.points)
    return self

</t>
<t tx="ekr.20250122151620.992"># Errors
def throw_error_if_no_points(self) -&gt; None:
    if self.has_no_points():
        caller_name = sys._getframe(1).f_code.co_name
        raise Exception(
            f"Cannot call Mobject.{caller_name} for a Mobject with no points",
        )

</t>
<t tx="ekr.20250122151620.993"># About z-index
def set_z_index(
    self,
    z_index_value: float,
    family: bool = True,
) -&gt; Self:
    """Sets the :class:`~.Mobject`'s :attr:`z_index` to the value specified in `z_index_value`.

    Parameters
    ----------
    z_index_value
        The new value of :attr:`z_index` set.
    family
        If ``True``, the :attr:`z_index` value of all submobjects is also set.

    Returns
    -------
    :class:`Mobject`
        The Mobject itself, after :attr:`z_index` is set. For chaining purposes. (Returns `self`.)

    Examples
    --------
    .. manim:: SetZIndex
        :save_last_frame:

        class SetZIndex(Scene):
            def construct(self):
                text = Text('z_index = 3', color = PURE_RED).shift(UP).set_z_index(3)
                square = Square(2, fill_opacity=1).set_z_index(2)
                tex = Tex(r'zIndex = 1', color = PURE_BLUE).shift(DOWN).set_z_index(1)
                circle = Circle(radius = 1.7, color = GREEN, fill_opacity = 1) # z_index = 0

                # Displaying order is now defined by z_index values
                self.add(text)
                self.add(square)
                self.add(tex)
                self.add(circle)
    """
    if family:
        for submob in self.submobjects:
            submob.set_z_index(z_index_value, family=family)
    self.z_index = z_index_value
    return self

</t>
<t tx="ekr.20250122151620.994">def set_z_index_by_z_Point3D(self) -&gt; Self:
    """Sets the :class:`~.Mobject`'s z Point3D to the value of :attr:`z_index`.

    Returns
    -------
    :class:`Mobject`
        The Mobject itself, after :attr:`z_index` is set. (Returns `self`.)
    """
    z_coord = self.get_center()[-1]
    self.set_z_index(z_coord)
    return self


</t>
<t tx="ekr.20250122151620.995">def __init__(self, *mobjects, **kwargs) -&gt; None:
    super().__init__(**kwargs)
    self.add(*mobjects)


</t>
<t tx="ekr.20250122151620.996">def __init__(self, mobject) -&gt; None:
    self.mobject = mobject
    self.mobject.generate_target()

    self.overridden_animation = None
    self.is_chaining = False
    self.methods = []

    # Whether animation args can be passed
    self.cannot_pass_args = False
    self.anim_args = {}

</t>
<t tx="ekr.20250122151620.997">def __call__(self, **kwargs) -&gt; Self:
    if self.cannot_pass_args:
        raise ValueError(
            "Animation arguments must be passed before accessing methods and can only be passed once",
        )

    self.anim_args = kwargs
    self.cannot_pass_args = True

    return self

</t>
<t tx="ekr.20250122151620.998">def __getattr__(self, method_name) -&gt; types.MethodType:
    method = getattr(self.mobject.target, method_name)
    has_overridden_animation = hasattr(method, "_override_animate")

    if (self.is_chaining and has_overridden_animation) or self.overridden_animation:
        raise NotImplementedError(
            "Method chaining is currently not supported for overridden animations",
        )

    def update_target(*method_args, **method_kwargs):
        if has_overridden_animation:
            self.overridden_animation = method._override_animate(
                self.mobject,
                *method_args,
                anim_args=self.anim_args,
                **method_kwargs,
            )
        else:
            self.methods.append([method, method_args, method_kwargs])
            method(*method_args, **method_kwargs)
        return self

    self.is_chaining = True
    self.cannot_pass_args = True

    return update_target

</t>
<t tx="ekr.20250122151620.999">def build(self) -&gt; Animation:
    from ..animation.transform import (  # is this to prevent circular import?
        _MethodAnimation,
    )

    if self.overridden_animation:
        anim = self.overridden_animation
    else:
        anim = _MethodAnimation(self.mobject, self.methods)

    for attr, value in self.anim_args.items():
        setattr(anim, attr, value)

    return anim


</t>
<t tx="ekr.20250122151621.1"></t>
<t tx="ekr.20250122151621.10">def __init__(
    self,
    vertex_coords: list[list[float] | np.ndarray],
    faces_list: list[list[int]],
    faces_config: dict[str, str | int | float | bool] = {},
    graph_config: dict[str, str | int | float | bool] = {},
):
    super().__init__()
    self.faces_config = dict(
        {"fill_opacity": 0.5, "shade_in_3d": True}, **faces_config
    )
    self.graph_config = dict(
        {
            "vertex_type": Dot3D,
            "edge_config": {
                "stroke_opacity": 0,  # I find that having the edges visible makes the polyhedra look weird
            },
        },
        **graph_config,
    )
    self.vertex_coords = vertex_coords
    self.vertex_indices = list(range(len(self.vertex_coords)))
    self.layout = dict(enumerate(self.vertex_coords))
    self.faces_list = faces_list
    self.face_coords = [[self.layout[j] for j in i] for i in faces_list]
    self.edges = self.get_edges(self.faces_list)
    self.faces = self.create_faces(self.face_coords)
    self.graph = Graph(
        self.vertex_indices, self.edges, layout=self.layout, **self.graph_config
    )
    self.add(self.faces, self.graph)
    self.add_updater(self.update_faces)

</t>
<t tx="ekr.20250122151621.100">def add_display_frame(self, **kwargs: Any) -&gt; Self:
    config = dict(self.default_display_frame_config)
    config.update(kwargs)
    self.display_frame = SurroundingRectangle(self, **config)
    self.add(self.display_frame)
    return self

</t>
<t tx="ekr.20250122151621.1000">@staticmethod
def _internal_from_int_rgb(
    rgb: RGB_Tuple_Int, alpha: float = 1.0
) -&gt; ManimColorInternal:
    """Internal function for converting an RGB tuple of integers into the internal
    representation of a :class:`ManimColor`.

    *For internal use only*

    Parameters
    ----------
    rgb
        Integer RGB tuple to be parsed
    alpha
        Optional alpha value. Default is 1.0.

    Returns
    -------
    ManimColorInternal
        Internal color representation.
    """
    value: np.ndarray = np.asarray(rgb, dtype=ManimColorDType).copy() / 255
    value.resize(4, refcheck=False)
    value[3] = alpha
    return value

</t>
<t tx="ekr.20250122151621.1001">@staticmethod
def _internal_from_rgb(
    rgb: RGB_Tuple_Float, alpha: float = 1.0
) -&gt; ManimColorInternal:
    """Internal function for converting a rgb tuple of floats into the internal
    representation of a :class:`ManimColor`.

    *For internal use only*

    Parameters
    ----------
    rgb
        Float RGB tuple to be parsed.
    alpha
        Optional alpha value. Default is 1.0.

    Returns
    -------
    ManimColorInternal
        Internal color representation.
    """
    value: np.ndarray = np.asarray(rgb, dtype=ManimColorDType).copy()
    value.resize(4, refcheck=False)
    value[3] = alpha
    return value

</t>
<t tx="ekr.20250122151621.1002">@staticmethod
def _internal_from_int_rgba(rgba: RGBA_Tuple_Int) -&gt; ManimColorInternal:
    """Internal function for converting an RGBA tuple of integers into the internal
    representation of a :class:`ManimColor`.

    *For internal use only*

    Parameters
    ----------
    rgba
        Int RGBA tuple to be parsed.

    Returns
    -------
    ManimColorInternal
        Internal color representation.
    """
    return np.asarray(rgba, dtype=ManimColorDType) / 255

</t>
<t tx="ekr.20250122151621.1003">@staticmethod
def _internal_from_rgba(rgba: RGBA_Tuple_Float) -&gt; ManimColorInternal:
    """Internal function for converting an RGBA tuple of floats into the internal
    representation of a :class:`ManimColor`.

    *For internal use only*

    Parameters
    ----------
    rgba
        Int RGBA tuple to be parsed.

    Returns
    -------
    ManimColorInternal
        Internal color representation.
    """
    return np.asarray(rgba, dtype=ManimColorDType)

</t>
<t tx="ekr.20250122151621.1004">@staticmethod
def _internal_from_string(name: str, alpha: float) -&gt; ManimColorInternal:
    """Internal function for converting a string into the internal representation of
    a :class:`ManimColor`. This is not used for hex strings: please refer to
    :meth:`_internal_from_hex` for this functionality.

    *For internal use only*

    Parameters
    ----------
    name
        The color name to be parsed into a color. Refer to the different color
        modules in the documentation page to find the corresponding color names.

    Returns
    -------
    ManimColorInternal
        Internal color representation.

    Raises
    ------
    ValueError
        If the color name is not present in Manim.
    """
    from . import _all_color_dict

    if tmp := _all_color_dict.get(name.upper()):
        tmp._internal_value[3] = alpha
        return tmp._internal_value.copy()
    else:
        raise ValueError(f"Color {name} not found")

</t>
<t tx="ekr.20250122151621.1005">def to_integer(self) -&gt; int:
    """Convert the current :class:`ManimColor` into an integer.

    .. warning::
        This will return only the RGB part of the color.

    Returns
    -------
    int
        Integer representation of the color.
    """
    tmp = (self._internal_value[:3] * 255).astype(dtype=np.byte).tobytes()
    return int.from_bytes(tmp, "big")

</t>
<t tx="ekr.20250122151621.1006">def to_rgb(self) -&gt; RGB_Array_Float:
    """Convert the current :class:`ManimColor` into an RGB array of floats.

    Returns
    -------
    RGB_Array_Float
        RGB array of 3 floats from 0.0 to 1.0.
    """
    return self._internal_value[:3]

</t>
<t tx="ekr.20250122151621.1007">def to_int_rgb(self) -&gt; RGB_Array_Int:
    """Convert the current :class:`ManimColor` into an RGB array of integers.

    Returns
    -------
    RGB_Array_Int
        RGB array of 3 integers from 0 to 255.
    """
    return (self._internal_value[:3] * 255).astype(int)

</t>
<t tx="ekr.20250122151621.1008">def to_rgba(self) -&gt; RGBA_Array_Float:
    """Convert the current :class:`ManimColor` into an RGBA array of floats.

    Returns
    -------
    RGBA_Array_Float
        RGBA array of 4 floats from 0.0 to 1.0.
    """
    return self._internal_value

</t>
<t tx="ekr.20250122151621.1009">def to_int_rgba(self) -&gt; RGBA_Array_Int:
    """Convert the current ManimColor into an RGBA array of integers.


    Returns
    -------
    RGBA_Array_Int
        RGBA array of 4 integers from 0 to 255.
    """
    return (self._internal_value * 255).astype(int)

</t>
<t tx="ekr.20250122151621.101">def interpolate_color(self, mobject1, mobject2, alpha) -&gt; None:
    assert mobject1.pixel_array.shape == mobject2.pixel_array.shape, (
        f"Mobject pixel array shapes incompatible for interpolation.\n"
        f"Mobject 1 ({mobject1}) : {mobject1.pixel_array.shape}\n"
        f"Mobject 2 ({mobject2}) : {mobject2.pixel_array.shape}"
    )
    self.pixel_array = interpolate(
        mobject1.pixel_array,
        mobject2.pixel_array,
        alpha,
    ).astype(self.pixel_array_dtype)
</t>
<t tx="ekr.20250122151621.1010">def to_rgba_with_alpha(self, alpha: float) -&gt; RGBA_Array_Float:
    """Convert the current :class:`ManimColor` into an RGBA array of floats. This is
    similar to :meth:`to_rgba`, but you can change the alpha value.

    Parameters
    ----------
    alpha
        Alpha value to be used in the return value.

    Returns
    -------
    RGBA_Array_Float
        RGBA array of 4 floats from 0.0 to 1.0.
    """
    return np.fromiter((*self._internal_value[:3], alpha), dtype=ManimColorDType)

</t>
<t tx="ekr.20250122151621.1011">def to_int_rgba_with_alpha(self, alpha: float) -&gt; RGBA_Array_Int:
    """Convert the current :class:`ManimColor` into an RGBA array of integers. This
    is similar to :meth:`to_int_rgba`, but you can change the alpha value.

    Parameters
    ----------
    alpha
        Alpha value to be used for the return value. Pass a float between 0.0 and
        1.0: it will automatically be scaled to an integer between 0 and 255.

    Returns
    -------
    RGBA_Array_Int
        RGBA array of 4 integers from 0 to 255.
    """
    tmp = self._internal_value * 255
    tmp[3] = alpha * 255
    return tmp.astype(int)

</t>
<t tx="ekr.20250122151621.1012">def to_hex(self, with_alpha: bool = False) -&gt; str:
    """Convert the :class:`ManimColor` to a hexadecimal representation of the color.

    Parameters
    ----------
    with_alpha
        If ``True``, append 2 extra characters to the hex string which represent the
        alpha value of the color between 0 and 255. Default is ``False``.

    Returns
    -------
    str
        A hex string starting with a ``#``, with either 6 or 8 nibbles depending on
        the ``with_alpha`` parameter. By default, it has 6 nibbles, i.e. ``#XXXXXX``.
    """
    tmp = (
        f"#{int(self._internal_value[0] * 255):02X}"
        f"{int(self._internal_value[1] * 255):02X}"
        f"{int(self._internal_value[2] * 255):02X}"
    )
    if with_alpha:
        tmp += f"{int(self._internal_value[3] * 255):02X}"
    return tmp

</t>
<t tx="ekr.20250122151621.1013">def to_hsv(self) -&gt; HSV_Array_Float:
    """Convert the :class:`ManimColor` to an HSV array.

    .. note::
       Be careful: this returns an array in the form ``[h, s, v]``, where the
       elements are floats. This might be confusing, because RGB can also be an array
       of floats. You might want to annotate the usage of this function in your code
       by typing your HSV array variables as :class:`HSV_Array_Float` in order to
       differentiate them from RGB arrays.

    Returns
    -------
    HSV_Array_Float
        An HSV array of 3 floats from 0.0 to 1.0.
    """
    return np.array(colorsys.rgb_to_hsv(*self.to_rgb()))

</t>
<t tx="ekr.20250122151621.1014">def to_hsl(self) -&gt; HSL_Array_Float:
    """Convert the :class:`ManimColor` to an HSL array.

    .. note::
       Be careful: this returns an array in the form ``[h, s, l]``, where the
       elements are floats. This might be confusing, because RGB can also be an array
       of floats. You might want to annotate the usage of this function in your code
       by typing your HSL array variables as :class:`HSL_Array_Float` in order to
       differentiate them from RGB arrays.

    Returns
    -------
    HSL_Array_Float
        An HSL array of 3 floats from 0.0 to 1.0.
    """
    return np.array(colorsys.rgb_to_hls(*self.to_rgb()))

</t>
<t tx="ekr.20250122151621.1015">def invert(self, with_alpha: bool = False) -&gt; Self:
    """Return a new, linearly inverted version of this :class:`ManimColor` (no
    inplace changes).

    Parameters
    ----------
    with_alpha
        If ``True``, the alpha value will be inverted too. Default is ``False``.

        .. note::
            Setting ``with_alpha=True`` can result in unintended behavior where
            objects are not displayed because their new alpha value is suddenly 0 or
            very low.

    Returns
    -------
    ManimColor
        The linearly inverted :class:`ManimColor`.
    """
    if with_alpha:
        return self._construct_from_space(1.0 - self._internal_space)
    else:
        alpha = self._internal_space[3]
        new = 1.0 - self._internal_space
        new[-1] = alpha
        return self._construct_from_space(new)

</t>
<t tx="ekr.20250122151621.1016">def interpolate(self, other: Self, alpha: float) -&gt; Self:
    """Interpolate between the current and the given :class:`ManimColor`, and return
    the result.

    Parameters
    ----------
    other
        The other :class:`ManimColor` to be used for interpolation.
    alpha
        A point on the line in RGBA colorspace connecting the two colors, i.e. the
        interpolation point. 0.0 corresponds to the current :class:`ManimColor` and
        1.0 corresponds to the other :class:`ManimColor`.

    Returns
    -------
    ManimColor
        The interpolated :class:`ManimColor`.
    """
    return self._construct_from_space(
        self._internal_space * (1 - alpha) + other._internal_space * alpha
    )

</t>
<t tx="ekr.20250122151621.1017">def darker(self, blend: float = 0.2) -&gt; Self:
    """Return a new color that is darker than the current color, i.e.
    interpolated with ``BLACK``. The opacity is unchanged.

    Parameters
    ----------
    blend
        The blend ratio for the interpolation, from 0.0 (the current color
        unchanged) to 1.0 (pure black). Default is 0.2, which results in a
        slightly darker color.

    Returns
    -------
    ManimColor
        The darker :class:`ManimColor`.

    See Also
    --------
    :meth:`lighter`
    """
    from manim.utils.color.manim_colors import BLACK

    alpha = self._internal_space[3]
    black = self._from_internal(BLACK._internal_value)
    return self.interpolate(black, blend).opacity(alpha)

</t>
<t tx="ekr.20250122151621.1018">def lighter(self, blend: float = 0.2) -&gt; Self:
    """Return a new color that is lighter than the current color, i.e.
    interpolated with ``WHITE``. The opacity is unchanged.

    Parameters
    ----------
    blend
        The blend ratio for the interpolation, from 0.0 (the current color
        unchanged) to 1.0 (pure white). Default is 0.2, which results in a
        slightly lighter color.

    Returns
    -------
    ManimColor
        The lighter :class:`ManimColor`.

    See Also
    --------
    :meth:`darker`
    """
    from manim.utils.color.manim_colors import WHITE

    alpha = self._internal_space[3]
    white = self._from_internal(WHITE._internal_value)
    return self.interpolate(white, blend).opacity(alpha)

</t>
<t tx="ekr.20250122151621.1019">def contrasting(
    self,
    threshold: float = 0.5,
    light: Self | None = None,
    dark: Self | None = None,
) -&gt; Self:
    """Return one of two colors, light or dark (by default white or black),
    that contrasts with the current color (depending on its luminance).
    This is typically used to set text in a contrasting color that ensures
    it is readable against a background of the current color.

    Parameters
    ----------
    threshold
        The luminance threshold which dictates whether the current color is
        considered light or dark (and thus whether to return the dark or
        light color, respectively). Default is 0.5.
    light
        The light color to return if the current color is considered dark.
        Default is ``None``: in this case, pure ``WHITE`` will be returned.
    dark
        The dark color to return if the current color is considered light,
        Default is ``None``: in this case, pure ``BLACK`` will be returned.

    Returns
    -------
    ManimColor
        The contrasting :class:`ManimColor`.
    """
    from manim.utils.color.manim_colors import BLACK, WHITE

    luminance, _, _ = colorsys.rgb_to_yiq(*self.to_rgb())
    if luminance &lt; threshold:
        if light is not None:
            return light
        return self._from_internal(WHITE._internal_value)
    else:
        if dark is not None:
            return dark
        return self._from_internal(BLACK._internal_value)

</t>
<t tx="ekr.20250122151621.102">"""Mobjects representing point clouds."""

from __future__ import annotations

__all__ = ["PMobject", "Mobject1D", "Mobject2D", "PGroup", "PointCloudDot", "Point"]

from typing import TYPE_CHECKING

import numpy as np

from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.opengl.opengl_point_cloud_mobject import OpenGLPMobject

from ...constants import *
from ...mobject.mobject import Mobject
from ...utils.bezier import interpolate
from ...utils.color import (
    BLACK,
    WHITE,
    YELLOW,
    ManimColor,
    ParsableManimColor,
    color_gradient,
    color_to_rgba,
    rgba_to_color,
)
from ...utils.iterables import stretch_array_to_length

__all__ = ["PMobject", "Mobject1D", "Mobject2D", "PGroup", "PointCloudDot", "Point"]

if TYPE_CHECKING:
    from collections.abc import Callable
    from typing import Any

    import numpy.typing as npt
    from typing_extensions import Self

    from manim.typing import ManimFloat, Point3DLike, Vector3D


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1020">def opacity(self, opacity: float) -&gt; Self:
    """Create a new :class:`ManimColor` with the given opacity and the same color
    values as before.

    Parameters
    ----------
    opacity
        The new opacity value to be used.

    Returns
    -------
    ManimColor
        The new :class:`ManimColor` with the same color values and the new opacity.
    """
    tmp = self._internal_space.copy()
    tmp[-1] = opacity
    return self._construct_from_space(tmp)

</t>
<t tx="ekr.20250122151621.1021">def into(self, class_type: type[ManimColorT]) -&gt; ManimColorT:
    """Convert the current color into a different colorspace given by ``class_type``,
    without changing the :attr:`_internal_value`.

    Parameters
    ----------
    class_type
        The class that is used for conversion. It must be a subclass of
        :class:`ManimColor` which respects the specification HSV, RGBA, ...

    Returns
    -------
    ManimColorT
        A new color object of type ``class_type`` and the same
        :attr:`_internal_value` as the original color.
    """
    return class_type._from_internal(self._internal_value)

</t>
<t tx="ekr.20250122151621.1022">@classmethod
def _from_internal(cls, value: ManimColorInternal) -&gt; Self:
    """This method is intended to be overwritten by custom color space classes
    which are subtypes of :class:`ManimColor`.

    The method constructs a new object of the given class by transforming the value
    in the internal format ``[r,g,b,a]`` into a format which the constructor of the
    custom class can understand. Look at :class:`.HSV` for an example.
    """
    return cls(value)

</t>
<t tx="ekr.20250122151621.1023">@classmethod
def from_rgb(
    cls,
    rgb: RGB_Array_Float | RGB_Tuple_Float | RGB_Array_Int | RGB_Tuple_Int,
    alpha: float = 1.0,
) -&gt; Self:
    """Create a ManimColor from an RGB array. Automagically decides which type it
    is: ``int`` or ``float``.

    .. warning::
        Please make sure that your elements are not floats if you want integers. A
        ``5.0`` will result in the input being interpreted as if it was an RGB float
        array with the value ``5.0`` and not the integer ``5``.


    Parameters
    ----------
    rgb
        Any iterable of 3 floats or 3 integers.
    alpha
        Alpha value to be used in the color. Default is 1.0.

    Returns
    -------
    ManimColor
        The :class:`ManimColor` which corresponds to the given ``rgb``.
    """
    return cls._from_internal(ManimColor(rgb, alpha)._internal_value)

</t>
<t tx="ekr.20250122151621.1024">@classmethod
def from_rgba(
    cls, rgba: RGBA_Array_Float | RGBA_Tuple_Float | RGBA_Array_Int | RGBA_Tuple_Int
) -&gt; Self:
    """Create a ManimColor from an RGBA Array. Automagically decides which type it
    is: ``int`` or ``float``.

    .. warning::
        Please make sure that your elements are not floats if you want integers. A
        ``5.0`` will result in the input being interpreted as if it was a float RGB
        array with the float ``5.0`` and not the integer ``5``.

    Parameters
    ----------
    rgba
        Any iterable of 4 floats or 4 integers.

    Returns
    -------
    ManimColor
        The :class:`ManimColor` corresponding to the given ``rgba``.
    """
    return cls(rgba)

</t>
<t tx="ekr.20250122151621.1025">@classmethod
def from_hex(cls, hex_str: str, alpha: float = 1.0) -&gt; Self:
    """Create a :class:`ManimColor` from a hex string.

    Parameters
    ----------
    hex_str
        The hex string to be converted.  The allowed prefixes for this string are
        ``#`` and ``0x``. Currently, this method only supports 6 nibbles, i.e. only
        strings in the format ``#XXXXXX`` or ``0xXXXXXX``.
    alpha
        Alpha value to be used for the hex string. Default is 1.0.

    Returns
    -------
    ManimColor
        The :class:`ManimColor` represented by the hex string.
    """
    return cls._from_internal(ManimColor(hex_str, alpha)._internal_value)

</t>
<t tx="ekr.20250122151621.1026">@classmethod
def from_hsv(
    cls, hsv: HSV_Array_Float | HSV_Tuple_Float, alpha: float = 1.0
) -&gt; Self:
    """Create a :class:`ManimColor` from an HSV array.

    Parameters
    ----------
    hsv
        Any iterable containing 3 floats from 0.0 to 1.0.
    alpha
        The alpha value to be used. Default is 1.0.

    Returns
    -------
    ManimColor
        The :class:`ManimColor` with the corresponding RGB values to the given HSV
        array.
    """
    rgb = colorsys.hsv_to_rgb(*hsv)
    return cls._from_internal(ManimColor(rgb, alpha)._internal_value)

</t>
<t tx="ekr.20250122151621.1027">@classmethod
def from_hsl(
    cls, hsl: HSL_Array_Float | HSL_Tuple_Float, alpha: float = 1.0
) -&gt; Self:
    """Create a :class:`ManimColor` from an HSL array.

    Parameters
    ----------
    hsl
        Any iterable containing 3 floats from 0.0 to 1.0.
    alpha
        The alpha value to be used. Default is 1.0.

    Returns
    -------
    ManimColor
        The :class:`ManimColor` with the corresponding RGB values to the given HSL
        array.
    """
    rgb = colorsys.hls_to_rgb(*hsl)
    return cls._from_internal(ManimColor(rgb, alpha)._internal_value)

</t>
<t tx="ekr.20250122151621.1028">@overload
@classmethod
def parse(
    cls,
    color: ParsableManimColor | None,
    alpha: float = ...,
) -&gt; Self: ...

</t>
<t tx="ekr.20250122151621.1029">@overload
@classmethod
def parse(
    cls,
    color: Sequence[ParsableManimColor],
    alpha: float = ...,
) -&gt; list[Self]: ...

</t>
<t tx="ekr.20250122151621.103">class PMobject(Mobject, metaclass=ConvertToOpenGL):
    """A disc made of a cloud of Dots

    Examples
    --------

    .. manim:: PMobjectExample
        :save_last_frame:

        class PMobjectExample(Scene):
            def construct(self):

                pG = PGroup()  # This is just a collection of PMobject's

                # As the scale factor increases, the number of points
                # removed increases.
                for sf in range(1, 9 + 1):
                    p = PointCloudDot(density=20, radius=1).thin_out(sf)
                    # PointCloudDot is a type of PMobject
                    # and can therefore be added to a PGroup
                    pG.add(p)

                # This organizes all the shapes in a grid.
                pG.arrange_in_grid()

                self.add(pG)

    """

    @others
</t>
<t tx="ekr.20250122151621.1030">@classmethod
def parse(
    cls,
    color: ParsableManimColor | Sequence[ParsableManimColor] | None,
    alpha: float = 1.0,
) -&gt; Self | list[Self]:
    """Parse one color as a :class:`ManimColor` or a sequence of colors as a list of
    :class:`ManimColor`'s.

    Parameters
    ----------
    color
        The color or list of colors to parse. Note that this function can not accept
        tuples: it will assume that you mean ``Sequence[ParsableManimColor]`` and will
        return a ``list[ManimColor]``.
    alpha
        The alpha (opacity) value to use for the passed color(s).

    Returns
    -------
    ManimColor | list[ManimColor]
        Either a list of colors or a singular color, depending on the input.
    """

    def is_sequence(
        color: ParsableManimColor | Sequence[ParsableManimColor] | None,
    ) -&gt; TypeIs[Sequence[ParsableManimColor]]:
        return isinstance(color, (list, tuple))

    if is_sequence(color):
        return [
            cls._from_internal(ManimColor(c, alpha)._internal_value) for c in color
        ]
    else:
        return cls._from_internal(ManimColor(color, alpha)._internal_value)

</t>
<t tx="ekr.20250122151621.1031">@staticmethod
def gradient(
    colors: list[ManimColor], length: int
) -&gt; ManimColor | list[ManimColor]:
    """This method is currently not implemented. Refer to :func:`color_gradient` for
    a working implementation for now.
    """
    # TODO: implement proper gradient, research good implementation for this or look at 3b1b implementation
    raise NotImplementedError

</t>
<t tx="ekr.20250122151621.1032">def __repr__(self) -&gt; str:
    return f"{self.__class__.__name__}('{self.to_hex()}')"

</t>
<t tx="ekr.20250122151621.1033">def __str__(self) -&gt; str:
    return f"{self.to_hex()}"

</t>
<t tx="ekr.20250122151621.1034">def __eq__(self, other: object) -&gt; bool:
    if not isinstance(other, ManimColor):
        raise TypeError(
            f"Cannot compare {self.__class__.__name__} with {other.__class__.__name__}"
        )
    are_equal: bool = np.allclose(self._internal_value, other._internal_value)
    return are_equal

</t>
<t tx="ekr.20250122151621.1035">def __add__(self, other: int | float | Self) -&gt; Self:
    if isinstance(other, (int, float)):
        return self._construct_from_space(self._internal_space + other)
    else:
        return self._construct_from_space(
            self._internal_space + other._internal_space
        )

</t>
<t tx="ekr.20250122151621.1036">def __radd__(self, other: int | float | Self) -&gt; Self:
    return self + other

</t>
<t tx="ekr.20250122151621.1037">def __sub__(self, other: int | float | Self) -&gt; Self:
    if isinstance(other, (int, float)):
        return self._construct_from_space(self._internal_space - other)
    else:
        return self._construct_from_space(
            self._internal_space - other._internal_space
        )

</t>
<t tx="ekr.20250122151621.1038">def __rsub__(self, other: int | float | Self) -&gt; Self:
    return self - other

</t>
<t tx="ekr.20250122151621.1039">def __mul__(self, other: int | float | Self) -&gt; Self:
    if isinstance(other, (int, float)):
        return self._construct_from_space(self._internal_space * other)
    else:
        return self._construct_from_space(
            self._internal_space * other._internal_space
        )

</t>
<t tx="ekr.20250122151621.104"># TODO, Make the two implementations below non-redundant
class Mobject1D(PMobject, metaclass=ConvertToOpenGL):
    @others
</t>
<t tx="ekr.20250122151621.1040">def __rmul__(self, other: int | float | Self) -&gt; Self:
    return self * other

</t>
<t tx="ekr.20250122151621.1041">def __truediv__(self, other: int | float | Self) -&gt; Self:
    if isinstance(other, (int, float)):
        return self._construct_from_space(self._internal_space / other)
    else:
        return self._construct_from_space(
            self._internal_space / other._internal_space
        )

</t>
<t tx="ekr.20250122151621.1042">def __rtruediv__(self, other: int | float | Self) -&gt; Self:
    return self / other

</t>
<t tx="ekr.20250122151621.1043">def __floordiv__(self, other: int | float | Self) -&gt; Self:
    if isinstance(other, (int, float)):
        return self._construct_from_space(self._internal_space // other)
    else:
        return self._construct_from_space(
            self._internal_space // other._internal_space
        )

</t>
<t tx="ekr.20250122151621.1044">def __rfloordiv__(self, other: int | float | Self) -&gt; Self:
    return self // other

</t>
<t tx="ekr.20250122151621.1045">def __mod__(self, other: int | float | Self) -&gt; Self:
    if isinstance(other, (int, float)):
        return self._construct_from_space(self._internal_space % other)
    else:
        return self._construct_from_space(
            self._internal_space % other._internal_space
        )

</t>
<t tx="ekr.20250122151621.1046">def __rmod__(self, other: int | float | Self) -&gt; Self:
    return self % other

</t>
<t tx="ekr.20250122151621.1047">def __pow__(self, other: int | float | Self) -&gt; Self:
    if isinstance(other, (int, float)):
        return self._construct_from_space(self._internal_space**other)
    else:
        return self._construct_from_space(
            self._internal_space**other._internal_space
        )

</t>
<t tx="ekr.20250122151621.1048">def __rpow__(self, other: int | float | Self) -&gt; Self:
    return self**other

</t>
<t tx="ekr.20250122151621.1049">def __invert__(self) -&gt; Self:
    return self.invert()

</t>
<t tx="ekr.20250122151621.105">class Mobject2D(PMobject, metaclass=ConvertToOpenGL):
    @others
</t>
<t tx="ekr.20250122151621.1050">def __int__(self) -&gt; int:
    return self.to_integer()

</t>
<t tx="ekr.20250122151621.1051">def __getitem__(self, index: int) -&gt; float:
    item: float = self._internal_space[index]
    return item

</t>
<t tx="ekr.20250122151621.1052">def __and__(self, other: Self) -&gt; Self:
    return self._construct_from_space(
        self._internal_from_integer(self.to_integer() &amp; int(other), 1.0)
    )

</t>
<t tx="ekr.20250122151621.1053">def __or__(self, other: Self) -&gt; Self:
    return self._construct_from_space(
        self._internal_from_integer(self.to_integer() | int(other), 1.0)
    )

</t>
<t tx="ekr.20250122151621.1054">def __xor__(self, other: Self) -&gt; Self:
    return self._construct_from_space(
        self._internal_from_integer(self.to_integer() ^ int(other), 1.0)
    )

</t>
<t tx="ekr.20250122151621.1055">def __hash__(self) -&gt; int:
    return hash(self.to_hex(with_alpha=True))


</t>
<t tx="ekr.20250122151621.1056">def __init__(
    self,
    hsv: HSV_Array_Float | HSV_Tuple_Float | HSVA_Array_Float | HSVA_Tuple_Float,
    alpha: float = 1.0,
) -&gt; None:
    super().__init__(None)
    self.__hsv: HSVA_Array_Float
    if len(hsv) == 3:
        self.__hsv = np.asarray((*hsv, alpha))
    elif len(hsv) == 4:
        self.__hsv = np.asarray(hsv)
    else:
        raise ValueError("HSV Color must be an array of 3 values")

</t>
<t tx="ekr.20250122151621.1057">@classmethod
@override
def _from_internal(cls, value: ManimColorInternal) -&gt; Self:
    hsv = colorsys.rgb_to_hsv(*value[:3])
    hsva = [*hsv, value[-1]]
    return cls(np.array(hsva))

</t>
<t tx="ekr.20250122151621.1058">@property
def hue(self) -&gt; float:
    hue: float = self.__hsv[0]
    return hue

</t>
<t tx="ekr.20250122151621.1059">@hue.setter
def hue(self, hue: float) -&gt; None:
    self.__hsv[0] = hue

</t>
<t tx="ekr.20250122151621.106">class PGroup(PMobject):
    """A group for several point mobjects.

    Examples
    --------

    .. manim:: PgroupExample
        :save_last_frame:

        class PgroupExample(Scene):
            def construct(self):

                p1 = PointCloudDot(radius=1, density=20, color=BLUE)
                p1.move_to(4.5 * LEFT)
                p2 = PointCloudDot()
                p3 = PointCloudDot(radius=1.5, stroke_width=2.5, color=PINK)
                p3.move_to(4.5 * RIGHT)
                pList = PGroup(p1, p2, p3)

                self.add(pList)

    """

    @others
</t>
<t tx="ekr.20250122151621.1060">@property
def saturation(self) -&gt; float:
    saturation: float = self.__hsv[1]
    return saturation

</t>
<t tx="ekr.20250122151621.1061">@saturation.setter
def saturation(self, saturation: float) -&gt; None:
    self.__hsv[1] = saturation

</t>
<t tx="ekr.20250122151621.1062">@property
def value(self) -&gt; float:
    value: float = self.__hsv[2]
    return value

</t>
<t tx="ekr.20250122151621.1063">@value.setter
def value(self, value: float) -&gt; None:
    self.__hsv[2] = value

</t>
<t tx="ekr.20250122151621.1064">@property
def h(self) -&gt; float:
    hue: float = self.__hsv[0]
    return hue

</t>
<t tx="ekr.20250122151621.1065">@h.setter
def h(self, hue: float) -&gt; None:
    self.__hsv[0] = hue

</t>
<t tx="ekr.20250122151621.1066">@property
def s(self) -&gt; float:
    saturation: float = self.__hsv[1]
    return saturation

</t>
<t tx="ekr.20250122151621.1067">@s.setter
def s(self, saturation: float) -&gt; None:
    self.__hsv[1] = saturation

</t>
<t tx="ekr.20250122151621.1068">@property
def v(self) -&gt; float:
    value: float = self.__hsv[2]
    return value

</t>
<t tx="ekr.20250122151621.1069">@v.setter
def v(self, value: float) -&gt; None:
    self.__hsv[2] = value

</t>
<t tx="ekr.20250122151621.107">class PointCloudDot(Mobject1D):
    """A disc made of a cloud of dots.

    Examples
    --------
    .. manim:: PointCloudDotExample
        :save_last_frame:

        class PointCloudDotExample(Scene):
            def construct(self):
                cloud_1 = PointCloudDot(color=RED)
                cloud_2 = PointCloudDot(stroke_width=4, radius=1)
                cloud_3 = PointCloudDot(density=15)

                group = Group(cloud_1, cloud_2, cloud_3).arrange()
                self.add(group)

    .. manim:: PointCloudDotExample2

        class PointCloudDotExample2(Scene):
            def construct(self):
                plane = ComplexPlane()
                cloud = PointCloudDot(color=RED)
                self.add(
                    plane, cloud
                )
                self.wait()
                self.play(
                    cloud.animate.apply_complex_function(lambda z: np.exp(z))
                )
    """

    @others
</t>
<t tx="ekr.20250122151621.1070">@property
def _internal_space(self) -&gt; npt.NDArray:
    return self.__hsv

</t>
<t tx="ekr.20250122151621.1071">@property
def _internal_value(self) -&gt; ManimColorInternal:
    """Return the internal value of the current :class:`ManimColor` as an
    ``[r,g,b,a]`` float array.

    Returns
    -------
    ManimColorInternal
        Internal color representation.
    """
    return np.array(
        [
            *colorsys.hsv_to_rgb(self.__hsv[0], self.__hsv[1], self.__hsv[2]),
            self.__alpha,
        ],
        dtype=ManimColorDType,
    )

</t>
<t tx="ekr.20250122151621.1072">@_internal_value.setter
def _internal_value(self, value: ManimColorInternal) -&gt; None:
    """Overwrite the internal color value of this :class:`ManimColor`.

    Parameters
    ----------
    value
        The value which will overwrite the current color.

    Raises
    ------
    TypeError
        If an invalid array is passed.
    """
    if not isinstance(value, np.ndarray):
        raise TypeError("Value must be a NumPy array.")
    if value.shape[0] != 4:
        raise TypeError("Array must have exactly 4 values.")
    tmp = colorsys.rgb_to_hsv(value[0], value[1], value[2])
    self.__hsv = np.array(tmp)
    self.__alpha = value[3]


</t>
<t tx="ekr.20250122151621.1073">"""Colors included in the global name space.

These colors form Manim's default color space.

.. manim:: ColorsOverview
    :save_last_frame:
    :hide_source:

    import manim.utils.color.manim_colors as Colors

    class ColorsOverview(Scene):
        def construct(self):
            def color_group(color):
                group = VGroup(
                    *[
                        Line(ORIGIN, RIGHT * 1.5, stroke_width=35, color=getattr(Colors, name.upper()))
                        for name in subnames(color)
                    ]
                ).arrange_submobjects(buff=0.4, direction=DOWN)

                name = Text(color).scale(0.6).next_to(group, UP, buff=0.3)
                if any(decender in color for decender in "gjpqy"):
                    name.shift(DOWN * 0.08)
                group.add(name)
                return group

            def subnames(name):
                return [name + "_" + char for char in "abcde"]

            color_groups = VGroup(
                *[
                    color_group(color)
                    for color in [
                        "blue",
                        "teal",
                        "green",
                        "yellow",
                        "gold",
                        "red",
                        "maroon",
                        "purple",
                    ]
                ]
            ).arrange_submobjects(buff=0.2, aligned_edge=DOWN)

            for line, char in zip(color_groups[0], "abcde"):
                color_groups.add(Text(char).scale(0.6).next_to(line, LEFT, buff=0.2))

            def named_lines_group(length, color_names, labels, align_to_block):
                colors = [getattr(Colors, color.upper()) for color in color_names]
                lines = VGroup(
                    *[
                        Line(
                            ORIGIN,
                            RIGHT * length,
                            stroke_width=55,
                            color=color,
                        )
                        for color in colors
                    ]
                ).arrange_submobjects(buff=0.6, direction=DOWN)

                for line, name, color in zip(lines, labels, colors):
                    line.add(Text(name, color=color.contrasting()).scale(0.6).move_to(line))
                lines.next_to(color_groups, DOWN, buff=0.5).align_to(
                    color_groups[align_to_block], LEFT
                )
                return lines

            other_colors = (
                "pink",
                "light_pink",
                "orange",
                "light_brown",
                "dark_brown",
                "gray_brown",
            )

            other_lines = named_lines_group(
                3.2,
                other_colors,
                other_colors,
                0,
            )

            gray_lines = named_lines_group(
                6.6,
                ["white"] + subnames("gray") + ["black"],
                [
                    "white",
                    "lighter_gray / gray_a",
                    "light_gray / gray_b",
                    "gray / gray_c",
                    "dark_gray / gray_d",
                    "darker_gray / gray_e",
                    "black",
                ],
                2,
            )

            pure_colors = (
                "pure_red",
                "pure_green",
                "pure_blue",
            )

            pure_lines = named_lines_group(
                3.2,
                pure_colors,
                pure_colors,
                6,
            )

            self.add(color_groups, other_lines, gray_lines, pure_lines)

            VGroup(*self.mobjects).move_to(ORIGIN)

.. automanimcolormodule:: manim.utils.color.manim_colors

"""

from __future__ import annotations

from .core import ManimColor

WHITE = ManimColor("#FFFFFF")
GRAY_A = ManimColor("#DDDDDD")
GREY_A = ManimColor("#DDDDDD")
GRAY_B = ManimColor("#BBBBBB")
GREY_B = ManimColor("#BBBBBB")
GRAY_C = ManimColor("#888888")
GREY_C = ManimColor("#888888")
GRAY_D = ManimColor("#444444")
GREY_D = ManimColor("#444444")
GRAY_E = ManimColor("#222222")
GREY_E = ManimColor("#222222")
BLACK = ManimColor("#000000")
LIGHTER_GRAY = ManimColor("#DDDDDD")
LIGHTER_GREY = ManimColor("#DDDDDD")
LIGHT_GRAY = ManimColor("#BBBBBB")
LIGHT_GREY = ManimColor("#BBBBBB")
GRAY = ManimColor("#888888")
GREY = ManimColor("#888888")
DARK_GRAY = ManimColor("#444444")
DARK_GREY = ManimColor("#444444")
DARKER_GRAY = ManimColor("#222222")
DARKER_GREY = ManimColor("#222222")
BLUE_A = ManimColor("#C7E9F1")
BLUE_B = ManimColor("#9CDCEB")
BLUE_C = ManimColor("#58C4DD")
BLUE_D = ManimColor("#29ABCA")
BLUE_E = ManimColor("#236B8E")
PURE_BLUE = ManimColor("#0000FF")
BLUE = ManimColor("#58C4DD")
DARK_BLUE = ManimColor("#236B8E")
TEAL_A = ManimColor("#ACEAD7")
TEAL_B = ManimColor("#76DDC0")
TEAL_C = ManimColor("#5CD0B3")
TEAL_D = ManimColor("#55C1A7")
TEAL_E = ManimColor("#49A88F")
TEAL = ManimColor("#5CD0B3")
GREEN_A = ManimColor("#C9E2AE")
GREEN_B = ManimColor("#A6CF8C")
GREEN_C = ManimColor("#83C167")
GREEN_D = ManimColor("#77B05D")
GREEN_E = ManimColor("#699C52")
PURE_GREEN = ManimColor("#00FF00")
GREEN = ManimColor("#83C167")
YELLOW_A = ManimColor("#FFF1B6")
YELLOW_B = ManimColor("#FFEA94")
YELLOW_C = ManimColor("#FFFF00")
YELLOW_D = ManimColor("#F4D345")
YELLOW_E = ManimColor("#E8C11C")
YELLOW = ManimColor("#FFFF00")
GOLD_A = ManimColor("#F7C797")
GOLD_B = ManimColor("#F9B775")
GOLD_C = ManimColor("#F0AC5F")
GOLD_D = ManimColor("#E1A158")
GOLD_E = ManimColor("#C78D46")
GOLD = ManimColor("#F0AC5F")
RED_A = ManimColor("#F7A1A3")
RED_B = ManimColor("#FF8080")
RED_C = ManimColor("#FC6255")
RED_D = ManimColor("#E65A4C")
RED_E = ManimColor("#CF5044")
PURE_RED = ManimColor("#FF0000")
RED = ManimColor("#FC6255")
MAROON_A = ManimColor("#ECABC1")
MAROON_B = ManimColor("#EC92AB")
MAROON_C = ManimColor("#C55F73")
MAROON_D = ManimColor("#A24D61")
MAROON_E = ManimColor("#94424F")
MAROON = ManimColor("#C55F73")
PURPLE_A = ManimColor("#CAA3E8")
PURPLE_B = ManimColor("#B189C6")
PURPLE_C = ManimColor("#9A72AC")
PURPLE_D = ManimColor("#715582")
PURPLE_E = ManimColor("#644172")
PURPLE = ManimColor("#9A72AC")
PINK = ManimColor("#D147BD")
LIGHT_PINK = ManimColor("#DC75CD")
ORANGE = ManimColor("#FF862F")
LIGHT_BROWN = ManimColor("#CD853F")
DARK_BROWN = ManimColor("#8B4513")
GRAY_BROWN = ManimColor("#736357")
GREY_BROWN = ManimColor("#736357")

# Colors used for Manim Community's logo and banner

LOGO_WHITE = ManimColor("#ECE7E2")
LOGO_GREEN = ManimColor("#87C2A5")
LOGO_BLUE = ManimColor("#525893")
LOGO_RED = ManimColor("#E07A5F")
LOGO_BLACK = ManimColor("#343434")

_all_manim_colors: list[ManimColor] = [
    x for x in globals().values() if isinstance(x, ManimColor)
]
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1074"></t>
<t tx="ekr.20250122151621.1075">"""Utilities for building the Manim documentation.

For more information about the Manim documentation building, see:

-   :doc:`/contributing/development`, specifically the ``Documentation``
    bullet point under :ref:`polishing-changes-and-submitting-a-pull-request`
-   :doc:`/contributing/docs`

.. autosummary::
   :toctree: ../reference

   autoaliasattr_directive
   autocolor_directive
   manim_directive
   module_parsing

"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1076">"""A directive for documenting type aliases and other module-level attributes."""

from __future__ import annotations

from typing import TYPE_CHECKING

from docutils import nodes
from docutils.parsers.rst import Directive
from docutils.statemachine import ViewList

from manim.utils.docbuild.module_parsing import parse_module_attributes

if TYPE_CHECKING:
    from sphinx.application import Sphinx

__all__ = ["AliasAttrDocumenter"]


ALIAS_DOCS_DICT, DATA_DICT, TYPEVAR_DICT = parse_module_attributes()
ALIAS_LIST = [
    alias_name
    for module_dict in ALIAS_DOCS_DICT.values()
    for category_dict in module_dict.values()
    for alias_name in category_dict
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1077">def smart_replace(base: str, alias: str, substitution: str) -&gt; str:
    """Auxiliary function for substituting type aliases into a base
    string, when there are overlaps between the aliases themselves.

    Parameters
    ----------
    base
        The string in which the type aliases will be located and
        replaced.
    alias
        The substring to be substituted.
    substitution
        The string which will replace every occurrence of ``alias``.

    Returns
    -------
    str
        The new string after the alias substitution.
    """
    occurrences = []
    len_alias = len(alias)
    len_base = len(base)

    def condition(char: str) -&gt; bool:
        return not char.isalnum() and char != "_"

    start = 0
    i = 0
    while True:
        i = base.find(alias, start)
        if i == -1:
            break
        if (i == 0 or condition(base[i - 1])) and (
            i + len_alias == len_base or condition(base[i + len_alias])
        ):
            occurrences.append(i)
        start = i + len_alias

    for o in occurrences[::-1]:
        base = base[:o] + substitution + base[o + len_alias :]

    return base


</t>
<t tx="ekr.20250122151621.1078">def setup(app: Sphinx) -&gt; None:
    app.add_directive("autoaliasattr", AliasAttrDocumenter)


</t>
<t tx="ekr.20250122151621.1079">class AliasAttrDocumenter(Directive):
    """Directive which replaces Sphinx's Autosummary for module-level
    attributes: instead, it manually crafts a new "Type Aliases"
    section, where all the module-level attributes which are explicitly
    annotated as :class:`TypeAlias` are considered as such, for their
    use all around the Manim docs.

    These type aliases are separated from the "regular" module-level
    attributes, which get their traditional "Module Attributes"
    section autogenerated with Sphinx's Autosummary under "Type
    Aliases".

    See ``docs/source/_templates/autosummary/module.rst`` to watch
    this directive in action.

    See :func:`~.parse_module_attributes` for more information on how
    the modules are parsed to obtain the :class:`TypeAlias` information
    and separate it from the other attributes.
    """

    @others
</t>
<t tx="ekr.20250122151621.108">class Point(PMobject):
    """A mobject representing a point.

    Examples
    --------

    .. manim:: ExamplePoint
        :save_last_frame:

        class ExamplePoint(Scene):
            def construct(self):
                colorList = [RED, GREEN, BLUE, YELLOW]
                for i in range(200):
                    point = Point(location=[0.63 * np.random.randint(-4, 4), 0.37 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))
                    self.add(point)
                for i in range(200):
                    point = Point(location=[0.37 * np.random.randint(-4, 4), 0.63 * np.random.randint(-4, 4), 0], color=np.random.choice(colorList))
                    self.add(point)
                self.add(point)
    """

    @others
</t>
<t tx="ekr.20250122151621.1080">objtype = "autoaliasattr"
required_arguments = 1
has_content = True

def run(self) -&gt; list[nodes.Element]:
    module_name = self.arguments[0]
    # not present in the keys of the DICTs
    module_name = module_name.removeprefix("manim.")
    module_alias_dict = ALIAS_DOCS_DICT.get(module_name, None)
    module_attrs_list = DATA_DICT.get(module_name, None)
    module_typevars = TYPEVAR_DICT.get(module_name, None)

    content = nodes.container()

    # Add "Type Aliases" section
    if module_alias_dict is not None:
        module_alias_section = nodes.section(ids=[f"{module_name}.alias"])
        content += module_alias_section

        # Use a rubric (title-like), just like in `module.rst`
        module_alias_section += nodes.rubric(text="Type Aliases")

        # category_name: str
        # category_dict: AliasCategoryDict = dict[str, AliasInfo]
        for category_name, category_dict in module_alias_dict.items():
            category_section = nodes.section(
                ids=[category_name.lower().replace(" ", "_")]
            )
            module_alias_section += category_section
            # category_name can be possibly "" for uncategorized aliases
            if category_name:
                category_section += nodes.title(text=category_name)

            category_alias_container = nodes.container()
            category_section += category_alias_container

            # alias_name: str
            # alias_info: AliasInfo = dict[str, str]
            #   Contains "definition": str
            #   Can possibly contain "doc": str
            for alias_name, alias_info in category_dict.items():
                # Replace all occurrences of type aliases in the
                # definition for automatic cross-referencing!
                alias_def = alias_info["definition"]
                for A in ALIAS_LIST:
                    alias_def = smart_replace(alias_def, A, f":class:`~.{A}`")

                # Using the `.. class::` directive is CRUCIAL, since
                # function/method parameters are always annotated via
                # classes - therefore Sphinx expects a class
                unparsed = ViewList(
                    [
                        f".. class:: {alias_name}",
                        "",
                        "    .. parsed-literal::",
                        "",
                        f"        {alias_def}",
                        "",
                    ]
                )

                if "doc" in alias_info:
                    # Replace all occurrences of type aliases in
                    # the docs for automatic cross-referencing!
                    alias_doc = alias_info["doc"]
                    for A in ALIAS_LIST:
                        alias_doc = alias_doc.replace(f"`{A}`", f":class:`~.{A}`")

                    # also hyperlink the TypeVars from that module
                    if module_typevars is not None:
                        for T in module_typevars:
                            alias_doc = alias_doc.replace(f"`{T}`", f":class:`{T}`")

                    # Add all the lines with 4 spaces behind, to consider all the
                    # documentation as a paragraph INSIDE the `.. class::` block
                    doc_lines = alias_doc.split("\n")
                    unparsed.extend(ViewList([f"    {line}" for line in doc_lines]))

                # Parse the reST text into a fresh container
                # https://www.sphinx-doc.org/en/master/extdev/markupapi.html#parsing-directive-content-as-rest
                alias_container = nodes.container()
                self.state.nested_parse(unparsed, 0, alias_container)
                category_alias_container += alias_container

    # then add the module TypeVars section
    if module_typevars is not None:
        module_typevars_section = nodes.section(ids=[f"{module_name}.typevars"])
        content += module_typevars_section

        # Use a rubric (title-like), just like in `module.rst`
        module_typevars_section += nodes.rubric(text="TypeVar's")

        # name: str
        # definition: TypeVarDict = dict[str, str]
        for name, definition in module_typevars.items():
            # Using the `.. class::` directive is CRUCIAL, since
            # function/method parameters are always annotated via
            # classes - therefore Sphinx expects a class
            unparsed = ViewList(
                [
                    f".. class:: {name}",
                    "",
                    "    .. parsed-literal::",
                    "",
                    f"        {definition}",
                    "",
                ]
            )

            # Parse the reST text into a fresh container
            # https://www.sphinx-doc.org/en/master/extdev/markupapi.html#parsing-directive-content-as-rest
            typevar_container = nodes.container()
            self.state.nested_parse(unparsed, 0, typevar_container)
            module_typevars_section += typevar_container

    # Then, add the traditional "Module Attributes" section
    if module_attrs_list is not None:
        module_attrs_section = nodes.section(ids=[f"{module_name}.data"])
        content += module_attrs_section

        # Use the same rubric (title-like) as in `module.rst`
        module_attrs_section += nodes.rubric(text="Module Attributes")
        # Let Sphinx Autosummary do its thing as always
        # Add all the attribute names with 4 spaces behind, so that
        # they're considered as INSIDE the `.. autosummary::` block
        unparsed = ViewList(
            [
                ".. autosummary::",
                *(f"    {attr}" for attr in module_attrs_list),
            ]
        )

        # Parse the reST text into a fresh container
        # https://www.sphinx-doc.org/en/master/extdev/markupapi.html#parsing-directive-content-as-rest
        data_container = nodes.container()
        self.state.nested_parse(unparsed, 0, data_container)
        module_attrs_section += data_container

    return [content]
</t>
<t tx="ekr.20250122151621.1081">"""A directive for documenting colors in Manim."""

from __future__ import annotations

import inspect
from typing import TYPE_CHECKING

from docutils import nodes
from docutils.parsers.rst import Directive

from manim import ManimColor

if TYPE_CHECKING:
    from sphinx.application import Sphinx

__all__ = ["ManimColorModuleDocumenter"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1082">def setup(app: Sphinx) -&gt; None:
    app.add_directive("automanimcolormodule", ManimColorModuleDocumenter)


</t>
<t tx="ekr.20250122151621.1083">class ManimColorModuleDocumenter(Directive):
    @others
</t>
<t tx="ekr.20250122151621.1084">objtype = "automanimcolormodule"
required_arguments = 1
has_content = True

def add_directive_header(self, sig: str) -&gt; None:
    # TODO: The Directive class has no method named
    # add_directive_header.
    super().add_directive_header(sig)  # type: ignore[misc]

</t>
<t tx="ekr.20250122151621.1085">def run(self) -&gt; list[nodes.Element]:
    module_name = self.arguments[0]
    try:
        import importlib

        module = importlib.import_module(module_name)
    except ImportError:
        return [
            nodes.error(
                None,  # type: ignore[arg-type]
                nodes.paragraph(text=f"Failed to import module '{module_name}'"),
            )
        ]

    # Number of Colors displayed in one row
    num_color_cols = 2
    table = nodes.table(align="center")

    tgroup = nodes.tgroup(cols=num_color_cols * 2)
    table += tgroup
    for _ in range(num_color_cols * 2):
        tgroup += nodes.colspec(colwidth=1)

    # Create header rows for the table
    thead = nodes.thead()
    header_row = nodes.row()
    for _ in range(num_color_cols):
        header_col1 = nodes.paragraph(text="Color Name")
        header_col2 = nodes.paragraph(text="RGB Hex Code")
        header_row += nodes.entry("", header_col1)
        header_row += nodes.entry("", header_col2)
    thead += header_row
    tgroup += thead

    color_elements = []
    for member_name, member_obj in inspect.getmembers(module):
        if isinstance(member_obj, ManimColor):
            r, g, b = member_obj.to_rgb()
            luminance = 0.2126 * r + 0.7152 * g + 0.0722 * b

            # Choose the font color based on the background luminance
            font_color = "black" if luminance &gt; 0.5 else "white"

            color_elements.append((member_name, member_obj.to_hex(), font_color))

    tbody = nodes.tbody()

    for base_i in range(0, len(color_elements), num_color_cols):
        row = nodes.row()
        for member_name, hex_code, font_color in color_elements[
            base_i : base_i + num_color_cols
        ]:
            col1 = nodes.literal(text=member_name)
            col2 = nodes.raw(
                "",
                f'&lt;div style="background-color:{hex_code};padding: 0.25rem 0;border-radius:8px;margin: 0.5rem 0.2rem"&gt;&lt;code style="color:{font_color};"&gt;{hex_code}&lt;/code&gt;&lt;/div&gt;',
                format="html",
            )
            row += nodes.entry("", col1)
            row += nodes.entry("", col2)
        tbody += row
    tgroup += tbody

    return [table]
</t>
<t tx="ekr.20250122151621.1086">r"""
A directive for including Manim videos in a Sphinx document
===========================================================

When rendering the HTML documentation, the ``.. manim::`` directive
implemented here allows to include rendered videos.

Its basic usage that allows processing **inline content**
looks as follows::

    .. manim:: MyScene

        class MyScene(Scene):
            def construct(self):
                ...

It is required to pass the name of the class representing the
scene to be rendered to the directive.

As a second application, the directive can also be used to
render scenes that are defined within doctests, for example::

    .. manim:: DirectiveDoctestExample
        :ref_classes: Dot

        &gt;&gt;&gt; from manim import Create, Dot, RED, Scene
        &gt;&gt;&gt; dot = Dot(color=RED)
        &gt;&gt;&gt; dot.color
        ManimColor('#FC6255')
        &gt;&gt;&gt; class DirectiveDoctestExample(Scene):
        ...     def construct(self):
        ...         self.play(Create(dot))


Options
-------

Options can be passed as follows::

    .. manim:: &lt;Class name&gt;
        :&lt;option name&gt;: &lt;value&gt;

The following configuration options are supported by the
directive:

    hide_source
        If this flag is present without argument,
        the source code is not displayed above the rendered video.

    no_autoplay
        If this flag is present without argument,
        the video will not autoplay.

    quality : {'low', 'medium', 'high', 'fourk'}
        Controls render quality of the video, in analogy to
        the corresponding command line flags.

    save_as_gif
        If this flag is present without argument,
        the scene is rendered as a gif.

    save_last_frame
        If this flag is present without argument,
        an image representing the last frame of the scene will
        be rendered and displayed, instead of a video.

    ref_classes
        A list of classes, separated by spaces, that is
        rendered in a reference block after the source code.

    ref_functions
        A list of functions, separated by spaces,
        that is rendered in a reference block after the source code.

    ref_methods
        A list of methods, separated by spaces,
        that is rendered in a reference block after the source code.

"""

from __future__ import annotations

import csv
import itertools as it
import re
import shutil
import sys
import textwrap
from pathlib import Path
from timeit import timeit
from typing import TYPE_CHECKING, Any, TypedDict

import jinja2
from docutils import nodes
from docutils.parsers.rst import Directive, directives
from docutils.statemachine import StringList

from manim import QUALITIES
from manim import __version__ as manim_version

if TYPE_CHECKING:
    from sphinx.application import Sphinx


__all__ = ["ManimDirective"]


classnamedict: dict[str, int] = {}


@others
TEMPLATE = r"""
{% if not hide_source %}
.. raw:: html

    &lt;div id="{{ clsname_lowercase }}" class="admonition admonition-manim-example"&gt;
    &lt;p class="admonition-title"&gt;Example: {{ clsname }} &lt;a class="headerlink" href="#{{ clsname_lowercase }}"&gt;¶&lt;/a&gt;&lt;/p&gt;

{% endif %}

{% if not (save_as_gif or save_last_frame) %}
.. raw:: html

    &lt;video
        class="manim-video"
        controls
        loop
        {{ '' if no_autoplay else 'autoplay' }}
        src="./{{ output_file }}.mp4"&gt;
    &lt;/video&gt;

{% elif save_as_gif %}
.. image:: /{{ filesrc_rel }}
    :align: center

{% elif save_last_frame %}
.. image:: /{{ filesrc_rel }}
    :align: center

{% endif %}
{% if not hide_source %}
{{ source_block }}

{{ ref_block }}

.. raw:: html

    &lt;/div&gt;

{% endif %}
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1087">class SetupMetadata(TypedDict):
    parallel_read_safe: bool
    parallel_write_safe: bool


</t>
<t tx="ekr.20250122151621.1088">class SkipManimNode(nodes.Admonition, nodes.Element):
    """Auxiliary node class that is used when the ``skip-manim`` tag is present
    or ``.pot`` files are being built.

    Skips rendering the manim directive and outputs a placeholder instead.
    """

    pass


</t>
<t tx="ekr.20250122151621.1089">def visit(self: SkipManimNode, node: nodes.Element, name: str = "") -&gt; None:
    # TODO: Parent classes don't have a visit_admonition() method.
    self.visit_admonition(node, name)  # type: ignore[attr-defined]
    if not isinstance(node[0], nodes.title):
        node.insert(0, nodes.title("skip-manim", "Example Placeholder"))


</t>
<t tx="ekr.20250122151621.109">def __init__(self, stroke_width: int = DEFAULT_STROKE_WIDTH, **kwargs: Any) -&gt; None:
    self.stroke_width = stroke_width
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151621.1090">def depart(self: SkipManimNode, node: nodes.Element) -&gt; None:
    # TODO: Parent classes don't have a depart_admonition() method.
    self.depart_admonition(node)  # type: ignore[attr-defined]


</t>
<t tx="ekr.20250122151621.1091">def process_name_list(option_input: str, reference_type: str) -&gt; list[str]:
    r"""Reformats a string of space separated class names
    as a list of strings containing valid Sphinx references.

    Tests
    -----

    ::

        &gt;&gt;&gt; process_name_list("Tex TexTemplate", "class")
        [':class:`~.Tex`', ':class:`~.TexTemplate`']
        &gt;&gt;&gt; process_name_list("Scene.play Mobject.rotate", "func")
        [':func:`~.Scene.play`', ':func:`~.Mobject.rotate`']
    """
    return [f":{reference_type}:`~.{name}`" for name in option_input.split()]


</t>
<t tx="ekr.20250122151621.1092">class ManimDirective(Directive):
    @others
</t>
<t tx="ekr.20250122151621.1093">rendering_times_file_path = Path("../rendering_times.csv")


def _write_rendering_stats(scene_name: str, run_time: float, file_name: str) -&gt; None:
    with rendering_times_file_path.open("a") as file:
        csv.writer(file).writerow(
            [
                re.sub(r"^(reference\/)|(manim\.)", "", file_name),
                scene_name,
                f"{run_time:.3f}",
            ],
        )


</t>
<t tx="ekr.20250122151621.1094">def _log_rendering_times(*args: tuple[Any]) -&gt; None:
    if rendering_times_file_path.exists():
        with rendering_times_file_path.open() as file:
            data = list(csv.reader(file))
        if len(data) == 0:
            sys.exit()

        print("\nRendering Summary\n-----------------\n")

        # filter out empty lists caused by csv reader
        data = [row for row in data if row]

        max_file_length = max(len(row[0]) for row in data)
        for key, group_iter in it.groupby(data, key=lambda row: row[0]):
            key = key.ljust(max_file_length + 1, ".")
            group = list(group_iter)
            if len(group) == 1:
                row = group[0]
                print(f"{key}{row[2].rjust(7, '.')}s {row[1]}")
                continue
            time_sum = sum(float(row[2]) for row in group)
            print(
                f"{key}{f'{time_sum:.3f}'.rjust(7, '.')}s  =&gt; {len(group)} EXAMPLES",
            )
            for row in group:
                print(f"{' ' * max_file_length} {row[2].rjust(7)}s {row[1]}")
        print("")


</t>
<t tx="ekr.20250122151621.1095">def _delete_rendering_times(*args: tuple[Any]) -&gt; None:
    if rendering_times_file_path.exists():
        rendering_times_file_path.unlink()


</t>
<t tx="ekr.20250122151621.1096">def setup(app: Sphinx) -&gt; SetupMetadata:
    app.add_node(SkipManimNode, html=(visit, depart))

    setup.app = app  # type: ignore[attr-defined]
    setup.config = app.config  # type: ignore[attr-defined]
    setup.confdir = app.confdir  # type: ignore[attr-defined]

    app.add_directive("manim", ManimDirective)

    app.connect("builder-inited", _delete_rendering_times)
    app.connect("build-finished", _log_rendering_times)

    app.add_js_file("manim-binder.min.js")
    app.add_js_file(
        None,
        body=textwrap.dedent(
            f"""\
                window.initManimBinder({{branch: "v{manim_version}"}})
            """
        ).strip(),
    )

    metadata: SetupMetadata = {
        "parallel_read_safe": False,
        "parallel_write_safe": True,
    }
    return metadata


</t>
<t tx="ekr.20250122151621.1097">r"""The manim directive, rendering videos while building
the documentation.

See the module docstring for documentation.
"""

has_content = True
required_arguments = 1
optional_arguments = 0
option_spec = {
    "hide_source": bool,
    "no_autoplay": bool,
    "quality": lambda arg: directives.choice(
        arg,
        ("low", "medium", "high", "fourk"),
    ),
    "save_as_gif": bool,
    "save_last_frame": bool,
    "ref_modules": lambda arg: process_name_list(arg, "mod"),
    "ref_classes": lambda arg: process_name_list(arg, "class"),
    "ref_functions": lambda arg: process_name_list(arg, "func"),
    "ref_methods": lambda arg: process_name_list(arg, "meth"),
}
final_argument_whitespace = True

def run(self) -&gt; list[nodes.Element]:
    # Rendering is skipped if the tag skip-manim is present,
    # or if we are making the pot-files
    should_skip = (
        "skip-manim" in self.state.document.settings.env.app.builder.tags
        or self.state.document.settings.env.app.builder.name == "gettext"
    )
    if should_skip:
        clsname = self.arguments[0]
        node = SkipManimNode()
        self.state.nested_parse(
            StringList(
                [
                    f"Placeholder block for ``{clsname}``.",
                    "",
                    ".. code-block:: python",
                    "",
                ]
                + ["    " + line for line in self.content]
                + [
                    "",
                    ".. raw:: html",
                    "",
                    f'    &lt;pre data-manim-binder data-manim-classname="{clsname}"&gt;',
                ]
                + ["    " + line for line in self.content]
                + ["    &lt;/pre&gt;"],
            ),
            self.content_offset,
            node,
        )
        return [node]

    from manim import config, tempconfig

    global classnamedict

    clsname = self.arguments[0]
    if clsname not in classnamedict:
        classnamedict[clsname] = 1
    else:
        classnamedict[clsname] += 1

    hide_source = "hide_source" in self.options
    no_autoplay = "no_autoplay" in self.options
    save_as_gif = "save_as_gif" in self.options
    save_last_frame = "save_last_frame" in self.options
    assert not (save_as_gif and save_last_frame)

    ref_content = (
        self.options.get("ref_modules", [])
        + self.options.get("ref_classes", [])
        + self.options.get("ref_functions", [])
        + self.options.get("ref_methods", [])
    )
    ref_block = "References: " + " ".join(ref_content) if ref_content else ""

    if "quality" in self.options:
        quality = f"{self.options['quality']}_quality"
    else:
        quality = "example_quality"
    frame_rate = QUALITIES[quality]["frame_rate"]
    pixel_height = QUALITIES[quality]["pixel_height"]
    pixel_width = QUALITIES[quality]["pixel_width"]

    state_machine = self.state_machine
    document = state_machine.document

    source_file_name = Path(document.attributes["source"])
    source_rel_name = source_file_name.relative_to(setup.confdir)  # type: ignore[attr-defined]
    source_rel_dir = source_rel_name.parents[0]
    dest_dir = Path(setup.app.builder.outdir, source_rel_dir).absolute()  # type: ignore[attr-defined]
    if not dest_dir.exists():
        dest_dir.mkdir(parents=True, exist_ok=True)

    source_block_in = [
        ".. code-block:: python",
        "",
        "    from manim import *\n",
        *("    " + line for line in self.content),
        "",
        ".. raw:: html",
        "",
        f'    &lt;pre data-manim-binder data-manim-classname="{clsname}"&gt;',
        *("    " + line for line in self.content),
        "",
        "    &lt;/pre&gt;",
    ]
    source_block = "\n".join(source_block_in)

    config.media_dir = (Path(setup.confdir) / "media").absolute()  # type: ignore[attr-defined,assignment]
    config.images_dir = "{media_dir}/images"
    config.video_dir = "{media_dir}/videos/{quality}"
    output_file = f"{clsname}-{classnamedict[clsname]}"
    config.assets_dir = Path("_static")  # type: ignore[assignment]
    config.progress_bar = "none"
    config.verbosity = "WARNING"

    example_config = {
        "frame_rate": frame_rate,
        "no_autoplay": no_autoplay,
        "pixel_height": pixel_height,
        "pixel_width": pixel_width,
        "save_last_frame": save_last_frame,
        "write_to_movie": not save_last_frame,
        "output_file": output_file,
    }
    if save_last_frame:
        example_config["format"] = None
    if save_as_gif:
        example_config["format"] = "gif"

    user_code = list(self.content)
    if user_code[0].startswith("&gt;&gt;&gt; "):  # check whether block comes from doctest
        user_code = [
            line[4:] for line in user_code if line.startswith(("&gt;&gt;&gt; ", "... "))
        ]

    code = [
        "from manim import *",
        *user_code,
        f"{clsname}().render()",
    ]

    try:
        with tempconfig(example_config):
            run_time = timeit(lambda: exec("\n".join(code), globals()), number=1)
            video_dir = config.get_dir("video_dir")
            images_dir = config.get_dir("images_dir")
    except Exception as e:
        raise RuntimeError(f"Error while rendering example {clsname}") from e

    _write_rendering_stats(
        clsname,
        run_time,
        self.state.document.settings.env.docname,
    )

    # copy video file to output directory
    if not (save_as_gif or save_last_frame):
        filename = f"{output_file}.mp4"
        filesrc = video_dir / filename
        destfile = Path(dest_dir, filename)
        shutil.copyfile(filesrc, destfile)
    elif save_as_gif:
        filename = f"{output_file}.gif"
        filesrc = video_dir / filename
    elif save_last_frame:
        filename = f"{output_file}.png"
        filesrc = images_dir / filename
    else:
        raise ValueError("Invalid combination of render flags received.")
    rendered_template = jinja2.Template(TEMPLATE).render(
        clsname=clsname,
        clsname_lowercase=clsname.lower(),
        hide_source=hide_source,
        filesrc_rel=Path(filesrc).relative_to(setup.confdir).as_posix(),  # type: ignore[attr-defined]
        no_autoplay=no_autoplay,
        output_file=output_file,
        save_last_frame=save_last_frame,
        save_as_gif=save_as_gif,
        source_block=source_block,
        ref_block=ref_block,
    )
    state_machine.insert_input(
        rendered_template.split("\n"),
        source=document.attributes["source"],
    )

    return []


</t>
<t tx="ekr.20250122151621.1098">"""Read and parse all the Manim modules and extract documentation from them."""

from __future__ import annotations

import ast
import sys
from ast import Attribute, Name, Subscript
from pathlib import Path
from typing import Any

from typing_extensions import TypeAlias

__all__ = ["parse_module_attributes"]


AliasInfo: TypeAlias = dict[str, str]
"""Dictionary with a `definition` key containing the definition of
a :class:`TypeAlias` as a string, and optionally a `doc` key containing
the documentation for that alias, if it exists.
"""

AliasCategoryDict: TypeAlias = dict[str, AliasInfo]
"""Dictionary which holds an `AliasInfo` for every alias name in a same
category.
"""

ModuleLevelAliasDict: TypeAlias = dict[str, AliasCategoryDict]
"""Dictionary containing every :class:`TypeAlias` defined in a module,
classified by category in different `AliasCategoryDict` objects.
"""

ModuleTypeVarDict: TypeAlias = dict[str, str]
"""Dictionary containing every :class:`TypeVar` defined in a module."""


AliasDocsDict: TypeAlias = dict[str, ModuleLevelAliasDict]
"""Dictionary which, for every module in Manim, contains documentation
about their module-level attributes which are explicitly defined as
:class:`TypeAlias`, separating them from the rest of attributes.
"""

DataDict: TypeAlias = dict[str, list[str]]
"""Type for a dictionary which, for every module, contains a list with
the names of all their DOCUMENTED module-level attributes (identified
by Sphinx via the ``data`` role, hence the name) which are NOT
explicitly defined as :class:`TypeAlias`.
"""

TypeVarDict: TypeAlias = dict[str, ModuleTypeVarDict]
"""A dictionary mapping module names to dictionaries of :class:`TypeVar` objects."""

ALIAS_DOCS_DICT: AliasDocsDict = {}
DATA_DICT: DataDict = {}
TYPEVAR_DICT: TypeVarDict = {}

MANIM_ROOT = Path(__file__).resolve().parent.parent.parent

# In the following, we will use ``type(xyz) is xyz_type`` instead of
# isinstance checks to make sure no subclasses of the type pass the
# check
# ruff: noqa: E721


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1099">def parse_module_attributes() -&gt; tuple[AliasDocsDict, DataDict, TypeVarDict]:
    """Read all files, generate Abstract Syntax Trees from them, and
    extract useful information about the type aliases defined in the
    files: the category they belong to, their definition and their
    description, separating them from the "regular" module attributes.

    Returns
    -------
    ALIAS_DOCS_DICT : :class:`AliasDocsDict`
        A dictionary containing the information from all the type
        aliases in Manim. See :class:`AliasDocsDict` for more information.

    DATA_DICT : :class:`DataDict`
        A dictionary containing the names of all DOCUMENTED
        module-level attributes which are not a :class:`TypeAlias`.

    TYPEVAR_DICT : :class:`TypeVarDict`
        A dictionary containing the definitions of :class:`TypeVar` objects,
        organized by modules.
    """
    global ALIAS_DOCS_DICT
    global DATA_DICT
    global TYPEVAR_DICT

    if ALIAS_DOCS_DICT or DATA_DICT or TYPEVAR_DICT:
        return ALIAS_DOCS_DICT, DATA_DICT, TYPEVAR_DICT

    for module_path in MANIM_ROOT.rglob("*.py"):
        module_name_t1 = module_path.resolve().relative_to(MANIM_ROOT)
        module_name_t2 = list(module_name_t1.parts)
        module_name_t2[-1] = module_name_t2[-1].removesuffix(".py")
        module_name = ".".join(module_name_t2)

        module_content = module_path.read_text(encoding="utf-8")

        # For storing TypeAliases
        module_dict: ModuleLevelAliasDict = {}
        category_dict: AliasCategoryDict | None = None
        alias_info: AliasInfo | None = None

        # For storing TypeVars
        module_typevars: ModuleTypeVarDict = {}

        # For storing regular module attributes
        data_list: list[str] = []
        data_name: str | None = None

        for node in ast.iter_child_nodes(ast.parse(module_content)):
            # If we encounter a string:
            if (
                type(node) is ast.Expr
                and type(node.value) is ast.Constant
                and type(node.value.value) is str
            ):
                string = node.value.value.strip()
                # It can be the start of a category
                section_str = "[CATEGORY]"
                if string.startswith(section_str):
                    category_name = string[len(section_str) :].strip()
                    module_dict[category_name] = {}
                    category_dict = module_dict[category_name]
                    alias_info = None
                # or a docstring of the alias defined before
                elif alias_info:
                    alias_info["doc"] = string
                # or a docstring of the module attribute defined before
                elif data_name:
                    data_list.append(data_name)
                continue

            # if it's defined under if TYPE_CHECKING
            # go through the body of the if statement
            if (
                # NOTE: This logic does not (and cannot)
                # check if the comparison is against a
                # variable called TYPE_CHECKING
                # It also says that you cannot do the following
                # import typing as foo
                # if foo.TYPE_CHECKING:
                #   BAR: TypeAlias = ...
                type(node) is ast.If
                and (
                    (
                        # if TYPE_CHECKING
                        type(node.test) is ast.Name and node.test.id == "TYPE_CHECKING"
                    )
                    or (
                        # if typing.TYPE_CHECKING
                        type(node.test) is ast.Attribute
                        and type(node.test.value) is ast.Name
                        and node.test.value.id == "typing"
                        and node.test.attr == "TYPE_CHECKING"
                    )
                )
            ):
                inner_nodes: list[Any] = node.body
            else:
                inner_nodes = [node]

            for node in inner_nodes:
                # Check if this node is a TypeAlias (type &lt;name&gt; = &lt;value&gt;)
                # or an AnnAssign annotated as TypeAlias (&lt;target&gt;: TypeAlias = &lt;value&gt;).
                is_type_alias = (
                    sys.version_info &gt;= (3, 12) and type(node) is ast.TypeAlias
                )
                is_annotated_assignment_with_value = (
                    type(node) is ast.AnnAssign
                    and type(node.annotation) is ast.Name
                    and node.annotation.id == "TypeAlias"
                    and type(node.target) is ast.Name
                    and node.value is not None
                )
                if is_type_alias or is_annotated_assignment_with_value:
                    # TODO: ast.TypeAlias does not exist before Python 3.12, and that
                    # could be the reason why MyPy does not recognize these as
                    # attributes of node.
                    alias_name = node.name.id if is_type_alias else node.target.id  # type: ignore[attr-defined]
                    definition_node = node.value  # type: ignore[attr-defined]

                    # If the definition is a Union, replace with vertical bar notation.
                    # Instead of "Union[Type1, Type2]", we'll have "Type1 | Type2".
                    if (
                        type(definition_node) is ast.Subscript
                        and type(definition_node.value) is ast.Name
                        and definition_node.value.id == "Union"
                    ):
                        union_elements = definition_node.slice.elts  # type: ignore[attr-defined]
                        definition = " | ".join(
                            ast.unparse(elem) for elem in union_elements
                        )
                    else:
                        definition = ast.unparse(definition_node)

                    definition = definition.replace("npt.", "")
                    if category_dict is None:
                        module_dict[""] = {}
                        category_dict = module_dict[""]
                    category_dict[alias_name] = {"definition": definition}
                    alias_info = category_dict[alias_name]
                    continue

                # Check if it is a typing.TypeVar (&lt;target&gt; = TypeVar(...)).
                elif (
                    type(node) is ast.Assign
                    and type(node.targets[0]) is ast.Name
                    and type(node.value) is ast.Call
                    and type(node.value.func) is ast.Name
                    and node.value.func.id.endswith("TypeVar")
                ):
                    module_typevars[node.targets[0].id] = ast.unparse(
                        node.value
                    ).replace("_", r"\_")
                    continue

                # If here, the node is not a TypeAlias definition
                alias_info = None

                # It could still be a module attribute definition.
                # Does the assignment have a target of type Name? Then
                # it could be considered a definition of a module attribute.
                if type(node) is ast.AnnAssign:
                    target: Name | Attribute | Subscript | ast.expr | None = node.target
                elif type(node) is ast.Assign and len(node.targets) == 1:
                    target = node.targets[0]
                else:
                    target = None

                if type(target) is ast.Name and not (
                    type(node) is ast.Assign and target.id not in module_typevars
                ):
                    data_name = target.id
                else:
                    data_name = None

        if len(module_dict) &gt; 0:
            ALIAS_DOCS_DICT[module_name] = module_dict
        if len(data_list) &gt; 0:
            DATA_DICT[module_name] = data_list
        if module_typevars:
            TYPEVAR_DICT[module_name] = module_typevars

    return ALIAS_DOCS_DICT, DATA_DICT, TYPEVAR_DICT
</t>
<t tx="ekr.20250122151621.11">def get_edges(self, faces_list: list[list[int]]) -&gt; list[tuple[int, int]]:
    """Creates list of cyclic pairwise tuples."""
    edges = []
    for face in faces_list:
        edges += zip(face, face[1:] + face[:1])
    return edges

</t>
<t tx="ekr.20250122151621.110">def reset_points(self) -&gt; Self:
    self.rgbas = np.zeros((0, 4))
    self.points = np.zeros((0, 3))
    return self

</t>
<t tx="ekr.20250122151621.1100"></t>
<t tx="ekr.20250122151621.1101">"""Utilities for Manim tests using `pytest &lt;https://pytest.org&gt;`_.

For more information about Manim testing, see:

-   :doc:`/contributing/development`, specifically the ``Tests`` bullet
    point under :ref:`polishing-changes-and-submitting-a-pull-request`
-   :doc:`/contributing/testing`

.. autosummary::
   :toctree: ../reference

   frames_comparison
   _frames_testers
   _show_diff
   _test_class_makers

"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1102">from __future__ import annotations

import contextlib
import logging
import warnings
from collections.abc import Generator
from pathlib import Path

import numpy as np

from manim.typing import PixelArray

from ._show_diff import show_diff_helper

FRAME_ABSOLUTE_TOLERANCE = 1.01
FRAME_MISMATCH_RATIO_TOLERANCE = 1e-5

logger = logging.getLogger("manim")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1103">class _FramesTester:
    @others
</t>
<t tx="ekr.20250122151621.1104">class _ControlDataWriter(_FramesTester):
    @others
</t>
<t tx="ekr.20250122151621.1105">def __init__(self, file_path: Path, show_diff: bool = False) -&gt; None:
    self._file_path = file_path
    self._show_diff = show_diff
    self._frames: np.ndarray
    self._number_frames: int = 0
    self._frames_compared = 0

</t>
<t tx="ekr.20250122151621.1106">@contextlib.contextmanager
def testing(self) -&gt; Generator[None, None, None]:
    with np.load(self._file_path) as data:
        self._frames = data["frame_data"]
        # For backward compatibility, when the control data contains only one frame (&lt;= v0.8.0)
        if len(self._frames.shape) != 4:
            self._frames = np.expand_dims(self._frames, axis=0)
        logger.debug(self._frames.shape)
        self._number_frames = np.ma.size(self._frames, axis=0)
        yield
        assert self._frames_compared == self._number_frames, (
            f"The scene tested contained {self._frames_compared} frames, "
            f"when there are {self._number_frames} control frames for this test."
        )

</t>
<t tx="ekr.20250122151621.1107">def check_frame(self, frame_number: int, frame: PixelArray) -&gt; None:
    assert frame_number &lt; self._number_frames, (
        f"The tested scene is at frame number {frame_number} "
        f"when there are {self._number_frames} control frames."
    )
    try:
        np.testing.assert_allclose(
            frame,
            self._frames[frame_number],
            atol=FRAME_ABSOLUTE_TOLERANCE,
            err_msg=f"Frame no {frame_number}. You can use --show_diff to visually show the difference.",
            verbose=False,
        )
        self._frames_compared += 1
    except AssertionError as e:
        number_of_matches = np.isclose(
            frame, self._frames[frame_number], atol=FRAME_ABSOLUTE_TOLERANCE
        ).sum()
        number_of_mismatches = frame.size - number_of_matches
        if number_of_mismatches / frame.size &lt; FRAME_MISMATCH_RATIO_TOLERANCE:
            # we tolerate a small (&lt; 0.001%) amount of pixel value errors
            # in the tests, this accounts for minor OS dependent inconsistencies
            self._frames_compared += 1
            warnings.warn(
                f"Mismatch of {number_of_mismatches} pixel values in frame {frame_number} "
                f"against control data in {self._file_path}. Below error threshold, "
                "continuing...",
                stacklevel=1,
            )
            return

        if self._show_diff:
            show_diff_helper(
                frame_number,
                frame,
                self._frames[frame_number],
                self._file_path.name,
            )
        raise e


</t>
<t tx="ekr.20250122151621.1108">def __init__(self, file_path: Path, size_frame: tuple) -&gt; None:
    self.file_path = file_path
    self.frames = np.empty((0, *size_frame, 4))
    self._number_frames_written: int = 0

</t>
<t tx="ekr.20250122151621.1109"># Actually write a frame.
def check_frame(self, index: int, frame: PixelArray) -&gt; None:
    frame = frame[np.newaxis, ...]
    self.frames = np.concatenate((self.frames, frame))
    self._number_frames_written += 1

</t>
<t tx="ekr.20250122151621.111">def get_array_attrs(self) -&gt; list[str]:
    return super().get_array_attrs() + ["rgbas"]

</t>
<t tx="ekr.20250122151621.1110">@contextlib.contextmanager
def testing(self) -&gt; Generator[None, None, None]:
    yield
    self.save_contol_data()

</t>
<t tx="ekr.20250122151621.1111">def save_contol_data(self) -&gt; None:
    self.frames = self.frames.astype("uint8")
    np.savez_compressed(self.file_path, frame_data=self.frames)
    logger.info(
        f"{self._number_frames_written} control frames saved in {self.file_path}",
    )
</t>
<t tx="ekr.20250122151621.1112">from __future__ import annotations

import logging
import warnings

import numpy as np

from manim.typing import PixelArray


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1113">def show_diff_helper(
    frame_number: int,
    frame_data: PixelArray,
    expected_frame_data: PixelArray,
    control_data_filename: str,
) -&gt; None:
    """Will visually display with matplotlib differences between frame generated and the one expected."""
    import matplotlib.gridspec as gridspec
    import matplotlib.pyplot as plt

    gs = gridspec.GridSpec(2, 2)
    fig = plt.figure()
    fig.suptitle(f"Test difference summary at frame {frame_number}", fontsize=16)

    ax = fig.add_subplot(gs[0, 0])
    ax.imshow(frame_data)
    ax.set_title("Generated")

    ax = fig.add_subplot(gs[0, 1])
    ax.imshow(expected_frame_data)
    ax.set_title("Expected")

    ax = fig.add_subplot(gs[1, :])
    diff_im = expected_frame_data.copy()
    diff_im = np.where(
        frame_data != np.array([0, 0, 0, 255]),
        np.array([0, 255, 0, 255], dtype="uint8"),
        np.array([0, 0, 0, 255], dtype="uint8"),
    )  # Set any non-black pixels to green
    np.putmask(
        diff_im,
        expected_frame_data != frame_data,
        np.array([255, 0, 0, 255], dtype="uint8"),
    )  # Set any different pixels to red
    ax.imshow(diff_im, interpolation="nearest")
    ax.set_title("Difference summary: (green = same, red = different)")

    with warnings.catch_warnings():
        warnings.simplefilter("error")
        try:
            plt.show()
        except UserWarning:
            filename = f"{control_data_filename[:-4]}-diff.pdf"
            plt.savefig(filename)
            logging.warning(
                "Interactive matplotlib interface not available,"
                f" diff saved to {filename}."
            )
</t>
<t tx="ekr.20250122151621.1114">from __future__ import annotations

from typing import Any, Callable

from manim.renderer.cairo_renderer import CairoRenderer
from manim.renderer.opengl_renderer import OpenGLRenderer
from manim.scene.scene import Scene
from manim.scene.scene_file_writer import SceneFileWriter
from manim.typing import PixelArray, StrPath

from ._frames_testers import _FramesTester


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1115">def _make_test_scene_class(
@others
    return _TestedScene


</t>
<t tx="ekr.20250122151621.1116">def _make_test_renderer_class(from_renderer: type) -&gt; Any:
    @others
    return _TestRenderer


</t>
<t tx="ekr.20250122151621.1117">class DummySceneFileWriter(SceneFileWriter):
    """Delegate of SceneFileWriter used to test the frames."""

    @others
</t>
<t tx="ekr.20250122151621.1118">def _make_scene_file_writer_class(tester: _FramesTester) -&gt; type[SceneFileWriter]:
    @others
    return TestSceneFileWriter
</t>
<t tx="ekr.20250122151621.1119">    base_scene: type[Scene],
    construct_test: Callable[[Scene], None],
    test_renderer: CairoRenderer | OpenGLRenderer | None,
) -&gt; type[Scene]:
    # TODO: Get the type annotation right for the base_scene argument.
    class _TestedScene(base_scene):  # type: ignore[valid-type, misc]
        @others
</t>
<t tx="ekr.20250122151621.112">def add_points(
    self,
    points: npt.NDArray,
    rgbas: npt.NDArray | None = None,
    color: ParsableManimColor | None = None,
    alpha: float = 1,
) -&gt; Self:
    """Add points.

    Points must be a Nx3 numpy array.
    Rgbas must be a Nx4 numpy array if it is not None.
    """
    if not isinstance(points, np.ndarray):
        points = np.array(points)
    num_new_points = len(points)
    self.points = np.append(self.points, points, axis=0)
    if rgbas is None:
        color = ManimColor(color) if color else self.color
        rgbas = np.repeat([color_to_rgba(color, alpha)], num_new_points, axis=0)
    elif len(rgbas) != len(points):
        raise ValueError("points and rgbas must have same length")
    self.rgbas = np.append(self.rgbas, rgbas, axis=0)
    return self

</t>
<t tx="ekr.20250122151621.1120"># Just for inheritance.
class _TestRenderer(from_renderer):
    pass

</t>
<t tx="ekr.20250122151621.1121">def __init__(
    self,
    renderer: CairoRenderer | OpenGLRenderer,
    scene_name: StrPath,
    **kwargs: Any,
) -&gt; None:
    super().__init__(renderer, scene_name, **kwargs)
    self.i = 0

</t>
<t tx="ekr.20250122151621.1122">def init_output_directories(self, scene_name: StrPath) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151621.1123">def add_partial_movie_file(self, hash_animation: str) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151621.1124">def begin_animation(
    self, allow_write: bool = True, file_path: StrPath | None = None
) -&gt; Any:
    pass

</t>
<t tx="ekr.20250122151621.1125">def end_animation(self, allow_write: bool = False) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151621.1126">def combine_to_movie(self) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151621.1127">def combine_to_section_videos(self) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151621.1128">def clean_cache(self) -&gt; None:
    pass

</t>
<t tx="ekr.20250122151621.1129">def write_frame(
    self, frame_or_renderer: PixelArray | OpenGLRenderer, num_frames: int = 1
) -&gt; None:
    self.i += 1


</t>
<t tx="ekr.20250122151621.113">def set_color(
    self, color: ParsableManimColor = YELLOW, family: bool = True
) -&gt; Self:
    rgba = color_to_rgba(color)
    mobs = self.family_members_with_points() if family else [self]
    for mob in mobs:
        mob.rgbas[:, :] = rgba
    self.color = ManimColor.parse(color)
    return self

</t>
<t tx="ekr.20250122151621.1130">class TestSceneFileWriter(DummySceneFileWriter):
    @others
</t>
<t tx="ekr.20250122151621.1131">def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
    super().__init__(*args, renderer=test_renderer, **kwargs)

</t>
<t tx="ekr.20250122151621.1132">def construct(self) -&gt; None:
    construct_test(self)

    # Manim hack to render the very last frame (normally the last frame is not the very end of the animation)
    if self.animations is not None:
        self.update_to_time(self.get_run_time(self.animations))
        self.renderer.render(self, 1, self.moving_mobjects)

</t>
<t tx="ekr.20250122151621.1133">def write_frame(
    self, frame_or_renderer: PixelArray | OpenGLRenderer, num_frames: int = 1
) -&gt; None:
    tester.check_frame(self.i, frame_or_renderer)
    super().write_frame(frame_or_renderer, num_frames=num_frames)

</t>
<t tx="ekr.20250122151621.1134">from __future__ import annotations

import functools
import inspect
from pathlib import Path
from typing import Any, Callable

import cairo
import pytest
from _pytest.fixtures import FixtureRequest

from manim import Scene
from manim._config import tempconfig
from manim._config.utils import ManimConfig
from manim.camera.three_d_camera import ThreeDCamera
from manim.renderer.cairo_renderer import CairoRenderer
from manim.renderer.opengl_renderer import OpenGLRenderer
from manim.scene.three_d_scene import ThreeDScene
from manim.typing import StrPath

from ._frames_testers import _ControlDataWriter, _FramesTester
from ._test_class_makers import (
    DummySceneFileWriter,
    _make_scene_file_writer_class,
    _make_test_renderer_class,
    _make_test_scene_class,
)

SCENE_PARAMETER_NAME = "scene"
_tests_root_dir_path = Path(__file__).absolute().parents[2]
PATH_CONTROL_DATA = _tests_root_dir_path / Path("control_data", "graphical_units_data")
MIN_CAIRO_VERSION = 11800


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.1135">def frames_comparison(
    func: Callable | None = None,
    *,
    last_frame: bool = True,
    renderer_class: type[CairoRenderer | OpenGLRenderer] = CairoRenderer,
    base_scene: type[Scene] = Scene,
    **custom_config: Any,
) -&gt; Callable:
    """Compares the frames generated by the test with control frames previously registered.

    If there is no control frames for this test, the test will fail. To generate
    control frames for a given test, pass ``--set_test`` flag to pytest
    while running the test.

    Note that this decorator can be use with or without parentheses.

    Parameters
    ----------
    last_frame
        whether the test should test the last frame, by default True.
    renderer_class
        The base renderer to use (OpenGLRenderer/CairoRenderer), by default CairoRenderer
    base_scene
        The base class for the scene (ThreeDScene, etc.), by default Scene

    .. warning::
        By default, last_frame is True, which means that only the last frame is tested.
        If the scene has a moving animation, then the test must set last_frame to False.
    """

    def decorator_maker(tested_scene_construct: Callable) -&gt; Callable:
        if (
            SCENE_PARAMETER_NAME
            not in inspect.getfullargspec(tested_scene_construct).args
        ):
            raise Exception(
                f"Invalid graphical test function test function : must have '{SCENE_PARAMETER_NAME}'as one of the parameters.",
            )

        # Exclude "scene" from the argument list of the signature.
        old_sig = inspect.signature(
            functools.partial(tested_scene_construct, scene=None),
        )

        if "__module_test__" not in tested_scene_construct.__globals__:
            raise Exception(
                "There is no module test name indicated for the graphical unit test. You have to declare __module_test__ in the test file.",
            )
        module_name = tested_scene_construct.__globals__.get("__module_test__")
        assert isinstance(module_name, str)
        test_name = tested_scene_construct.__name__[len("test_") :]

        @functools.wraps(tested_scene_construct)
        # The "request" parameter is meant to be used as a fixture by pytest. See below.
        def wrapper(
            *args: Any, request: FixtureRequest, tmp_path: StrPath, **kwargs: Any
        ) -&gt; None:
            # check for cairo version
            if (
                renderer_class is CairoRenderer
                and cairo.cairo_version() &lt; MIN_CAIRO_VERSION
            ):
                pytest.skip("Cairo version is too old. Skipping cairo graphical tests.")
            # Wraps the test_function to a construct method, to "freeze" the eventual additional arguments (parametrizations fixtures).
            construct = functools.partial(tested_scene_construct, *args, **kwargs)

            # Kwargs contains the eventual parametrization arguments.
            # This modifies the test_name so that it is defined by the parametrization
            # arguments too.
            # Example: if "length" is parametrized from 0 to 20, the kwargs
            # will be once with {"length" : 1}, etc.
            test_name_with_param = test_name + "_".join(
                f"_{str(tup[0])}[{str(tup[1])}]" for tup in kwargs.items()
            )

            config_tests = _config_test(last_frame)

            config_tests["text_dir"] = tmp_path
            config_tests["tex_dir"] = tmp_path

            if last_frame:
                config_tests["frame_rate"] = 1
                config_tests["dry_run"] = True

            setting_test = request.config.getoption("--set_test")
            try:
                test_file_path = tested_scene_construct.__globals__["__file__"]
            except Exception:
                test_file_path = None
            real_test = _make_test_comparing_frames(
                file_path=_control_data_path(
                    test_file_path,
                    module_name,
                    test_name_with_param,
                    setting_test,
                ),
                base_scene=base_scene,
                construct=construct,
                renderer_class=renderer_class,
                is_set_test_data_test=setting_test,
                last_frame=last_frame,
                show_diff=request.config.getoption("--show_diff"),
                size_frame=(config_tests["pixel_height"], config_tests["pixel_width"]),
            )

            # Isolate the config used for the test, to avoid modifying the global config during the test run.
            with tempconfig({**config_tests, **custom_config}):
                real_test()

        parameters = list(old_sig.parameters.values())
        # Adds "request" param into the signature of the wrapper, to use the associated pytest fixture.
        # This fixture is needed to have access to flags value and pytest's config. See above.
        if "request" not in old_sig.parameters:
            parameters += [inspect.Parameter("request", inspect.Parameter.KEYWORD_ONLY)]
        if "tmp_path" not in old_sig.parameters:
            parameters += [
                inspect.Parameter("tmp_path", inspect.Parameter.KEYWORD_ONLY),
            ]
        new_sig = old_sig.replace(parameters=parameters)
        wrapper.__signature__ = new_sig  # type: ignore[attr-defined]

        # Reach a bit into pytest internals to hoist the marks from our wrapped
        # function.
        wrapper.pytestmark = []  # type: ignore[attr-defined]
        new_marks = getattr(tested_scene_construct, "pytestmark", [])
        wrapper.pytestmark = new_marks  # type: ignore[attr-defined]
        return wrapper

    # Case where the decorator is called with and without parentheses.
    # If func is None, callabl(None) returns False
    if callable(func):
        return decorator_maker(func)
    return decorator_maker


</t>
<t tx="ekr.20250122151621.1136">def _make_test_comparing_frames(
    file_path: Path,
    base_scene: type[Scene],
    construct: Callable[[Scene], None],
    renderer_class: type,  # Renderer type, there is no superclass renderer yet .....
    is_set_test_data_test: bool,
    last_frame: bool,
    show_diff: bool,
    size_frame: tuple,
) -&gt; Callable[[], None]:
    """Create the real pytest test that will fail if the frames mismatch.

    Parameters
    ----------
    file_path
        The path of the control frames.
    base_scene
        The base scene class.
    construct
        The construct method (= the test function)
    renderer_class
        The renderer base class.
    show_diff
        whether to visually show_diff (see --show_diff)

    Returns
    -------
    Callable[[], None]
        The pytest test.
    """
    if is_set_test_data_test:
        frames_tester: _FramesTester = _ControlDataWriter(
            file_path, size_frame=size_frame
        )
    else:
        frames_tester = _FramesTester(file_path, show_diff=show_diff)

    file_writer_class = (
        _make_scene_file_writer_class(frames_tester)
        if not last_frame
        else DummySceneFileWriter
    )
    testRenderer = _make_test_renderer_class(renderer_class)

    def real_test() -&gt; None:
        with frames_tester.testing():
            sceneTested = _make_test_scene_class(
                base_scene=base_scene,
                construct_test=construct,
                # NOTE this is really ugly but it's due to the very bad design of the two renderers.
                # If you pass a custom renderer to the Scene, the Camera class given as an argument in the Scene
                # is not passed to the renderer. See __init__ of Scene.
                # This potentially prevents OpenGL testing.
                test_renderer=(
                    testRenderer(file_writer_class=file_writer_class)
                    if base_scene is not ThreeDScene
                    else testRenderer(
                        file_writer_class=file_writer_class,
                        camera_class=ThreeDCamera,
                    )
                ),  # testRenderer(file_writer_class=file_writer_class),
            )
            scene_tested = sceneTested(skip_animations=True)
            scene_tested.render()
            if last_frame:
                frames_tester.check_frame(-1, scene_tested.renderer.get_frame())

    return real_test


</t>
<t tx="ekr.20250122151621.1137">def _control_data_path(
    test_file_path: str | None, module_name: str, test_name: str, setting_test: bool
) -&gt; Path:
    if test_file_path is None:
        # For some reason, path to test file containing @frames_comparison could not
        # be determined. Use local directory instead.
        test_file_path = __file__

    path = Path(test_file_path).absolute().parent / "control_data" / module_name

    if setting_test:
        # Create the directory if not existing.
        path.mkdir(exist_ok=True)
    if not setting_test and not path.exists():
        raise Exception(f"The control frames directory can't be found  in {path}")
    path = (path / test_name).with_suffix(".npz")
    if not setting_test and not path.is_file():
        raise Exception(
            f"The control frame for the test {test_name} cannot be found in {path.parent}. "
            "Make sure you generated the control frames first.",
        )
    return path


</t>
<t tx="ekr.20250122151621.1138">def _config_test(last_frame: bool) -&gt; ManimConfig:
    return ManimConfig().digest_file(
        str(
            Path(__file__).parent
            / (
                "config_graphical_tests_monoframe.cfg"
                if last_frame
                else "config_graphical_tests_multiframes.cfg"
            ),
        ),
    )
</t>
<t tx="ekr.20250122151621.114">def get_stroke_width(self) -&gt; int:
    return self.stroke_width

</t>
<t tx="ekr.20250122151621.115">def set_stroke_width(self, width: int, family: bool = True) -&gt; Self:
    mobs = self.family_members_with_points() if family else [self]
    for mob in mobs:
        mob.stroke_width = width
    return self

</t>
<t tx="ekr.20250122151621.116">def set_color_by_gradient(self, *colors: ParsableManimColor) -&gt; Self:
    self.rgbas = np.array(
        list(map(color_to_rgba, color_gradient(*colors, len(self.points)))),
    )
    return self

</t>
<t tx="ekr.20250122151621.117">def set_colors_by_radial_gradient(
    self,
    center: Point3DLike | None = None,
    radius: float = 1,
    inner_color: ParsableManimColor = WHITE,
    outer_color: ParsableManimColor = BLACK,
) -&gt; Self:
    start_rgba, end_rgba = list(map(color_to_rgba, [inner_color, outer_color]))
    if center is None:
        center = self.get_center()
    for mob in self.family_members_with_points():
        distances = np.abs(self.points - center)
        alphas = np.linalg.norm(distances, axis=1) / radius

        mob.rgbas = np.array(
            np.array(
                [interpolate(start_rgba, end_rgba, alpha) for alpha in alphas],
            ),
        )
    return self

</t>
<t tx="ekr.20250122151621.118">def match_colors(self, mobject: Mobject) -&gt; Self:
    Mobject.align_data(self, mobject)
    self.rgbas = np.array(mobject.rgbas)
    return self

</t>
<t tx="ekr.20250122151621.119">def filter_out(self, condition: npt.NDArray) -&gt; Self:
    for mob in self.family_members_with_points():
        to_eliminate = ~np.apply_along_axis(condition, 1, mob.points)
        mob.points = mob.points[to_eliminate]
        mob.rgbas = mob.rgbas[to_eliminate]
    return self

</t>
<t tx="ekr.20250122151621.12">def create_faces(
    self,
    face_coords: list[list[list | np.ndarray]],
) -&gt; VGroup:
    """Creates VGroup of faces from a list of face coordinates."""
    face_group = VGroup()
    for face in face_coords:
        face_group.add(Polygon(*face, **self.faces_config))
    return face_group

</t>
<t tx="ekr.20250122151621.120">def thin_out(self, factor: int = 5) -&gt; Self:
    """Removes all but every nth point for n = factor"""
    for mob in self.family_members_with_points():
        num_points = self.get_num_points()
        mob.apply_over_attr_arrays(
            lambda arr, n=num_points: arr[np.arange(0, n, factor)],
        )
    return self

</t>
<t tx="ekr.20250122151621.121">def sort_points(
    self, function: Callable[[npt.NDArray[ManimFloat]], float] = lambda p: p[0]
) -&gt; Self:
    """Function is any map from R^3 to R"""
    for mob in self.family_members_with_points():
        indices = np.argsort(np.apply_along_axis(function, 1, mob.points))
        mob.apply_over_attr_arrays(lambda arr, idx=indices: arr[idx])
    return self

</t>
<t tx="ekr.20250122151621.122">def fade_to(
    self, color: ParsableManimColor, alpha: float, family: bool = True
) -&gt; Self:
    self.rgbas = interpolate(self.rgbas, color_to_rgba(color), alpha)
    for mob in self.submobjects:
        mob.fade_to(color, alpha, family)
    return self

</t>
<t tx="ekr.20250122151621.123">def get_all_rgbas(self) -&gt; npt.NDArray:
    return self.get_merged_array("rgbas")

</t>
<t tx="ekr.20250122151621.124">def ingest_submobjects(self) -&gt; Self:
    attrs = self.get_array_attrs()
    arrays = list(map(self.get_merged_array, attrs))
    for attr, array in zip(attrs, arrays):
        setattr(self, attr, array)
    self.submobjects = []
    return self

</t>
<t tx="ekr.20250122151621.125">def get_color(self) -&gt; ManimColor:
    return rgba_to_color(self.rgbas[0, :])

</t>
<t tx="ekr.20250122151621.126">def point_from_proportion(self, alpha: float) -&gt; Any:
    index = alpha * (self.get_num_points() - 1)
    return self.points[np.floor(index)]

</t>
<t tx="ekr.20250122151621.127">@staticmethod
def get_mobject_type_class() -&gt; type[PMobject]:
    return PMobject

</t>
<t tx="ekr.20250122151621.128"># Alignment
def align_points_with_larger(self, larger_mobject: Mobject) -&gt; None:
    assert isinstance(larger_mobject, PMobject)
    self.apply_over_attr_arrays(
        lambda a: stretch_array_to_length(a, larger_mobject.get_num_points()),
    )

</t>
<t tx="ekr.20250122151621.129">def get_point_mobject(self, center: Point3DLike | None = None) -&gt; Point:
    if center is None:
        center = self.get_center()
    return Point(center)

</t>
<t tx="ekr.20250122151621.13">def update_faces(self, m: Mobject):
    face_coords = self.extract_face_coords()
    new_faces = self.create_faces(face_coords)
    self.faces.match_points(new_faces)

</t>
<t tx="ekr.20250122151621.130">def interpolate_color(
    self, mobject1: Mobject, mobject2: Mobject, alpha: float
) -&gt; Self:
    self.rgbas = interpolate(mobject1.rgbas, mobject2.rgbas, alpha)
    self.set_stroke_width(
        interpolate(
            mobject1.get_stroke_width(),
            mobject2.get_stroke_width(),
            alpha,
        ),
    )
    return self

</t>
<t tx="ekr.20250122151621.131">def pointwise_become_partial(self, mobject: Mobject, a: float, b: float) -&gt; None:
    lower_index, upper_index = (int(x * mobject.get_num_points()) for x in (a, b))
    for attr in self.get_array_attrs():
        full_array = getattr(mobject, attr)
        partial_array = full_array[lower_index:upper_index]
        setattr(self, attr, partial_array)


</t>
<t tx="ekr.20250122151621.132">def __init__(self, density: int = DEFAULT_POINT_DENSITY_1D, **kwargs: Any) -&gt; None:
    self.density = density
    self.epsilon = 1.0 / self.density
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151621.133">def add_line(
    self,
    start: npt.NDArray,
    end: npt.NDArray,
    color: ParsableManimColor | None = None,
) -&gt; None:
    start, end = list(map(np.array, [start, end]))
    length = np.linalg.norm(end - start)
    if length == 0:
        points = np.array([start])
    else:
        epsilon = self.epsilon / length
        points = np.array(
            [interpolate(start, end, t) for t in np.arange(0, 1, epsilon)]
        )
    self.add_points(points, color=color)


</t>
<t tx="ekr.20250122151621.134">def __init__(self, density: int = DEFAULT_POINT_DENSITY_2D, **kwargs: Any) -&gt; None:
    self.density = density
    self.epsilon = 1.0 / self.density
    super().__init__(**kwargs)


</t>
<t tx="ekr.20250122151621.135">def __init__(self, *pmobs: Any, **kwargs: Any) -&gt; None:
    if not all(isinstance(m, (PMobject, OpenGLPMobject)) for m in pmobs):
        raise ValueError(
            "All submobjects must be of type PMobject or OpenGLPMObject"
            " if using the opengl renderer",
        )
    super().__init__(**kwargs)
    self.add(*pmobs)

</t>
<t tx="ekr.20250122151621.136">def fade_to(
    self, color: ParsableManimColor, alpha: float, family: bool = True
) -&gt; Self:
    if family:
        for mob in self.submobjects:
            mob.fade_to(color, alpha, family)
    return self


</t>
<t tx="ekr.20250122151621.137">def __init__(
    self,
    center: Vector3D = ORIGIN,
    radius: float = 2.0,
    stroke_width: int = 2,
    density: int = DEFAULT_POINT_DENSITY_1D,
    color: ManimColor = YELLOW,
    **kwargs: Any,
) -&gt; None:
    self.radius = radius
    self.epsilon = 1.0 / density
    super().__init__(
        stroke_width=stroke_width, density=density, color=color, **kwargs
    )
    self.shift(center)

</t>
<t tx="ekr.20250122151621.138">def init_points(self) -&gt; None:
    self.reset_points()
    self.generate_points()

</t>
<t tx="ekr.20250122151621.139">def generate_points(self) -&gt; None:
    self.add_points(
        np.array(
            [
                r * (np.cos(theta) * RIGHT + np.sin(theta) * UP)
                for r in np.arange(self.epsilon, self.radius, self.epsilon)
                # Num is equal to int(stop - start)/ (step + 1) reformulated.
                for theta in np.linspace(
                    0,
                    2 * np.pi,
                    num=int(2 * np.pi * (r + self.epsilon) / self.epsilon),
                )
            ]
        ),
    )


</t>
<t tx="ekr.20250122151621.14">def extract_face_coords(self) -&gt; list[list[np.ndarray]]:
    """Extracts the coordinates of the vertices in the graph.
    Used for updating faces.
    """
    new_vertex_coords = []
    for v in self.graph.vertices:
        new_vertex_coords.append(self.graph[v].get_center())
    layout = dict(enumerate(new_vertex_coords))
    return [[layout[j] for j in i] for i in self.faces_list]


</t>
<t tx="ekr.20250122151621.140">def __init__(
    self, location: Vector3D = ORIGIN, color: ManimColor = BLACK, **kwargs: Any
) -&gt; None:
    self.location = location
    super().__init__(color=color, **kwargs)

</t>
<t tx="ekr.20250122151621.141">def init_points(self) -&gt; None:
    self.reset_points()
    self.generate_points()
    self.set_points([self.location])

</t>
<t tx="ekr.20250122151621.142">def generate_points(self) -&gt; None:
    self.add_points(np.array([self.location]))
</t>
<t tx="ekr.20250122151621.143">"""Mobjects that use vector graphics."""

from __future__ import annotations

__all__ = [
    "VMobject",
    "VGroup",
    "VDict",
    "VectorizedPoint",
    "CurvesAsSubmobjects",
    "DashedVMobject",
]


import itertools as it
import sys
from collections.abc import Hashable, Iterable, Mapping, Sequence
from typing import TYPE_CHECKING, Callable, Literal

import numpy as np
from PIL.Image import Image

from manim import config
from manim.constants import *
from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject
from manim.mobject.three_d.three_d_utils import (
    get_3d_vmob_gradient_start_and_end_points,
)
from manim.utils.bezier import (
    bezier,
    bezier_remap,
    get_smooth_cubic_bezier_handle_points,
    integer_interpolate,
    interpolate,
    partial_bezier_points,
    proportions_along_bezier_curve_for_point,
)
from manim.utils.color import BLACK, WHITE, ManimColor, ParsableManimColor
from manim.utils.iterables import (
    make_even,
    resize_array,
    stretch_array_to_length,
    tuplify,
)
from manim.utils.space_ops import rotate_vector, shoelace_direction

if TYPE_CHECKING:
    from typing import Any

    import numpy.typing as npt
    from typing_extensions import Self

    from manim.typing import (
        CubicBezierPath,
        CubicBezierPointsLike,
        CubicSpline,
        ManimFloat,
        MappingFunction,
        Point2DLike,
        Point3D,
        Point3D_Array,
        Point3DLike,
        Point3DLike_Array,
        RGBA_Array_Float,
        Vector3D,
        Zeros,
    )

# TODO
# - Change cubic curve groups to have 4 points instead of 3
# - Change sub_path idea accordingly
# - No more mark_paths_closed, instead have the camera test
#   if last point in close to first point
# - Think about length of self.points.  Always 0 or 1 mod 4?
#   That's kind of weird.


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.144">class VMobject(Mobject):
    """A vectorized mobject.

    Parameters
    ----------
    background_stroke_color
        The purpose of background stroke is to have something
        that won't overlap fill, e.g.  For text against some
        textured background.
    sheen_factor
        When a color c is set, there will be a second color
        computed based on interpolating c to WHITE by with
        sheen_factor, and the display will gradient to this
        secondary color in the direction of sheen_direction.
    close_new_points
        Indicates that it will not be displayed, but
        that it should count in parent mobject's path
    tolerance_for_point_equality
        This is within a pixel
    joint_type
        The line joint type used to connect the curve segments
        of this vectorized mobject. See :class:`.LineJointType`
        for options.
    """

    @others
</t>
<t tx="ekr.20250122151621.145">class VGroup(VMobject, metaclass=ConvertToOpenGL):
    """A group of vectorized mobjects.

    This can be used to group multiple :class:`~.VMobject` instances together
    in order to scale, move, ... them together.

    Notes
    -----
    When adding the same mobject more than once, repetitions are ignored.
    Use :meth:`.Mobject.copy` to create a separate copy which can then
    be added to the group.

    Examples
    --------

    To add :class:`~.VMobject`s to a :class:`~.VGroup`, you can either use the
    :meth:`~.VGroup.add` method, or use the `+` and `+=` operators. Similarly, you
    can subtract elements of a VGroup via :meth:`~.VGroup.remove` method, or
    `-` and `-=` operators:

        &gt;&gt;&gt; from manim import Triangle, Square, VGroup
        &gt;&gt;&gt; vg = VGroup()
        &gt;&gt;&gt; triangle, square = Triangle(), Square()
        &gt;&gt;&gt; vg.add(triangle)
        VGroup(Triangle)
        &gt;&gt;&gt; vg + square  # a new VGroup is constructed
        VGroup(Triangle, Square)
        &gt;&gt;&gt; vg  # not modified
        VGroup(Triangle)
        &gt;&gt;&gt; vg += square
        &gt;&gt;&gt; vg  # modifies vg
        VGroup(Triangle, Square)
        &gt;&gt;&gt; vg.remove(triangle)
        VGroup(Square)
        &gt;&gt;&gt; vg - square  # a new VGroup is constructed
        VGroup()
        &gt;&gt;&gt; vg  # not modified
        VGroup(Square)
        &gt;&gt;&gt; vg -= square
        &gt;&gt;&gt; vg  # modifies vg
        VGroup()

    .. manim:: ArcShapeIris
        :save_last_frame:

        class ArcShapeIris(Scene):
            def construct(self):
                colors = [DARK_BROWN, BLUE_E, BLUE_D, BLUE_A, TEAL_B, GREEN_B, YELLOW_E]
                radius = [1 + rad * 0.1 for rad in range(len(colors))]

                circles_group = VGroup()

                # zip(radius, color) makes the iterator [(radius[i], color[i]) for i in range(radius)]
                circles_group.add(*[Circle(radius=rad, stroke_width=10, color=col)
                                    for rad, col in zip(radius, colors)])
                self.add(circles_group)

    """

    @others
</t>
<t tx="ekr.20250122151621.146">class VDict(VMobject, metaclass=ConvertToOpenGL):
    """A VGroup-like class, also offering submobject access by
    key, like a python dict

    Parameters
    ----------
    mapping_or_iterable
            The parameter specifying the key-value mapping of keys and mobjects.
    show_keys
            Whether to also display the key associated with
            the mobject. This might be useful when debugging,
            especially when there are a lot of mobjects in the
            :class:`VDict`. Defaults to False.
    kwargs
            Other arguments to be passed to `Mobject`.

    Attributes
    ----------
    show_keys : :class:`bool`
            Whether to also display the key associated with
            the mobject. This might be useful when debugging,
            especially when there are a lot of mobjects in the
            :class:`VDict`. When displayed, the key is towards
            the left of the mobject.
            Defaults to False.
    submob_dict : :class:`dict`
            Is the actual python dictionary that is used to bind
            the keys to the mobjects.

    Examples
    --------

    .. manim:: ShapesWithVDict

        class ShapesWithVDict(Scene):
            def construct(self):
                square = Square().set_color(RED)
                circle = Circle().set_color(YELLOW).next_to(square, UP)

                # create dict from list of tuples each having key-mobject pair
                pairs = [("s", square), ("c", circle)]
                my_dict = VDict(pairs, show_keys=True)

                # display it just like a VGroup
                self.play(Create(my_dict))
                self.wait()

                text = Tex("Some text").set_color(GREEN).next_to(square, DOWN)

                # add a key-value pair by wrapping it in a single-element list of tuple
                # after attrs branch is merged, it will be easier like `.add(t=text)`
                my_dict.add([("t", text)])
                self.wait()

                rect = Rectangle().next_to(text, DOWN)
                # can also do key assignment like a python dict
                my_dict["r"] = rect

                # access submobjects like a python dict
                my_dict["t"].set_color(PURPLE)
                self.play(my_dict["t"].animate.scale(3))
                self.wait()

                # also supports python dict styled reassignment
                my_dict["t"] = Tex("Some other text").set_color(BLUE)
                self.wait()

                # remove submobject by key
                my_dict.remove("t")
                self.wait()

                self.play(Uncreate(my_dict["s"]))
                self.wait()

                self.play(FadeOut(my_dict["c"]))
                self.wait()

                self.play(FadeOut(my_dict["r"], shift=DOWN))
                self.wait()

                # you can also make a VDict from an existing dict of mobjects
                plain_dict = {
                    1: Integer(1).shift(DOWN),
                    2: Integer(2).shift(2 * DOWN),
                    3: Integer(3).shift(3 * DOWN),
                }

                vdict_from_plain_dict = VDict(plain_dict)
                vdict_from_plain_dict.shift(1.5 * (UP + LEFT))
                self.play(Create(vdict_from_plain_dict))

                # you can even use zip
                vdict_using_zip = VDict(zip(["s", "c", "r"], [Square(), Circle(), Rectangle()]))
                vdict_using_zip.shift(1.5 * RIGHT)
                self.play(Create(vdict_using_zip))
                self.wait()
    """

    @others
</t>
<t tx="ekr.20250122151621.147">class VectorizedPoint(VMobject, metaclass=ConvertToOpenGL):
    @others
</t>
<t tx="ekr.20250122151621.148">class CurvesAsSubmobjects(VGroup):
    """Convert a curve's elements to submobjects.

    Examples
    --------
    .. manim:: LineGradientExample
        :save_last_frame:

        class LineGradientExample(Scene):
            def construct(self):
                curve = ParametricFunction(lambda t: [t, np.sin(t), 0], t_range=[-PI, PI, 0.01], stroke_width=10)
                new_curve = CurvesAsSubmobjects(curve)
                new_curve.set_color_by_gradient(BLUE, RED)
                self.add(new_curve.shift(UP), curve)

    """

    @others
</t>
<t tx="ekr.20250122151621.149">class DashedVMobject(VMobject, metaclass=ConvertToOpenGL):
    """A :class:`VMobject` composed of dashes instead of lines.

    Parameters
    ----------
        vmobject
            The object that will get dashed
        num_dashes
            Number of dashes to add.
        dashed_ratio
            Ratio of dash to empty space.
        dash_offset
            Shifts the starting point of dashes along the
            path. Value 1 shifts by one full dash length.
        equal_lengths
            If ``True``, dashes will be (approximately) equally long.
            If ``False``, dashes will be split evenly in the curve's
            input t variable (legacy behavior).

    Examples
    --------
    .. manim:: DashedVMobjectExample
        :save_last_frame:

        class DashedVMobjectExample(Scene):
            def construct(self):
                r = 0.5

                top_row = VGroup()  # Increasing num_dashes
                for dashes in range(1, 12):
                    circ = DashedVMobject(Circle(radius=r, color=WHITE), num_dashes=dashes)
                    top_row.add(circ)

                middle_row = VGroup()  # Increasing dashed_ratio
                for ratio in np.arange(1 / 11, 1, 1 / 11):
                    circ = DashedVMobject(
                        Circle(radius=r, color=WHITE), dashed_ratio=ratio
                    )
                    middle_row.add(circ)

                func1 = FunctionGraph(lambda t: t**5,[-1,1],color=WHITE)
                func_even = DashedVMobject(func1,num_dashes=6,equal_lengths=True)
                func_stretched = DashedVMobject(func1, num_dashes=6, equal_lengths=False)
                bottom_row = VGroup(func_even,func_stretched)


                top_row.arrange(buff=0.3)
                middle_row.arrange()
                bottom_row.arrange(buff=1)
                everything = VGroup(top_row, middle_row, bottom_row).arrange(DOWN, buff=1)
                self.add(everything)

    """

    @others
</t>
<t tx="ekr.20250122151621.15">def __init__(self, edge_length: float = 1, **kwargs):
    unit = edge_length * np.sqrt(2) / 4
    super().__init__(
        vertex_coords=[
            np.array([unit, unit, unit]),
            np.array([unit, -unit, -unit]),
            np.array([-unit, unit, -unit]),
            np.array([-unit, -unit, unit]),
        ],
        faces_list=[[0, 1, 2], [3, 0, 2], [0, 1, 3], [3, 1, 2]],
        **kwargs,
    )


</t>
<t tx="ekr.20250122151621.150">sheen_factor = 0.0

def __init__(
    self,
    fill_color: ParsableManimColor | None = None,
    fill_opacity: float = 0.0,
    stroke_color: ParsableManimColor | None = None,
    stroke_opacity: float = 1.0,
    stroke_width: float = DEFAULT_STROKE_WIDTH,
    background_stroke_color: ParsableManimColor | None = BLACK,
    background_stroke_opacity: float = 1.0,
    background_stroke_width: float = 0,
    sheen_factor: float = 0.0,
    joint_type: LineJointType | None = None,
    sheen_direction: Vector3D = UL,
    close_new_points: bool = False,
    pre_function_handle_to_anchor_scale_factor: float = 0.01,
    make_smooth_after_applying_functions: bool = False,
    background_image: Image | str | None = None,
    shade_in_3d: bool = False,
    # TODO, do we care about accounting for varying zoom levels?
    tolerance_for_point_equality: float = 1e-6,
    n_points_per_cubic_curve: int = 4,
    cap_style: CapStyleType = CapStyleType.AUTO,
    **kwargs: Any,
):
    self.fill_opacity = fill_opacity
    self.stroke_opacity = stroke_opacity
    self.stroke_width = stroke_width
    if background_stroke_color is not None:
        self.background_stroke_color: ManimColor = ManimColor(
            background_stroke_color
        )
    self.background_stroke_opacity: float = background_stroke_opacity
    self.background_stroke_width: float = background_stroke_width
    self.sheen_factor: float = sheen_factor
    self.joint_type: LineJointType = (
        LineJointType.AUTO if joint_type is None else joint_type
    )
    self.sheen_direction: Vector3D = sheen_direction
    self.close_new_points: bool = close_new_points
    self.pre_function_handle_to_anchor_scale_factor: float = (
        pre_function_handle_to_anchor_scale_factor
    )
    self.make_smooth_after_applying_functions: bool = (
        make_smooth_after_applying_functions
    )
    self.background_image: Image | str | None = background_image
    self.shade_in_3d: bool = shade_in_3d
    self.tolerance_for_point_equality: float = tolerance_for_point_equality
    self.n_points_per_cubic_curve: int = n_points_per_cubic_curve
    self._bezier_t_values: npt.NDArray[float] = np.linspace(
        0, 1, n_points_per_cubic_curve
    )
    self.cap_style: CapStyleType = cap_style
    super().__init__(**kwargs)
    self.submobjects: list[VMobject]

    # TODO: Find where color overwrites are happening and remove the color doubling
    # if "color" in kwargs:
    #     fill_color = kwargs["color"]
    #     stroke_color = kwargs["color"]
    if fill_color is not None:
        self.fill_color = ManimColor.parse(fill_color)
    if stroke_color is not None:
        self.stroke_color = ManimColor.parse(stroke_color)

</t>
<t tx="ekr.20250122151621.151">def _assert_valid_submobjects(self, submobjects: Iterable[VMobject]) -&gt; Self:
    return self._assert_valid_submobjects_internal(submobjects, VMobject)

</t>
<t tx="ekr.20250122151621.152"># OpenGL compatibility
@property
def n_points_per_curve(self) -&gt; int:
    return self.n_points_per_cubic_curve

</t>
<t tx="ekr.20250122151621.153">def get_group_class(self) -&gt; type[VGroup]:
    return VGroup

</t>
<t tx="ekr.20250122151621.154">@staticmethod
def get_mobject_type_class() -&gt; type[VMobject]:
    return VMobject

</t>
<t tx="ekr.20250122151621.155"># Colors
def init_colors(self, propagate_colors: bool = True) -&gt; Self:
    self.set_fill(
        color=self.fill_color,
        opacity=self.fill_opacity,
        family=propagate_colors,
    )
    self.set_stroke(
        color=self.stroke_color,
        width=self.stroke_width,
        opacity=self.stroke_opacity,
        family=propagate_colors,
    )
    self.set_background_stroke(
        color=self.background_stroke_color,
        width=self.background_stroke_width,
        opacity=self.background_stroke_opacity,
        family=propagate_colors,
    )
    self.set_sheen(
        factor=self.sheen_factor,
        direction=self.sheen_direction,
        family=propagate_colors,
    )

    if not propagate_colors:
        for submobject in self.submobjects:
            submobject.init_colors(propagate_colors=False)

    return self

</t>
<t tx="ekr.20250122151621.156">def generate_rgbas_array(
    self, color: ManimColor | list[ManimColor], opacity: float | Iterable[float]
) -&gt; RGBA_Array_Float:
    """
    First arg can be either a color, or a tuple/list of colors.
    Likewise, opacity can either be a float, or a tuple of floats.
    If self.sheen_factor is not zero, and only
    one color was passed in, a second slightly light color
    will automatically be added for the gradient
    """
    colors: list[ManimColor] = [
        ManimColor(c) if (c is not None) else BLACK for c in tuplify(color)
    ]
    opacities: list[float] = [
        o if (o is not None) else 0.0 for o in tuplify(opacity)
    ]
    rgbas: npt.NDArray[RGBA_Array_Float] = np.array(
        [c.to_rgba_with_alpha(o) for c, o in zip(*make_even(colors, opacities))],
    )

    sheen_factor = self.get_sheen_factor()
    if sheen_factor != 0 and len(rgbas) == 1:
        light_rgbas = np.array(rgbas)
        light_rgbas[:, :3] += sheen_factor
        np.clip(light_rgbas, 0, 1, out=light_rgbas)
        rgbas = np.append(rgbas, light_rgbas, axis=0)
    return rgbas

</t>
<t tx="ekr.20250122151621.157">def update_rgbas_array(
    self,
    array_name: str,
    color: ManimColor | None = None,
    opacity: float | None = None,
) -&gt; Self:
    rgbas = self.generate_rgbas_array(color, opacity)
    if not hasattr(self, array_name):
        setattr(self, array_name, rgbas)
        return self
    # Match up current rgbas array with the newly calculated
    # one. 99% of the time they'll be the same.
    curr_rgbas = getattr(self, array_name)
    if len(curr_rgbas) &lt; len(rgbas):
        curr_rgbas = stretch_array_to_length(curr_rgbas, len(rgbas))
        setattr(self, array_name, curr_rgbas)
    elif len(rgbas) &lt; len(curr_rgbas):
        rgbas = stretch_array_to_length(rgbas, len(curr_rgbas))
    # Only update rgb if color was not None, and only
    # update alpha channel if opacity was passed in
    if color is not None:
        curr_rgbas[:, :3] = rgbas[:, :3]
    if opacity is not None:
        curr_rgbas[:, 3] = rgbas[:, 3]
    return self

</t>
<t tx="ekr.20250122151621.158">def set_fill(
    self,
    color: ParsableManimColor | None = None,
    opacity: float | None = None,
    family: bool = True,
) -&gt; Self:
    """Set the fill color and fill opacity of a :class:`VMobject`.

    Parameters
    ----------
    color
        Fill color of the :class:`VMobject`.
    opacity
        Fill opacity of the :class:`VMobject`.
    family
        If ``True``, the fill color of all submobjects is also set.

    Returns
    -------
    :class:`VMobject`
        ``self``

    Examples
    --------
    .. manim:: SetFill
        :save_last_frame:

        class SetFill(Scene):
            def construct(self):
                square = Square().scale(2).set_fill(WHITE,1)
                circle1 = Circle().set_fill(GREEN,0.8)
                circle2 = Circle().set_fill(YELLOW) # No fill_opacity
                circle3 = Circle().set_fill(color = '#FF2135', opacity = 0.2)
                group = Group(circle1,circle2,circle3).arrange()
                self.add(square)
                self.add(group)

    See Also
    --------
    :meth:`~.VMobject.set_style`
    """
    if family:
        for submobject in self.submobjects:
            submobject.set_fill(color, opacity, family)
    self.update_rgbas_array("fill_rgbas", color, opacity)
    self.fill_rgbas: RGBA_Array_Float
    if opacity is not None:
        self.fill_opacity = opacity
    return self

</t>
<t tx="ekr.20250122151621.159">def set_stroke(
    self,
    color: ParsableManimColor = None,
    width: float | None = None,
    opacity: float | None = None,
    background=False,
    family: bool = True,
) -&gt; Self:
    if family:
        for submobject in self.submobjects:
            submobject.set_stroke(color, width, opacity, background, family)
    if background:
        array_name = "background_stroke_rgbas"
        width_name = "background_stroke_width"
        opacity_name = "background_stroke_opacity"
    else:
        array_name = "stroke_rgbas"
        width_name = "stroke_width"
        opacity_name = "stroke_opacity"
    self.update_rgbas_array(array_name, color, opacity)
    if width is not None:
        setattr(self, width_name, width)
    if opacity is not None:
        setattr(self, opacity_name, opacity)
    if color is not None and background:
        if isinstance(color, (list, tuple)):
            self.background_stroke_color = ManimColor.parse(color)
        else:
            self.background_stroke_color = ManimColor(color)
    return self

</t>
<t tx="ekr.20250122151621.16">def __init__(self, edge_length: float = 1, **kwargs):
    unit = edge_length * np.sqrt(2) / 2
    super().__init__(
        vertex_coords=[
            np.array([unit, 0, 0]),
            np.array([-unit, 0, 0]),
            np.array([0, unit, 0]),
            np.array([0, -unit, 0]),
            np.array([0, 0, unit]),
            np.array([0, 0, -unit]),
        ],
        faces_list=[
            [2, 4, 1],
            [0, 4, 2],
            [4, 3, 0],
            [1, 3, 4],
            [3, 5, 0],
            [1, 5, 3],
            [2, 5, 1],
            [0, 5, 2],
        ],
        **kwargs,
    )


</t>
<t tx="ekr.20250122151621.160">def set_cap_style(self, cap_style: CapStyleType) -&gt; Self:
    """
    Sets the cap style of the :class:`VMobject`.

    Parameters
    ----------
    cap_style
        The cap style to be set. See :class:`.CapStyleType` for options.

    Returns
    -------
    :class:`VMobject`
        ``self``

    Examples
    --------
    .. manim:: CapStyleExample
        :save_last_frame:

        class CapStyleExample(Scene):
            def construct(self):
                line = Line(LEFT, RIGHT, color=YELLOW, stroke_width=20)
                line.set_cap_style(CapStyleType.ROUND)
                self.add(line)
    """
    self.cap_style = cap_style
    return self

</t>
<t tx="ekr.20250122151621.161">def set_background_stroke(self, **kwargs) -&gt; Self:
    kwargs["background"] = True
    self.set_stroke(**kwargs)
    return self

</t>
<t tx="ekr.20250122151621.162">def set_style(
    self,
    fill_color: ParsableManimColor | None = None,
    fill_opacity: float | None = None,
    stroke_color: ParsableManimColor | None = None,
    stroke_width: float | None = None,
    stroke_opacity: float | None = None,
    background_stroke_color: ParsableManimColor | None = None,
    background_stroke_width: float | None = None,
    background_stroke_opacity: float | None = None,
    sheen_factor: float | None = None,
    sheen_direction: Vector3D | None = None,
    background_image: Image | str | None = None,
    family: bool = True,
) -&gt; Self:
    self.set_fill(color=fill_color, opacity=fill_opacity, family=family)
    self.set_stroke(
        color=stroke_color,
        width=stroke_width,
        opacity=stroke_opacity,
        family=family,
    )
    self.set_background_stroke(
        color=background_stroke_color,
        width=background_stroke_width,
        opacity=background_stroke_opacity,
        family=family,
    )
    if sheen_factor:
        self.set_sheen(
            factor=sheen_factor,
            direction=sheen_direction,
            family=family,
        )
    if background_image:
        self.color_using_background_image(background_image)
    return self

</t>
<t tx="ekr.20250122151621.163">def get_style(self, simple: bool = False) -&gt; dict:
    ret = {
        "stroke_opacity": self.get_stroke_opacity(),
        "stroke_width": self.get_stroke_width(),
    }

    # TODO: FIX COLORS HERE
    if simple:
        ret["fill_color"] = self.get_fill_color()
        ret["fill_opacity"] = self.get_fill_opacity()
        ret["stroke_color"] = self.get_stroke_color()
    else:
        ret["fill_color"] = self.get_fill_colors()
        ret["fill_opacity"] = self.get_fill_opacities()
        ret["stroke_color"] = self.get_stroke_colors()
        ret["background_stroke_color"] = self.get_stroke_colors(background=True)
        ret["background_stroke_width"] = self.get_stroke_width(background=True)
        ret["background_stroke_opacity"] = self.get_stroke_opacity(background=True)
        ret["sheen_factor"] = self.get_sheen_factor()
        ret["sheen_direction"] = self.get_sheen_direction()
        ret["background_image"] = self.get_background_image()

    return ret

</t>
<t tx="ekr.20250122151621.164">def match_style(self, vmobject: VMobject, family: bool = True) -&gt; Self:
    self.set_style(**vmobject.get_style(), family=False)

    if family:
        # Does its best to match up submobject lists, and
        # match styles accordingly
        submobs1, submobs2 = self.submobjects, vmobject.submobjects
        if len(submobs1) == 0:
            return self
        elif len(submobs2) == 0:
            submobs2 = [vmobject]
        for sm1, sm2 in zip(*make_even(submobs1, submobs2)):
            sm1.match_style(sm2)
    return self

</t>
<t tx="ekr.20250122151621.165">def set_color(self, color: ParsableManimColor, family: bool = True) -&gt; Self:
    self.set_fill(color, family=family)
    self.set_stroke(color, family=family)
    return self

</t>
<t tx="ekr.20250122151621.166">def set_opacity(self, opacity: float, family: bool = True) -&gt; Self:
    self.set_fill(opacity=opacity, family=family)
    self.set_stroke(opacity=opacity, family=family)
    self.set_stroke(opacity=opacity, family=family, background=True)
    return self

</t>
<t tx="ekr.20250122151621.167">def scale(self, scale_factor: float, scale_stroke: bool = False, **kwargs) -&gt; Self:
    r"""Scale the size by a factor.

    Default behavior is to scale about the center of the vmobject.

    Parameters
    ----------
    scale_factor
        The scaling factor :math:`\alpha`. If :math:`0 &lt; |\alpha| &lt; 1`, the mobject
        will shrink, and for :math:`|\alpha| &gt; 1` it will grow. Furthermore,
        if :math:`\alpha &lt; 0`, the mobject is also flipped.
    scale_stroke
        Boolean determining if the object's outline is scaled when the object is scaled.
        If enabled, and object with 2px outline is scaled by a factor of .5, it will have an outline of 1px.
    kwargs
        Additional keyword arguments passed to
        :meth:`~.Mobject.scale`.

    Returns
    -------
    :class:`VMobject`
        ``self``

    Examples
    --------

    .. manim:: MobjectScaleExample
        :save_last_frame:

        class MobjectScaleExample(Scene):
            def construct(self):
                c1 = Circle(1, RED).set_x(-1)
                c2 = Circle(1, GREEN).set_x(1)

                vg = VGroup(c1, c2)
                vg.set_stroke(width=50)
                self.add(vg)

                self.play(
                    c1.animate.scale(.25),
                    c2.animate.scale(.25,
                        scale_stroke=True)
                )

    See also
    --------
    :meth:`move_to`

    """
    if scale_stroke:
        self.set_stroke(width=abs(scale_factor) * self.get_stroke_width())
        self.set_stroke(
            width=abs(scale_factor) * self.get_stroke_width(background=True),
            background=True,
        )
    super().scale(scale_factor, **kwargs)
    return self

</t>
<t tx="ekr.20250122151621.168">def fade(self, darkness: float = 0.5, family: bool = True) -&gt; Self:
    factor = 1.0 - darkness
    self.set_fill(opacity=factor * self.get_fill_opacity(), family=False)
    self.set_stroke(opacity=factor * self.get_stroke_opacity(), family=False)
    self.set_background_stroke(
        opacity=factor * self.get_stroke_opacity(background=True),
        family=False,
    )
    super().fade(darkness, family)
    return self

</t>
<t tx="ekr.20250122151621.169">def get_fill_rgbas(self) -&gt; RGBA_Array_Float | Zeros:
    try:
        return self.fill_rgbas
    except AttributeError:
        return np.zeros((1, 4))

</t>
<t tx="ekr.20250122151621.17">def __init__(self, edge_length: float = 1, **kwargs):
    unit_a = edge_length * ((1 + np.sqrt(5)) / 4)
    unit_b = edge_length * (1 / 2)
    super().__init__(
        vertex_coords=[
            np.array([0, unit_b, unit_a]),
            np.array([0, -unit_b, unit_a]),
            np.array([0, unit_b, -unit_a]),
            np.array([0, -unit_b, -unit_a]),
            np.array([unit_b, unit_a, 0]),
            np.array([unit_b, -unit_a, 0]),
            np.array([-unit_b, unit_a, 0]),
            np.array([-unit_b, -unit_a, 0]),
            np.array([unit_a, 0, unit_b]),
            np.array([unit_a, 0, -unit_b]),
            np.array([-unit_a, 0, unit_b]),
            np.array([-unit_a, 0, -unit_b]),
        ],
        faces_list=[
            [1, 8, 0],
            [1, 5, 7],
            [8, 5, 1],
            [7, 3, 5],
            [5, 9, 3],
            [8, 9, 5],
            [3, 2, 9],
            [9, 4, 2],
            [8, 4, 9],
            [0, 4, 8],
            [6, 4, 0],
            [6, 2, 4],
            [11, 2, 6],
            [3, 11, 2],
            [0, 6, 10],
            [10, 1, 0],
            [10, 7, 1],
            [11, 7, 3],
            [10, 11, 7],
            [10, 11, 6],
        ],
        **kwargs,
    )


</t>
<t tx="ekr.20250122151621.170">def get_fill_color(self) -&gt; ManimColor:
    """
    If there are multiple colors (for gradient)
    this returns the first one
    """
    return self.get_fill_colors()[0]

</t>
<t tx="ekr.20250122151621.171">fill_color = property(get_fill_color, set_fill)

def get_fill_opacity(self) -&gt; ManimFloat:
    """
    If there are multiple opacities, this returns the
    first
    """
    return self.get_fill_opacities()[0]

</t>
<t tx="ekr.20250122151621.172"># TODO: Does this just do a copy?
# TODO: I have the feeling that this function should not return None, does that have any usage ?
def get_fill_colors(self) -&gt; list[ManimColor | None]:
    return [
        ManimColor(rgba[:3]) if rgba.any() else None
        for rgba in self.get_fill_rgbas()
    ]

</t>
<t tx="ekr.20250122151621.173">def get_fill_opacities(self) -&gt; npt.NDArray[ManimFloat]:
    return self.get_fill_rgbas()[:, 3]

</t>
<t tx="ekr.20250122151621.174">def get_stroke_rgbas(self, background: bool = False) -&gt; RGBA_Array_float | Zeros:
    try:
        if background:
            self.background_stroke_rgbas: RGBA_Array_Float
            rgbas = self.background_stroke_rgbas
        else:
            self.stroke_rgbas: RGBA_Array_Float
            rgbas = self.stroke_rgbas
        return rgbas
    except AttributeError:
        return np.zeros((1, 4))

</t>
<t tx="ekr.20250122151621.175">def get_stroke_color(self, background: bool = False) -&gt; ManimColor | None:
    return self.get_stroke_colors(background)[0]

</t>
<t tx="ekr.20250122151621.176">stroke_color = property(get_stroke_color, set_stroke)

def get_stroke_width(self, background: bool = False) -&gt; float:
    if background:
        self.background_stroke_width: float
        width = self.background_stroke_width
    else:
        width = self.stroke_width
        if isinstance(width, str):
            width = int(width)
    return max(0.0, width)

</t>
<t tx="ekr.20250122151621.177">def get_stroke_opacity(self, background: bool = False) -&gt; ManimFloat:
    return self.get_stroke_opacities(background)[0]

</t>
<t tx="ekr.20250122151621.178">def get_stroke_colors(self, background: bool = False) -&gt; list[ManimColor | None]:
    return [
        ManimColor(rgba[:3]) if rgba.any() else None
        for rgba in self.get_stroke_rgbas(background)
    ]

</t>
<t tx="ekr.20250122151621.179">def get_stroke_opacities(self, background: bool = False) -&gt; npt.NDArray[ManimFloat]:
    return self.get_stroke_rgbas(background)[:, 3]

</t>
<t tx="ekr.20250122151621.18">def __init__(self, edge_length: float = 1, **kwargs):
    unit_a = edge_length * ((1 + np.sqrt(5)) / 4)
    unit_b = edge_length * ((3 + np.sqrt(5)) / 4)
    unit_c = edge_length * (1 / 2)
    super().__init__(
        vertex_coords=[
            np.array([unit_a, unit_a, unit_a]),
            np.array([unit_a, unit_a, -unit_a]),
            np.array([unit_a, -unit_a, unit_a]),
            np.array([unit_a, -unit_a, -unit_a]),
            np.array([-unit_a, unit_a, unit_a]),
            np.array([-unit_a, unit_a, -unit_a]),
            np.array([-unit_a, -unit_a, unit_a]),
            np.array([-unit_a, -unit_a, -unit_a]),
            np.array([0, unit_c, unit_b]),
            np.array([0, unit_c, -unit_b]),
            np.array([0, -unit_c, -unit_b]),
            np.array([0, -unit_c, unit_b]),
            np.array([unit_c, unit_b, 0]),
            np.array([-unit_c, unit_b, 0]),
            np.array([unit_c, -unit_b, 0]),
            np.array([-unit_c, -unit_b, 0]),
            np.array([unit_b, 0, unit_c]),
            np.array([-unit_b, 0, unit_c]),
            np.array([unit_b, 0, -unit_c]),
            np.array([-unit_b, 0, -unit_c]),
        ],
        faces_list=[
            [18, 16, 0, 12, 1],
            [3, 18, 16, 2, 14],
            [3, 10, 9, 1, 18],
            [1, 9, 5, 13, 12],
            [0, 8, 4, 13, 12],
            [2, 16, 0, 8, 11],
            [4, 17, 6, 11, 8],
            [17, 19, 5, 13, 4],
            [19, 7, 15, 6, 17],
            [6, 15, 14, 2, 11],
            [19, 5, 9, 10, 7],
            [7, 10, 3, 14, 15],
        ],
        **kwargs,
    )


</t>
<t tx="ekr.20250122151621.180">def get_color(self) -&gt; ManimColor:
    if np.all(self.get_fill_opacities() == 0):
        return self.get_stroke_color()
    return self.get_fill_color()

</t>
<t tx="ekr.20250122151621.181">color = property(get_color, set_color)

def set_sheen_direction(self, direction: Vector3D, family: bool = True) -&gt; Self:
    """Sets the direction of the applied sheen.

    Parameters
    ----------
    direction
        Direction from where the gradient is applied.

    Examples
    --------
    Normal usage::

        Circle().set_sheen_direction(UP)

    See Also
    --------
    :meth:`~.VMobject.set_sheen`
    :meth:`~.VMobject.rotate_sheen_direction`
    """
    direction = np.array(direction)
    if family:
        for submob in self.get_family():
            submob.sheen_direction = direction
    else:
        self.sheen_direction: Vector3D = direction
    return self

</t>
<t tx="ekr.20250122151621.182">def rotate_sheen_direction(
    self, angle: float, axis: Vector3D = OUT, family: bool = True
) -&gt; Self:
    """Rotates the direction of the applied sheen.

    Parameters
    ----------
    angle
        Angle by which the direction of sheen is rotated.
    axis
        Axis of rotation.

    Examples
    --------
    Normal usage::

        Circle().set_sheen_direction(UP).rotate_sheen_direction(PI)

    See Also
    --------
    :meth:`~.VMobject.set_sheen_direction`
    """
    if family:
        for submob in self.get_family():
            submob.sheen_direction = rotate_vector(
                submob.sheen_direction,
                angle,
                axis,
            )
    else:
        self.sheen_direction = rotate_vector(self.sheen_direction, angle, axis)
    return self

</t>
<t tx="ekr.20250122151621.183">def set_sheen(
    self, factor: float, direction: Vector3D | None = None, family: bool = True
) -&gt; Self:
    """Applies a color gradient from a direction.

    Parameters
    ----------
    factor
        The extent of lustre/gradient to apply. If negative, the gradient
        starts from black, if positive the gradient starts from white and
        changes to the current color.
    direction
        Direction from where the gradient is applied.

    Examples
    --------
    .. manim:: SetSheen
        :save_last_frame:

        class SetSheen(Scene):
            def construct(self):
                circle = Circle(fill_opacity=1).set_sheen(-0.3, DR)
                self.add(circle)
    """
    if family:
        for submob in self.submobjects:
            submob.set_sheen(factor, direction, family)
    self.sheen_factor: float = factor
    if direction is not None:
        # family set to false because recursion will
        # already be handled above
        self.set_sheen_direction(direction, family=False)
    # Reset color to put sheen_factor into effect
    if factor != 0:
        self.set_stroke(self.get_stroke_color(), family=family)
        self.set_fill(self.get_fill_color(), family=family)
    return self

</t>
<t tx="ekr.20250122151621.184">def get_sheen_direction(self) -&gt; Vector3D:
    return np.array(self.sheen_direction)

</t>
<t tx="ekr.20250122151621.185">def get_sheen_factor(self) -&gt; float:
    return self.sheen_factor

</t>
<t tx="ekr.20250122151621.186">def get_gradient_start_and_end_points(self) -&gt; tuple[Point3D, Point3D]:
    if self.shade_in_3d:
        return get_3d_vmob_gradient_start_and_end_points(self)
    else:
        direction = self.get_sheen_direction()
        c = self.get_center()
        bases = np.array(
            [self.get_edge_center(vect) - c for vect in [RIGHT, UP, OUT]],
        ).transpose()
        offset = np.dot(bases, direction)
        return (c - offset, c + offset)

</t>
<t tx="ekr.20250122151621.187">def color_using_background_image(self, background_image: Image | str) -&gt; Self:
    self.background_image: Image | str = background_image
    self.set_color(WHITE)
    for submob in self.submobjects:
        submob.color_using_background_image(background_image)
    return self

</t>
<t tx="ekr.20250122151621.188">def get_background_image(self) -&gt; Image | str:
    return self.background_image

</t>
<t tx="ekr.20250122151621.189">def match_background_image(self, vmobject: VMobject) -&gt; Self:
    self.color_using_background_image(vmobject.get_background_image())
    return self

</t>
<t tx="ekr.20250122151621.19">def __init__(self, *points: Point3D, tolerance: float = 1e-5, **kwargs):
    # Build Convex Hull
    array = np.array(points)
    hull = QuickHull(tolerance)
    hull.build(array)

    # Setup Lists
    vertices = []
    faces = []

    # Extract Faces
    c = 0
    d = {}
    facets = set(hull.facets) - hull.removed
    for facet in facets:
        tmp = set()
        for subfacet in facet.subfacets:
            for point in subfacet.points:
                if point not in d:
                    vertices.append(point.coordinates)
                    d[point] = c
                    c += 1
                tmp.add(point)
        faces.append([d[point] for point in tmp])

    # Call Polyhedron
    super().__init__(
        vertex_coords=vertices,
        faces_list=faces,
        **kwargs,
    )
</t>
<t tx="ekr.20250122151621.190">def set_shade_in_3d(
    self, value: bool = True, z_index_as_group: bool = False
) -&gt; Self:
    for submob in self.get_family():
        submob.shade_in_3d = value
        if z_index_as_group:
            submob.z_index_group = self
    return self

</t>
<t tx="ekr.20250122151621.191">def set_points(self, points: Point3DLike_Array) -&gt; Self:
    self.points: Point3D_Array = np.array(points)
    return self

</t>
<t tx="ekr.20250122151621.192">def resize_points(
    self,
    new_length: int,
    resize_func: Callable[[Point3D_Array, int], Point3D_Array] = resize_array,
) -&gt; Self:
    """Resize the array of anchor points and handles to have
    the specified size.

    Parameters
    ----------
    new_length
        The new (total) number of points.
    resize_func
        A function mapping a Numpy array (the points) and an integer
        (the target size) to a Numpy array. The default implementation
        is based on Numpy's ``resize`` function.
    """
    if new_length != len(self.points):
        self.points = resize_func(self.points, new_length)
    return self

</t>
<t tx="ekr.20250122151621.193">def set_anchors_and_handles(
    self,
    anchors1: Point3DLike_Array,
    handles1: Point3DLike_Array,
    handles2: Point3DLike_Array,
    anchors2: Point3DLike_Array,
) -&gt; Self:
    """Given two sets of anchors and handles, process them to set them as anchors
    and handles of the VMobject.

    anchors1[i], handles1[i], handles2[i] and anchors2[i] define the i-th bezier
    curve of the vmobject. There are four hardcoded parameters and this is a
    problem as it makes the number of points per cubic curve unchangeable from 4
    (two anchors and two handles).

    Returns
    -------
    :class:`VMobject`
        ``self``
    """
    assert len(anchors1) == len(handles1) == len(handles2) == len(anchors2)
    nppcc = self.n_points_per_cubic_curve  # 4
    total_len = nppcc * len(anchors1)
    self.points = np.empty((total_len, self.dim))
    # the following will, from the four sets, dispatch them in points such that
    # self.points = [
    #     anchors1[0], handles1[0], handles2[0], anchors1[0], anchors1[1],
    #     handles1[1], ...
    # ]
    arrays = [anchors1, handles1, handles2, anchors2]
    for index, array in enumerate(arrays):
        self.points[index::nppcc] = array
    return self

</t>
<t tx="ekr.20250122151621.194">def clear_points(self) -&gt; None:
    # TODO: shouldn't this return self instead of None?
    self.points = np.zeros((0, self.dim))

</t>
<t tx="ekr.20250122151621.195">def append_points(self, new_points: Point3DLike_Array) -&gt; Self:
    """Append the given ``new_points`` to the end of
    :attr:`VMobject.points`.

    Parameters
    ----------
    new_points
        An array of 3D points to append.

    Returns
    -------
    :class:`VMobject`
        The VMobject itself, after appending ``new_points``.
    """
    # TODO, check that number new points is a multiple of 4?
    # or else that if len(self.points) % 4 == 1, then
    # len(new_points) % 4 == 3?
    n = len(self.points)
    points = np.empty((n + len(new_points), self.dim))
    points[:n] = self.points
    points[n:] = new_points
    self.points = points
    return self

</t>
<t tx="ekr.20250122151621.196">def start_new_path(self, point: Point3DLike) -&gt; Self:
    """Append a ``point`` to the :attr:`VMobject.points`, which will be the
    beginning of a new Bézier curve in the path given by the points. If
    there's an unfinished curve at the end of :attr:`VMobject.points`,
    complete it by appending the last Bézier curve's start anchor as many
    times as needed.

    Parameters
    ----------
    point
        A 3D point to append to :attr:`VMobject.points`.

    Returns
    -------
    :class:`VMobject`
        The VMobject itself, after appending ``point`` and starting a new
        curve.
    """
    n_points = len(self.points)
    nppc = self.n_points_per_curve
    if n_points % nppc != 0:
        # close the open path by appending the last
        # start anchor sufficiently often
        last_anchor = self.get_start_anchors()[-1]
        closure = [last_anchor] * (nppc - (n_points % nppc))
        self.append_points(closure + [point])
    else:
        self.append_points([point])
    return self

</t>
<t tx="ekr.20250122151621.197">def add_cubic_bezier_curve(
    self,
    anchor1: Point3DLike,
    handle1: Point3DLike,
    handle2: Point3DLike,
    anchor2: Point3DLike,
) -&gt; None:
    # TODO, check the len(self.points) % 4 == 0?
    self.append_points([anchor1, handle1, handle2, anchor2])

</t>
<t tx="ekr.20250122151621.198"># what type is curves?
def add_cubic_bezier_curves(self, curves) -&gt; None:
    self.append_points(curves.flatten())

</t>
<t tx="ekr.20250122151621.199">def add_cubic_bezier_curve_to(
    self,
    handle1: Point3DLike,
    handle2: Point3DLike,
    anchor: Point3DLike,
) -&gt; Self:
    """Add cubic bezier curve to the path.

    NOTE : the first anchor is not a parameter as by default the end of the last sub-path!

    Parameters
    ----------
    handle1
        first handle
    handle2
        second handle
    anchor
        anchor

    Returns
    -------
    :class:`VMobject`
        ``self``
    """
    self.throw_error_if_no_points()
    new_points = [handle1, handle2, anchor]
    if self.has_new_path_started():
        self.append_points(new_points)
    else:
        self.append_points([self.get_last_point()] + new_points)
    return self

</t>
<t tx="ekr.20250122151621.2">"""Three-dimensional mobjects.

Modules
=======

.. autosummary::
    :toctree: ../reference

    ~polyhedra
    ~three_d_utils
    ~three_dimensions
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.20">"""Utility functions for three-dimensional mobjects."""

from __future__ import annotations

__all__ = [
    "get_3d_vmob_gradient_start_and_end_points",
    "get_3d_vmob_start_corner_index",
    "get_3d_vmob_end_corner_index",
    "get_3d_vmob_start_corner",
    "get_3d_vmob_end_corner",
    "get_3d_vmob_unit_normal",
    "get_3d_vmob_start_corner_unit_normal",
    "get_3d_vmob_end_corner_unit_normal",
]


from typing import TYPE_CHECKING, Literal

import numpy as np

from manim.constants import ORIGIN, UP
from manim.utils.space_ops import get_unit_normal

if TYPE_CHECKING:
    from manim.typing import Point3D, Vector3D


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.200">def add_quadratic_bezier_curve_to(
    self,
    handle: Point3DLike,
    anchor: Point3DLike,
) -&gt; Self:
    """Add Quadratic bezier curve to the path.

    Returns
    -------
    :class:`VMobject`
        ``self``
    """
    # How does one approximate a quadratic with a cubic?
    # refer to the Wikipedia page on Bezier curves
    # https://en.wikipedia.org/wiki/B%C3%A9zier_curve#Degree_elevation, accessed Jan 20, 2021
    # 1. Copy the end points, and then
    # 2. Place the 2 middle control points 2/3 along the line segments
    # from the end points to the quadratic curve's middle control point.
    # I think that's beautiful.
    self.add_cubic_bezier_curve_to(
        2 / 3 * handle + 1 / 3 * self.get_last_point(),
        2 / 3 * handle + 1 / 3 * anchor,
        anchor,
    )
    return self

</t>
<t tx="ekr.20250122151621.201">def add_line_to(self, point: Point3DLike) -&gt; Self:
    """Add a straight line from the last point of VMobject to the given point.

    Parameters
    ----------

    point
        The end of the straight line.

    Returns
    -------
    :class:`VMobject`
        ``self``
    """
    self.add_cubic_bezier_curve_to(
        *(
            interpolate(self.get_last_point(), point, t)
            for t in self._bezier_t_values[1:]
        )
    )
    return self

</t>
<t tx="ekr.20250122151621.202">def add_smooth_curve_to(self, *points: Point3DLike) -&gt; Self:
    """Creates a smooth curve from given points and add it to the VMobject. If two points are passed in, the first is interpreted
    as a handle, the second as an anchor.

    Parameters
    ----------
    points
        Points (anchor and handle, or just anchor) to add a smooth curve from

    Returns
    -------
    :class:`VMobject`
        ``self``

    Raises
    ------
    ValueError
        If 0 or more than 2 points are given.
    """
    # TODO remove the value error and just add two parameters with one optional
    if len(points) == 1:
        handle2 = None
        new_anchor = points[0]
    elif len(points) == 2:
        handle2, new_anchor = points
    else:
        name = sys._getframe(0).f_code.co_name
        raise ValueError(f"Only call {name} with 1 or 2 points")

    if self.has_new_path_started():
        self.add_line_to(new_anchor)
    else:
        self.throw_error_if_no_points()
        last_h2, last_a2 = self.points[-2:]
        last_tangent = last_a2 - last_h2
        handle1 = last_a2 + last_tangent
        if handle2 is None:
            to_anchor_vect = new_anchor - last_a2
            new_tangent = rotate_vector(last_tangent, PI, axis=to_anchor_vect)
            handle2 = new_anchor - new_tangent
        self.append_points([last_a2, handle1, handle2, new_anchor])
    return self

</t>
<t tx="ekr.20250122151621.203">def has_new_path_started(self) -&gt; bool:
    nppcc = self.n_points_per_cubic_curve  # 4
    # A new path starting is defined by a control point which is not part of a bezier subcurve.
    return len(self.points) % nppcc == 1

</t>
<t tx="ekr.20250122151621.204">def get_last_point(self) -&gt; Point3D:
    return self.points[-1]

</t>
<t tx="ekr.20250122151621.205">def is_closed(self) -&gt; bool:
    # TODO use consider_points_equals_2d ?
    return self.consider_points_equals(self.points[0], self.points[-1])

</t>
<t tx="ekr.20250122151621.206">def close_path(self) -&gt; None:
    if not self.is_closed():
        self.add_line_to(self.get_subpaths()[-1][0])

</t>
<t tx="ekr.20250122151621.207">def add_points_as_corners(self, points: Point3DLike_Array) -&gt; Self:
    """Append multiple straight lines at the end of
    :attr:`VMobject.points`, which connect the given ``points`` in order
    starting from the end of the current path. These ``points`` would be
    therefore the corners of the new polyline appended to the path.

    Parameters
    ----------
    points
        An array of 3D points representing the corners of the polyline to
        append to :attr:`VMobject.points`.

    Returns
    -------
    :class:`VMobject`
        The VMobject itself, after appending the straight lines to its
        path.
    """
    points = np.asarray(points).reshape(-1, self.dim)
    num_points = points.shape[0]
    if num_points == 0:
        return self

    if self.has_new_path_started():
        # Pop the last point from self.points and
        # add it to start_corners
        start_corners = np.empty((num_points, self.dim))
        start_corners[0] = self.points[-1]
        start_corners[1:] = points[:-1]
        end_corners = points
        self.points = self.points[:-1]
    else:
        start_corners = points[:-1]
        end_corners = points[1:]

    nppcc = self.n_points_per_cubic_curve
    new_points = np.empty((nppcc * start_corners.shape[0], self.dim))
    new_points[::nppcc] = start_corners
    new_points[nppcc - 1 :: nppcc] = end_corners
    for i, t in enumerate(self._bezier_t_values):
        new_points[i::nppcc] = interpolate(start_corners, end_corners, t)

    self.append_points(new_points)
    return self

</t>
<t tx="ekr.20250122151621.208">def set_points_as_corners(self, points: Point3DLike_Array) -&gt; Self:
    """Given an array of points, set them as corners of the
    :class:`VMobject`.

    To achieve that, this algorithm sets handles aligned with the anchors
    such that the resultant Bézier curve will be the segment between the
    two anchors.

    Parameters
    ----------
    points
        Array of points that will be set as corners.

    Returns
    -------
    :class:`VMobject`
        The VMobject itself, after setting the new points as corners.


    Examples
    --------
    .. manim:: PointsAsCornersExample
        :save_last_frame:

        class PointsAsCornersExample(Scene):
            def construct(self):
                corners = (
                    # create square
                    UR, UL,
                    DL, DR,
                    UR,
                    # create crosses
                    DL, UL,
                    DR
                )
                vmob = VMobject(stroke_color=RED)
                vmob.set_points_as_corners(corners).scale(2)
                self.add(vmob)
    """
    points = np.array(points)
    # This will set the handles aligned with the anchors.
    # Id est, a bezier curve will be the segment from the two anchors such that the handles belongs to this segment.
    self.set_anchors_and_handles(
        *(interpolate(points[:-1], points[1:], t) for t in self._bezier_t_values)
    )
    return self

</t>
<t tx="ekr.20250122151621.209">def set_points_smoothly(self, points: Point3DLike_Array) -&gt; Self:
    self.set_points_as_corners(points)
    self.make_smooth()
    return self

</t>
<t tx="ekr.20250122151621.21">def get_3d_vmob_gradient_start_and_end_points(vmob) -&gt; tuple[Point3D, Point3D]:
    return (
        get_3d_vmob_start_corner(vmob),
        get_3d_vmob_end_corner(vmob),
    )


</t>
<t tx="ekr.20250122151621.210">def change_anchor_mode(self, mode: Literal["jagged", "smooth"]) -&gt; Self:
    """Changes the anchor mode of the bezier curves. This will modify the handles.

    There can be only two modes, "jagged", and "smooth".

    Returns
    -------
    :class:`VMobject`
        ``self``
    """
    assert mode in ["jagged", "smooth"], 'mode must be either "jagged" or "smooth"'
    nppcc = self.n_points_per_cubic_curve
    for submob in self.family_members_with_points():
        subpaths = submob.get_subpaths()
        submob.clear_points()
        # A subpath can be composed of several bezier curves.
        for subpath in subpaths:
            # This will retrieve the anchors of the subpath, by selecting every n element in the array subpath
            # The append is needed as the last element is not reached when slicing with numpy.
            anchors = np.append(subpath[::nppcc], subpath[-1:], 0)
            if mode == "smooth":
                h1, h2 = get_smooth_cubic_bezier_handle_points(anchors)
            else:  # mode == "jagged"
                # The following will make the handles aligned with the anchors, thus making the bezier curve a segment
                a1 = anchors[:-1]
                a2 = anchors[1:]
                h1 = interpolate(a1, a2, 1.0 / 3)
                h2 = interpolate(a1, a2, 2.0 / 3)
            new_subpath = np.array(subpath)
            new_subpath[1::nppcc] = h1
            new_subpath[2::nppcc] = h2
            submob.append_points(new_subpath)
    return self

</t>
<t tx="ekr.20250122151621.211">def make_smooth(self) -&gt; Self:
    return self.change_anchor_mode("smooth")

</t>
<t tx="ekr.20250122151621.212">def make_jagged(self) -&gt; Self:
    return self.change_anchor_mode("jagged")

</t>
<t tx="ekr.20250122151621.213">def add_subpath(self, points: CubicBezierPathLike) -&gt; Self:
    assert len(points) % 4 == 0
    self.append_points(points)
    return self

</t>
<t tx="ekr.20250122151621.214">def append_vectorized_mobject(self, vectorized_mobject: VMobject) -&gt; None:
    if self.has_new_path_started():
        # Remove last point, which is starting
        # a new path
        self.points = self.points[:-1]
    self.append_points(vectorized_mobject.points)

</t>
<t tx="ekr.20250122151621.215">def apply_function(self, function: MappingFunction) -&gt; Self:
    factor = self.pre_function_handle_to_anchor_scale_factor
    self.scale_handle_to_anchor_distances(factor)
    super().apply_function(function)
    self.scale_handle_to_anchor_distances(1.0 / factor)
    if self.make_smooth_after_applying_functions:
        self.make_smooth()
    return self

</t>
<t tx="ekr.20250122151621.216">def rotate(
    self,
    angle: float,
    axis: Vector3D = OUT,
    about_point: Point3DLike | None = None,
    **kwargs,
) -&gt; Self:
    self.rotate_sheen_direction(angle, axis)
    super().rotate(angle, axis, about_point, **kwargs)
    return self

</t>
<t tx="ekr.20250122151621.217">def scale_handle_to_anchor_distances(self, factor: float) -&gt; Self:
    """If the distance between a given handle point H and its associated
    anchor point A is d, then it changes H to be a distances factor*d
    away from A, but so that the line from A to H doesn't change.
    This is mostly useful in the context of applying a (differentiable)
    function, to preserve tangency properties.  One would pull all the
    handles closer to their anchors, apply the function then push them out
    again.

    Parameters
    ----------
    factor
        The factor used for scaling.

    Returns
    -------
    :class:`VMobject`
        ``self``
    """
    for submob in self.family_members_with_points():
        if len(submob.points) &lt; self.n_points_per_cubic_curve:
            # The case that a bezier quad is not complete (there is no bezier curve as there is not enough control points.)
            continue
        a1, h1, h2, a2 = submob.get_anchors_and_handles()
        a1_to_h1 = h1 - a1
        a2_to_h2 = h2 - a2
        new_h1 = a1 + factor * a1_to_h1
        new_h2 = a2 + factor * a2_to_h2
        submob.set_anchors_and_handles(a1, new_h1, new_h2, a2)
    return self

</t>
<t tx="ekr.20250122151621.218">#
def consider_points_equals(self, p0: Point3DLike, p1: Point3DLike) -&gt; bool:
    return np.allclose(p0, p1, atol=self.tolerance_for_point_equality)

</t>
<t tx="ekr.20250122151621.219">def consider_points_equals_2d(self, p0: Point2DLike, p1: Point2DLike) -&gt; bool:
    """Determine if two points are close enough to be considered equal.

    This uses the algorithm from np.isclose(), but expanded here for the
    2D point case. NumPy is overkill for such a small question.
    Parameters
    ----------
    p0
        first point
    p1
        second point

    Returns
    -------
    bool
        whether two points considered close.
    """
    rtol = 1.0e-5  # default from np.isclose()
    atol = self.tolerance_for_point_equality
    if abs(p0[0] - p1[0]) &gt; atol + rtol * abs(p1[0]):
        return False
    return abs(p0[1] - p1[1]) &lt;= atol + rtol * abs(p1[1])

</t>
<t tx="ekr.20250122151621.22">def get_3d_vmob_start_corner_index(vmob) -&gt; Literal[0]:
    return 0


</t>
<t tx="ekr.20250122151621.220"># Information about line
def get_cubic_bezier_tuples_from_points(
    self, points: CubicBezierPathLike
) -&gt; CubicBezierPoints_Array:
    return np.array(self.gen_cubic_bezier_tuples_from_points(points))

</t>
<t tx="ekr.20250122151621.221">def gen_cubic_bezier_tuples_from_points(
    self, points: CubicBezierPathLike
) -&gt; tuple[CubicBezierPointsLike, ...]:
    """Returns the bezier tuples from an array of points.

    self.points is a list of the anchors and handles of the bezier curves of the mobject (ie [anchor1, handle1, handle2, anchor2, anchor3 ..])
    This algorithm basically retrieve them by taking an element every n, where n is the number of control points
    of the bezier curve.


    Parameters
    ----------
    points
        Points from which control points will be extracted.

    Returns
    -------
    tuple
        Bezier control points.
    """
    nppcc = self.n_points_per_cubic_curve
    remainder = len(points) % nppcc
    points = points[: len(points) - remainder]
    # Basically take every nppcc element.
    return tuple(points[i : i + nppcc] for i in range(0, len(points), nppcc))

</t>
<t tx="ekr.20250122151621.222">def get_cubic_bezier_tuples(self) -&gt; CubicBezierPoints_Array:
    return self.get_cubic_bezier_tuples_from_points(self.points)

</t>
<t tx="ekr.20250122151621.223">def _gen_subpaths_from_points(
    self,
    points: CubicBezierPath,
    filter_func: Callable[[int], bool],
) -&gt; Iterable[CubicSpline]:
    """Given an array of points defining the bezier curves of the vmobject, return subpaths formed by these points.
    Here, Two bezier curves form a path if at least two of their anchors are evaluated True by the relation defined by filter_func.

    The algorithm every bezier tuple (anchors and handles) in ``self.points`` (by regrouping each n elements, where
    n is the number of points per cubic curve)), and evaluate the relation between two anchors with filter_func.
    NOTE : The filter_func takes an int n as parameter, and will evaluate the relation between points[n] and points[n - 1]. This should probably be changed so
    the function takes two points as parameters.

    Parameters
    ----------
    points
        points defining the bezier curve.
    filter_func
        Filter-func defining the relation.

    Returns
    -------
    Iterable[CubicSpline]
        subpaths formed by the points.
    """
    nppcc = self.n_points_per_cubic_curve
    filtered = filter(filter_func, range(nppcc, len(points), nppcc))
    split_indices = [0] + list(filtered) + [len(points)]
    return (
        points[i1:i2]
        for i1, i2 in zip(split_indices, split_indices[1:])
        if (i2 - i1) &gt;= nppcc
    )

</t>
<t tx="ekr.20250122151621.224">def get_subpaths_from_points(self, points: CubicBezierPath) -&gt; list[CubicSpline]:
    return list(
        self._gen_subpaths_from_points(
            points,
            lambda n: not self.consider_points_equals(points[n - 1], points[n]),
        ),
    )

</t>
<t tx="ekr.20250122151621.225">def gen_subpaths_from_points_2d(
    self, points: CubicBezierPath
) -&gt; Iterable[CubicSpline]:
    return self._gen_subpaths_from_points(
        points,
        lambda n: not self.consider_points_equals_2d(points[n - 1], points[n]),
    )

</t>
<t tx="ekr.20250122151621.226">def get_subpaths(self) -&gt; list[CubicSpline]:
    """Returns subpaths formed by the curves of the VMobject.

    Subpaths are ranges of curves with each pair of consecutive curves having their end/start points coincident.

    Returns
    -------
    list[CubicSpline]
        subpaths.
    """
    return self.get_subpaths_from_points(self.points)

</t>
<t tx="ekr.20250122151621.227">def get_nth_curve_points(self, n: int) -&gt; CubicBezierPoints:
    """Returns the points defining the nth curve of the vmobject.

    Parameters
    ----------
    n
        index of the desired bezier curve.

    Returns
    -------
    CubicBezierPoints
        points defining the nth bezier curve (anchors, handles)
    """
    assert n &lt; self.get_num_curves()
    nppcc = self.n_points_per_cubic_curve
    return self.points[nppcc * n : nppcc * (n + 1)]

</t>
<t tx="ekr.20250122151621.228">def get_nth_curve_function(self, n: int) -&gt; Callable[[float], Point3D]:
    """Returns the expression of the nth curve.

    Parameters
    ----------
    n
        index of the desired curve.

    Returns
    -------
    Callable[float, Point3D]
        expression of the nth bezier curve.
    """
    return bezier(self.get_nth_curve_points(n))

</t>
<t tx="ekr.20250122151621.229">def get_nth_curve_length_pieces(
    self,
    n: int,
    sample_points: int | None = None,
) -&gt; npt.NDArray[ManimFloat]:
    """Returns the array of short line lengths used for length approximation.

    Parameters
    ----------
    n
        The index of the desired curve.
    sample_points
        The number of points to sample to find the length.

    Returns
    -------
        The short length-pieces of the nth curve.
    """
    if sample_points is None:
        sample_points = 10

    curve = self.get_nth_curve_function(n)
    points = np.array([curve(a) for a in np.linspace(0, 1, sample_points)])
    diffs = points[1:] - points[:-1]
    norms = np.linalg.norm(diffs, axis=1)

    return norms

</t>
<t tx="ekr.20250122151621.23">def get_3d_vmob_end_corner_index(vmob) -&gt; int:
    return ((len(vmob.points) - 1) // 6) * 3


</t>
<t tx="ekr.20250122151621.230">def get_nth_curve_length(
    self,
    n: int,
    sample_points: int | None = None,
) -&gt; float:
    """Returns the (approximate) length of the nth curve.

    Parameters
    ----------
    n
        The index of the desired curve.
    sample_points
        The number of points to sample to find the length.

    Returns
    -------
    length : :class:`float`
        The length of the nth curve.
    """
    _, length = self.get_nth_curve_function_with_length(n, sample_points)

    return length

</t>
<t tx="ekr.20250122151621.231">def get_nth_curve_function_with_length(
    self,
    n: int,
    sample_points: int | None = None,
) -&gt; tuple[Callable[[float], Point3D], float]:
    """Returns the expression of the nth curve along with its (approximate) length.

    Parameters
    ----------
    n
        The index of the desired curve.
    sample_points
        The number of points to sample to find the length.

    Returns
    -------
    curve : Callable[[float], Point3D]
        The function for the nth curve.
    length : :class:`float`
        The length of the nth curve.
    """
    curve = self.get_nth_curve_function(n)
    norms = self.get_nth_curve_length_pieces(n, sample_points=sample_points)
    length = np.sum(norms)

    return curve, length

</t>
<t tx="ekr.20250122151621.232">def get_num_curves(self) -&gt; int:
    """Returns the number of curves of the vmobject.

    Returns
    -------
    int
        number of curves of the vmobject.
    """
    nppcc = self.n_points_per_cubic_curve
    return len(self.points) // nppcc

</t>
<t tx="ekr.20250122151621.233">def get_curve_functions(
    self,
) -&gt; Iterable[Callable[[float], Point3D]]:
    """Gets the functions for the curves of the mobject.

    Returns
    -------
    Iterable[Callable[[float], Point3D]]
        The functions for the curves.
    """
    num_curves = self.get_num_curves()

    for n in range(num_curves):
        yield self.get_nth_curve_function(n)

</t>
<t tx="ekr.20250122151621.234">def get_curve_functions_with_lengths(
    self, **kwargs
) -&gt; Iterable[tuple[Callable[[float], Point3D], float]]:
    """Gets the functions and lengths of the curves for the mobject.

    Parameters
    ----------
    **kwargs
        The keyword arguments passed to :meth:`get_nth_curve_function_with_length`

    Returns
    -------
    Iterable[tuple[Callable[[float], Point3D], float]]
        The functions and lengths of the curves.
    """
    num_curves = self.get_num_curves()

    for n in range(num_curves):
        yield self.get_nth_curve_function_with_length(n, **kwargs)

</t>
<t tx="ekr.20250122151621.235">def point_from_proportion(self, alpha: float) -&gt; Point3D:
    """Gets the point at a proportion along the path of the :class:`VMobject`.

    Parameters
    ----------
    alpha
        The proportion along the the path of the :class:`VMobject`.

    Returns
    -------
    :class:`numpy.ndarray`
        The point on the :class:`VMobject`.

    Raises
    ------
    :exc:`ValueError`
        If ``alpha`` is not between 0 and 1.
    :exc:`Exception`
        If the :class:`VMobject` has no points.

    Example
    -------
    .. manim:: PointFromProportion
        :save_last_frame:

        class PointFromProportion(Scene):
            def construct(self):
                line = Line(2*DL, 2*UR)
                self.add(line)
                colors = (RED, BLUE, YELLOW)
                proportions = (1/4, 1/2, 3/4)
                for color, proportion in zip(colors, proportions):
                    self.add(Dot(color=color).move_to(
                            line.point_from_proportion(proportion)
                    ))
    """
    if alpha &lt; 0 or alpha &gt; 1:
        raise ValueError(f"Alpha {alpha} not between 0 and 1.")

    self.throw_error_if_no_points()
    if alpha == 1:
        return self.points[-1]

    curves_and_lengths = tuple(self.get_curve_functions_with_lengths())

    target_length = alpha * sum(length for _, length in curves_and_lengths)
    current_length = 0

    for curve, length in curves_and_lengths:
        if current_length + length &gt;= target_length:
            if length != 0:
                residue = (target_length - current_length) / length
            else:
                residue = 0

            return curve(residue)

        current_length += length
    raise Exception(
        "Not sure how you reached here, please file a bug report at https://github.com/ManimCommunity/manim/issues/new/choose"
    )

</t>
<t tx="ekr.20250122151621.236">def proportion_from_point(
    self,
    point: Point3DLike,
) -&gt; float:
    """Returns the proportion along the path of the :class:`VMobject`
    a particular given point is at.

    Parameters
    ----------
    point
        The Cartesian coordinates of the point which may or may not lie on the :class:`VMobject`

    Returns
    -------
    float
        The proportion along the path of the :class:`VMobject`.

    Raises
    ------
    :exc:`ValueError`
        If ``point`` does not lie on the curve.
    :exc:`Exception`
        If the :class:`VMobject` has no points.
    """
    self.throw_error_if_no_points()

    # Iterate over each bezier curve that the ``VMobject`` is composed of, checking
    # if the point lies on that curve. If it does not lie on that curve, add
    # the whole length of the curve to ``target_length`` and move onto the next
    # curve. If the point does lie on the curve, add how far along the curve
    # the point is to ``target_length``.
    # Then, divide ``target_length`` by the total arc length of the shape to get
    # the proportion along the ``VMobject`` the point is at.

    num_curves = self.get_num_curves()
    total_length = self.get_arc_length()
    target_length = 0
    for n in range(num_curves):
        control_points = self.get_nth_curve_points(n)
        length = self.get_nth_curve_length(n)
        proportions_along_bezier = proportions_along_bezier_curve_for_point(
            point,
            control_points,
        )
        if len(proportions_along_bezier) &gt; 0:
            proportion_along_nth_curve = max(proportions_along_bezier)
            target_length += length * proportion_along_nth_curve
            break
        target_length += length
    else:
        raise ValueError(f"Point {point} does not lie on this curve.")

    alpha = target_length / total_length

    return alpha

</t>
<t tx="ekr.20250122151621.237">def get_anchors_and_handles(self) -&gt; list[Point3D_Array]:
    """Returns anchors1, handles1, handles2, anchors2,
    where (anchors1[i], handles1[i], handles2[i], anchors2[i])
    will be four points defining a cubic bezier curve
    for any i in range(0, len(anchors1))

    Returns
    -------
    `list[Point3D_Array]`
        Iterable of the anchors and handles.
    """
    nppcc = self.n_points_per_cubic_curve
    return [self.points[i::nppcc] for i in range(nppcc)]

</t>
<t tx="ekr.20250122151621.238">def get_start_anchors(self) -&gt; Point3D_Array:
    """Returns the start anchors of the bezier curves.

    Returns
    -------
    Point3D_Array
        Starting anchors
    """
    return self.points[:: self.n_points_per_cubic_curve]

</t>
<t tx="ekr.20250122151621.239">def get_end_anchors(self) -&gt; Point3D_Array:
    """Return the end anchors of the bezier curves.

    Returns
    -------
    Point3D_Array
        Starting anchors
    """
    nppcc = self.n_points_per_cubic_curve
    return self.points[nppcc - 1 :: nppcc]

</t>
<t tx="ekr.20250122151621.24">def get_3d_vmob_start_corner(vmob) -&gt; Point3D:
    if vmob.get_num_points() == 0:
        return np.array(ORIGIN)
    return vmob.points[get_3d_vmob_start_corner_index(vmob)]


</t>
<t tx="ekr.20250122151621.240">def get_anchors(self) -&gt; list[Point3D]:
    """Returns the anchors of the curves forming the VMobject.

    Returns
    -------
    Point3D_Array
        The anchors.
    """
    if self.points.shape[0] == 1:
        return self.points

    s = self.get_start_anchors()
    e = self.get_end_anchors()
    return list(it.chain.from_iterable(zip(s, e)))

</t>
<t tx="ekr.20250122151621.241">def get_points_defining_boundary(self) -&gt; Point3D_Array:
    # Probably returns all anchors, but this is weird regarding  the name of the method.
    return np.array(
        tuple(it.chain(*(sm.get_anchors() for sm in self.get_family())))
    )

</t>
<t tx="ekr.20250122151621.242">def get_arc_length(self, sample_points_per_curve: int | None = None) -&gt; float:
    """Return the approximated length of the whole curve.

    Parameters
    ----------
    sample_points_per_curve
        Number of sample points per curve used to approximate the length. More points result in a better approximation.

    Returns
    -------
    float
        The length of the :class:`VMobject`.
    """
    return sum(
        length
        for _, length in self.get_curve_functions_with_lengths(
            sample_points=sample_points_per_curve,
        )
    )

</t>
<t tx="ekr.20250122151621.243"># Alignment
def align_points(self, vmobject: VMobject) -&gt; Self:
    """Adds points to self and vmobject so that they both have the same number of subpaths, with
    corresponding subpaths each containing the same number of points.

    Points are added either by subdividing curves evenly along the subpath, or by creating new subpaths consisting
    of a single point repeated.

    Parameters
    ----------
    vmobject
        The object to align points with.

    Returns
    -------
    :class:`VMobject`
       ``self``
    """
    self.align_rgbas(vmobject)
    # TODO: This shortcut can be a bit over eager. What if they have the same length, but different subpath lengths?
    if self.get_num_points() == vmobject.get_num_points():
        return

    for mob in self, vmobject:
        # If there are no points, add one to
        # wherever the "center" is
        if mob.has_no_points():
            mob.start_new_path(mob.get_center())
        # If there's only one point, turn it into
        # a null curve
        if mob.has_new_path_started():
            mob.add_line_to(mob.get_last_point())

    # Figure out what the subpaths are
    subpaths1 = self.get_subpaths()
    subpaths2 = vmobject.get_subpaths()
    n_subpaths = max(len(subpaths1), len(subpaths2))
    # Start building new ones
    new_path1 = np.zeros((0, self.dim))
    new_path2 = np.zeros((0, self.dim))

    nppcc = self.n_points_per_cubic_curve

    def get_nth_subpath(path_list, n):
        if n &gt;= len(path_list):
            # Create a null path at the very end
            return [path_list[-1][-1]] * nppcc
        path = path_list[n]
        # Check for useless points at the end of the path and remove them
        # https://github.com/ManimCommunity/manim/issues/1959
        while len(path) &gt; nppcc:
            # If the last nppc points are all equal to the preceding point
            if self.consider_points_equals(path[-nppcc:], path[-nppcc - 1]):
                path = path[:-nppcc]
            else:
                break
        return path

    for n in range(n_subpaths):
        # For each pair of subpaths, add points until they are the same length
        sp1 = get_nth_subpath(subpaths1, n)
        sp2 = get_nth_subpath(subpaths2, n)
        diff1 = max(0, (len(sp2) - len(sp1)) // nppcc)
        diff2 = max(0, (len(sp1) - len(sp2)) // nppcc)
        sp1 = self.insert_n_curves_to_point_list(diff1, sp1)
        sp2 = self.insert_n_curves_to_point_list(diff2, sp2)
        new_path1 = np.append(new_path1, sp1, axis=0)
        new_path2 = np.append(new_path2, sp2, axis=0)
    self.set_points(new_path1)
    vmobject.set_points(new_path2)
    return self

</t>
<t tx="ekr.20250122151621.244">def insert_n_curves(self, n: int) -&gt; Self:
    """Inserts n curves to the bezier curves of the vmobject.

    Parameters
    ----------
    n
        Number of curves to insert.

    Returns
    -------
    :class:`VMobject`
        ``self``
    """
    new_path_point = None
    if self.has_new_path_started():
        new_path_point = self.get_last_point()

    new_points = self.insert_n_curves_to_point_list(n, self.points)
    self.set_points(new_points)

    if new_path_point is not None:
        self.append_points([new_path_point])
    return self

</t>
<t tx="ekr.20250122151621.245">def insert_n_curves_to_point_list(
    self, n: int, points: BezierPathLike
) -&gt; BezierPath:
    """Given an array of k points defining a bezier curves (anchors and handles), returns points defining exactly k + n bezier curves.

    Parameters
    ----------
    n
        Number of desired curves.
    points
        Starting points.

    Returns
    -------
        Points generated.
    """
    if len(points) == 1:
        nppcc = self.n_points_per_cubic_curve
        return np.repeat(points, nppcc * n, 0)
    bezier_tuples = self.get_cubic_bezier_tuples_from_points(points)
    current_number_of_curves = len(bezier_tuples)
    new_number_of_curves = current_number_of_curves + n
    new_bezier_tuples = bezier_remap(bezier_tuples, new_number_of_curves)
    new_points = new_bezier_tuples.reshape(-1, 3)
    return new_points

</t>
<t tx="ekr.20250122151621.246">def align_rgbas(self, vmobject: VMobject) -&gt; Self:
    attrs = ["fill_rgbas", "stroke_rgbas", "background_stroke_rgbas"]
    for attr in attrs:
        a1 = getattr(self, attr)
        a2 = getattr(vmobject, attr)
        if len(a1) &gt; len(a2):
            new_a2 = stretch_array_to_length(a2, len(a1))
            setattr(vmobject, attr, new_a2)
        elif len(a2) &gt; len(a1):
            new_a1 = stretch_array_to_length(a1, len(a2))
            setattr(self, attr, new_a1)
    return self

</t>
<t tx="ekr.20250122151621.247">def get_point_mobject(self, center: Point3DLike | None = None) -&gt; VectorizedPoint:
    if center is None:
        center = self.get_center()
    point = VectorizedPoint(center)
    point.match_style(self)
    return point

</t>
<t tx="ekr.20250122151621.248">def interpolate_color(
    self, mobject1: VMobject, mobject2: VMobject, alpha: float
) -&gt; None:
    attrs = [
        "fill_rgbas",
        "stroke_rgbas",
        "background_stroke_rgbas",
        "stroke_width",
        "background_stroke_width",
        "sheen_direction",
        "sheen_factor",
    ]
    for attr in attrs:
        setattr(
            self,
            attr,
            interpolate(getattr(mobject1, attr), getattr(mobject2, attr), alpha),
        )
        if alpha == 1.0:
            val = getattr(mobject2, attr)
            if isinstance(val, np.ndarray):
                val = val.copy()
            setattr(self, attr, val)

</t>
<t tx="ekr.20250122151621.249">def pointwise_become_partial(
    self,
    vmobject: VMobject,
    a: float,
    b: float,
) -&gt; Self:
    """Given a 2nd :class:`.VMobject` ``vmobject``, a lower bound ``a`` and
    an upper bound ``b``, modify this :class:`.VMobject`'s points to
    match the portion of the Bézier spline described by ``vmobject.points``
    with the parameter ``t`` between ``a`` and ``b``.

    Parameters
    ----------
    vmobject
        The :class:`.VMobject` that will serve as a model.
    a
        The lower bound for ``t``.
    b
        The upper bound for ``t``

    Returns
    -------
    :class:`.VMobject`
        The :class:`.VMobject` itself, after the transformation.

    Raises
    ------
    TypeError
        If ``vmobject`` is not an instance of :class:`VMobject`.
    """
    if not isinstance(vmobject, VMobject):
        raise TypeError(
            f"Expected a VMobject, got value {vmobject} of type "
            f"{type(vmobject).__name__}."
        )
    # Partial curve includes three portions:
    # - A middle section, which matches the curve exactly.
    # - A start, which is some ending portion of an inner cubic.
    # - An end, which is the starting portion of a later inner cubic.
    if a &lt;= 0 and b &gt;= 1:
        self.set_points(vmobject.points)
        return self
    num_curves = vmobject.get_num_curves()
    if num_curves == 0:
        self.clear_points()
        return self

    # The following two lines will compute which Bézier curves of the given Mobject must be processed.
    # The residue indicates the proportion of the selected Bézier curve which must be selected.
    #
    # Example: if num_curves is 10, a is 0.34 and b is 0.78, then:
    # - lower_index is 3 and lower_residue is 0.4, which means the algorithm will look at the 3rd Bézier
    #   and select its part which ranges from t=0.4 to t=1.
    # - upper_index is 7 and upper_residue is 0.8, which means the algorithm will look at the 7th Bézier
    #   and select its part which ranges from t=0 to t=0.8.
    lower_index, lower_residue = integer_interpolate(0, num_curves, a)
    upper_index, upper_residue = integer_interpolate(0, num_curves, b)

    nppc = self.n_points_per_curve
    # If both indices coincide, get a part of a single Bézier curve.
    if lower_index == upper_index:
        # Look at the "lower_index"-th Bézier curve and select its part from
        # t=lower_residue to t=upper_residue.
        self.points = partial_bezier_points(
            vmobject.points[nppc * lower_index : nppc * (lower_index + 1)],
            lower_residue,
            upper_residue,
        )
    else:
        # Allocate space for (upper_index-lower_index+1) Bézier curves.
        self.points = np.empty((nppc * (upper_index - lower_index + 1), self.dim))
        # Look at the "lower_index"-th Bezier curve and select its part from
        # t=lower_residue to t=1. This is the first curve in self.points.
        self.points[:nppc] = partial_bezier_points(
            vmobject.points[nppc * lower_index : nppc * (lower_index + 1)],
            lower_residue,
            1,
        )
        # If there are more curves between the "lower_index"-th and the
        # "upper_index"-th Béziers, add them all to self.points.
        self.points[nppc:-nppc] = vmobject.points[
            nppc * (lower_index + 1) : nppc * upper_index
        ]
        # Look at the "upper_index"-th Bézier curve and select its part from
        # t=0 to t=upper_residue. This is the last curve in self.points.
        self.points[-nppc:] = partial_bezier_points(
            vmobject.points[nppc * upper_index : nppc * (upper_index + 1)],
            0,
            upper_residue,
        )

    return self

</t>
<t tx="ekr.20250122151621.25">def get_3d_vmob_end_corner(vmob) -&gt; Point3D:
    if vmob.get_num_points() == 0:
        return np.array(ORIGIN)
    return vmob.points[get_3d_vmob_end_corner_index(vmob)]


</t>
<t tx="ekr.20250122151621.250">def get_subcurve(self, a: float, b: float) -&gt; Self:
    """Returns the subcurve of the VMobject between the interval [a, b].
    The curve is a VMobject itself.

    Parameters
    ----------

    a
        The lower bound.
    b
        The upper bound.

    Returns
    -------
    VMobject
        The subcurve between of [a, b]
    """
    if self.is_closed() and a &gt; b:
        vmob = self.copy()
        vmob.pointwise_become_partial(self, a, 1)
        vmob2 = self.copy()
        vmob2.pointwise_become_partial(self, 0, b)
        vmob.append_vectorized_mobject(vmob2)
    else:
        vmob = self.copy()
        vmob.pointwise_become_partial(self, a, b)
    return vmob

</t>
<t tx="ekr.20250122151621.251">def get_direction(self) -&gt; Literal["CW", "CCW"]:
    """Uses :func:`~.space_ops.shoelace_direction` to calculate the direction.
    The direction of points determines in which direction the
    object is drawn, clockwise or counterclockwise.

    Examples
    --------
    The default direction of a :class:`~.Circle` is counterclockwise::

        &gt;&gt;&gt; from manim import Circle
        &gt;&gt;&gt; Circle().get_direction()
        'CCW'

    Returns
    -------
    :class:`str`
        Either ``"CW"`` or ``"CCW"``.
    """
    return shoelace_direction(self.get_start_anchors())

</t>
<t tx="ekr.20250122151621.252">def reverse_direction(self) -&gt; Self:
    """Reverts the point direction by inverting the point order.

    Returns
    -------
    :class:`VMobject`
        Returns self.

    Examples
    --------
    .. manim:: ChangeOfDirection

        class ChangeOfDirection(Scene):
            def construct(self):
                ccw = RegularPolygon(5)
                ccw.shift(LEFT)
                cw = RegularPolygon(5)
                cw.shift(RIGHT).reverse_direction()

                self.play(Create(ccw), Create(cw),
                run_time=4)
    """
    self.points = self.points[::-1]
    return self

</t>
<t tx="ekr.20250122151621.253">def force_direction(self, target_direction: Literal["CW", "CCW"]) -&gt; Self:
    """Makes sure that points are either directed clockwise or
    counterclockwise.

    Parameters
    ----------
    target_direction
        Either ``"CW"`` or ``"CCW"``.
    """
    if target_direction not in ("CW", "CCW"):
        raise ValueError('Invalid input for force_direction. Use "CW" or "CCW"')
    if self.get_direction() != target_direction:
        # Since we already assured the input is CW or CCW,
        # and the directions don't match, we just reverse
        self.reverse_direction()
    return self


</t>
<t tx="ekr.20250122151621.254">def __init__(
    self, *vmobjects: VMobject | Iterable[VMobject], **kwargs: Any
) -&gt; None:
    super().__init__(**kwargs)
    self.add(*vmobjects)

</t>
<t tx="ekr.20250122151621.255">def __repr__(self) -&gt; str:
    return f"{self.__class__.__name__}({', '.join(str(mob) for mob in self.submobjects)})"

</t>
<t tx="ekr.20250122151621.256">def __str__(self) -&gt; str:
    return (
        f"{self.__class__.__name__} of {len(self.submobjects)} "
        f"submobject{'s' if len(self.submobjects) &gt; 0 else ''}"
    )

</t>
<t tx="ekr.20250122151621.257">def add(
    self,
    *vmobjects: VMobject | Iterable[VMobject],
) -&gt; Self:
    """Checks if all passed elements are an instance, or iterables of VMobject and then adds them to submobjects

    Parameters
    ----------
    vmobjects
        List or iterable of VMobjects to add

    Returns
    -------
    :class:`VGroup`

    Raises
    ------
    TypeError
        If one element of the list, or iterable is not an instance of VMobject

    Examples
    --------
    The following example shows how to add individual or multiple `VMobject` instances through the `VGroup`
    constructor and its `.add()` method.

    .. manim:: AddToVGroup

        class AddToVGroup(Scene):
            def construct(self):
                circle_red = Circle(color=RED)
                circle_green = Circle(color=GREEN)
                circle_blue = Circle(color=BLUE)
                circle_red.shift(LEFT)
                circle_blue.shift(RIGHT)
                gr = VGroup(circle_red, circle_green)
                gr2 = VGroup(circle_blue) # Constructor uses add directly
                self.add(gr,gr2)
                self.wait()
                gr += gr2 # Add group to another
                self.play(
                    gr.animate.shift(DOWN),
                )
                gr -= gr2 # Remove group
                self.play( # Animate groups separately
                    gr.animate.shift(LEFT),
                    gr2.animate.shift(UP),
                )
                self.play( #Animate groups without modification
                    (gr+gr2).animate.shift(RIGHT)
                )
                self.play( # Animate group without component
                    (gr-circle_red).animate.shift(RIGHT)
                )

    A `VGroup` can be created using iterables as well. Keep in mind that all generated values from an
    iterable must be an instance of `VMobject`. This is demonstrated below:

    .. manim:: AddIterableToVGroupExample
        :save_last_frame:

        class AddIterableToVGroupExample(Scene):
            def construct(self):
                v = VGroup(
                    Square(),               # Singular VMobject instance
                    [Circle(), Triangle()], # List of VMobject instances
                    Dot(),
                    (Dot() for _ in range(2)), # Iterable that generates VMobjects
                )
                v.arrange()
                self.add(v)

    To facilitate this, the iterable is unpacked before its individual instances are added to the `VGroup`.
    As a result, when you index a `VGroup`, you will never get back an iterable.
    Instead, you will always receive `VMobject` instances, including those
    that were part of the iterable/s that you originally added to the `VGroup`.
    """

    def get_type_error_message(invalid_obj, invalid_indices):
        return (
            f"Only values of type {vmobject_render_type.__name__} can be added "
            "as submobjects of VGroup, but the value "
            f"{repr(invalid_obj)} (at index {invalid_indices[1]} of "
            f"parameter {invalid_indices[0]}) is of type "
            f"{type(invalid_obj).__name__}."
        )

    vmobject_render_type = (
        OpenGLVMobject if config.renderer == RendererType.OPENGL else VMobject
    )
    valid_vmobjects = []

    for i, vmobject in enumerate(vmobjects):
        if isinstance(vmobject, vmobject_render_type):
            valid_vmobjects.append(vmobject)
        elif isinstance(vmobject, Iterable) and not isinstance(
            vmobject, (Mobject, OpenGLMobject)
        ):
            for j, subvmobject in enumerate(vmobject):
                if not isinstance(subvmobject, vmobject_render_type):
                    raise TypeError(get_type_error_message(subvmobject, (i, j)))
                valid_vmobjects.append(subvmobject)
        elif isinstance(vmobject, Iterable) and isinstance(
            vmobject, (Mobject, OpenGLMobject)
        ):
            raise TypeError(
                f"{get_type_error_message(vmobject, (i, 0))} "
                "You can try adding this value into a Group instead."
            )
        else:
            raise TypeError(get_type_error_message(vmobject, (i, 0)))

    return super().add(*valid_vmobjects)

</t>
<t tx="ekr.20250122151621.258">def __add__(self, vmobject: VMobject) -&gt; Self:
    return VGroup(*self.submobjects, vmobject)

</t>
<t tx="ekr.20250122151621.259">def __iadd__(self, vmobject: VMobject) -&gt; Self:
    return self.add(vmobject)

</t>
<t tx="ekr.20250122151621.26">def get_3d_vmob_unit_normal(vmob, point_index: int) -&gt; Vector3D:
    n_points = vmob.get_num_points()
    if len(vmob.get_anchors()) &lt;= 2:
        return np.array(UP)
    i = point_index
    im3 = i - 3 if i &gt; 2 else (n_points - 4)
    ip3 = i + 3 if i &lt; (n_points - 3) else 3
    unit_normal = get_unit_normal(
        vmob.points[ip3] - vmob.points[i],
        vmob.points[im3] - vmob.points[i],
    )
    if np.linalg.norm(unit_normal) == 0:
        return np.array(UP)
    return unit_normal


</t>
<t tx="ekr.20250122151621.260">def __sub__(self, vmobject: VMobject) -&gt; Self:
    copy = VGroup(*self.submobjects)
    copy.remove(vmobject)
    return copy

</t>
<t tx="ekr.20250122151621.261">def __isub__(self, vmobject: VMobject) -&gt; Self:
    return self.remove(vmobject)

</t>
<t tx="ekr.20250122151621.262">def __setitem__(self, key: int, value: VMobject | Sequence[VMobject]) -&gt; None:
    """Override the [] operator for item assignment.

    Parameters
    ----------
    key
        The index of the submobject to be assigned
    value
        The vmobject value to assign to the key

    Returns
    -------
    None

    Tests
    -----
    Check that item assignment does not raise error::
        &gt;&gt;&gt; vgroup = VGroup(VMobject())
        &gt;&gt;&gt; new_obj = VMobject()
        &gt;&gt;&gt; vgroup[0] = new_obj
    """
    self._assert_valid_submobjects(tuplify(value))
    self.submobjects[key] = value


</t>
<t tx="ekr.20250122151621.263">def __init__(
    self,
    mapping_or_iterable: (
        Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]
    ) = {},
    show_keys: bool = False,
    **kwargs,
</t>
<t tx="ekr.20250122151621.264">) -&gt; None:
    super().__init__(**kwargs)
    self.show_keys = show_keys
    self.submob_dict = {}
    self.add(mapping_or_iterable)

def __repr__(self) -&gt; str:
    return f"{self.__class__.__name__}({repr(self.submob_dict)})"

</t>
<t tx="ekr.20250122151621.265">def add(
    self,
    mapping_or_iterable: (
        Mapping[Hashable, VMobject] | Iterable[tuple[Hashable, VMobject]]
    ),
</t>
<t tx="ekr.20250122151621.266">) -&gt; Self:
    """Adds the key-value pairs to the :class:`VDict` object.

    Also, it internally adds the value to the `submobjects` :class:`list`
    of :class:`~.Mobject`, which is responsible for actual on-screen display.

    Parameters
    ---------
    mapping_or_iterable
        The parameter specifying the key-value mapping of keys and mobjects.

    Returns
    -------
    :class:`VDict`
        Returns the :class:`VDict` object on which this method was called.

    Examples
    --------
    Normal usage::

        square_obj = Square()
        my_dict.add([("s", square_obj)])
    """
    for key, value in dict(mapping_or_iterable).items():
        self.add_key_value_pair(key, value)

    return self

def remove(self, key: Hashable) -&gt; Self:
    """Removes the mobject from the :class:`VDict` object having the key `key`

    Also, it internally removes the mobject from the `submobjects` :class:`list`
    of :class:`~.Mobject`, (which is responsible for removing it from the screen)

    Parameters
    ----------
    key
        The key of the submoject to be removed.

    Returns
    -------
    :class:`VDict`
        Returns the :class:`VDict` object on which this method was called.

    Examples
    --------
    Normal usage::

        my_dict.remove("square")
    """
    if key not in self.submob_dict:
        raise KeyError(f"The given key '{key!s}' is not present in the VDict")
    super().remove(self.submob_dict[key])
    del self.submob_dict[key]
    return self

</t>
<t tx="ekr.20250122151621.267">def __getitem__(self, key: Hashable):
    """Override the [] operator for item retrieval.

    Parameters
    ----------
    key
       The key of the submoject to be accessed

    Returns
    -------
    :class:`VMobject`
       The submobject corresponding to the key `key`

    Examples
    --------
    Normal usage::

       self.play(Create(my_dict["s"]))
    """
    submob = self.submob_dict[key]
    return submob

</t>
<t tx="ekr.20250122151621.268">def __setitem__(self, key: Hashable, value: VMobject) -&gt; None:
    """Override the [] operator for item assignment.

    Parameters
    ----------
    key
        The key of the submoject to be assigned
    value
        The submobject to bind the key to

    Returns
    -------
    None

    Examples
    --------
    Normal usage::

        square_obj = Square()
        my_dict["sq"] = square_obj
    """
    if key in self.submob_dict:
        self.remove(key)
    self.add([(key, value)])

</t>
<t tx="ekr.20250122151621.269">def __delitem__(self, key: Hashable):
    """Override the del operator for deleting an item.

    Parameters
    ----------
    key
        The key of the submoject to be deleted

    Returns
    -------
    None

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import *
        &gt;&gt;&gt; my_dict = VDict({'sq': Square()})
        &gt;&gt;&gt; 'sq' in my_dict
        True
        &gt;&gt;&gt; del my_dict['sq']
        &gt;&gt;&gt; 'sq' in my_dict
        False

    Notes
    -----
    Removing an item from a VDict does not remove that item from any Scene
    that the VDict is part of.

    """
    del self.submob_dict[key]

</t>
<t tx="ekr.20250122151621.27">def get_3d_vmob_start_corner_unit_normal(vmob) -&gt; Vector3D:
    return get_3d_vmob_unit_normal(vmob, get_3d_vmob_start_corner_index(vmob))


</t>
<t tx="ekr.20250122151621.270">def __contains__(self, key: Hashable):
    """Override the in operator.

    Parameters
    ----------
    key
        The key to check membership of.

    Returns
    -------
    :class:`bool`

    Examples
    --------
    ::

        &gt;&gt;&gt; from manim import *
        &gt;&gt;&gt; my_dict = VDict({'sq': Square()})
        &gt;&gt;&gt; 'sq' in my_dict
        True

    """
    return key in self.submob_dict

</t>
<t tx="ekr.20250122151621.271">def get_all_submobjects(self) -&gt; list[list]:
    """To get all the submobjects associated with a particular :class:`VDict` object

    Returns
    -------
    :class:`dict_values`
        All the submobjects associated with the :class:`VDict` object

    Examples
    --------
    Normal usage::

        for submob in my_dict.get_all_submobjects():
            self.play(Create(submob))
    """
    submobjects = self.submob_dict.values()
    return submobjects

</t>
<t tx="ekr.20250122151621.272">def add_key_value_pair(self, key: Hashable, value: VMobject) -&gt; None:
    """A utility function used by :meth:`add` to add the key-value pair
    to :attr:`submob_dict`. Not really meant to be used externally.

    Parameters
    ----------
    key
        The key of the submobject to be added.
    value
        The mobject associated with the key

    Returns
    -------
    None

    Raises
    ------
    TypeError
        If the value is not an instance of VMobject

    Examples
    --------
    Normal usage::

        square_obj = Square()
        self.add_key_value_pair("s", square_obj)

    """
    self._assert_valid_submobjects([value])
    mob = value
    if self.show_keys:
        # This import is here and not at the top to avoid circular import
        from manim.mobject.text.tex_mobject import Tex

        key_text = Tex(str(key)).next_to(value, LEFT)
        mob.add(key_text)

    self.submob_dict[key] = mob
    super().add(value)


</t>
<t tx="ekr.20250122151621.273">def __init__(
    self,
    location: Point3DLike = ORIGIN,
    color: ManimColor = BLACK,
    fill_opacity: float = 0,
    stroke_width: float = 0,
    artificial_width: float = 0.01,
    artificial_height: float = 0.01,
    **kwargs,
) -&gt; None:
    self.artificial_width = artificial_width
    self.artificial_height = artificial_height
    super().__init__(
        color=color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        **kwargs,
    )
    self.set_points(np.array([location]))

</t>
<t tx="ekr.20250122151621.274">basecls = OpenGLVMobject if config.renderer == RendererType.OPENGL else VMobject

@basecls.width.getter
def width(self) -&gt; float:
    return self.artificial_width

</t>
<t tx="ekr.20250122151621.275">@basecls.height.getter
def height(self) -&gt; float:
    return self.artificial_height

</t>
<t tx="ekr.20250122151621.276">def get_location(self) -&gt; Point3D:
    return np.array(self.points[0])

</t>
<t tx="ekr.20250122151621.277">def set_location(self, new_loc: Point3D):
    self.set_points(np.array([new_loc]))


</t>
<t tx="ekr.20250122151621.278">def __init__(self, vmobject: VMobject, **kwargs) -&gt; None:
    super().__init__(**kwargs)
    tuples = vmobject.get_cubic_bezier_tuples()
    for tup in tuples:
        part = VMobject()
        part.set_points(tup)
        part.match_style(vmobject)
        self.add(part)

</t>
<t tx="ekr.20250122151621.279">def point_from_proportion(self, alpha: float) -&gt; Point3D:
    """Gets the point at a proportion along the path of the :class:`CurvesAsSubmobjects`.

    Parameters
    ----------
    alpha
        The proportion along the the path of the :class:`CurvesAsSubmobjects`.

    Returns
    -------
    :class:`numpy.ndarray`
        The point on the :class:`CurvesAsSubmobjects`.

    Raises
    ------
    :exc:`ValueError`
        If ``alpha`` is not between 0 and 1.
    :exc:`Exception`
        If the :class:`CurvesAsSubmobjects` has no submobjects, or no submobject has points.
    """
    if alpha &lt; 0 or alpha &gt; 1:
        raise ValueError(f"Alpha {alpha} not between 0 and 1.")

    self._throw_error_if_no_submobjects()
    submobjs_with_pts = self._get_submobjects_with_points()

    if alpha == 1:
        return submobjs_with_pts[-1].points[-1]

    submobjs_arc_lengths = tuple(
        part.get_arc_length() for part in submobjs_with_pts
    )

    total_length = sum(submobjs_arc_lengths)
    target_length = alpha * total_length
    current_length = 0

    for i, part in enumerate(submobjs_with_pts):
        part_length = submobjs_arc_lengths[i]
        if current_length + part_length &gt;= target_length:
            residue = (target_length - current_length) / part_length
            return part.point_from_proportion(residue)

        current_length += part_length

</t>
<t tx="ekr.20250122151621.28">def get_3d_vmob_end_corner_unit_normal(vmob) -&gt; Vector3D:
    return get_3d_vmob_unit_normal(vmob, get_3d_vmob_end_corner_index(vmob))
</t>
<t tx="ekr.20250122151621.280">def _throw_error_if_no_submobjects(self):
    if len(self.submobjects) == 0:
        caller_name = sys._getframe(1).f_code.co_name
        raise Exception(
            f"Cannot call CurvesAsSubmobjects. {caller_name} for a CurvesAsSubmobject with no submobjects"
        )

</t>
<t tx="ekr.20250122151621.281">def _get_submobjects_with_points(self):
    submobjs_with_pts = tuple(
        part for part in self.submobjects if len(part.points) &gt; 0
    )
    if len(submobjs_with_pts) == 0:
        caller_name = sys._getframe(1).f_code.co_name
        raise Exception(
            f"Cannot call CurvesAsSubmobjects. {caller_name} for a CurvesAsSubmobject whose submobjects have no points"
        )
    return submobjs_with_pts


</t>
<t tx="ekr.20250122151621.282">def __init__(
    self,
    vmobject: VMobject,
    num_dashes: int = 15,
    dashed_ratio: float = 0.5,
    dash_offset: float = 0,
    color: ManimColor = WHITE,
    equal_lengths: bool = True,
    **kwargs,
) -&gt; None:
    self.dashed_ratio = dashed_ratio
    self.num_dashes = num_dashes
    super().__init__(color=color, **kwargs)
    r = self.dashed_ratio
    n = self.num_dashes
    if n &gt; 0:
        # Assuming total length is 1
        dash_len = r / n
        if vmobject.is_closed():
            void_len = (1 - r) / n
        else:
            void_len = 1 - r if n == 1 else (1 - r) / (n - 1)

        period = dash_len + void_len
        phase_shift = (dash_offset % 1) * period

        if vmobject.is_closed():  # noqa: SIM108
            # closed curves have equal amount of dashes and voids
            pattern_len = 1
        else:
            # open curves start and end with a dash, so the whole dash pattern with the last void is longer
            pattern_len = 1 + void_len

        dash_starts = [((i * period + phase_shift) % pattern_len) for i in range(n)]
        dash_ends = [
            ((i * period + dash_len + phase_shift) % pattern_len) for i in range(n)
        ]

        # closed shapes can handle overflow at the 0-point
        # open shapes need special treatment for it
        if not vmobject.is_closed():
            # due to phase shift being [0...1] range, always the last dash element needs attention for overflow
            # if an entire dash moves out of the shape end:
            if dash_ends[-1] &gt; 1 and dash_starts[-1] &gt; 1:
                # remove the last element since it is out-of-bounds
                dash_ends.pop()
                dash_starts.pop()
            elif dash_ends[-1] &lt; dash_len:  # if it overflowed
                if (
                    dash_starts[-1] &lt; 1
                ):  # if the beginning of the piece is still in range
                    dash_starts.append(0)
                    dash_ends.append(dash_ends[-1])
                    dash_ends[-2] = 1
                else:
                    dash_starts[-1] = 0
            elif dash_starts[-1] &gt; (1 - dash_len):
                dash_ends[-1] = 1

        if equal_lengths:
            # calculate the entire length by adding up short line-pieces
            norms = np.array(0)
            for k in range(vmobject.get_num_curves()):
                norms = np.append(norms, vmobject.get_nth_curve_length_pieces(k))
            # add up length-pieces in array form
            length_vals = np.cumsum(norms)
            ref_points = np.linspace(0, 1, length_vals.size)
            curve_length = length_vals[-1]
            self.add(
                *(
                    vmobject.get_subcurve(
                        np.interp(
                            dash_starts[i] * curve_length,
                            length_vals,
                            ref_points,
                        ),
                        np.interp(
                            dash_ends[i] * curve_length,
                            length_vals,
                            ref_points,
                        ),
                    )
                    for i in range(len(dash_starts))
                )
            )
        else:
            self.add(
                *(
                    vmobject.get_subcurve(
                        dash_starts[i],
                        dash_ends[i],
                    )
                    for i in range(len(dash_starts))
                )
            )
    # Family is already taken care of by get_subcurve
    # implementation
    if config.renderer == RendererType.OPENGL:
        self.match_style(vmobject, recurse=False)
    else:
        self.match_style(vmobject, family=False)
</t>
<t tx="ekr.20250122151621.283"></t>
<t tx="ekr.20250122151621.284">from __future__ import annotations

import contextlib

with contextlib.suppress(ImportError):
    from dearpygui import dearpygui as dpg


from manim.mobject.opengl.dot_cloud import *
from manim.mobject.opengl.opengl_image_mobject import *
from manim.mobject.opengl.opengl_mobject import *
from manim.mobject.opengl.opengl_point_cloud_mobject import *
from manim.mobject.opengl.opengl_surface import *
from manim.mobject.opengl.opengl_three_dimensions import *
from manim.mobject.opengl.opengl_vectorized_mobject import *

from ..renderer.shader import *
from ..utils.opengl import *
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.285"></t>
<t tx="ekr.20250122151621.286">from __future__ import annotations

from manim._config import config, logger
from manim.plugins.plugins_flags import get_plugins, list_plugins

__all__ = [
    "get_plugins",
    "list_plugins",
]

requested_plugins: set[str] = set(config["plugins"])
missing_plugins = requested_plugins - set(get_plugins().keys())


if missing_plugins:
    logger.warning("Missing Plugins: %s", missing_plugins)
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.287">"""Plugin Managing Utility"""

from __future__ import annotations

import sys
from typing import Any

if sys.version_info &lt; (3, 10):
    from importlib_metadata import entry_points
else:
    from importlib.metadata import entry_points

from manim._config import console

__all__ = ["list_plugins"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.288">def get_plugins() -&gt; dict[str, Any]:
    plugins: dict[str, Any] = {
        entry_point.name: entry_point.load()
        for entry_point in entry_points(group="manim.plugins")
    }
    return plugins


</t>
<t tx="ekr.20250122151621.289">def list_plugins() -&gt; None:
    console.print("[green bold]Plugins:[/green bold]", justify="left")

    plugins = get_plugins()
    for plugin_name in plugins:
        console.print(f" • {plugin_name}")
</t>
<t tx="ekr.20250122151621.29">"""Three-dimensional mobjects."""

from __future__ import annotations

from manim.typing import Point3DLike, Vector3D
from manim.utils.color import BLUE, BLUE_D, BLUE_E, LIGHT_GREY, WHITE, interpolate_color

__all__ = [
    "ThreeDVMobject",
    "Surface",
    "Sphere",
    "Dot3D",
    "Cube",
    "Prism",
    "Cone",
    "Arrow3D",
    "Cylinder",
    "Line3D",
    "Torus",
]

from collections.abc import Iterable, Sequence
from typing import Any, Callable

import numpy as np
from typing_extensions import Self

from manim import config, logger
from manim.constants import *
from manim.mobject.geometry.arc import Circle
from manim.mobject.geometry.polygram import Square
from manim.mobject.mobject import *
from manim.mobject.opengl.opengl_compatibility import ConvertToOpenGL
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.mobject.types.vectorized_mobject import VectorizedPoint, VGroup, VMobject
from manim.utils.color import (
    ManimColor,
    ParsableManimColor,
)
from manim.utils.iterables import tuplify
from manim.utils.space_ops import normalize, perpendicular_bisector, z_to_vector


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.290"></t>
<t tx="ekr.20250122151621.291"></t>
<t tx="ekr.20250122151621.292">from __future__ import annotations

import typing

import numpy as np

from manim.utils.hashing import get_hash_from_play_call

from .. import config, logger
from ..camera.camera import Camera
from ..mobject.mobject import Mobject, _AnimationBuilder
from ..scene.scene_file_writer import SceneFileWriter
from ..utils.exceptions import EndSceneEarlyException
from ..utils.iterables import list_update

if typing.TYPE_CHECKING:
    from typing import Any

    from manim.animation.animation import Animation
    from manim.scene.scene import Scene

    from ..typing import PixelArray

__all__ = ["CairoRenderer"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.293">class CairoRenderer:
    """A renderer using Cairo.

    num_plays : Number of play() functions in the scene.
    time: time elapsed since initialisation of scene.
    """

    @others
</t>
<t tx="ekr.20250122151621.294">def __init__(
    self,
    file_writer_class=SceneFileWriter,
    camera_class=None,
    skip_animations=False,
    **kwargs,
):
    # All of the following are set to EITHER the value passed via kwargs,
    # OR the value stored in the global config dict at the time of
    # _instance construction_.
    self._file_writer_class = file_writer_class
    camera_cls = camera_class if camera_class is not None else Camera
    self.camera = camera_cls()
    self._original_skipping_status = skip_animations
    self.skip_animations = skip_animations
    self.animations_hashes = []
    self.num_plays = 0
    self.time = 0
    self.static_image = None

</t>
<t tx="ekr.20250122151621.295">def init_scene(self, scene):
    self.file_writer: Any = self._file_writer_class(
        self,
        scene.__class__.__name__,
    )

</t>
<t tx="ekr.20250122151621.296">def play(
    self,
    scene: Scene,
    *args: Animation | Mobject | _AnimationBuilder,
    **kwargs,
):
    # Reset skip_animations to the original state.
    # Needed when rendering only some animations, and skipping others.
    self.skip_animations = self._original_skipping_status
    self.update_skipping_status()

    scene.compile_animation_data(*args, **kwargs)

    if self.skip_animations:
        logger.debug(f"Skipping animation {self.num_plays}")
        hash_current_animation = None
        self.time += scene.duration
    else:
        if config["disable_caching"]:
            logger.info("Caching disabled.")
            hash_current_animation = f"uncached_{self.num_plays:05}"
        else:
            hash_current_animation = get_hash_from_play_call(
                scene,
                self.camera,
                scene.animations,
                scene.mobjects,
            )
            if self.file_writer.is_already_cached(hash_current_animation):
                logger.info(
                    f"Animation {self.num_plays} : Using cached data (hash : %(hash_current_animation)s)",
                    {"hash_current_animation": hash_current_animation},
                )
                self.skip_animations = True
                self.time += scene.duration
    # adding None as a partial movie file will make file_writer ignore the latter.
    self.file_writer.add_partial_movie_file(hash_current_animation)
    self.animations_hashes.append(hash_current_animation)
    logger.debug(
        "List of the first few animation hashes of the scene: %(h)s",
        {"h": str(self.animations_hashes[:5])},
    )

    self.file_writer.begin_animation(not self.skip_animations)
    scene.begin_animations()

    # Save a static image, to avoid rendering non moving objects.
    self.save_static_frame_data(scene, scene.static_mobjects)

    if scene.is_current_animation_frozen_frame():
        self.update_frame(scene, mobjects=scene.moving_mobjects)
        # self.duration stands for the total run time of all the animations.
        # In this case, as there is only a wait, it will be the length of the wait.
        self.freeze_current_frame(scene.duration)
    else:
        scene.play_internal()
    self.file_writer.end_animation(not self.skip_animations)

    self.num_plays += 1

</t>
<t tx="ekr.20250122151621.297">def update_frame(  # TODO Description in Docstring
    self,
    scene,
    mobjects: typing.Iterable[Mobject] | None = None,
    include_submobjects: bool = True,
    ignore_skipping: bool = True,
    **kwargs,
):
    """Update the frame.

    Parameters
    ----------
    scene

    mobjects
        list of mobjects

    include_submobjects

    ignore_skipping

    **kwargs

    """
    if self.skip_animations and not ignore_skipping:
        return
    if not mobjects:
        mobjects = list_update(
            scene.mobjects,
            scene.foreground_mobjects,
        )
    if self.static_image is not None:
        self.camera.set_frame_to_background(self.static_image)
    else:
        self.camera.reset()

    kwargs["include_submobjects"] = include_submobjects
    self.camera.capture_mobjects(mobjects, **kwargs)

</t>
<t tx="ekr.20250122151621.298">def render(self, scene, time, moving_mobjects):
    self.update_frame(scene, moving_mobjects)
    self.add_frame(self.get_frame())

</t>
<t tx="ekr.20250122151621.299">def get_frame(self) -&gt; PixelArray:
    """
    Gets the current frame as NumPy array.

    Returns
    -------
    np.array
        NumPy array of pixel values of each pixel in screen.
        The shape of the array is height x width x 3
    """
    return np.array(self.camera.pixel_array)

</t>
<t tx="ekr.20250122151621.3">"""General polyhedral class and platonic solids."""

from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np

from manim.mobject.geometry.polygram import Polygon
from manim.mobject.graph import Graph
from manim.mobject.three_d.three_dimensions import Dot3D
from manim.mobject.types.vectorized_mobject import VGroup
from manim.utils.qhull import QuickHull

if TYPE_CHECKING:
    from manim.mobject.mobject import Mobject
    from manim.typing import Point3D

__all__ = [
    "Polyhedron",
    "Tetrahedron",
    "Octahedron",
    "Icosahedron",
    "Dodecahedron",
    "ConvexHull3D",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.30">class ThreeDVMobject(VMobject, metaclass=ConvertToOpenGL):
    @others
</t>
<t tx="ekr.20250122151621.300">def add_frame(self, frame: np.ndarray, num_frames: int = 1):
    """
    Adds a frame to the video_file_stream

    Parameters
    ----------
    frame
        The frame to add, as a pixel array.
    num_frames
        The number of times to add frame.
    """
    dt = 1 / self.camera.frame_rate
    if self.skip_animations:
        return
    self.time += num_frames * dt
    self.file_writer.write_frame(frame, num_frames=num_frames)

</t>
<t tx="ekr.20250122151621.301">def freeze_current_frame(self, duration: float):
    """Adds a static frame to the movie for a given duration. The static frame is the current frame.

    Parameters
    ----------
    duration
        [description]
    """
    dt = 1 / self.camera.frame_rate
    self.add_frame(
        self.get_frame(),
        num_frames=int(duration / dt),
    )

</t>
<t tx="ekr.20250122151621.302">def show_frame(self):
    """
    Opens the current frame in the Default Image Viewer
    of your system.
    """
    self.update_frame(ignore_skipping=True)
    self.camera.get_image().show()

</t>
<t tx="ekr.20250122151621.303">def save_static_frame_data(
    self,
    scene: Scene,
    static_mobjects: typing.Iterable[Mobject],
) -&gt; typing.Iterable[Mobject] | None:
    """Compute and save the static frame, that will be reused at each frame
    to avoid unnecessarily computing static mobjects.

    Parameters
    ----------
    scene
        The scene played.
    static_mobjects
        Static mobjects of the scene. If None, self.static_image is set to None

    Returns
    -------
    typing.Iterable[Mobject]
        The static image computed.
    """
    self.static_image = None
    if not static_mobjects:
        return None
    self.update_frame(scene, mobjects=static_mobjects)
    self.static_image = self.get_frame()
    return self.static_image

</t>
<t tx="ekr.20250122151621.304">def update_skipping_status(self):
    """
    This method is used internally to check if the current
    animation needs to be skipped or not. It also checks if
    the number of animations that were played correspond to
    the number of animations that need to be played, and
    raises an EndSceneEarlyException if they don't correspond.
    """
    # there is always at least one section -&gt; no out of bounds here
    if self.file_writer.sections[-1].skip_animations:
        self.skip_animations = True
    if config["save_last_frame"]:
        self.skip_animations = True
    if (
        config.from_animation_number &gt; 0
        and self.num_plays &lt; config.from_animation_number
    ):
        self.skip_animations = True
    if (
        config.upto_animation_number &gt;= 0
        and self.num_plays &gt; config.upto_animation_number
    ):
        self.skip_animations = True
        raise EndSceneEarlyException()

</t>
<t tx="ekr.20250122151621.305">def scene_finished(self, scene):
    # If no animations in scene, render an image instead
    if self.num_plays:
        self.file_writer.finish()
    elif config.write_to_movie:
        config.save_last_frame = True
        config.write_to_movie = False
    else:
        self.static_image = None
        self.update_frame(scene)

    if config["save_last_frame"]:
        self.static_image = None
        self.update_frame(scene)
        self.file_writer.save_final_image(self.camera.get_image())
</t>
<t tx="ekr.20250122151621.306">from __future__ import annotations

import contextlib
import itertools as it
import time
from functools import cached_property
from typing import Any

import moderngl
import numpy as np
from PIL import Image

from manim import config, logger
from manim.mobject.opengl.opengl_mobject import OpenGLMobject, OpenGLPoint
from manim.mobject.opengl.opengl_vectorized_mobject import OpenGLVMobject
from manim.utils.caching import handle_caching_play
from manim.utils.color import color_to_rgba
from manim.utils.exceptions import EndSceneEarlyException

from ..constants import *
from ..scene.scene_file_writer import SceneFileWriter
from ..utils import opengl
from ..utils.config_ops import _Data
from ..utils.simple_functions import clip
from ..utils.space_ops import (
    angle_of_vector,
    quaternion_from_angle_axis,
    quaternion_mult,
    rotation_matrix_transpose,
    rotation_matrix_transpose_from_quaternion,
)
from .shader import Mesh, Shader
from .vectorized_mobject_rendering import (
    render_opengl_vectorized_mobject_fill,
    render_opengl_vectorized_mobject_stroke,
)

__all__ = ["OpenGLCamera", "OpenGLRenderer"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.307">class OpenGLCamera(OpenGLMobject):
    @others
</t>
<t tx="ekr.20250122151621.308">class OpenGLRenderer:
    @others
</t>
<t tx="ekr.20250122151621.309">euler_angles = _Data()

def __init__(
    self,
    frame_shape=None,
    center_point=None,
    # Theta, phi, gamma
    euler_angles=[0, 0, 0],
    focal_distance=2,
    light_source_position=[-10, 10, 10],
    orthographic=False,
    minimum_polar_angle=-PI / 2,
    maximum_polar_angle=PI / 2,
    model_matrix=None,
    **kwargs,
):
    self.use_z_index = True
    self.frame_rate = 60
    self.orthographic = orthographic
    self.minimum_polar_angle = minimum_polar_angle
    self.maximum_polar_angle = maximum_polar_angle
    if self.orthographic:
        self.projection_matrix = opengl.orthographic_projection_matrix()
        self.unformatted_projection_matrix = opengl.orthographic_projection_matrix(
            format_=False,
        )
    else:
        self.projection_matrix = opengl.perspective_projection_matrix()
        self.unformatted_projection_matrix = opengl.perspective_projection_matrix(
            format_=False,
        )

    if frame_shape is None:
        self.frame_shape = (config["frame_width"], config["frame_height"])
    else:
        self.frame_shape = frame_shape

    if center_point is None:
        self.center_point = ORIGIN
    else:
        self.center_point = center_point

    if model_matrix is None:
        model_matrix = opengl.translation_matrix(0, 0, 11)

    self.focal_distance = focal_distance

    if light_source_position is None:
        self.light_source_position = [-10, 10, 10]
    else:
        self.light_source_position = light_source_position
    self.light_source = OpenGLPoint(self.light_source_position)

    self.default_model_matrix = model_matrix
    super().__init__(model_matrix=model_matrix, should_render=False, **kwargs)

    if euler_angles is None:
        euler_angles = [0, 0, 0]
    euler_angles = np.array(euler_angles, dtype=float)

    self.euler_angles = euler_angles
    self.refresh_rotation_matrix()

</t>
<t tx="ekr.20250122151621.31">class Surface(VGroup, metaclass=ConvertToOpenGL):
    """Creates a Parametric Surface using a checkerboard pattern.

    Parameters
    ----------
    func
        The function defining the :class:`Surface`.
    u_range
        The range of the ``u`` variable: ``(u_min, u_max)``.
    v_range
        The range of the ``v`` variable: ``(v_min, v_max)``.
    resolution
        The number of samples taken of the :class:`Surface`. A tuple can be
        used to define different resolutions for ``u`` and ``v`` respectively.
    fill_color
        The color of the :class:`Surface`. Ignored if ``checkerboard_colors``
        is set.
    fill_opacity
        The opacity of the :class:`Surface`, from 0 being fully transparent
        to 1 being fully opaque. Defaults to 1.
    checkerboard_colors
        ng individual faces alternating colors. Overrides ``fill_color``.
    stroke_color
        Color of the stroke surrounding each face of :class:`Surface`.
    stroke_width
        Width of the stroke surrounding each face of :class:`Surface`.
        Defaults to 0.5.
    should_make_jagged
        Changes the anchor mode of the Bézier curves from smooth to jagged.
        Defaults to ``False``.

    Examples
    --------
    .. manim:: ParaSurface
        :save_last_frame:

        class ParaSurface(ThreeDScene):
            def func(self, u, v):
                return np.array([np.cos(u) * np.cos(v), np.cos(u) * np.sin(v), u])

            def construct(self):
                axes = ThreeDAxes(x_range=[-4,4], x_length=8)
                surface = Surface(
                    lambda u, v: axes.c2p(*self.func(u, v)),
                    u_range=[-PI, PI],
                    v_range=[0, TAU],
                    resolution=8,
                )
                self.set_camera_orientation(theta=70 * DEGREES, phi=75 * DEGREES)
                self.add(axes, surface)
    """

    @others
</t>
<t tx="ekr.20250122151621.310">def get_position(self):
    return self.model_matrix[:, 3][:3]

</t>
<t tx="ekr.20250122151621.311">def set_position(self, position):
    self.model_matrix[:, 3][:3] = position
    return self

</t>
<t tx="ekr.20250122151621.312">@cached_property
def formatted_view_matrix(self):
    return opengl.matrix_to_shader_input(np.linalg.inv(self.model_matrix))

</t>
<t tx="ekr.20250122151621.313">@cached_property
def unformatted_view_matrix(self):
    return np.linalg.inv(self.model_matrix)

</t>
<t tx="ekr.20250122151621.314">def init_points(self):
    self.set_points([ORIGIN, LEFT, RIGHT, DOWN, UP])
    self.set_width(self.frame_shape[0], stretch=True)
    self.set_height(self.frame_shape[1], stretch=True)
    self.move_to(self.center_point)

</t>
<t tx="ekr.20250122151621.315">def to_default_state(self):
    self.center()
    self.set_height(config["frame_height"])
    self.set_width(config["frame_width"])
    self.set_euler_angles(0, 0, 0)
    self.model_matrix = self.default_model_matrix
    return self

</t>
<t tx="ekr.20250122151621.316">def refresh_rotation_matrix(self):
    # Rotate based on camera orientation
    theta, phi, gamma = self.euler_angles
    quat = quaternion_mult(
        quaternion_from_angle_axis(theta, OUT, axis_normalized=True),
        quaternion_from_angle_axis(phi, RIGHT, axis_normalized=True),
        quaternion_from_angle_axis(gamma, OUT, axis_normalized=True),
    )
    self.inverse_rotation_matrix = rotation_matrix_transpose_from_quaternion(quat)

</t>
<t tx="ekr.20250122151621.317">def rotate(self, angle, axis=OUT, **kwargs):
    curr_rot_T = self.inverse_rotation_matrix
    added_rot_T = rotation_matrix_transpose(angle, axis)
    new_rot_T = np.dot(curr_rot_T, added_rot_T)
    Fz = new_rot_T[2]
    phi = np.arccos(Fz[2])
    theta = angle_of_vector(Fz[:2]) + PI / 2
    partial_rot_T = np.dot(
        rotation_matrix_transpose(phi, RIGHT),
        rotation_matrix_transpose(theta, OUT),
    )
    gamma = angle_of_vector(np.dot(partial_rot_T, new_rot_T.T)[:, 0])
    self.set_euler_angles(theta, phi, gamma)
    return self

</t>
<t tx="ekr.20250122151621.318">def set_euler_angles(self, theta=None, phi=None, gamma=None):
    if theta is not None:
        self.euler_angles[0] = theta
    if phi is not None:
        self.euler_angles[1] = phi
    if gamma is not None:
        self.euler_angles[2] = gamma
    self.refresh_rotation_matrix()
    return self

</t>
<t tx="ekr.20250122151621.319">def set_theta(self, theta):
    return self.set_euler_angles(theta=theta)

</t>
<t tx="ekr.20250122151621.32"># Specific shapes


class Sphere(Surface):
    """A three-dimensional sphere.

    Parameters
    ----------
    center
        Center of the :class:`Sphere`.
    radius
        The radius of the :class:`Sphere`.
    resolution
        The number of samples taken of the :class:`Sphere`. A tuple can be used
        to define different resolutions for ``u`` and ``v`` respectively.
    u_range
        The range of the ``u`` variable: ``(u_min, u_max)``.
    v_range
        The range of the ``v`` variable: ``(v_min, v_max)``.

    Examples
    --------

    .. manim:: ExampleSphere
        :save_last_frame:

        class ExampleSphere(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=PI / 6, theta=PI / 6)
                sphere1 = Sphere(
                    center=(3, 0, 0),
                    radius=1,
                    resolution=(20, 20),
                    u_range=[0.001, PI - 0.001],
                    v_range=[0, TAU]
                )
                sphere1.set_color(RED)
                self.add(sphere1)
                sphere2 = Sphere(center=(-1, -3, 0), radius=2, resolution=(18, 18))
                sphere2.set_color(GREEN)
                self.add(sphere2)
                sphere3 = Sphere(center=(-1, 2, 0), radius=2, resolution=(16, 16))
                sphere3.set_color(BLUE)
                self.add(sphere3)
    """

    @others
</t>
<t tx="ekr.20250122151621.320">def set_phi(self, phi):
    return self.set_euler_angles(phi=phi)

</t>
<t tx="ekr.20250122151621.321">def set_gamma(self, gamma):
    return self.set_euler_angles(gamma=gamma)

</t>
<t tx="ekr.20250122151621.322">def increment_theta(self, dtheta):
    self.euler_angles[0] += dtheta
    self.refresh_rotation_matrix()
    return self

</t>
<t tx="ekr.20250122151621.323">def increment_phi(self, dphi):
    phi = self.euler_angles[1]
    new_phi = clip(phi + dphi, -PI / 2, PI / 2)
    self.euler_angles[1] = new_phi
    self.refresh_rotation_matrix()
    return self

</t>
<t tx="ekr.20250122151621.324">def increment_gamma(self, dgamma):
    self.euler_angles[2] += dgamma
    self.refresh_rotation_matrix()
    return self

</t>
<t tx="ekr.20250122151621.325">def get_shape(self):
    return (self.get_width(), self.get_height())

</t>
<t tx="ekr.20250122151621.326">def get_center(self):
    # Assumes first point is at the center
    return self.points[0]

</t>
<t tx="ekr.20250122151621.327">def get_width(self):
    points = self.points
    return points[2, 0] - points[1, 0]

</t>
<t tx="ekr.20250122151621.328">def get_height(self):
    points = self.points
    return points[4, 1] - points[3, 1]

</t>
<t tx="ekr.20250122151621.329">def get_focal_distance(self):
    return self.focal_distance * self.get_height()

</t>
<t tx="ekr.20250122151621.33">class Dot3D(Sphere):
    """A spherical dot.

    Parameters
    ----------
    point
        The location of the dot.
    radius
        The radius of the dot.
    color
        The color of the :class:`Dot3D`.
    resolution
        The number of samples taken of the :class:`Dot3D`. A tuple can be
        used to define different resolutions for ``u`` and ``v`` respectively.

    Examples
    --------

    .. manim:: Dot3DExample
        :save_last_frame:

        class Dot3DExample(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)

                axes = ThreeDAxes()
                dot_1 = Dot3D(point=axes.coords_to_point(0, 0, 1), color=RED)
                dot_2 = Dot3D(point=axes.coords_to_point(2, 0, 0), radius=0.1, color=BLUE)
                dot_3 = Dot3D(point=[0, 0, 0], radius=0.1, color=ORANGE)
                self.add(axes, dot_1, dot_2,dot_3)
    """

    @others
    ) -&gt; None:
        super().__init__(center=point, radius=radius, resolution=resolution, **kwargs)
        self.set_color(color)


</t>
<t tx="ekr.20250122151621.330">def interpolate(self, *args, **kwargs):
    super().interpolate(*args, **kwargs)
    self.refresh_rotation_matrix()


</t>
<t tx="ekr.20250122151621.331">def __init__(
    self,
    file_writer_class: type[SceneFileWriter] = SceneFileWriter,
    skip_animations: bool = False,
) -&gt; None:
    # Measured in pixel widths, used for vector graphics
    self.anti_alias_width = 1.5
    self._file_writer_class = file_writer_class

    self._original_skipping_status = skip_animations
    self.skip_animations = skip_animations
    self.animation_start_time = 0
    self.animation_elapsed_time = 0
    self.time = 0
    self.animations_hashes = []
    self.num_plays = 0

    self.camera = OpenGLCamera()
    self.pressed_keys = set()

    # Initialize texture map.
    self.path_to_texture_id = {}

    self.background_color = config["background_color"]

</t>
<t tx="ekr.20250122151621.332">def init_scene(self, scene):
    self.partial_movie_files = []
    self.file_writer: Any = self._file_writer_class(
        self,
        scene.__class__.__name__,
    )
    self.scene = scene
    self.background_color = config["background_color"]
    if not hasattr(self, "window"):
        if self.should_create_window():
            from .opengl_renderer_window import Window

            self.window = Window(self)
            self.context = self.window.ctx
            self.frame_buffer_object = self.context.detect_framebuffer()
        else:
            self.window = None
            try:
                self.context = moderngl.create_context(standalone=True)
            except Exception:
                self.context = moderngl.create_context(
                    standalone=True,
                    backend="egl",
                )
            self.frame_buffer_object = self.get_frame_buffer_object(self.context, 0)
            self.frame_buffer_object.use()
        self.context.enable(moderngl.BLEND)
        self.context.wireframe = config["enable_wireframe"]
        self.context.blend_func = (
            moderngl.SRC_ALPHA,
            moderngl.ONE_MINUS_SRC_ALPHA,
            moderngl.ONE,
            moderngl.ONE,
        )

</t>
<t tx="ekr.20250122151621.333">def should_create_window(self):
    if config["force_window"]:
        logger.warning(
            "'--force_window' is enabled, this is intended for debugging purposes "
            "and may impact performance if used when outputting files",
        )
        return True
    return (
        config["preview"]
        and not config["save_last_frame"]
        and not config["format"]
        and not config["write_to_movie"]
        and not config["dry_run"]
    )

</t>
<t tx="ekr.20250122151621.334">def get_pixel_shape(self):
    if hasattr(self, "frame_buffer_object"):
        return self.frame_buffer_object.viewport[2:4]
    else:
        return None

</t>
<t tx="ekr.20250122151621.335">def refresh_perspective_uniforms(self, camera):
    pw, ph = self.get_pixel_shape()
    fw, fh = camera.get_shape()
    # TODO, this should probably be a mobject uniform, with
    # the camera taking care of the conversion factor
    anti_alias_width = self.anti_alias_width / (ph / fh)
    # Orient light
    rotation = camera.inverse_rotation_matrix
    light_pos = camera.light_source.get_location()
    light_pos = np.dot(rotation, light_pos)

    self.perspective_uniforms = {
        "frame_shape": camera.get_shape(),
        "anti_alias_width": anti_alias_width,
        "camera_center": tuple(camera.get_center()),
        "camera_rotation": tuple(np.array(rotation).T.flatten()),
        "light_source_position": tuple(light_pos),
        "focal_distance": camera.get_focal_distance(),
    }

</t>
<t tx="ekr.20250122151621.336">def render_mobject(self, mobject):
    if isinstance(mobject, OpenGLVMobject):
        if config["use_projection_fill_shaders"]:
            render_opengl_vectorized_mobject_fill(self, mobject)

        if config["use_projection_stroke_shaders"]:
            render_opengl_vectorized_mobject_stroke(self, mobject)

    shader_wrapper_list = mobject.get_shader_wrapper_list()

    # Convert ShaderWrappers to Meshes.
    for shader_wrapper in shader_wrapper_list:
        shader = Shader(self.context, shader_wrapper.shader_folder)

        # Set textures.
        for name, path in shader_wrapper.texture_paths.items():
            tid = self.get_texture_id(path)
            shader.shader_program[name].value = tid

        # Set uniforms.
        for name, value in it.chain(
            shader_wrapper.uniforms.items(),
            self.perspective_uniforms.items(),
        ):
            with contextlib.suppress(KeyError):
                shader.set_uniform(name, value)
        try:
            shader.set_uniform(
                "u_view_matrix", self.scene.camera.formatted_view_matrix
            )
            shader.set_uniform(
                "u_projection_matrix",
                self.scene.camera.projection_matrix,
            )
        except KeyError:
            pass

        # Set depth test.
        if shader_wrapper.depth_test:
            self.context.enable(moderngl.DEPTH_TEST)
        else:
            self.context.disable(moderngl.DEPTH_TEST)

        # Render.
        mesh = Mesh(
            shader,
            shader_wrapper.vert_data,
            indices=shader_wrapper.vert_indices,
            use_depth_test=shader_wrapper.depth_test,
            primitive=mobject.render_primitive,
        )
        mesh.set_uniforms(self)
        mesh.render()

</t>
<t tx="ekr.20250122151621.337">def get_texture_id(self, path):
    if repr(path) not in self.path_to_texture_id:
        tid = len(self.path_to_texture_id)
        texture = self.context.texture(
            size=path.size,
            components=len(path.getbands()),
            data=path.tobytes(),
        )
        texture.repeat_x = False
        texture.repeat_y = False
        texture.filter = (moderngl.NEAREST, moderngl.NEAREST)
        texture.swizzle = "RRR1" if path.mode == "L" else "RGBA"
        texture.use(location=tid)
        self.path_to_texture_id[repr(path)] = tid

    return self.path_to_texture_id[repr(path)]

</t>
<t tx="ekr.20250122151621.338">def update_skipping_status(self) -&gt; None:
    """
    This method is used internally to check if the current
    animation needs to be skipped or not. It also checks if
    the number of animations that were played correspond to
    the number of animations that need to be played, and
    raises an EndSceneEarlyException if they don't correspond.
    """
    # there is always at least one section -&gt; no out of bounds here
    if self.file_writer.sections[-1].skip_animations:
        self.skip_animations = True
    if (
        config.from_animation_number &gt; 0
        and self.num_plays &lt; config.from_animation_number
    ):
        self.skip_animations = True
    if (
        config.upto_animation_number &gt;= 0
        and self.num_plays &gt; config.upto_animation_number
    ):
        self.skip_animations = True
        raise EndSceneEarlyException()

</t>
<t tx="ekr.20250122151621.339">@handle_caching_play
def play(self, scene, *args, **kwargs):
    # TODO: Handle data locking / unlocking.
    self.animation_start_time = time.time()
    self.file_writer.begin_animation(not self.skip_animations)

    scene.compile_animation_data(*args, **kwargs)
    scene.begin_animations()
    if scene.is_current_animation_frozen_frame():
        self.update_frame(scene)

        if not self.skip_animations:
            self.file_writer.write_frame(
                self, num_frames=int(config.frame_rate * scene.duration)
            )

        if self.window is not None:
            self.window.swap_buffers()
            while time.time() - self.animation_start_time &lt; scene.duration:
                pass
        self.animation_elapsed_time = scene.duration

    else:
        scene.play_internal()

    self.file_writer.end_animation(not self.skip_animations)
    self.time += scene.duration
    self.num_plays += 1

</t>
<t tx="ekr.20250122151621.34">class Cube(VGroup):
    """A three-dimensional cube.

    Parameters
    ----------
    side_length
        Length of each side of the :class:`Cube`.
    fill_opacity
        The opacity of the :class:`Cube`, from 0 being fully transparent to 1 being
        fully opaque. Defaults to 0.75.
    fill_color
        The color of the :class:`Cube`.
    stroke_width
        The width of the stroke surrounding each face of the :class:`Cube`.

    Examples
    --------

    .. manim:: CubeExample
        :save_last_frame:

        class CubeExample(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=75*DEGREES, theta=-45*DEGREES)

                axes = ThreeDAxes()
                cube = Cube(side_length=3, fill_opacity=0.7, fill_color=BLUE)
                self.add(cube)
    """

    @others
    init_points = generate_points


</t>
<t tx="ekr.20250122151621.340">def clear_screen(self):
    self.frame_buffer_object.clear(*self.background_color)
    self.window.swap_buffers()

</t>
<t tx="ekr.20250122151621.341">def render(self, scene, frame_offset, moving_mobjects):
    self.update_frame(scene)

    if self.skip_animations:
        return

    self.file_writer.write_frame(self)

    if self.window is not None:
        self.window.swap_buffers()
        while self.animation_elapsed_time &lt; frame_offset:
            self.update_frame(scene)
            self.window.swap_buffers()

</t>
<t tx="ekr.20250122151621.342">def update_frame(self, scene):
    self.frame_buffer_object.clear(*self.background_color)
    self.refresh_perspective_uniforms(scene.camera)

    for mobject in scene.mobjects:
        if not mobject.should_render:
            continue
        self.render_mobject(mobject)

    for obj in scene.meshes:
        for mesh in obj.get_meshes():
            mesh.set_uniforms(self)
            mesh.render()

    self.animation_elapsed_time = time.time() - self.animation_start_time

</t>
<t tx="ekr.20250122151621.343">def scene_finished(self, scene):
    # When num_plays is 0, no images have been output, so output a single
    # image in this case
    if self.num_plays &gt; 0:
        self.file_writer.finish()
    elif self.num_plays == 0 and config.write_to_movie:
        config.write_to_movie = False

    if self.should_save_last_frame():
        config.save_last_frame = True
        self.update_frame(scene)
        self.file_writer.save_final_image(self.get_image())

</t>
<t tx="ekr.20250122151621.344">def should_save_last_frame(self):
    if config["save_last_frame"]:
        return True
    if self.scene.interactive_mode:
        return False
    return self.num_plays == 0

</t>
<t tx="ekr.20250122151621.345">def get_image(self) -&gt; Image.Image:
    """Returns an image from the current frame. The first argument passed to image represents
    the mode RGB with the alpha channel A. The data we read is from the currently bound frame
    buffer. We pass in 'raw' as the name of the decoder, 0 and -1 args are specifically
    used for the decoder tand represent the stride and orientation. 0 means there is no
    padding expected between bytes and -1 represents the orientation and means the first
    line of the image is the bottom line on the screen.

    Returns
    -------
    PIL.Image
        The PIL image of the array.
    """
    raw_buffer_data = self.get_raw_frame_buffer_object_data()
    image = Image.frombytes(
        "RGBA",
        self.get_pixel_shape(),
        raw_buffer_data,
        "raw",
        "RGBA",
        0,
        -1,
    )
    return image

</t>
<t tx="ekr.20250122151621.346">def save_static_frame_data(self, scene, static_mobjects):
    pass

</t>
<t tx="ekr.20250122151621.347">def get_frame_buffer_object(self, context, samples=0):
    pixel_width = config["pixel_width"]
    pixel_height = config["pixel_height"]
    num_channels = 4
    return context.framebuffer(
        color_attachments=context.texture(
            (pixel_width, pixel_height),
            components=num_channels,
            samples=samples,
        ),
        depth_attachment=context.depth_renderbuffer(
            (pixel_width, pixel_height),
            samples=samples,
        ),
    )

</t>
<t tx="ekr.20250122151621.348">def get_raw_frame_buffer_object_data(self, dtype="f1"):
    # Copy blocks from the fbo_msaa to the drawn fbo using Blit
    # pw, ph = self.get_pixel_shape()
    # gl.glBindFramebuffer(gl.GL_READ_FRAMEBUFFER, self.fbo_msaa.glo)
    # gl.glBindFramebuffer(gl.GL_DRAW_FRAMEBUFFER, self.fbo.glo)
    # gl.glBlitFramebuffer(
    #     0, 0, pw, ph, 0, 0, pw, ph, gl.GL_COLOR_BUFFER_BIT, gl.GL_LINEAR
    # )
    num_channels = 4
    ret = self.frame_buffer_object.read(
        viewport=self.frame_buffer_object.viewport,
        components=num_channels,
        dtype=dtype,
    )
    return ret

</t>
<t tx="ekr.20250122151621.349">def get_frame(self):
    # get current pixel values as numpy data in order to test output
    raw = self.get_raw_frame_buffer_object_data(dtype="f1")
    pixel_shape = self.get_pixel_shape()
    result_dimensions = (pixel_shape[1], pixel_shape[0], 4)
    np_buf = np.frombuffer(raw, dtype="uint8").reshape(result_dimensions)
    np_buf = np.flipud(np_buf)
    return np_buf

</t>
<t tx="ekr.20250122151621.35">class Prism(Cube):
    """A right rectangular prism (or rectangular cuboid).
    Defined by the length of each side in ``[x, y, z]`` format.

    Parameters
    ----------
    dimensions
        Dimensions of the :class:`Prism` in ``[x, y, z]`` format.

    Examples
    --------

    .. manim:: ExamplePrism
        :save_last_frame:

        class ExamplePrism(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=60 * DEGREES, theta=150 * DEGREES)
                prismSmall = Prism(dimensions=[1, 2, 3]).rotate(PI / 2)
                prismLarge = Prism(dimensions=[1.5, 3, 4.5]).move_to([2, 0, 0])
                self.add(prismSmall, prismLarge)
    """

    @others
</t>
<t tx="ekr.20250122151621.350"># Returns offset from the bottom left corner in pixels.
# top_left flag should be set to True when using a GUI framework
# where the (0,0) is at the top left: e.g. PySide6
def pixel_coords_to_space_coords(self, px, py, relative=False, top_left=False):
    pixel_shape = self.get_pixel_shape()
    if pixel_shape is None:
        return np.array([0, 0, 0])
    pw, ph = pixel_shape
    fh = config["frame_height"]
    fc = self.camera.get_center()
    if relative:
        return 2 * np.array([px / pw, py / ph, 0])
    else:
        # Only scale wrt one axis
        scale = fh / ph
        return fc + scale * np.array(
            [(px - pw / 2), (-1 if top_left else 1) * (py - ph / 2), 0]
        )

</t>
<t tx="ekr.20250122151621.351">@property
def background_color(self):
    return self._background_color

</t>
<t tx="ekr.20250122151621.352">@background_color.setter
def background_color(self, value):
    self._background_color = color_to_rgba(value, 1.0)
</t>
<t tx="ekr.20250122151621.353">from __future__ import annotations

import moderngl_window as mglw
from moderngl_window.context.pyglet.window import Window as PygletWindow
from moderngl_window.timers.clock import Timer
from screeninfo import get_monitors

from .. import __version__, config

__all__ = ["Window"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.354">class Window(PygletWindow):
    @others
</t>
<t tx="ekr.20250122151621.355">fullscreen = False
resizable = True
gl_version = (3, 3)
vsync = True
cursor = True

def __init__(self, renderer, size=config.window_size, **kwargs):
    monitors = get_monitors()
    mon_index = config.window_monitor
    monitor = monitors[min(mon_index, len(monitors) - 1)]

    if size == "default":
        # make window_width half the width of the monitor
        # but make it full screen if --fullscreen

        window_width = monitor.width
        if not config.fullscreen:
            window_width //= 2

        #  by default window_height = 9/16 * window_width
        window_height = int(
            window_width * config.frame_height // config.frame_width,
        )
        size = (window_width, window_height)
    else:
        size = tuple(size)

    super().__init__(size=size)

    self.title = f"Manim Community {__version__}"
    self.size = size
    self.renderer = renderer

    mglw.activate_context(window=self)
    self.timer = Timer()
    self.config = mglw.WindowConfig(ctx=self.ctx, wnd=self, timer=self.timer)
    self.timer.start()

    self.swap_buffers()

    initial_position = self.find_initial_position(size, monitor)
    self.position = initial_position

</t>
<t tx="ekr.20250122151621.356"># Delegate event handling to scene.
def on_mouse_motion(self, x, y, dx, dy):
    super().on_mouse_motion(x, y, dx, dy)
    point = self.renderer.pixel_coords_to_space_coords(x, y)
    d_point = self.renderer.pixel_coords_to_space_coords(dx, dy, relative=True)
    self.renderer.scene.on_mouse_motion(point, d_point)

</t>
<t tx="ekr.20250122151621.357">def on_mouse_scroll(self, x, y, x_offset: float, y_offset: float):
    super().on_mouse_scroll(x, y, x_offset, y_offset)
    point = self.renderer.pixel_coords_to_space_coords(x, y)
    offset = self.renderer.pixel_coords_to_space_coords(
        x_offset,
        y_offset,
        relative=True,
    )
    self.renderer.scene.on_mouse_scroll(point, offset)

</t>
<t tx="ekr.20250122151621.358">def on_key_press(self, symbol, modifiers):
    self.renderer.pressed_keys.add(symbol)
    super().on_key_press(symbol, modifiers)
    self.renderer.scene.on_key_press(symbol, modifiers)

</t>
<t tx="ekr.20250122151621.359">def on_key_release(self, symbol, modifiers):
    if symbol in self.renderer.pressed_keys:
        self.renderer.pressed_keys.remove(symbol)
    super().on_key_release(symbol, modifiers)
    self.renderer.scene.on_key_release(symbol, modifiers)

</t>
<t tx="ekr.20250122151621.36">class Cone(Surface):
    """A circular cone.
    Can be defined using 2 parameters: its height, and its base radius.
    The polar angle, theta, can be calculated using arctan(base_radius /
    height) The spherical radius, r, is calculated using the pythagorean
    theorem.

    Parameters
    ----------
    base_radius
        The base radius from which the cone tapers.
    height
        The height measured from the plane formed by the base_radius to
        the apex of the cone.
    direction
        The direction of the apex.
    show_base
        Whether to show the base plane or not.
    v_range
        The azimuthal angle to start and end at.
    u_min
        The radius at the apex.
    checkerboard_colors
        Show checkerboard grid texture on the cone.

    Examples
    --------
    .. manim:: ExampleCone
        :save_last_frame:

        class ExampleCone(ThreeDScene):
            def construct(self):
                axes = ThreeDAxes()
                cone = Cone(direction=X_AXIS+Y_AXIS+2*Z_AXIS, resolution=8)
                self.set_camera_orientation(phi=5*PI/11, theta=PI/9)
                self.add(axes, cone)
    """

    @others
</t>
<t tx="ekr.20250122151621.360">def on_mouse_drag(self, x, y, dx, dy, buttons, modifiers):
    super().on_mouse_drag(x, y, dx, dy, buttons, modifiers)
    point = self.renderer.pixel_coords_to_space_coords(x, y)
    d_point = self.renderer.pixel_coords_to_space_coords(dx, dy, relative=True)
    self.renderer.scene.on_mouse_drag(point, d_point, buttons, modifiers)

</t>
<t tx="ekr.20250122151621.361">def find_initial_position(self, size, monitor):
    custom_position = config.window_position
    window_width, window_height = size
    # Position might be specified with a string of the form
    # x,y for integers x and y
    if len(custom_position) == 1:
        raise ValueError(
            "window_position must specify both Y and X positions (Y/X -&gt; UR). Also accepts LEFT/RIGHT/ORIGIN/UP/DOWN.",
        )
    # in the form Y/X (UR)
    if custom_position in ["LEFT", "RIGHT"]:
        custom_position = "O" + custom_position[0]
    elif custom_position in ["UP", "DOWN"]:
        custom_position = custom_position[0] + "O"
    elif custom_position == "ORIGIN":
        custom_position = "O" * 2
    elif "," in custom_position:
        return tuple(map(int, custom_position.split(",")))

    # Alternatively, it might be specified with a string like
    # UR, OO, DL, etc. specifying what corner it should go to
    char_to_n = {"L": 0, "U": 0, "O": 1, "R": 2, "D": 2}
    width_diff = monitor.width - window_width
    height_diff = monitor.height - window_height

    return (
        monitor.x + char_to_n[custom_position[1]] * width_diff // 2,
        -monitor.y + char_to_n[custom_position[0]] * height_diff // 2,
    )

</t>
<t tx="ekr.20250122151621.362">def on_mouse_press(self, x, y, button, modifiers):
    super().on_mouse_press(x, y, button, modifiers)
    point = self.renderer.pixel_coords_to_space_coords(x, y)
    mouse_button_map = {
        1: "LEFT",
        2: "MOUSE",
        4: "RIGHT",
    }
    self.renderer.scene.on_mouse_press(point, mouse_button_map[button], modifiers)
</t>
<t tx="ekr.20250122151621.363">from __future__ import annotations

import contextlib
import inspect
import re
import textwrap
from pathlib import Path

import moderngl
import numpy as np

from .. import config
from ..utils import opengl

SHADER_FOLDER = Path(__file__).parent / "shaders"
shader_program_cache: dict = {}
file_path_to_code_map: dict = {}

__all__ = [
    "Object3D",
    "Mesh",
    "Shader",
    "FullScreenQuad",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.364">def get_shader_code_from_file(file_path: Path) -&gt; str:
    if file_path in file_path_to_code_map:
        return file_path_to_code_map[file_path]
    source = file_path.read_text()
    include_lines = re.finditer(
        r"^#include (?P&lt;include_path&gt;.*\.glsl)$",
        source,
        flags=re.MULTILINE,
    )
    for match in include_lines:
        include_path = match.group("include_path")
        included_code = get_shader_code_from_file(
            file_path.parent / include_path,
        )
        source = source.replace(match.group(0), included_code)
    file_path_to_code_map[file_path] = source
    return source


</t>
<t tx="ekr.20250122151621.365">def filter_attributes(unfiltered_attributes, attributes):
    # Construct attributes for only those needed by the shader.
    filtered_attributes_dtype = []
    for i, dtype_name in enumerate(unfiltered_attributes.dtype.names):
        if dtype_name in attributes:
            filtered_attributes_dtype.append(
                (
                    dtype_name,
                    unfiltered_attributes.dtype[i].subdtype[0].str,
                    unfiltered_attributes.dtype[i].shape,
                ),
            )

    filtered_attributes = np.zeros(
        unfiltered_attributes[unfiltered_attributes.dtype.names[0]].shape[0],
        dtype=filtered_attributes_dtype,
    )

    for dtype_name in unfiltered_attributes.dtype.names:
        if dtype_name in attributes:
            filtered_attributes[dtype_name] = unfiltered_attributes[dtype_name]

    return filtered_attributes


</t>
<t tx="ekr.20250122151621.366">class Object3D:
    @others
</t>
<t tx="ekr.20250122151621.367">class Mesh(Object3D):
    @others
</t>
<t tx="ekr.20250122151621.368">class Shader:
    @others
</t>
<t tx="ekr.20250122151621.369">class FullScreenQuad(Mesh):
    @others
</t>
<t tx="ekr.20250122151621.37">class Cylinder(Surface):
    """A cylinder, defined by its height, radius and direction,

    Parameters
    ----------
    radius
        The radius of the cylinder.
    height
        The height of the cylinder.
    direction
        The direction of the central axis of the cylinder.
    v_range
        The height along the height axis (given by direction) to start and end on.
    show_ends
        Whether to show the end caps or not.
    resolution
        The number of samples taken of the :class:`Cylinder`. A tuple can be used
        to define different resolutions for ``u`` and ``v`` respectively.

    Examples
    --------
    .. manim:: ExampleCylinder
        :save_last_frame:

        class ExampleCylinder(ThreeDScene):
            def construct(self):
                axes = ThreeDAxes()
                cylinder = Cylinder(radius=2, height=3)
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                self.add(axes, cylinder)
    """

    @others
</t>
<t tx="ekr.20250122151621.370">def __init__(self, *children):
    self.model_matrix = np.eye(4)
    self.normal_matrix = np.eye(4)
    self.children = []
    self.parent = None
    self.add(*children)
    self.init_updaters()

</t>
<t tx="ekr.20250122151621.371"># TODO: Use path_func.
def interpolate(self, start, end, alpha, _):
    self.model_matrix = (1 - alpha) * start.model_matrix + alpha * end.model_matrix
    self.normal_matrix = (
        1 - alpha
    ) * start.normal_matrix + alpha * end.normal_matrix

</t>
<t tx="ekr.20250122151621.372">def single_copy(self):
    copy = Object3D()
    copy.model_matrix = self.model_matrix.copy()
    copy.normal_matrix = self.normal_matrix.copy()
    return copy

</t>
<t tx="ekr.20250122151621.373">def copy(self):
    node_to_copy = {}

    bfs = [self]
    while bfs:
        node = bfs.pop(0)
        bfs.extend(node.children)

        node_copy = node.single_copy()
        node_to_copy[node] = node_copy

        # Add the copy to the copy of the parent.
        if node.parent is not None and node is not self:
            node_to_copy[node.parent].add(node_copy)
    return node_to_copy[self]

</t>
<t tx="ekr.20250122151621.374">def add(self, *children):
    for child in children:
        if child.parent is not None:
            raise Exception(
                "Attempt to add child that's already added to another Object3D",
            )
    self.remove(*children, current_children_only=False)
    self.children.extend(children)
    for child in children:
        child.parent = self

</t>
<t tx="ekr.20250122151621.375">def remove(self, *children, current_children_only=True):
    if current_children_only:
        for child in children:
            if child.parent != self:
                raise Exception(
                    "Attempt to remove child that isn't added to this Object3D",
                )
    self.children = list(filter(lambda child: child not in children, self.children))
    for child in children:
        child.parent = None

</t>
<t tx="ekr.20250122151621.376">def get_position(self):
    return self.model_matrix[:, 3][:3]

</t>
<t tx="ekr.20250122151621.377">def set_position(self, position):
    self.model_matrix[:, 3][:3] = position
    return self

</t>
<t tx="ekr.20250122151621.378">def get_meshes(self):
    dfs = [self]
    while dfs:
        parent = dfs.pop()
        if isinstance(parent, Mesh):
            yield parent
        dfs.extend(parent.children)

</t>
<t tx="ekr.20250122151621.379">def get_family(self):
    dfs = [self]
    while dfs:
        parent = dfs.pop()
        yield parent
        dfs.extend(parent.children)

</t>
<t tx="ekr.20250122151621.38">class Line3D(Cylinder):
    """A cylindrical line, for use in ThreeDScene.

    Parameters
    ----------
    start
        The start point of the line.
    end
        The end point of the line.
    thickness
        The thickness of the line.
    color
        The color of the line.
    resolution
        The resolution of the line.
        By default this value is the number of points the line will sampled at.
        If you want the line to also come out checkered, use a tuple.
        For example, for a line made of 24 points with 4 checker points on each
        cylinder, pass the tuple (4, 24).

    Examples
    --------
    .. manim:: ExampleLine3D
        :save_last_frame:

        class ExampleLine3D(ThreeDScene):
            def construct(self):
                axes = ThreeDAxes()
                line = Line3D(start=np.array([0, 0, 0]), end=np.array([2, 2, 2]))
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                self.add(axes, line)
    """

    @others
</t>
<t tx="ekr.20250122151621.380">def align_data_and_family(self, _):
    pass

</t>
<t tx="ekr.20250122151621.381">def hierarchical_model_matrix(self):
    if self.parent is None:
        return self.model_matrix

    model_matrices = [self.model_matrix]
    current_object = self
    while current_object.parent is not None:
        model_matrices.append(current_object.parent.model_matrix)
        current_object = current_object.parent
    return np.linalg.multi_dot(list(reversed(model_matrices)))

</t>
<t tx="ekr.20250122151621.382">def hierarchical_normal_matrix(self):
    if self.parent is None:
        return self.normal_matrix[:3, :3]

    normal_matrices = [self.normal_matrix]
    current_object = self
    while current_object.parent is not None:
        normal_matrices.append(current_object.parent.model_matrix)
        current_object = current_object.parent
    return np.linalg.multi_dot(list(reversed(normal_matrices)))[:3, :3]

</t>
<t tx="ekr.20250122151621.383">def init_updaters(self):
    self.time_based_updaters = []
    self.non_time_updaters = []
    self.has_updaters = False
    self.updating_suspended = False

</t>
<t tx="ekr.20250122151621.384">def update(self, dt=0):
    if not self.has_updaters or self.updating_suspended:
        return self
    for updater in self.time_based_updaters:
        updater(self, dt)
    for updater in self.non_time_updaters:
        updater(self)
    return self

</t>
<t tx="ekr.20250122151621.385">def get_time_based_updaters(self):
    return self.time_based_updaters

</t>
<t tx="ekr.20250122151621.386">def has_time_based_updater(self):
    return len(self.time_based_updaters) &gt; 0

</t>
<t tx="ekr.20250122151621.387">def get_updaters(self):
    return self.time_based_updaters + self.non_time_updaters

</t>
<t tx="ekr.20250122151621.388">def add_updater(self, update_function, index=None, call_updater=True):
    if "dt" in inspect.signature(update_function).parameters:
        updater_list = self.time_based_updaters
    else:
        updater_list = self.non_time_updaters

    if index is None:
        updater_list.append(update_function)
    else:
        updater_list.insert(index, update_function)

    self.refresh_has_updater_status()
    if call_updater:
        self.update()
    return self

</t>
<t tx="ekr.20250122151621.389">def remove_updater(self, update_function):
    for updater_list in [self.time_based_updaters, self.non_time_updaters]:
        while update_function in updater_list:
            updater_list.remove(update_function)
    self.refresh_has_updater_status()
    return self

</t>
<t tx="ekr.20250122151621.39">class Arrow3D(Line3D):
    """An arrow made out of a cylindrical line and a conical tip.

    Parameters
    ----------
    start
        The start position of the arrow.
    end
        The end position of the arrow.
    thickness
        The thickness of the arrow.
    height
        The height of the conical tip.
    base_radius
        The base radius of the conical tip.
    color
        The color of the arrow.
    resolution
        The resolution of the arrow line.

    Examples
    --------
    .. manim:: ExampleArrow3D
        :save_last_frame:

        class ExampleArrow3D(ThreeDScene):
            def construct(self):
                axes = ThreeDAxes()
                arrow = Arrow3D(
                    start=np.array([0, 0, 0]),
                    end=np.array([2, 2, 2]),
                    resolution=8
                )
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                self.add(axes, arrow)
    """

    @others
</t>
<t tx="ekr.20250122151621.390">def clear_updaters(self):
    self.time_based_updaters = []
    self.non_time_updaters = []
    self.refresh_has_updater_status()
    return self

</t>
<t tx="ekr.20250122151621.391">def match_updaters(self, mobject):
    self.clear_updaters()
    for updater in mobject.get_updaters():
        self.add_updater(updater)
    return self

</t>
<t tx="ekr.20250122151621.392">def suspend_updating(self):
    self.updating_suspended = True
    return self

</t>
<t tx="ekr.20250122151621.393">def resume_updating(self, call_updater=True):
    self.updating_suspended = False
    if call_updater:
        self.update(dt=0)
    return self

</t>
<t tx="ekr.20250122151621.394">def refresh_has_updater_status(self):
    self.has_updaters = len(self.get_updaters()) &gt; 0
    return self


</t>
<t tx="ekr.20250122151621.395">def __init__(
    self,
    shader=None,
    attributes=None,
    geometry=None,
    material=None,
    indices=None,
    use_depth_test=True,
    primitive=moderngl.TRIANGLES,
):
    super().__init__()
    if shader is not None and attributes is not None:
        self.shader = shader
        self.attributes = attributes
        self.indices = indices
    elif geometry is not None and material is not None:
        self.shader = material
        self.attributes = geometry.attributes
        self.indices = geometry.index
    else:
        raise Exception(
            "Mesh requires either attributes and a Shader or a Geometry and a "
            "Material",
        )
    self.use_depth_test = use_depth_test
    self.primitive = primitive
    self.skip_render = False
    self.init_updaters()

</t>
<t tx="ekr.20250122151621.396">def single_copy(self):
    copy = Mesh(
        attributes=self.attributes.copy(),
        shader=self.shader,
        indices=self.indices.copy() if self.indices is not None else None,
        use_depth_test=self.use_depth_test,
        primitive=self.primitive,
    )
    copy.skip_render = self.skip_render
    copy.model_matrix = self.model_matrix.copy()
    copy.normal_matrix = self.normal_matrix.copy()
    # TODO: Copy updaters?
    return copy

</t>
<t tx="ekr.20250122151621.397">def set_uniforms(self, renderer):
    self.shader.set_uniform(
        "u_model_matrix",
        opengl.matrix_to_shader_input(self.model_matrix),
    )
    self.shader.set_uniform("u_view_matrix", renderer.camera.formatted_view_matrix)
    self.shader.set_uniform(
        "u_projection_matrix",
        renderer.camera.projection_matrix,
    )

</t>
<t tx="ekr.20250122151621.398">def render(self):
    if self.skip_render:
        return

    if self.use_depth_test:
        self.shader.context.enable(moderngl.DEPTH_TEST)
    else:
        self.shader.context.disable(moderngl.DEPTH_TEST)

    from moderngl import Attribute

    shader_attributes = []
    for k, v in self.shader.shader_program._members.items():
        if isinstance(v, Attribute):
            shader_attributes.append(k)
    shader_attributes = filter_attributes(self.attributes, shader_attributes)

    vertex_buffer_object = self.shader.context.buffer(shader_attributes.tobytes())
    if self.indices is None:
        index_buffer_object = None
    else:
        vert_index_data = self.indices.astype("i4").tobytes()
        if vert_index_data:
            index_buffer_object = self.shader.context.buffer(vert_index_data)
        else:
            index_buffer_object = None
    vertex_array_object = self.shader.context.simple_vertex_array(
        self.shader.shader_program,
        vertex_buffer_object,
        *shader_attributes.dtype.names,
        index_buffer=index_buffer_object,
    )
    vertex_array_object.render(self.primitive)
    vertex_buffer_object.release()
    vertex_array_object.release()
    if index_buffer_object is not None:
        index_buffer_object.release()


</t>
<t tx="ekr.20250122151621.399">def __init__(
    self,
    context,
    name=None,
    source=None,
):
    global shader_program_cache
    self.context = context
    self.name = name

    # See if the program is cached.
    if (
        self.name in shader_program_cache
        and shader_program_cache[self.name].ctx == self.context
    ):
        self.shader_program = shader_program_cache[self.name]
    elif source is not None:
        # Generate the shader from inline code if it was passed.
        self.shader_program = context.program(**source)
    else:
        # Search for a file containing the shader.
        source_dict = {}
        source_dict_key = {
            "vert": "vertex_shader",
            "frag": "fragment_shader",
            "geom": "geometry_shader",
        }
        shader_folder = SHADER_FOLDER / name
        for shader_file in shader_folder.iterdir():
            shader_file_path = shader_folder / shader_file
            shader_source = get_shader_code_from_file(shader_file_path)
            source_dict[source_dict_key[shader_file_path.stem]] = shader_source
        self.shader_program = context.program(**source_dict)

    # Cache the shader.
    if name is not None and name not in shader_program_cache:
        shader_program_cache[self.name] = self.shader_program

</t>
<t tx="ekr.20250122151621.4">class Polyhedron(VGroup):
    """An abstract polyhedra class.

    In this implementation, polyhedra are defined with a list of vertex coordinates in space, and a list
    of faces. This implementation mirrors that of a standard polyhedral data format (OFF, object file format).

    Parameters
    ----------
    vertex_coords
        A list of coordinates of the corresponding vertices in the polyhedron. Each coordinate will correspond to
        a vertex. The vertices are indexed with the usual indexing of Python.
    faces_list
        A list of faces. Each face is a sublist containing the indices of the vertices that form the corners of that face.
    faces_config
        Configuration for the polygons representing the faces of the polyhedron.
    graph_config
        Configuration for the graph containing the vertices and edges of the polyhedron.

    Examples
    --------
    To understand how to create a custom polyhedra, let's use the example of a rather simple one - a square pyramid.

    .. manim:: SquarePyramidScene
        :save_last_frame:

        class SquarePyramidScene(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                vertex_coords = [
                    [1, 1, 0],
                    [1, -1, 0],
                    [-1, -1, 0],
                    [-1, 1, 0],
                    [0, 0, 2]
                ]
                faces_list = [
                    [0, 1, 4],
                    [1, 2, 4],
                    [2, 3, 4],
                    [3, 0, 4],
                    [0, 1, 2, 3]
                ]
                pyramid = Polyhedron(vertex_coords, faces_list)
                self.add(pyramid)

    In defining the polyhedron above, we first defined the coordinates of the vertices.
    These are the corners of the square base, given as the first four coordinates in the vertex list,
    and the apex, the last coordinate in the list.

    Next, we define the faces of the polyhedron. The triangular surfaces of the pyramid are polygons
    with two adjacent vertices in the base and the vertex at the apex as corners. We thus define these
    surfaces in the first four elements of our face list. The last element defines the base of the pyramid.

    The graph and faces of polyhedra can also be accessed and modified directly, after instantiation.
    They are stored in the `graph` and `faces` attributes respectively.

    .. manim:: PolyhedronSubMobjects
        :save_last_frame:

        class PolyhedronSubMobjects(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                octahedron = Octahedron(edge_length = 3)
                octahedron.graph[0].set_color(RED)
                octahedron.faces[2].set_color(YELLOW)
                self.add(octahedron)
    """

    @others
</t>
<t tx="ekr.20250122151621.40">class Torus(Surface):
    """A torus.

    Parameters
    ----------
    major_radius
        Distance from the center of the tube to the center of the torus.
    minor_radius
        Radius of the tube.
    u_range
        The range of the ``u`` variable: ``(u_min, u_max)``.
    v_range
        The range of the ``v`` variable: ``(v_min, v_max)``.
    resolution
        The number of samples taken of the :class:`Torus`. A tuple can be
        used to define different resolutions for ``u`` and ``v`` respectively.

    Examples
    --------
    .. manim :: ExampleTorus
        :save_last_frame:

        class ExampleTorus(ThreeDScene):
            def construct(self):
                axes = ThreeDAxes()
                torus = Torus()
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                self.add(axes, torus)
    """

    @others
</t>
<t tx="ekr.20250122151621.400">def set_uniform(self, name, value):
    with contextlib.suppress(KeyError):
        self.shader_program[name] = value


</t>
<t tx="ekr.20250122151621.401">def __init__(
    self,
    context,
    fragment_shader_source=None,
    fragment_shader_name=None,
):
    if fragment_shader_source is None and fragment_shader_name is None:
        raise Exception("Must either pass shader name or shader source.")

    if fragment_shader_name is not None:
        # Use the name.
        shader_file_path = SHADER_FOLDER / f"{fragment_shader_name}.frag"
        fragment_shader_source = get_shader_code_from_file(shader_file_path)
    elif fragment_shader_source is not None:
        fragment_shader_source = textwrap.dedent(fragment_shader_source.lstrip())

    shader = Shader(
        context,
        source={
            "vertex_shader": """
            #version 330
            in vec4 in_vert;
            uniform mat4 u_model_view_matrix;
            uniform mat4 u_projection_matrix;
            void main() {{
                vec4 camera_space_vertex = u_model_view_matrix * in_vert;
                vec4 clip_space_vertex = u_projection_matrix * camera_space_vertex;
                gl_Position = clip_space_vertex;
            }}
            """,
            "fragment_shader": fragment_shader_source,
        },
    )
    attributes = np.zeros(6, dtype=[("in_vert", np.float32, (4,))])
    attributes["in_vert"] = np.array(
        [
            [-config["frame_x_radius"], -config["frame_y_radius"], 0, 1],
            [-config["frame_x_radius"], config["frame_y_radius"], 0, 1],
            [config["frame_x_radius"], config["frame_y_radius"], 0, 1],
            [-config["frame_x_radius"], -config["frame_y_radius"], 0, 1],
            [config["frame_x_radius"], -config["frame_y_radius"], 0, 1],
            [config["frame_x_radius"], config["frame_y_radius"], 0, 1],
        ],
    )
    shader.set_uniform("u_model_view_matrix", opengl.view_matrix())
    shader.set_uniform(
        "u_projection_matrix",
        opengl.orthographic_projection_matrix(),
    )
    super().__init__(shader, attributes)

</t>
<t tx="ekr.20250122151621.402">def render(self):
    super().render()
</t>
<t tx="ekr.20250122151621.403">from __future__ import annotations

import copy
import logging
import re
from pathlib import Path

import moderngl
import numpy as np

# Mobjects that should be rendered with
# the same shader will be organized and
# clumped together based on keeping track
# of a dict holding all the relevant information
# to that shader

__all__ = ["ShaderWrapper"]

logger = logging.getLogger("manim")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.404">def get_shader_dir():
    return Path(__file__).parent / "shaders"


</t>
<t tx="ekr.20250122151621.405">def find_file(file_name: Path, directories: list[Path]) -&gt; Path:
    # Check if what was passed in is already a valid path to a file
    if file_name.exists():
        return file_name
    possible_paths = (directory / file_name for directory in directories)
    for path in possible_paths:
        if path.exists():
            return path
        else:
            logger.debug(f"{path} does not exist.")
    raise OSError(f"{file_name} not Found")


</t>
<t tx="ekr.20250122151621.406">class ShaderWrapper:
    @others
</t>
<t tx="ekr.20250122151621.407"># For caching
filename_to_code_map: dict = {}


def get_shader_code_from_file(filename: Path) -&gt; str | None:
    if filename in filename_to_code_map:
        return filename_to_code_map[filename]

    try:
        filepath = find_file(
            filename,
            directories=[get_shader_dir(), Path("/")],
        )
    except OSError:
        return None

    result = filepath.read_text()

    # To share functionality between shaders, some functions are read in
    # from other files an inserted into the relevant strings before
    # passing to ctx.program for compiling
    # Replace "#INSERT " lines with relevant code
    insertions = re.findall(
        r"^#include ../include/.*\.glsl$",
        result,
        flags=re.MULTILINE,
    )
    for line in insertions:
        inserted_code = get_shader_code_from_file(
            Path() / "include" / line.replace("#include ../include/", ""),
        )
        if inserted_code is None:
            return None
        result = result.replace(line, inserted_code)
    filename_to_code_map[filename] = result
    return result


</t>
<t tx="ekr.20250122151621.408">def get_colormap_code(rgb_list):
    data = ",".join("vec3({}, {}, {})".format(*rgb) for rgb in rgb_list)
    return f"vec3[{len(rgb_list)}]({data})"
</t>
<t tx="ekr.20250122151621.409">def __init__(
    self,
    vert_data=None,
    vert_indices=None,
    shader_folder=None,
    uniforms=None,  # A dictionary mapping names of uniform variables
    texture_paths=None,  # A dictionary mapping names to filepaths for textures.
    depth_test=False,
    render_primitive=moderngl.TRIANGLE_STRIP,
):
    self.vert_data = vert_data
    self.vert_indices = vert_indices
    self.vert_attributes = vert_data.dtype.names
    self.shader_folder = Path(shader_folder or "")
    self.uniforms = uniforms or {}
    self.texture_paths = texture_paths or {}
    self.depth_test = depth_test
    self.render_primitive = str(render_primitive)
    self.init_program_code()
    self.refresh_id()

</t>
<t tx="ekr.20250122151621.41">def __init__(self, shade_in_3d: bool = True, **kwargs):
    super().__init__(shade_in_3d=shade_in_3d, **kwargs)


</t>
<t tx="ekr.20250122151621.410">def copy(self):
    result = copy.copy(self)
    result.vert_data = np.array(self.vert_data)
    if result.vert_indices is not None:
        result.vert_indices = np.array(self.vert_indices)
    if self.uniforms:
        result.uniforms = dict(self.uniforms)
    if self.texture_paths:
        result.texture_paths = dict(self.texture_paths)
    return result

</t>
<t tx="ekr.20250122151621.411">def is_valid(self):
    return all(
        [
            self.vert_data is not None,
            self.program_code["vertex_shader"] is not None,
            self.program_code["fragment_shader"] is not None,
        ],
    )

</t>
<t tx="ekr.20250122151621.412">def get_id(self):
    return self.id

</t>
<t tx="ekr.20250122151621.413">def get_program_id(self):
    return self.program_id

</t>
<t tx="ekr.20250122151621.414">def create_id(self):
    # A unique id for a shader
    return "|".join(
        map(
            str,
            [
                self.program_id,
                self.uniforms,
                self.texture_paths,
                self.depth_test,
                self.render_primitive,
            ],
        ),
    )

</t>
<t tx="ekr.20250122151621.415">def refresh_id(self):
    self.program_id = self.create_program_id()
    self.id = self.create_id()

</t>
<t tx="ekr.20250122151621.416">def create_program_id(self):
    return hash(
        "".join(
            self.program_code[f"{name}_shader"] or ""
            for name in ("vertex", "geometry", "fragment")
        ),
    )

</t>
<t tx="ekr.20250122151621.417">def init_program_code(self):
    def get_code(name: str) -&gt; str | None:
        return get_shader_code_from_file(
            self.shader_folder / f"{name}.glsl",
        )

    self.program_code = {
        "vertex_shader": get_code("vert"),
        "geometry_shader": get_code("geom"),
        "fragment_shader": get_code("frag"),
    }

</t>
<t tx="ekr.20250122151621.418">def get_program_code(self):
    return self.program_code

</t>
<t tx="ekr.20250122151621.419">def replace_code(self, old, new):
    code_map = self.program_code
    for name, _code in code_map.items():
        if code_map[name] is None:
            continue
        code_map[name] = re.sub(old, new, code_map[name])
    self.refresh_id()

</t>
<t tx="ekr.20250122151621.42">def __init__(
    self,
    func: Callable[[float, float], np.ndarray],
    u_range: Sequence[float] = [0, 1],
    v_range: Sequence[float] = [0, 1],
    resolution: Sequence[int] = 32,
    surface_piece_config: dict = {},
    fill_color: ParsableManimColor = BLUE_D,
    fill_opacity: float = 1.0,
    checkerboard_colors: Sequence[ParsableManimColor] | bool = [BLUE_D, BLUE_E],
    stroke_color: ParsableManimColor = LIGHT_GREY,
    stroke_width: float = 0.5,
    should_make_jagged: bool = False,
    pre_function_handle_to_anchor_scale_factor: float = 0.00001,
    **kwargs: Any,
) -&gt; None:
    self.u_range = u_range
    self.v_range = v_range
    super().__init__(**kwargs)
    self.resolution = resolution
    self.surface_piece_config = surface_piece_config
    self.fill_color: ManimColor = ManimColor(fill_color)
    self.fill_opacity = fill_opacity
    if checkerboard_colors:
        self.checkerboard_colors: list[ManimColor] = [
            ManimColor(x) for x in checkerboard_colors
        ]
    else:
        self.checkerboard_colors = checkerboard_colors
    self.stroke_color: ManimColor = ManimColor(stroke_color)
    self.stroke_width = stroke_width
    self.should_make_jagged = should_make_jagged
    self.pre_function_handle_to_anchor_scale_factor = (
        pre_function_handle_to_anchor_scale_factor
    )
    self._func = func
    self._setup_in_uv_space()
    self.apply_function(lambda p: func(p[0], p[1]))
    if self.should_make_jagged:
        self.make_jagged()

</t>
<t tx="ekr.20250122151621.420">def combine_with(self, *shader_wrappers):
    # Assume they are of the same type
    if len(shader_wrappers) == 0:
        return
    if self.vert_indices is not None:
        num_verts = len(self.vert_data)
        indices_list = [self.vert_indices]
        data_list = [self.vert_data]
        for sw in shader_wrappers:
            indices_list.append(sw.vert_indices + num_verts)
            data_list.append(sw.vert_data)
            num_verts += len(sw.vert_data)
        self.vert_indices = np.hstack(indices_list)
        self.vert_data = np.hstack(data_list)
    else:
        self.vert_data = np.hstack(
            [self.vert_data, *(sw.vert_data for sw in shader_wrappers)],
        )
    return self


</t>
<t tx="ekr.20250122151621.421">from __future__ import annotations

import collections

import numpy as np

from ..utils import opengl
from ..utils.space_ops import cross2d, earclip_triangulation
from .shader import Shader

__all__ = [
    "render_opengl_vectorized_mobject_fill",
    "render_opengl_vectorized_mobject_stroke",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.422">def build_matrix_lists(mob):
    root_hierarchical_matrix = mob.hierarchical_model_matrix()
    matrix_to_mobject_list = collections.defaultdict(list)
    if mob.has_points():
        matrix_to_mobject_list[tuple(root_hierarchical_matrix.ravel())].append(mob)
    mobject_to_hierarchical_matrix = {mob: root_hierarchical_matrix}
    dfs = [mob]
    while dfs:
        parent = dfs.pop()
        for child in parent.submobjects:
            child_hierarchical_matrix = (
                mobject_to_hierarchical_matrix[parent] @ child.model_matrix
            )
            mobject_to_hierarchical_matrix[child] = child_hierarchical_matrix
            if child.has_points():
                matrix_to_mobject_list[tuple(child_hierarchical_matrix.ravel())].append(
                    child,
                )
            dfs.append(child)
    return matrix_to_mobject_list


</t>
<t tx="ekr.20250122151621.423">def render_opengl_vectorized_mobject_fill(renderer, mobject):
    matrix_to_mobject_list = build_matrix_lists(mobject)

    for matrix_tuple, mobject_list in matrix_to_mobject_list.items():
        model_matrix = np.array(matrix_tuple).reshape((4, 4))
        render_mobject_fills_with_matrix(renderer, model_matrix, mobject_list)


</t>
<t tx="ekr.20250122151621.424">def render_mobject_fills_with_matrix(renderer, model_matrix, mobjects):
    # Precompute the total number of vertices for which to reserve space.
    # Note that triangulate_mobject() will cache its results.
    total_size = 0
    for submob in mobjects:
        total_size += triangulate_mobject(submob).shape[0]

    attributes = np.empty(
        total_size,
        dtype=[
            ("in_vert", np.float32, (3,)),
            ("in_color", np.float32, (4,)),
            ("texture_coords", np.float32, (2,)),
            ("texture_mode", np.int32),
        ],
    )

    write_offset = 0
    for submob in mobjects:
        if not submob.has_points():
            continue
        mobject_triangulation = triangulate_mobject(submob)
        end_offset = write_offset + mobject_triangulation.shape[0]
        attributes[write_offset:end_offset] = mobject_triangulation
        attributes["in_color"][write_offset:end_offset] = np.repeat(
            submob.fill_rgba,
            mobject_triangulation.shape[0],
            axis=0,
        )
        write_offset = end_offset

    fill_shader = Shader(renderer.context, name="vectorized_mobject_fill")
    fill_shader.set_uniform(
        "u_model_view_matrix",
        opengl.matrix_to_shader_input(
            renderer.camera.unformatted_view_matrix @ model_matrix,
        ),
    )
    fill_shader.set_uniform(
        "u_projection_matrix",
        renderer.scene.camera.projection_matrix,
    )

    vbo = renderer.context.buffer(attributes.tobytes())
    vao = renderer.context.simple_vertex_array(
        fill_shader.shader_program,
        vbo,
        *attributes.dtype.names,
    )
    vao.render()
    vao.release()
    vbo.release()


</t>
<t tx="ekr.20250122151621.425">def triangulate_mobject(mob):
    if not mob.needs_new_triangulation:
        return mob.triangulation

    # Figure out how to triangulate the interior to know
    # how to send the points as to the vertex shader.
    # First triangles come directly from the points
    # normal_vector = mob.get_unit_normal()
    points = mob.points

    b0s = points[0::3]
    b1s = points[1::3]
    b2s = points[2::3]
    v01s = b1s - b0s
    v12s = b2s - b1s

    crosses = cross2d(v01s, v12s)
    convexities = np.sign(crosses)
    if mob.orientation == 1:
        concave_parts = convexities &gt; 0
        convex_parts = convexities &lt;= 0
    else:
        concave_parts = convexities &lt; 0
        convex_parts = convexities &gt;= 0

    # These are the vertices to which we'll apply a polygon triangulation
    atol = mob.tolerance_for_point_equality
    end_of_loop = np.zeros(len(b0s), dtype=bool)
    end_of_loop[:-1] = (np.abs(b2s[:-1] - b0s[1:]) &gt; atol).any(1)
    end_of_loop[-1] = True

    indices = np.arange(len(points), dtype=int)
    inner_vert_indices = np.hstack(
        [
            indices[0::3],
            indices[1::3][concave_parts],
            indices[2::3][end_of_loop],
        ],
    )
    inner_vert_indices.sort()
    rings = np.arange(1, len(inner_vert_indices) + 1)[inner_vert_indices % 3 == 2]

    # Triangulate
    inner_verts = points[inner_vert_indices]
    inner_tri_indices = inner_vert_indices[earclip_triangulation(inner_verts, rings)]

    bezier_triangle_indices = np.reshape(indices, (-1, 3))
    concave_triangle_indices = np.reshape(bezier_triangle_indices[concave_parts], (-1))
    convex_triangle_indices = np.reshape(bezier_triangle_indices[convex_parts], (-1))

    points = points[
        np.hstack(
            [
                concave_triangle_indices,
                convex_triangle_indices,
                inner_tri_indices,
            ],
        )
    ]
    texture_coords = np.tile(
        [
            [0.0, 0.0],
            [0.5, 0.0],
            [1.0, 1.0],
        ],
        (points.shape[0] // 3, 1),
    )
    texture_mode = np.hstack(
        (
            np.ones(concave_triangle_indices.shape[0]),
            -1 * np.ones(convex_triangle_indices.shape[0]),
            np.zeros(inner_tri_indices.shape[0]),
        ),
    )

    attributes = np.zeros(
        points.shape[0],
        dtype=[
            ("in_vert", np.float32, (3,)),
            ("in_color", np.float32, (4,)),
            ("texture_coords", np.float32, (2,)),
            ("texture_mode", np.int32),
        ],
    )
    attributes["in_vert"] = points
    attributes["texture_coords"] = texture_coords
    attributes["texture_mode"] = texture_mode

    mob.triangulation = attributes
    mob.needs_new_triangulation = False

    return attributes


</t>
<t tx="ekr.20250122151621.426">def render_opengl_vectorized_mobject_stroke(renderer, mobject):
    matrix_to_mobject_list = build_matrix_lists(mobject)
    for matrix_tuple, mobject_list in matrix_to_mobject_list.items():
        model_matrix = np.array(matrix_tuple).reshape((4, 4))
        render_mobject_strokes_with_matrix(renderer, model_matrix, mobject_list)


</t>
<t tx="ekr.20250122151621.427">def render_mobject_strokes_with_matrix(renderer, model_matrix, mobjects):
    # Precompute the total number of vertices for which to reserve space.
    total_size = 0
    for submob in mobjects:
        total_size += submob.points.shape[0]

    points = np.empty((total_size, 3))
    colors = np.empty((total_size, 4))
    widths = np.empty(total_size)

    write_offset = 0
    for submob in mobjects:
        if not submob.has_points():
            continue
        end_offset = write_offset + submob.points.shape[0]

        points[write_offset:end_offset] = submob.points
        if submob.stroke_rgba.shape[0] == points[write_offset:end_offset].shape[0]:
            colors[write_offset:end_offset] = submob.stroke_rgba
        else:
            colors[write_offset:end_offset] = np.repeat(
                submob.stroke_rgba,
                submob.points.shape[0],
                axis=0,
            )
        widths[write_offset:end_offset] = np.repeat(
            submob.stroke_width,
            submob.points.shape[0],
        )
        write_offset = end_offset

    stroke_data = np.zeros(
        len(points),
        dtype=[
            # ("previous_curve", np.float32, (3, 3)),
            ("current_curve", np.float32, (3, 3)),
            # ("next_curve", np.float32, (3, 3)),
            ("tile_coordinate", np.float32, (2,)),
            ("in_color", np.float32, (4,)),
            ("in_width", np.float32),
        ],
    )

    stroke_data["in_color"] = colors
    stroke_data["in_width"] = widths
    curves = np.reshape(points, (-1, 3, 3))
    # stroke_data["previous_curve"] = np.repeat(np.roll(curves, 1, axis=0), 3, axis=0)
    stroke_data["current_curve"] = np.repeat(curves, 3, axis=0)
    # stroke_data["next_curve"] = np.repeat(np.roll(curves, -1, axis=0), 3, axis=0)

    # Repeat each vertex in order to make a tile.
    stroke_data = np.tile(stroke_data, 2)
    stroke_data["tile_coordinate"] = np.vstack(
        (
            np.tile(
                [
                    [0.0, 0.0],
                    [0.0, 1.0],
                    [1.0, 1.0],
                ],
                (len(points) // 3, 1),
            ),
            np.tile(
                [
                    [0.0, 0.0],
                    [1.0, 0.0],
                    [1.0, 1.0],
                ],
                (len(points) // 3, 1),
            ),
        ),
    )

    shader = Shader(renderer.context, "vectorized_mobject_stroke")
    shader.set_uniform(
        "u_model_view_matrix",
        opengl.matrix_to_shader_input(
            renderer.camera.unformatted_view_matrix @ model_matrix,
        ),
    )
    shader.set_uniform("u_projection_matrix", renderer.scene.camera.projection_matrix)
    shader.set_uniform("manim_unit_normal", tuple(-mobjects[0].unit_normal[0]))

    vbo = renderer.context.buffer(stroke_data.tobytes())
    vao = renderer.context.simple_vertex_array(
        shader.shader_program, vbo, *stroke_data.dtype.names
    )
    renderer.frame_buffer_object.use()
    vao.render()
    vao.release()
    vbo.release()
</t>
<t tx="ekr.20250122151621.429"></t>
<t tx="ekr.20250122151621.43">def func(self, u: float, v: float) -&gt; np.ndarray:
    return self._func(u, v)

</t>
<t tx="ekr.20250122151621.430"></t>
<t tx="ekr.20250122151621.431">"""A scene whose camera can be moved around.

.. SEEALSO::

    :mod:`.moving_camera`


Examples
--------

.. manim:: ChangingCameraWidthAndRestore

    class ChangingCameraWidthAndRestore(MovingCameraScene):
        def construct(self):
            text = Text("Hello World").set_color(BLUE)
            self.add(text)
            self.camera.frame.save_state()
            self.play(self.camera.frame.animate.set(width=text.width * 1.2))
            self.wait(0.3)
            self.play(Restore(self.camera.frame))


.. manim:: MovingCameraCenter

    class MovingCameraCenter(MovingCameraScene):
        def construct(self):
            s = Square(color=RED, fill_opacity=0.5).move_to(2 * LEFT)
            t = Triangle(color=GREEN, fill_opacity=0.5).move_to(2 * RIGHT)
            self.wait(0.3)
            self.add(s, t)
            self.play(self.camera.frame.animate.move_to(s))
            self.wait(0.3)
            self.play(self.camera.frame.animate.move_to(t))


.. manim:: MovingAndZoomingCamera

    class MovingAndZoomingCamera(MovingCameraScene):
        def construct(self):
            s = Square(color=BLUE, fill_opacity=0.5).move_to(2 * LEFT)
            t = Triangle(color=YELLOW, fill_opacity=0.5).move_to(2 * RIGHT)
            self.add(s, t)
            self.play(self.camera.frame.animate.move_to(s).set(width=s.width*2))
            self.wait(0.3)
            self.play(self.camera.frame.animate.move_to(t).set(width=t.width*2))

            self.play(self.camera.frame.animate.move_to(ORIGIN).set(width=14))

.. manim:: MovingCameraOnGraph

    class MovingCameraOnGraph(MovingCameraScene):
        def construct(self):
            self.camera.frame.save_state()

            ax = Axes(x_range=[-1, 10], y_range=[-1, 10])
            graph = ax.plot(lambda x: np.sin(x), color=WHITE, x_range=[0, 3 * PI])

            dot_1 = Dot(ax.i2gp(graph.t_min, graph))
            dot_2 = Dot(ax.i2gp(graph.t_max, graph))
            self.add(ax, graph, dot_1, dot_2)

            self.play(self.camera.frame.animate.scale(0.5).move_to(dot_1))
            self.play(self.camera.frame.animate.move_to(dot_2))
            self.play(Restore(self.camera.frame))
            self.wait()

.. manim:: SlidingMultipleScenes

    class SlidingMultipleScenes(MovingCameraScene):
        def construct(self):
            def create_scene(number):
                frame = Rectangle(width=16,height=9)
                circ = Circle().shift(LEFT)
                text = Tex(f"This is Scene {str(number)}").next_to(circ, RIGHT)
                frame.add(circ,text)
                return frame

            group = VGroup(*(create_scene(i) for i in range(4))).arrange_in_grid(buff=4)
            self.add(group)
            self.camera.auto_zoom(group[0], animate=False)
            for scene in group:
                self.play(self.camera.auto_zoom(scene))
                self.wait()

            self.play(self.camera.auto_zoom(group, margin=2))
"""

from __future__ import annotations

__all__ = ["MovingCameraScene"]

from manim.animation.animation import Animation

from ..camera.moving_camera import MovingCamera
from ..scene.scene import Scene
from ..utils.family import extract_mobject_family_members
from ..utils.iterables import list_update


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.432">class MovingCameraScene(Scene):
    """
    This is a Scene, with special configurations and properties that
    make it suitable for cases where the camera must be moved around.

    Note: Examples are included in the moving_camera_scene module
    documentation, see below in the 'see also' section.

    .. SEEALSO::

        :mod:`.moving_camera_scene`
        :class:`.MovingCamera`
    """

    @others
</t>
<t tx="ekr.20250122151621.433">def __init__(self, camera_class=MovingCamera, **kwargs):
    super().__init__(camera_class=camera_class, **kwargs)

</t>
<t tx="ekr.20250122151621.434">def get_moving_mobjects(self, *animations: Animation):
    """
    This method returns a list of all of the Mobjects in the Scene that
    are moving, that are also in the animations passed.

    Parameters
    ----------
    *animations
        The Animations whose mobjects will be checked.
    """
    moving_mobjects = super().get_moving_mobjects(*animations)
    all_moving_mobjects = extract_mobject_family_members(moving_mobjects)
    movement_indicators = self.renderer.camera.get_mobjects_indicating_movement()
    for movement_indicator in movement_indicators:
        if movement_indicator in all_moving_mobjects:
            # When one of these is moving, the camera should
            # consider all mobjects to be moving
            return list_update(self.mobjects, moving_mobjects)
    return moving_mobjects
</t>
<t tx="ekr.20250122151621.435">"""Basic canvas for animations."""

from __future__ import annotations

from manim.utils.parameter_parsing import flatten_iterable_parameters

__all__ = ["Scene"]

import copy
import datetime
import inspect
import platform
import random
import threading
import time
import types
from queue import Queue

import srt

from manim.scene.section import DefaultSectionType

try:
    import dearpygui.dearpygui as dpg

    dearpygui_imported = True
except ImportError:
    dearpygui_imported = False
from typing import TYPE_CHECKING

import numpy as np
from tqdm import tqdm
from watchdog.events import FileSystemEventHandler
from watchdog.observers import Observer

from manim.mobject.mobject import Mobject
from manim.mobject.opengl.opengl_mobject import OpenGLPoint

from .. import config, logger
from ..animation.animation import Animation, Wait, prepare_animation
from ..camera.camera import Camera
from ..constants import *
from ..gui.gui import configure_pygui
from ..renderer.cairo_renderer import CairoRenderer
from ..renderer.opengl_renderer import OpenGLRenderer
from ..renderer.shader import Object3D
from ..utils import opengl, space_ops
from ..utils.exceptions import EndSceneEarlyException, RerunSceneException
from ..utils.family import extract_mobject_family_members
from ..utils.family_ops import restructure_list_to_exclude_certain_family_members
from ..utils.file_ops import open_media_file
from ..utils.iterables import list_difference_update, list_update

if TYPE_CHECKING:
    from collections.abc import Sequence
    from typing import Callable

    from manim.mobject.mobject import _AnimationBuilder


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.436">class RerunSceneHandler(FileSystemEventHandler):
    """A class to handle rerunning a Scene after the input file is modified."""

    @others
</t>
<t tx="ekr.20250122151621.437">class Scene:
    """A Scene is the canvas of your animation.

    The primary role of :class:`Scene` is to provide the user with tools to manage
    mobjects and animations.  Generally speaking, a manim script consists of a class
    that derives from :class:`Scene` whose :meth:`Scene.construct` method is overridden
    by the user's code.

    Mobjects are displayed on screen by calling :meth:`Scene.add` and removed from
    screen by calling :meth:`Scene.remove`.  All mobjects currently on screen are kept
    in :attr:`Scene.mobjects`.  Animations are played by calling :meth:`Scene.play`.

    A :class:`Scene` is rendered internally by calling :meth:`Scene.render`.  This in
    turn calls :meth:`Scene.setup`, :meth:`Scene.construct`, and
    :meth:`Scene.tear_down`, in that order.

    It is not recommended to override the ``__init__`` method in user Scenes.  For code
    that should be ran before a Scene is rendered, use :meth:`Scene.setup` instead.

    Examples
    --------
    Override the :meth:`Scene.construct` method with your code.

    .. code-block:: python

        class MyScene(Scene):
            def construct(self):
                self.play(Write(Text("Hello World!")))

    """

    @others
</t>
<t tx="ekr.20250122151621.438">def __init__(self, queue):
    super().__init__()
    self.queue = queue

</t>
<t tx="ekr.20250122151621.439">def on_modified(self, event):
    self.queue.put(("rerun_file", [], {}))


</t>
<t tx="ekr.20250122151621.44">def _get_u_values_and_v_values(self) -&gt; tuple[np.ndarray, np.ndarray]:
    res = tuplify(self.resolution)
    if len(res) == 1:
        u_res = v_res = res[0]
    else:
        u_res, v_res = res

    u_values = np.linspace(*self.u_range, u_res + 1)
    v_values = np.linspace(*self.v_range, v_res + 1)

    return u_values, v_values

</t>
<t tx="ekr.20250122151621.440">def __init__(
    self,
    renderer: CairoRenderer | OpenGLRenderer | None = None,
    camera_class: type[Camera] = Camera,
    always_update_mobjects: bool = False,
    random_seed: int | None = None,
    skip_animations: bool = False,
) -&gt; None:
    self.camera_class = camera_class
    self.always_update_mobjects = always_update_mobjects
    self.random_seed = random_seed
    self.skip_animations = skip_animations

    self.animations = None
    self.stop_condition = None
    self.moving_mobjects = []
    self.static_mobjects = []
    self.time_progression = None
    self.duration = None
    self.last_t = None
    self.queue = Queue()
    self.skip_animation_preview = False
    self.meshes = []
    self.camera_target = ORIGIN
    self.widgets = []
    self.dearpygui_imported = dearpygui_imported
    self.updaters = []
    self.point_lights = []
    self.ambient_light = None
    self.key_to_function_map = {}
    self.mouse_press_callbacks = []
    self.interactive_mode = False

    if config.renderer == RendererType.OPENGL:
        # Items associated with interaction
        self.mouse_point = OpenGLPoint()
        self.mouse_drag_point = OpenGLPoint()
        if renderer is None:
            renderer = OpenGLRenderer()

    if renderer is None:
        self.renderer = CairoRenderer(
            camera_class=self.camera_class,
            skip_animations=self.skip_animations,
        )
    else:
        self.renderer = renderer
    self.renderer.init_scene(self)

    self.mobjects = []
    # TODO, remove need for foreground mobjects
    self.foreground_mobjects = []
    if self.random_seed is not None:
        random.seed(self.random_seed)
        np.random.seed(self.random_seed)

</t>
<t tx="ekr.20250122151621.441">@property
def camera(self):
    return self.renderer.camera

</t>
<t tx="ekr.20250122151621.442">@property
def time(self) -&gt; float:
    """The time since the start of the scene."""
    return self.renderer.time

</t>
<t tx="ekr.20250122151621.443">def __deepcopy__(self, clone_from_id):
    cls = self.__class__
    result = cls.__new__(cls)
    clone_from_id[id(self)] = result
    for k, v in self.__dict__.items():
        if k in ["renderer", "time_progression"]:
            continue
        if k == "camera_class":
            setattr(result, k, v)
        setattr(result, k, copy.deepcopy(v, clone_from_id))
    result.mobject_updater_lists = []

    # Update updaters
    for mobject in self.mobjects:
        cloned_updaters = []
        for updater in mobject.updaters:
            # Make the cloned updater use the cloned Mobjects as free variables
            # rather than the original ones. Analyzing function bytecode with the
            # dis module will help in understanding this.
            # https://docs.python.org/3/library/dis.html
            # TODO: Do the same for function calls recursively.
            free_variable_map = inspect.getclosurevars(updater).nonlocals
            cloned_co_freevars = []
            cloned_closure = []
            for free_variable_name in updater.__code__.co_freevars:
                free_variable_value = free_variable_map[free_variable_name]

                # If the referenced variable has not been cloned, raise.
                if id(free_variable_value) not in clone_from_id:
                    raise Exception(
                        f"{free_variable_name} is referenced from an updater "
                        "but is not an attribute of the Scene, which isn't "
                        "allowed.",
                    )

                # Add the cloned object's name to the free variable list.
                cloned_co_freevars.append(free_variable_name)

                # Add a cell containing the cloned object's reference to the
                # closure list.
                cloned_closure.append(
                    types.CellType(clone_from_id[id(free_variable_value)]),
                )

            cloned_updater = types.FunctionType(
                updater.__code__.replace(co_freevars=tuple(cloned_co_freevars)),
                updater.__globals__,
                updater.__name__,
                updater.__defaults__,
                tuple(cloned_closure),
            )
            cloned_updaters.append(cloned_updater)
        mobject_clone = clone_from_id[id(mobject)]
        mobject_clone.updaters = cloned_updaters
        if len(cloned_updaters) &gt; 0:
            result.mobject_updater_lists.append((mobject_clone, cloned_updaters))
    return result

</t>
<t tx="ekr.20250122151621.444">def render(self, preview: bool = False):
    """
    Renders this Scene.

    Parameters
    ---------
    preview
        If true, opens scene in a file viewer.
    """
    self.setup()
    try:
        self.construct()
    except EndSceneEarlyException:
        pass
    except RerunSceneException:
        self.remove(*self.mobjects)
        self.renderer.clear_screen()
        self.renderer.num_plays = 0
        return True
    self.tear_down()
    # We have to reset these settings in case of multiple renders.
    self.renderer.scene_finished(self)

    # Show info only if animations are rendered or to get image
    if (
        self.renderer.num_plays
        or config["format"] == "png"
        or config["save_last_frame"]
    ):
        logger.info(
            f"Rendered {str(self)}\nPlayed {self.renderer.num_plays} animations",
        )

    # If preview open up the render after rendering.
    if preview:
        config["preview"] = True

    if config["preview"] or config["show_in_file_browser"]:
        open_media_file(self.renderer.file_writer)

</t>
<t tx="ekr.20250122151621.445">def setup(self):
    """
    This is meant to be implemented by any scenes which
    are commonly subclassed, and have some common setup
    involved before the construct method is called.
    """
    pass

</t>
<t tx="ekr.20250122151621.446">def tear_down(self):
    """
    This is meant to be implemented by any scenes which
    are commonly subclassed, and have some common method
    to be invoked before the scene ends.
    """
    pass

</t>
<t tx="ekr.20250122151621.447">def construct(self):
    """Add content to the Scene.

    From within :meth:`Scene.construct`, display mobjects on screen by calling
    :meth:`Scene.add` and remove them from screen by calling :meth:`Scene.remove`.
    All mobjects currently on screen are kept in :attr:`Scene.mobjects`.  Play
    animations by calling :meth:`Scene.play`.

    Notes
    -----
    Initialization code should go in :meth:`Scene.setup`.  Termination code should
    go in :meth:`Scene.tear_down`.

    Examples
    --------
    A typical manim script includes a class derived from :class:`Scene` with an
    overridden :meth:`Scene.construct` method:

    .. code-block:: python

        class MyScene(Scene):
            def construct(self):
                self.play(Write(Text("Hello World!")))

    See Also
    --------
    :meth:`Scene.setup`
    :meth:`Scene.render`
    :meth:`Scene.tear_down`

    """
    pass  # To be implemented in subclasses

</t>
<t tx="ekr.20250122151621.448">def next_section(
    self,
    name: str = "unnamed",
    section_type: str = DefaultSectionType.NORMAL,
    skip_animations: bool = False,
) -&gt; None:
    """Create separation here; the last section gets finished and a new one gets created.
    ``skip_animations`` skips the rendering of all animations in this section.
    Refer to :doc:`the documentation&lt;/tutorials/output_and_config&gt;` on how to use sections.
    """
    self.renderer.file_writer.next_section(name, section_type, skip_animations)

</t>
<t tx="ekr.20250122151621.449">def __str__(self):
    return self.__class__.__name__

</t>
<t tx="ekr.20250122151621.45">def _setup_in_uv_space(self) -&gt; None:
    u_values, v_values = self._get_u_values_and_v_values()
    faces = VGroup()
    for i in range(len(u_values) - 1):
        for j in range(len(v_values) - 1):
            u1, u2 = u_values[i : i + 2]
            v1, v2 = v_values[j : j + 2]
            face = ThreeDVMobject()
            face.set_points_as_corners(
                [
                    [u1, v1, 0],
                    [u2, v1, 0],
                    [u2, v2, 0],
                    [u1, v2, 0],
                    [u1, v1, 0],
                ],
            )
            faces.add(face)
            face.u_index = i
            face.v_index = j
            face.u1 = u1
            face.u2 = u2
            face.v1 = v1
            face.v2 = v2
    faces.set_fill(color=self.fill_color, opacity=self.fill_opacity)
    faces.set_stroke(
        color=self.stroke_color,
        width=self.stroke_width,
        opacity=self.stroke_opacity,
    )
    self.add(*faces)
    if self.checkerboard_colors:
        self.set_fill_by_checkerboard(*self.checkerboard_colors)

</t>
<t tx="ekr.20250122151621.450">def get_attrs(self, *keys: str):
    """
    Gets attributes of a scene given the attribute's identifier/name.

    Parameters
    ----------
    *keys
        Name(s) of the argument(s) to return the attribute of.

    Returns
    -------
    list
        List of attributes of the passed identifiers.
    """
    return [getattr(self, key) for key in keys]

</t>
<t tx="ekr.20250122151621.451">def update_mobjects(self, dt: float):
    """
    Begins updating all mobjects in the Scene.

    Parameters
    ----------
    dt
        Change in time between updates. Defaults (mostly) to 1/frames_per_second
    """
    for mobject in self.mobjects:
        mobject.update(dt)

</t>
<t tx="ekr.20250122151621.452">def update_meshes(self, dt):
    for obj in self.meshes:
        for mesh in obj.get_family():
            mesh.update(dt)

</t>
<t tx="ekr.20250122151621.453">def update_self(self, dt: float):
    """Run all scene updater functions.

    Among all types of update functions (mobject updaters, mesh updaters,
    scene updaters), scene update functions are called last.

    Parameters
    ----------
    dt
        Scene time since last update.

    See Also
    --------
    :meth:`.Scene.add_updater`
    :meth:`.Scene.remove_updater`
    """
    for func in self.updaters:
        func(dt)

</t>
<t tx="ekr.20250122151621.454">def should_update_mobjects(self) -&gt; bool:
    """
    Returns True if the mobjects of this scene should be updated.

    In particular, this checks whether

    - the :attr:`always_update_mobjects` attribute of :class:`.Scene`
      is set to ``True``,
    - the :class:`.Scene` itself has time-based updaters attached,
    - any mobject in this :class:`.Scene` has time-based updaters attached.

    This is only called when a single Wait animation is played.
    """
    wait_animation = self.animations[0]
    if wait_animation.is_static_wait is None:
        should_update = (
            self.always_update_mobjects
            or self.updaters
            or wait_animation.stop_condition is not None
            or any(
                mob.has_time_based_updater()
                for mob in self.get_mobject_family_members()
            )
        )
        wait_animation.is_static_wait = not should_update
    return not wait_animation.is_static_wait

</t>
<t tx="ekr.20250122151621.455">def get_top_level_mobjects(self):
    """
    Returns all mobjects which are not submobjects.

    Returns
    -------
    list
        List of top level mobjects.
    """
    # Return only those which are not in the family
    # of another mobject from the scene
    families = [m.get_family() for m in self.mobjects]

    def is_top_level(mobject):
        num_families = sum((mobject in family) for family in families)
        return num_families == 1

    return list(filter(is_top_level, self.mobjects))

</t>
<t tx="ekr.20250122151621.456">def get_mobject_family_members(self):
    """
    Returns list of family-members of all mobjects in scene.
    If a Circle() and a VGroup(Rectangle(),Triangle()) were added,
    it returns not only the Circle(), Rectangle() and Triangle(), but
    also the VGroup() object.

    Returns
    -------
    list
        List of mobject family members.
    """
    if config.renderer == RendererType.OPENGL:
        family_members = []
        for mob in self.mobjects:
            family_members.extend(mob.get_family())
        return family_members
    elif config.renderer == RendererType.CAIRO:
        return extract_mobject_family_members(
            self.mobjects,
            use_z_index=self.renderer.camera.use_z_index,
        )

</t>
<t tx="ekr.20250122151621.457">def add(self, *mobjects: Mobject):
    """
    Mobjects will be displayed, from background to
    foreground in the order with which they are added.

    Parameters
    ---------
    *mobjects
        Mobjects to add.

    Returns
    -------
    Scene
        The same scene after adding the Mobjects in.

    """
    if config.renderer == RendererType.OPENGL:
        new_mobjects = []
        new_meshes = []
        for mobject_or_mesh in mobjects:
            if isinstance(mobject_or_mesh, Object3D):
                new_meshes.append(mobject_or_mesh)
            else:
                new_mobjects.append(mobject_or_mesh)
        self.remove(*new_mobjects)
        self.mobjects += new_mobjects
        self.remove(*new_meshes)
        self.meshes += new_meshes
    elif config.renderer == RendererType.CAIRO:
        mobjects = [*mobjects, *self.foreground_mobjects]
        self.restructure_mobjects(to_remove=mobjects)
        self.mobjects += mobjects
        if self.moving_mobjects:
            self.restructure_mobjects(
                to_remove=mobjects,
                mobject_list_name="moving_mobjects",
            )
            self.moving_mobjects += mobjects
    return self

</t>
<t tx="ekr.20250122151621.458">def add_mobjects_from_animations(self, animations: list[Animation]) -&gt; None:
    curr_mobjects = self.get_mobject_family_members()
    for animation in animations:
        if animation.is_introducer():
            continue
        # Anything animated that's not already in the
        # scene gets added to the scene
        mob = animation.mobject
        if mob is not None and mob not in curr_mobjects:
            self.add(mob)
            curr_mobjects += mob.get_family()

</t>
<t tx="ekr.20250122151621.459">def remove(self, *mobjects: Mobject):
    """
    Removes mobjects in the passed list of mobjects
    from the scene and the foreground, by removing them
    from "mobjects" and "foreground_mobjects"

    Parameters
    ----------
    *mobjects
        The mobjects to remove.
    """
    if config.renderer == RendererType.OPENGL:
        mobjects_to_remove = []
        meshes_to_remove = set()
        for mobject_or_mesh in mobjects:
            if isinstance(mobject_or_mesh, Object3D):
                meshes_to_remove.add(mobject_or_mesh)
            else:
                mobjects_to_remove.append(mobject_or_mesh)
        self.mobjects = restructure_list_to_exclude_certain_family_members(
            self.mobjects,
            mobjects_to_remove,
        )
        self.meshes = list(
            filter(lambda mesh: mesh not in set(meshes_to_remove), self.meshes),
        )
        return self
    elif config.renderer == RendererType.CAIRO:
        for list_name in "mobjects", "foreground_mobjects":
            self.restructure_mobjects(mobjects, list_name, False)
        return self

</t>
<t tx="ekr.20250122151621.46">def set_fill_by_checkerboard(
    self, *colors: Iterable[ParsableManimColor], opacity: float | None = None
) -&gt; Self:
    """Sets the fill_color of each face of :class:`Surface` in
    an alternating pattern.

    Parameters
    ----------
    colors
        List of colors for alternating pattern.
    opacity
        The fill_opacity of :class:`Surface`, from 0 being fully transparent
        to 1 being fully opaque.

    Returns
    -------
    :class:`~.Surface`
        The parametric surface with an alternating pattern.
    """
    n_colors = len(colors)
    for face in self:
        c_index = (face.u_index + face.v_index) % n_colors
        face.set_fill(colors[c_index], opacity=opacity)
    return self

</t>
<t tx="ekr.20250122151621.460">def replace(self, old_mobject: Mobject, new_mobject: Mobject) -&gt; None:
    """Replace one mobject in the scene with another, preserving draw order.

    If ``old_mobject`` is a submobject of some other Mobject (e.g. a
    :class:`.Group`), the new_mobject will replace it inside the group,
    without otherwise changing the parent mobject.

    Parameters
    ----------
    old_mobject
        The mobject to be replaced. Must be present in the scene.
    new_mobject
        A mobject which must not already be in the scene.

    """
    if old_mobject is None or new_mobject is None:
        raise ValueError("Specified mobjects cannot be None")

    def replace_in_list(
        mobj_list: list[Mobject], old_m: Mobject, new_m: Mobject
    ) -&gt; bool:
        # We use breadth-first search because some Mobjects get very deep and
        # we expect top-level elements to be the most common targets for replace.
        for i in range(0, len(mobj_list)):
            # Is this the old mobject?
            if mobj_list[i] == old_m:
                # If so, write the new object to the same spot and stop looking.
                mobj_list[i] = new_m
                return True
        # Now check all the children of all these mobs.
        for mob in mobj_list:  # noqa: SIM110
            if replace_in_list(mob.submobjects, old_m, new_m):
                # If we found it in a submobject, stop looking.
                return True
        # If we did not find the mobject in the mobject list or any submobjects,
        # (or the list was empty), indicate we did not make the replacement.
        return False

    # Make use of short-circuiting conditionals to check mobjects and then
    # foreground_mobjects
    replaced = replace_in_list(
        self.mobjects, old_mobject, new_mobject
    ) or replace_in_list(self.foreground_mobjects, old_mobject, new_mobject)

    if not replaced:
        raise ValueError(f"Could not find {old_mobject} in scene")

</t>
<t tx="ekr.20250122151621.461">def add_updater(self, func: Callable[[float], None]) -&gt; None:
    """Add an update function to the scene.

    The scene updater functions are run every frame,
    and they are the last type of updaters to run.

    .. WARNING::

        When using the Cairo renderer, scene updaters that
        modify mobjects are not detected in the same way
        that mobject updaters are. To be more concrete,
        a mobject only modified via a scene updater will
        not necessarily be added to the list of *moving
        mobjects* and thus might not be updated every frame.

        TL;DR: Use mobject updaters to update mobjects.

    Parameters
    ----------
    func
        The updater function. It takes a float, which is the
        time difference since the last update (usually equal
        to the frame rate).

    See also
    --------
    :meth:`.Scene.remove_updater`
    :meth:`.Scene.update_self`
    """
    self.updaters.append(func)

</t>
<t tx="ekr.20250122151621.462">def remove_updater(self, func: Callable[[float], None]) -&gt; None:
    """Remove an update function from the scene.

    Parameters
    ----------
    func
        The updater function to be removed.

    See also
    --------
    :meth:`.Scene.add_updater`
    :meth:`.Scene.update_self`
    """
    self.updaters = [f for f in self.updaters if f is not func]

</t>
<t tx="ekr.20250122151621.463">def restructure_mobjects(
    self,
    to_remove: Sequence[Mobject],
    mobject_list_name: str = "mobjects",
    extract_families: bool = True,
):
    """
    tl:wr
        If your scene has a Group(), and you removed a mobject from the Group,
        this dissolves the group and puts the rest of the mobjects directly
        in self.mobjects or self.foreground_mobjects.

    In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one
    of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects
    will be edited to contain other submobjects, but not m1, e.g. it will now
    insert m2 and m3 to where the group once was.

    Parameters
    ----------
    to_remove
        The Mobject to remove.

    mobject_list_name
        The list of mobjects ("mobjects", "foreground_mobjects" etc) to remove from.

    extract_families
        Whether the mobject's families should be recursively extracted.

    Returns
    -------
    Scene
        The Scene mobject with restructured Mobjects.
    """
    if extract_families:
        to_remove = extract_mobject_family_members(
            to_remove,
            use_z_index=self.renderer.camera.use_z_index,
        )
    _list = getattr(self, mobject_list_name)
    new_list = self.get_restructured_mobject_list(_list, to_remove)
    setattr(self, mobject_list_name, new_list)
    return self

</t>
<t tx="ekr.20250122151621.464">def get_restructured_mobject_list(self, mobjects: list, to_remove: list):
    """
    Given a list of mobjects and a list of mobjects to be removed, this
    filters out the removable mobjects from the list of mobjects.

    Parameters
    ----------

    mobjects
        The Mobjects to check.

    to_remove
        The list of mobjects to remove.

    Returns
    -------
    list
        The list of mobjects with the mobjects to remove removed.
    """
    new_mobjects = []

    def add_safe_mobjects_from_list(list_to_examine, set_to_remove):
        for mob in list_to_examine:
            if mob in set_to_remove:
                continue
            intersect = set_to_remove.intersection(mob.get_family())
            if intersect:
                add_safe_mobjects_from_list(mob.submobjects, intersect)
            else:
                new_mobjects.append(mob)

    add_safe_mobjects_from_list(mobjects, set(to_remove))
    return new_mobjects

</t>
<t tx="ekr.20250122151621.465"># TODO, remove this, and calls to this
def add_foreground_mobjects(self, *mobjects: Mobject):
    """
    Adds mobjects to the foreground, and internally to the list
    foreground_mobjects, and mobjects.

    Parameters
    ----------
    *mobjects
        The Mobjects to add to the foreground.

    Returns
    ------
    Scene
        The Scene, with the foreground mobjects added.
    """
    self.foreground_mobjects = list_update(self.foreground_mobjects, mobjects)
    self.add(*mobjects)
    return self

</t>
<t tx="ekr.20250122151621.466">def add_foreground_mobject(self, mobject: Mobject):
    """
    Adds a single mobject to the foreground, and internally to the list
    foreground_mobjects, and mobjects.

    Parameters
    ----------
    mobject
        The Mobject to add to the foreground.

    Returns
    ------
    Scene
        The Scene, with the foreground mobject added.
    """
    return self.add_foreground_mobjects(mobject)

</t>
<t tx="ekr.20250122151621.467">def remove_foreground_mobjects(self, *to_remove: Mobject):
    """
    Removes mobjects from the foreground, and internally from the list
    foreground_mobjects.

    Parameters
    ----------
    *to_remove
        The mobject(s) to remove from the foreground.

    Returns
    ------
    Scene
        The Scene, with the foreground mobjects removed.
    """
    self.restructure_mobjects(to_remove, "foreground_mobjects")
    return self

</t>
<t tx="ekr.20250122151621.468">def remove_foreground_mobject(self, mobject: Mobject):
    """
    Removes a single mobject from the foreground, and internally from the list
    foreground_mobjects.

    Parameters
    ----------
    mobject
        The mobject to remove from the foreground.

    Returns
    ------
    Scene
        The Scene, with the foreground mobject removed.
    """
    return self.remove_foreground_mobjects(mobject)

</t>
<t tx="ekr.20250122151621.469">def bring_to_front(self, *mobjects: Mobject):
    """
    Adds the passed mobjects to the scene again,
    pushing them to he front of the scene.

    Parameters
    ----------
    *mobjects
        The mobject(s) to bring to the front of the scene.

    Returns
    ------
    Scene
        The Scene, with the mobjects brought to the front
        of the scene.
    """
    self.add(*mobjects)
    return self

</t>
<t tx="ekr.20250122151621.47">def set_fill_by_value(
    self,
    axes: Mobject,
    colorscale: list[ParsableManimColor] | ParsableManimColor | None = None,
    axis: int = 2,
    **kwargs,
) -&gt; Self:
    """Sets the color of each mobject of a parametric surface to a color
    relative to its axis-value.

    Parameters
    ----------
    axes
        The axes for the parametric surface, which will be used to map
        axis-values to colors.
    colorscale
        A list of colors, ordered from lower axis-values to higher axis-values.
        If a list of tuples is passed containing colors paired with numbers,
        then those numbers will be used as the pivots.
    axis
        The chosen axis to use for the color mapping. (0 = x, 1 = y, 2 = z)

    Returns
    -------
    :class:`~.Surface`
        The parametric surface with a gradient applied by value. For chaining.

    Examples
    --------
    .. manim:: FillByValueExample
        :save_last_frame:

        class FillByValueExample(ThreeDScene):
            def construct(self):
                resolution_fa = 8
                self.set_camera_orientation(phi=75 * DEGREES, theta=-160 * DEGREES)
                axes = ThreeDAxes(x_range=(0, 5, 1), y_range=(0, 5, 1), z_range=(-1, 1, 0.5))
                def param_surface(u, v):
                    x = u
                    y = v
                    z = np.sin(x) * np.cos(y)
                    return z
                surface_plane = Surface(
                    lambda u, v: axes.c2p(u, v, param_surface(u, v)),
                    resolution=(resolution_fa, resolution_fa),
                    v_range=[0, 5],
                    u_range=[0, 5],
                    )
                surface_plane.set_style(fill_opacity=1)
                surface_plane.set_fill_by_value(axes=axes, colorscale=[(RED, -0.5), (YELLOW, 0), (GREEN, 0.5)], axis=2)
                self.add(axes, surface_plane)
    """
    if "colors" in kwargs and colorscale is None:
        colorscale = kwargs.pop("colors")
        if kwargs:
            raise ValueError(
                "Unsupported keyword argument(s): "
                f"{', '.join(str(key) for key in kwargs)}"
            )
    if colorscale is None:
        logger.warning(
            "The value passed to the colorscale keyword argument was None, "
            "the surface fill color has not been changed"
        )
        return self

    ranges = [axes.x_range, axes.y_range, axes.z_range]

    if type(colorscale[0]) is tuple:
        new_colors, pivots = [
            [i for i, j in colorscale],
            [j for i, j in colorscale],
        ]
    else:
        new_colors = colorscale

        pivot_min = ranges[axis][0]
        pivot_max = ranges[axis][1]
        pivot_frequency = (pivot_max - pivot_min) / (len(new_colors) - 1)
        pivots = np.arange(
            start=pivot_min,
            stop=pivot_max + pivot_frequency,
            step=pivot_frequency,
        )

    for mob in self.family_members_with_points():
        axis_value = axes.point_to_coords(mob.get_midpoint())[axis]
        if axis_value &lt;= pivots[0]:
            mob.set_color(new_colors[0])
        elif axis_value &gt;= pivots[-1]:
            mob.set_color(new_colors[-1])
        else:
            for i, pivot in enumerate(pivots):
                if pivot &gt; axis_value:
                    color_index = (axis_value - pivots[i - 1]) / (
                        pivots[i] - pivots[i - 1]
                    )
                    color_index = min(color_index, 1)
                    mob_color = interpolate_color(
                        new_colors[i - 1],
                        new_colors[i],
                        color_index,
                    )
                    if config.renderer == RendererType.OPENGL:
                        mob.set_color(mob_color, recurse=False)
                    elif config.renderer == RendererType.CAIRO:
                        mob.set_color(mob_color, family=False)
                    break

    return self


</t>
<t tx="ekr.20250122151621.470">def bring_to_back(self, *mobjects: Mobject):
    """
    Removes the mobject from the scene and
    adds them to the back of the scene.

    Parameters
    ----------
    *mobjects
        The mobject(s) to push to the back of the scene.

    Returns
    ------
    Scene
        The Scene, with the mobjects pushed to the back
        of the scene.
    """
    self.remove(*mobjects)
    self.mobjects = list(mobjects) + self.mobjects
    return self

</t>
<t tx="ekr.20250122151621.471">def clear(self):
    """
    Removes all mobjects present in self.mobjects
    and self.foreground_mobjects from the scene.

    Returns
    ------
    Scene
        The Scene, with all of its mobjects in
        self.mobjects and self.foreground_mobjects
        removed.
    """
    self.mobjects = []
    self.foreground_mobjects = []
    return self

</t>
<t tx="ekr.20250122151621.472">def get_moving_mobjects(self, *animations: Animation):
    """
    Gets all moving mobjects in the passed animation(s).

    Parameters
    ----------
    *animations
        The animations to check for moving mobjects.

    Returns
    ------
    list
        The list of mobjects that could be moving in
        the Animation(s)
    """
    # Go through mobjects from start to end, and
    # as soon as there's one that needs updating of
    # some kind per frame, return the list from that
    # point forward.
    animation_mobjects = [anim.mobject for anim in animations]
    mobjects = self.get_mobject_family_members()
    for i, mob in enumerate(mobjects):
        update_possibilities = [
            mob in animation_mobjects,
            len(mob.get_family_updaters()) &gt; 0,
            mob in self.foreground_mobjects,
        ]
        if any(update_possibilities):
            return mobjects[i:]
    return []

</t>
<t tx="ekr.20250122151621.473">def get_moving_and_static_mobjects(self, animations):
    all_mobjects = list_update(self.mobjects, self.foreground_mobjects)
    all_mobject_families = extract_mobject_family_members(
        all_mobjects,
        use_z_index=self.renderer.camera.use_z_index,
        only_those_with_points=True,
    )
    moving_mobjects = self.get_moving_mobjects(*animations)
    all_moving_mobject_families = extract_mobject_family_members(
        moving_mobjects,
        use_z_index=self.renderer.camera.use_z_index,
    )
    static_mobjects = list_difference_update(
        all_mobject_families,
        all_moving_mobject_families,
    )
    return all_moving_mobject_families, static_mobjects

</t>
<t tx="ekr.20250122151621.474">def compile_animations(
    self,
    *args: Animation | Mobject | _AnimationBuilder,
    **kwargs,
):
    """
    Creates _MethodAnimations from any _AnimationBuilders and updates animation
    kwargs with kwargs passed to play().

    Parameters
    ----------
    *args
        Animations to be played.
    **kwargs
        Configuration for the call to play().

    Returns
    -------
    Tuple[:class:`Animation`]
        Animations to be played.
    """
    animations = []
    arg_anims = flatten_iterable_parameters(args)
    # Allow passing a generator to self.play instead of comma separated arguments
    for arg in arg_anims:
        try:
            animations.append(prepare_animation(arg))
        except TypeError as e:
            if inspect.ismethod(arg):
                raise TypeError(
                    "Passing Mobject methods to Scene.play is no longer"
                    " supported. Use Mobject.animate instead.",
                ) from e
            else:
                raise TypeError(
                    f"Unexpected argument {arg} passed to Scene.play().",
                ) from e

    for animation in animations:
        for k, v in kwargs.items():
            setattr(animation, k, v)

    return animations

</t>
<t tx="ekr.20250122151621.475">def _get_animation_time_progression(
    self, animations: list[Animation], duration: float
):
    """
    You will hardly use this when making your own animations.
    This method is for Manim's internal use.

    Uses :func:`~.get_time_progression` to obtain a
    CommandLine ProgressBar whose ``fill_time`` is
    dependent on the qualities of the passed Animation,

    Parameters
    ----------
    animations
        The list of animations to get
        the time progression for.

    duration
        duration of wait time

    Returns
    -------
    time_progression
        The CommandLine Progress Bar.
    """
    if len(animations) == 1 and isinstance(animations[0], Wait):
        stop_condition = animations[0].stop_condition
        if stop_condition is not None:
            time_progression = self.get_time_progression(
                duration,
                f"Waiting for {stop_condition.__name__}",
                n_iterations=-1,  # So it doesn't show % progress
                override_skip_animations=True,
            )
        else:
            time_progression = self.get_time_progression(
                duration,
                f"Waiting {self.renderer.num_plays}",
            )
    else:
        time_progression = self.get_time_progression(
            duration,
            "".join(
                [
                    f"Animation {self.renderer.num_plays}: ",
                    str(animations[0]),
                    (", etc." if len(animations) &gt; 1 else ""),
                ],
            ),
        )
    return time_progression

</t>
<t tx="ekr.20250122151621.476">def get_time_progression(
    self,
    run_time: float,
    description,
    n_iterations: int | None = None,
    override_skip_animations: bool = False,
):
    """
    You will hardly use this when making your own animations.
    This method is for Manim's internal use.

    Returns a CommandLine ProgressBar whose ``fill_time``
    is dependent on the ``run_time`` of an animation,
    the iterations to perform in that animation
    and a bool saying whether or not to consider
    the skipped animations.

    Parameters
    ----------
    run_time
        The ``run_time`` of the animation.

    n_iterations
        The number of iterations in the animation.

    override_skip_animations
        Whether or not to show skipped animations in the progress bar.

    Returns
    -------
    time_progression
        The CommandLine Progress Bar.
    """
    if self.renderer.skip_animations and not override_skip_animations:
        times = [run_time]
    else:
        step = 1 / config["frame_rate"]
        times = np.arange(0, run_time, step)
    time_progression = tqdm(
        times,
        desc=description,
        total=n_iterations,
        leave=config["progress_bar"] == "leave",
        ascii=True if platform.system() == "Windows" else None,
        disable=config["progress_bar"] == "none",
    )
    return time_progression

</t>
<t tx="ekr.20250122151621.477">@classmethod
def validate_run_time(
    cls,
    run_time: float,
    method: Callable[[Any, ...], Any],
    parameter_name: str = "run_time",
) -&gt; float:
    method_name = f"{cls.__name__}.{method.__name__}()"
    if run_time &lt;= 0:
        raise ValueError(
            f"{method_name} has a {parameter_name} of "
            f"{run_time:g} &lt;= 0 seconds which Manim cannot render. "
            f"The {parameter_name} must be a positive number."
        )

    # config.frame_rate holds the number of frames per second
    fps = config.frame_rate
    seconds_per_frame = 1 / fps
    if run_time &lt; seconds_per_frame:
        logger.warning(
            f"The original {parameter_name} of {method_name}, "
            f"{run_time:g} seconds, is too short for the current frame "
            f"rate of {fps:g} FPS. Rendering with the shortest possible "
            f"{parameter_name} of {seconds_per_frame:g} seconds instead."
        )
        run_time = seconds_per_frame

    return run_time

</t>
<t tx="ekr.20250122151621.478">def get_run_time(self, animations: list[Animation]):
    """
    Gets the total run time for a list of animations.

    Parameters
    ----------
    animations
        A list of the animations whose total
        ``run_time`` is to be calculated.

    Returns
    -------
    float
        The total ``run_time`` of all of the animations in the list.
    """
    run_time = max(animation.run_time for animation in animations)
    run_time = self.validate_run_time(run_time, self.play, "total run_time")
    return run_time

</t>
<t tx="ekr.20250122151621.479">def play(
    self,
    *args: Animation | Mobject | _AnimationBuilder,
    subcaption=None,
    subcaption_duration=None,
    subcaption_offset=0,
    **kwargs,
):
    r"""Plays an animation in this scene.

    Parameters
    ----------

    args
        Animations to be played.
    subcaption
        The content of the external subcaption that should
        be added during the animation.
    subcaption_duration
        The duration for which the specified subcaption is
        added. If ``None`` (the default), the run time of the
        animation is taken.
    subcaption_offset
        An offset (in seconds) for the start time of the
        added subcaption.
    kwargs
        All other keywords are passed to the renderer.

    """
    # If we are in interactive embedded mode, make sure this is running on the main thread (required for OpenGL)
    if (
        self.interactive_mode
        and config.renderer == RendererType.OPENGL
        and threading.current_thread().name != "MainThread"
    ):
        kwargs.update(
            {
                "subcaption": subcaption,
                "subcaption_duration": subcaption_duration,
                "subcaption_offset": subcaption_offset,
            }
        )
        self.queue.put(
            (
                "play",
                args,
                kwargs,
            )
        )
        return

    start_time = self.time
    self.renderer.play(self, *args, **kwargs)
    run_time = self.time - start_time
    if subcaption:
        if subcaption_duration is None:
            subcaption_duration = run_time
        # The start of the subcaption needs to be offset by the
        # run_time of the animation because it is added after
        # the animation has already been played (and Scene.time
        # has already been updated).
        self.add_subcaption(
            content=subcaption,
            duration=subcaption_duration,
            offset=-run_time + subcaption_offset,
        )

</t>
<t tx="ekr.20250122151621.48">def __init__(
    self,
    center: Point3DLike = ORIGIN,
    radius: float = 1,
    resolution: Sequence[int] | None = None,
    u_range: Sequence[float] = (0, TAU),
    v_range: Sequence[float] = (0, PI),
    **kwargs,
</t>
<t tx="ekr.20250122151621.480">def wait(
    self,
    duration: float = DEFAULT_WAIT_TIME,
    stop_condition: Callable[[], bool] | None = None,
    frozen_frame: bool | None = None,
):
    """Plays a "no operation" animation.

    Parameters
    ----------
    duration
        The run time of the animation.
    stop_condition
        A function without positional arguments that is evaluated every time
        a frame is rendered. The animation only stops when the return value
        of the function is truthy, or when the time specified in ``duration``
        passes.
    frozen_frame
        If True, updater functions are not evaluated, and the animation outputs
        a frozen frame. If False, updater functions are called and frames
        are rendered as usual. If None (the default), the scene tries to
        determine whether or not the frame is frozen on its own.

    See also
    --------
    :class:`.Wait`, :meth:`.should_mobjects_update`
    """
    duration = self.validate_run_time(duration, self.wait, "duration")
    self.play(
        Wait(
            run_time=duration,
            stop_condition=stop_condition,
            frozen_frame=frozen_frame,
        )
    )

</t>
<t tx="ekr.20250122151621.481">def pause(self, duration: float = DEFAULT_WAIT_TIME):
    """Pauses the scene (i.e., displays a frozen frame).

    This is an alias for :meth:`.wait` with ``frozen_frame``
    set to ``True``.

    Parameters
    ----------
    duration
        The duration of the pause.

    See also
    --------
    :meth:`.wait`, :class:`.Wait`
    """
    duration = self.validate_run_time(duration, self.pause, "duration")
    self.wait(duration=duration, frozen_frame=True)

</t>
<t tx="ekr.20250122151621.482">def wait_until(self, stop_condition: Callable[[], bool], max_time: float = 60):
    """Wait until a condition is satisfied, up to a given maximum duration.

    Parameters
    ----------
    stop_condition
        A function with no arguments that determines whether or not the
        scene should keep waiting.
    max_time
        The maximum wait time in seconds.
    """
    max_time = self.validate_run_time(max_time, self.wait_until, "max_time")
    self.wait(max_time, stop_condition=stop_condition)

</t>
<t tx="ekr.20250122151621.483">def compile_animation_data(
    self,
    *animations: Animation | Mobject | _AnimationBuilder,
    **play_kwargs,
):
    """Given a list of animations, compile the corresponding
    static and moving mobjects, and gather the animation durations.

    This also begins the animations.

    Parameters
    ----------
    animations
        Animation or mobject with mobject method and params
    play_kwargs
        Named parameters affecting what was passed in ``animations``,
        e.g. ``run_time``, ``lag_ratio`` and so on.

    Returns
    -------
    self, None
        None if there is nothing to play, or self otherwise.
    """
    # NOTE TODO : returns statement of this method are wrong. It should return nothing, as it makes a little sense to get any information from this method.
    # The return are kept to keep webgl renderer from breaking.
    if len(animations) == 0:
        raise ValueError("Called Scene.play with no animations")

    self.animations = self.compile_animations(*animations, **play_kwargs)
    self.add_mobjects_from_animations(self.animations)

    self.last_t = 0
    self.stop_condition = None
    self.moving_mobjects = []
    self.static_mobjects = []

    self.duration = self.get_run_time(self.animations)
    if len(self.animations) == 1 and isinstance(self.animations[0], Wait):
        if self.should_update_mobjects():
            self.update_mobjects(dt=0)  # Any problems with this?
            self.stop_condition = self.animations[0].stop_condition
        else:
            # Static image logic when the wait is static is done by the renderer, not here.
            self.animations[0].is_static_wait = True
            return None

    return self

</t>
<t tx="ekr.20250122151621.484">def begin_animations(self) -&gt; None:
    """Start the animations of the scene."""
    for animation in self.animations:
        animation._setup_scene(self)
        animation.begin()

    if config.renderer == RendererType.CAIRO:
        # Paint all non-moving objects onto the screen, so they don't
        # have to be rendered every frame
        (
            self.moving_mobjects,
            self.static_mobjects,
        ) = self.get_moving_and_static_mobjects(self.animations)

</t>
<t tx="ekr.20250122151621.485">def is_current_animation_frozen_frame(self) -&gt; bool:
    """Returns whether the current animation produces a static frame (generally a Wait)."""
    return (
        isinstance(self.animations[0], Wait)
        and len(self.animations) == 1
        and self.animations[0].is_static_wait
    )

</t>
<t tx="ekr.20250122151621.486">def play_internal(self, skip_rendering: bool = False):
    """
    This method is used to prep the animations for rendering,
    apply the arguments and parameters required to them,
    render them, and write them to the video file.

    Parameters
    ----------
    skip_rendering
        Whether the rendering should be skipped, by default False
    """
    self.duration = self.get_run_time(self.animations)
    self.time_progression = self._get_animation_time_progression(
        self.animations,
        self.duration,
    )
    for t in self.time_progression:
        self.update_to_time(t)
        if not skip_rendering and not self.skip_animation_preview:
            self.renderer.render(self, t, self.moving_mobjects)
        if self.stop_condition is not None and self.stop_condition():
            self.time_progression.close()
            break

    for animation in self.animations:
        animation.finish()
        animation.clean_up_from_scene(self)
    if not self.renderer.skip_animations:
        self.update_mobjects(0)
    self.renderer.static_image = None
    # Closing the progress bar at the end of the play.
    self.time_progression.close()

</t>
<t tx="ekr.20250122151621.487">def check_interactive_embed_is_valid(self):
    if config["force_window"]:
        return True
    if self.skip_animation_preview:
        logger.warning(
            "Disabling interactive embed as 'skip_animation_preview' is enabled",
        )
        return False
    elif config["write_to_movie"]:
        logger.warning("Disabling interactive embed as 'write_to_movie' is enabled")
        return False
    elif config["format"]:
        logger.warning(
            "Disabling interactive embed as '--format' is set as "
            + config["format"],
        )
        return False
    elif not self.renderer.window:
        logger.warning("Disabling interactive embed as no window was created")
        return False
    elif config.dry_run:
        logger.warning("Disabling interactive embed as dry_run is enabled")
        return False
    return True

</t>
<t tx="ekr.20250122151621.488">def interactive_embed(self):
    """Like embed(), but allows for screen interaction."""
    if not self.check_interactive_embed_is_valid():
        return
    self.interactive_mode = True

    def ipython(shell, namespace):
        import manim.opengl

        def load_module_into_namespace(module, namespace):
            for name in dir(module):
                namespace[name] = getattr(module, name)

        load_module_into_namespace(manim, namespace)
        load_module_into_namespace(manim.opengl, namespace)

        def embedded_rerun(*args, **kwargs):
            self.queue.put(("rerun_keyboard", args, kwargs))
            shell.exiter()

        namespace["rerun"] = embedded_rerun

        shell(local_ns=namespace)
        self.queue.put(("exit_keyboard", [], {}))

    def get_embedded_method(method_name):
        return lambda *args, **kwargs: self.queue.put((method_name, args, kwargs))

    local_namespace = inspect.currentframe().f_back.f_locals
    for method in ("play", "wait", "add", "remove"):
        embedded_method = get_embedded_method(method)
        # Allow for calling scene methods without prepending 'self.'.
        local_namespace[method] = embedded_method

    from sqlite3 import connect

    from IPython.core.getipython import get_ipython
    from IPython.terminal.embed import InteractiveShellEmbed
    from traitlets.config import Config

    cfg = Config()
    cfg.TerminalInteractiveShell.confirm_exit = False
    if get_ipython() is None:
        shell = InteractiveShellEmbed.instance(config=cfg)
    else:
        shell = InteractiveShellEmbed(config=cfg)
    hist = get_ipython().history_manager
    hist.db = connect(hist.hist_file, check_same_thread=False)

    keyboard_thread = threading.Thread(
        target=ipython,
        args=(shell, local_namespace),
    )
    # run as daemon to kill thread when main thread exits
    if not shell.pt_app:
        keyboard_thread.daemon = True
    keyboard_thread.start()

    if self.dearpygui_imported and config["enable_gui"]:
        if not dpg.is_dearpygui_running():
            gui_thread = threading.Thread(
                target=configure_pygui,
                args=(self.renderer, self.widgets),
                kwargs={"update": False},
            )
            gui_thread.start()
        else:
            configure_pygui(self.renderer, self.widgets, update=True)

    self.camera.model_matrix = self.camera.default_model_matrix

    self.interact(shell, keyboard_thread)

</t>
<t tx="ekr.20250122151621.489">def interact(self, shell, keyboard_thread):
    event_handler = RerunSceneHandler(self.queue)
    file_observer = Observer()
    file_observer.schedule(event_handler, config["input_file"], recursive=True)
    file_observer.start()

    self.quit_interaction = False
    keyboard_thread_needs_join = shell.pt_app is not None
    assert self.queue.qsize() == 0

    last_time = time.time()
    while not (self.renderer.window.is_closing or self.quit_interaction):
        if not self.queue.empty():
            tup = self.queue.get_nowait()
            if tup[0].startswith("rerun"):
                # Intentionally skip calling join() on the file thread to save time.
                if not tup[0].endswith("keyboard"):
                    if shell.pt_app:
                        shell.pt_app.app.exit(exception=EOFError)
                    file_observer.unschedule_all()
                    raise RerunSceneException
                keyboard_thread.join()

                kwargs = tup[2]
                if "from_animation_number" in kwargs:
                    config["from_animation_number"] = kwargs[
                        "from_animation_number"
                    ]
                # # TODO: This option only makes sense if interactive_embed() is run at the
                # # end of a scene by default.
                # if "upto_animation_number" in kwargs:
                #     config["upto_animation_number"] = kwargs[
                #         "upto_animation_number"
                #     ]

                keyboard_thread.join()
                file_observer.unschedule_all()
                raise RerunSceneException
            elif tup[0].startswith("exit"):
                # Intentionally skip calling join() on the file thread to save time.
                if not tup[0].endswith("keyboard") and shell.pt_app:
                    shell.pt_app.app.exit(exception=EOFError)
                keyboard_thread.join()
                # Remove exit_keyboard from the queue if necessary.
                while self.queue.qsize() &gt; 0:
                    self.queue.get()
                keyboard_thread_needs_join = False
                break
            else:
                method, args, kwargs = tup
                getattr(self, method)(*args, **kwargs)
        else:
            self.renderer.animation_start_time = 0
            dt = time.time() - last_time
            last_time = time.time()
            self.renderer.render(self, dt, self.moving_mobjects)
            self.update_mobjects(dt)
            self.update_meshes(dt)
            self.update_self(dt)

    # Join the keyboard thread if necessary.
    if shell is not None and keyboard_thread_needs_join:
        shell.pt_app.app.exit(exception=EOFError)
        keyboard_thread.join()
        # Remove exit_keyboard from the queue if necessary.
        while self.queue.qsize() &gt; 0:
            self.queue.get()

    file_observer.stop()
    file_observer.join()

    if self.dearpygui_imported and config["enable_gui"]:
        dpg.stop_dearpygui()

    if self.renderer.window.is_closing:
        self.renderer.window.destroy()

</t>
<t tx="ekr.20250122151621.49">) -&gt; None:
    if config.renderer == RendererType.OPENGL:
        res_value = (101, 51)
    elif config.renderer == RendererType.CAIRO:
        res_value = (24, 12)
    else:
        raise Exception("Unknown renderer")

    resolution = resolution if resolution is not None else res_value

    self.radius = radius

    super().__init__(
        self.func,
        resolution=resolution,
        u_range=u_range,
        v_range=v_range,
        **kwargs,
    )

    self.shift(center)

def func(self, u: float, v: float) -&gt; np.ndarray:
    """The z values defining the :class:`Sphere` being plotted.

    Returns
    -------
    :class:`numpy.array`
        The z values defining the :class:`Sphere`.
    """
    return self.radius * np.array(
        [np.cos(u) * np.sin(v), np.sin(u) * np.sin(v), -np.cos(v)],
    )


</t>
<t tx="ekr.20250122151621.490">def embed(self):
    if not config["preview"]:
        logger.warning("Called embed() while no preview window is available.")
        return
    if config["write_to_movie"]:
        logger.warning("embed() is skipped while writing to a file.")
        return

    self.renderer.animation_start_time = 0
    self.renderer.render(self, -1, self.moving_mobjects)

    # Configure IPython shell.
    from IPython.terminal.embed import InteractiveShellEmbed

    shell = InteractiveShellEmbed()

    # Have the frame update after each command
    shell.events.register(
        "post_run_cell",
        lambda *a, **kw: self.renderer.render(self, -1, self.moving_mobjects),
    )

    # Use the locals of the caller as the local namespace
    # once embedded, and add a few custom shortcuts.
    local_ns = inspect.currentframe().f_back.f_locals
    # local_ns["touch"] = self.interact
    for method in (
        "play",
        "wait",
        "add",
        "remove",
        "interact",
        # "clear",
        # "save_state",
        # "restore",
    ):
        local_ns[method] = getattr(self, method)
    shell(local_ns=local_ns, stack_depth=2)

    # End scene when exiting an embed.
    raise Exception("Exiting scene.")

</t>
<t tx="ekr.20250122151621.491">def update_to_time(self, t):
    dt = t - self.last_t
    self.last_t = t
    for animation in self.animations:
        animation.update_mobjects(dt)
        alpha = t / animation.run_time
        animation.interpolate(alpha)
    self.update_mobjects(dt)
    self.update_meshes(dt)
    self.update_self(dt)

</t>
<t tx="ekr.20250122151621.492">def add_subcaption(
    self, content: str, duration: float = 1, offset: float = 0
) -&gt; None:
    r"""Adds an entry in the corresponding subcaption file
    at the current time stamp.

    The current time stamp is obtained from ``Scene.time``.

    Parameters
    ----------

    content
        The subcaption content.
    duration
        The duration (in seconds) for which the subcaption is shown.
    offset
        This offset (in seconds) is added to the starting time stamp
        of the subcaption.

    Examples
    --------

    This example illustrates both possibilities for adding
    subcaptions to Manimations::

        class SubcaptionExample(Scene):
            def construct(self):
                square = Square()
                circle = Circle()

                # first option: via the add_subcaption method
                self.add_subcaption("Hello square!", duration=1)
                self.play(Create(square))

                # second option: within the call to Scene.play
                self.play(
                    Transform(square, circle), subcaption="The square transforms."
                )

    """
    subtitle = srt.Subtitle(
        index=len(self.renderer.file_writer.subcaptions),
        content=content,
        start=datetime.timedelta(seconds=float(self.time + offset)),
        end=datetime.timedelta(seconds=float(self.time + offset + duration)),
    )
    self.renderer.file_writer.subcaptions.append(subtitle)

</t>
<t tx="ekr.20250122151621.493">def add_sound(
    self,
    sound_file: str,
    time_offset: float = 0,
    gain: float | None = None,
    **kwargs,
):
    """
    This method is used to add a sound to the animation.

    Parameters
    ----------

    sound_file
        The path to the sound file.
    time_offset
        The offset in the sound file after which
        the sound can be played.
    gain
        Amplification of the sound.

    Examples
    --------
    .. manim:: SoundExample
        :no_autoplay:

        class SoundExample(Scene):
            # Source of sound under Creative Commons 0 License. https://freesound.org/people/Druminfected/sounds/250551/
            def construct(self):
                dot = Dot().set_color(GREEN)
                self.add_sound("click.wav")
                self.add(dot)
                self.wait()
                self.add_sound("click.wav")
                dot.set_color(BLUE)
                self.wait()
                self.add_sound("click.wav")
                dot.set_color(RED)
                self.wait()

    Download the resource for the previous example `here &lt;https://github.com/ManimCommunity/manim/blob/main/docs/source/_static/click.wav&gt;`_ .
    """
    if self.renderer.skip_animations:
        return
    time = self.time + time_offset
    self.renderer.file_writer.add_sound(sound_file, time, gain, **kwargs)

</t>
<t tx="ekr.20250122151621.494">def on_mouse_motion(self, point, d_point):
    self.mouse_point.move_to(point)
    if SHIFT_VALUE in self.renderer.pressed_keys:
        shift = -d_point
        shift[0] *= self.camera.get_width() / 2
        shift[1] *= self.camera.get_height() / 2
        transform = self.camera.inverse_rotation_matrix
        shift = np.dot(np.transpose(transform), shift)
        self.camera.shift(shift)

</t>
<t tx="ekr.20250122151621.495">def on_mouse_scroll(self, point, offset):
    if not config.use_projection_stroke_shaders:
        factor = 1 + np.arctan(-2.1 * offset[1])
        self.camera.scale(factor, about_point=self.camera_target)
    self.mouse_scroll_orbit_controls(point, offset)

</t>
<t tx="ekr.20250122151621.496">def on_key_press(self, symbol, modifiers):
    try:
        char = chr(symbol)
    except OverflowError:
        logger.warning("The value of the pressed key is too large.")
        return

    if char == "r":
        self.camera.to_default_state()
        self.camera_target = np.array([0, 0, 0], dtype=np.float32)
    elif char == "q":
        self.quit_interaction = True
    else:
        if char in self.key_to_function_map:
            self.key_to_function_map[char]()

</t>
<t tx="ekr.20250122151621.497">def on_key_release(self, symbol, modifiers):
    pass

</t>
<t tx="ekr.20250122151621.498">def on_mouse_drag(self, point, d_point, buttons, modifiers):
    self.mouse_drag_point.move_to(point)
    if buttons == 1:
        self.camera.increment_theta(-d_point[0])
        self.camera.increment_phi(d_point[1])
    elif buttons == 4:
        camera_x_axis = self.camera.model_matrix[:3, 0]
        horizontal_shift_vector = -d_point[0] * camera_x_axis
        vertical_shift_vector = -d_point[1] * np.cross(OUT, camera_x_axis)
        total_shift_vector = horizontal_shift_vector + vertical_shift_vector
        self.camera.shift(1.1 * total_shift_vector)

    self.mouse_drag_orbit_controls(point, d_point, buttons, modifiers)

</t>
<t tx="ekr.20250122151621.499">def mouse_scroll_orbit_controls(self, point, offset):
    camera_to_target = self.camera_target - self.camera.get_position()
    camera_to_target *= np.sign(offset[1])
    shift_vector = 0.01 * camera_to_target
    self.camera.model_matrix = (
        opengl.translation_matrix(*shift_vector) @ self.camera.model_matrix
    )

</t>
<t tx="ekr.20250122151621.5">class Tetrahedron(Polyhedron):
    """A tetrahedron, one of the five platonic solids. It has 4 faces, 6 edges, and 4 vertices.

    Parameters
    ----------
    edge_length
        The length of an edge between any two vertices.

    Examples
    --------

    .. manim:: TetrahedronScene
        :save_last_frame:

        class TetrahedronScene(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                obj = Tetrahedron()
                self.add(obj)
    """

    @others
</t>
<t tx="ekr.20250122151621.50">def __init__(
    self,
    point: list | np.ndarray = ORIGIN,
    radius: float = DEFAULT_DOT_RADIUS,
    color: ParsableManimColor = WHITE,
    resolution: tuple[int, int] = (8, 8),
    **kwargs,
</t>
<t tx="ekr.20250122151621.500">def mouse_drag_orbit_controls(self, point, d_point, buttons, modifiers):
    # Left click drag.
    if buttons == 1:
        # Translate to target the origin and rotate around the z axis.
        self.camera.model_matrix = (
            opengl.rotation_matrix(z=-d_point[0])
            @ opengl.translation_matrix(*-self.camera_target)
            @ self.camera.model_matrix
        )

        # Rotation off of the z axis.
        camera_position = self.camera.get_position()
        camera_y_axis = self.camera.model_matrix[:3, 1]
        axis_of_rotation = space_ops.normalize(
            np.cross(camera_y_axis, camera_position),
        )
        rotation_matrix = space_ops.rotation_matrix(
            d_point[1],
            axis_of_rotation,
            homogeneous=True,
        )

        maximum_polar_angle = self.camera.maximum_polar_angle
        minimum_polar_angle = self.camera.minimum_polar_angle

        potential_camera_model_matrix = rotation_matrix @ self.camera.model_matrix
        potential_camera_location = potential_camera_model_matrix[:3, 3]
        potential_camera_y_axis = potential_camera_model_matrix[:3, 1]
        sign = (
            np.sign(potential_camera_y_axis[2])
            if potential_camera_y_axis[2] != 0
            else 1
        )
        potential_polar_angle = sign * np.arccos(
            potential_camera_location[2]
            / np.linalg.norm(potential_camera_location),
        )
        if minimum_polar_angle &lt;= potential_polar_angle &lt;= maximum_polar_angle:
            self.camera.model_matrix = potential_camera_model_matrix
        else:
            sign = np.sign(camera_y_axis[2]) if camera_y_axis[2] != 0 else 1
            current_polar_angle = sign * np.arccos(
                camera_position[2] / np.linalg.norm(camera_position),
            )
            if potential_polar_angle &gt; maximum_polar_angle:
                polar_angle_delta = maximum_polar_angle - current_polar_angle
            else:
                polar_angle_delta = minimum_polar_angle - current_polar_angle
            rotation_matrix = space_ops.rotation_matrix(
                polar_angle_delta,
                axis_of_rotation,
                homogeneous=True,
            )
            self.camera.model_matrix = rotation_matrix @ self.camera.model_matrix

        # Translate to target the original target.
        self.camera.model_matrix = (
            opengl.translation_matrix(*self.camera_target)
            @ self.camera.model_matrix
        )
    # Right click drag.
    elif buttons == 4:
        camera_x_axis = self.camera.model_matrix[:3, 0]
        horizontal_shift_vector = -d_point[0] * camera_x_axis
        vertical_shift_vector = -d_point[1] * np.cross(OUT, camera_x_axis)
        total_shift_vector = horizontal_shift_vector + vertical_shift_vector

        self.camera.model_matrix = (
            opengl.translation_matrix(*total_shift_vector)
            @ self.camera.model_matrix
        )
        self.camera_target += total_shift_vector

</t>
<t tx="ekr.20250122151621.501">def set_key_function(self, char, func):
    self.key_to_function_map[char] = func

</t>
<t tx="ekr.20250122151621.502">def on_mouse_press(self, point, button, modifiers):
    for func in self.mouse_press_callbacks:
        func()
</t>
<t tx="ekr.20250122151621.503">"""The interface between scenes and ffmpeg."""

from __future__ import annotations

__all__ = ["SceneFileWriter"]

import json
import shutil
from fractions import Fraction
from pathlib import Path
from queue import Queue
from tempfile import NamedTemporaryFile
from threading import Thread
from typing import TYPE_CHECKING, Any

import av
import numpy as np
import srt
from PIL import Image
from pydub import AudioSegment

from manim import __version__
from manim.typing import PixelArray, StrPath

from .. import config, logger
from .._config.logger_utils import set_file_logger
from ..constants import RendererType
from ..utils.file_ops import (
    add_extension_if_not_present,
    add_version_before_extension,
    guarantee_existence,
    is_gif_format,
    is_png_format,
    modify_atime,
    write_to_movie,
)
from ..utils.sounds import get_full_sound_file_path
from .section import DefaultSectionType, Section

if TYPE_CHECKING:
    from manim.renderer.cairo_renderer import CairoRenderer
    from manim.renderer.opengl_renderer import OpenGLRenderer


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.504">def to_av_frame_rate(fps):
    epsilon1 = 1e-4
    epsilon2 = 0.02

    if isinstance(fps, int):
        (num, denom) = (fps, 1)
    elif abs(fps - round(fps)) &lt; epsilon1:
        (num, denom) = (round(fps), 1)
    else:
        denom = 1001
        num = round(fps * denom / 1000) * 1000
        if abs(fps - num / denom) &gt;= epsilon2:
            raise ValueError("invalid frame rate")

    return Fraction(num, denom)


</t>
<t tx="ekr.20250122151621.505">def convert_audio(input_path: Path, output_path: Path, codec_name: str):
    with (
        av.open(input_path) as input_audio,
        av.open(output_path, "w") as output_audio,
    ):
        input_audio_stream = input_audio.streams.audio[0]
        output_audio_stream = output_audio.add_stream(codec_name)
        for frame in input_audio.decode(input_audio_stream):
            for packet in output_audio_stream.encode(frame):
                output_audio.mux(packet)

        for packet in output_audio_stream.encode():
            output_audio.mux(packet)


</t>
<t tx="ekr.20250122151621.506">class SceneFileWriter:
    """
    SceneFileWriter is the object that actually writes the animations
    played, into video files, using FFMPEG.
    This is mostly for Manim's internal use. You will rarely, if ever,
    have to use the methods for this class, unless tinkering with the very
    fabric of Manim's reality.

    Attributes
    ----------
        sections : list of :class:`.Section`
            used to segment scene

        sections_output_dir : :class:`pathlib.Path`
            where are section videos stored

        output_name : str
            name of movie without extension and basis for section video names

    Some useful attributes are:
        "write_to_movie" (bool=False)
            Whether or not to write the animations into a video file.
        "movie_file_extension" (str=".mp4")
            The file-type extension of the outputted video.
        "partial_movie_files"
            List of all the partial-movie files.

    """

    @others
</t>
<t tx="ekr.20250122151621.507">force_output_as_scene_name = False

def __init__(
    self,
    renderer: CairoRenderer | OpenGLRenderer,
    scene_name: StrPath,
    **kwargs: Any,
) -&gt; None:
    self.renderer = renderer
    self.init_output_directories(scene_name)
    self.init_audio()
    self.frame_count = 0
    self.partial_movie_files: list[str] = []
    self.subcaptions: list[srt.Subtitle] = []
    self.sections: list[Section] = []
    # first section gets automatically created for convenience
    # if you need the first section to be skipped, add a first section by hand, it will replace this one
    self.next_section(
        name="autocreated", type_=DefaultSectionType.NORMAL, skip_animations=False
    )

</t>
<t tx="ekr.20250122151621.508">def init_output_directories(self, scene_name: StrPath) -&gt; None:
    """Initialise output directories.

    Notes
    -----
    The directories are read from ``config``, for example
    ``config['media_dir']``.  If the target directories don't already
    exist, they will be created.

    """
    if config["dry_run"]:  # in dry-run mode there is no output
        return

    module_name = config.get_dir("input_file").stem if config["input_file"] else ""

    if SceneFileWriter.force_output_as_scene_name:
        self.output_name = Path(scene_name)
    elif config["output_file"] and not config["write_all"]:
        self.output_name = config.get_dir("output_file")
    else:
        self.output_name = Path(scene_name)

    if config["media_dir"]:
        image_dir = guarantee_existence(
            config.get_dir(
                "images_dir", module_name=module_name, scene_name=scene_name
            ),
        )
        self.image_file_path = image_dir / add_extension_if_not_present(
            self.output_name, ".png"
        )

    if write_to_movie():
        movie_dir = guarantee_existence(
            config.get_dir(
                "video_dir", module_name=module_name, scene_name=scene_name
            ),
        )
        self.movie_file_path = movie_dir / add_extension_if_not_present(
            self.output_name, config["movie_file_extension"]
        )

        # TODO: /dev/null would be good in case sections_output_dir is used without being set (doesn't work on Windows), everyone likes defensive programming, right?
        self.sections_output_dir = Path("")
        if config.save_sections:
            self.sections_output_dir = guarantee_existence(
                config.get_dir(
                    "sections_dir", module_name=module_name, scene_name=scene_name
                )
            )

        if is_gif_format():
            self.gif_file_path = add_extension_if_not_present(
                self.output_name, ".gif"
            )

            if not config["output_file"]:
                self.gif_file_path = add_version_before_extension(
                    self.gif_file_path
                )

            self.gif_file_path = movie_dir / self.gif_file_path

        self.partial_movie_directory = guarantee_existence(
            config.get_dir(
                "partial_movie_dir",
                scene_name=scene_name,
                module_name=module_name,
            ),
        )

        if config["log_to_file"]:
            log_dir = guarantee_existence(config.get_dir("log_dir"))
            set_file_logger(
                scene_name=scene_name, module_name=module_name, log_dir=log_dir
            )

</t>
<t tx="ekr.20250122151621.509">def finish_last_section(self) -&gt; None:
    """Delete current section if it is empty."""
    if len(self.sections) and self.sections[-1].is_empty():
        self.sections.pop()

</t>
<t tx="ekr.20250122151621.51">def __init__(
    self,
    side_length: float = 2,
    fill_opacity: float = 0.75,
    fill_color: ParsableManimColor = BLUE,
    stroke_width: float = 0,
    **kwargs,
) -&gt; None:
    self.side_length = side_length
    super().__init__(
        fill_color=fill_color,
        fill_opacity=fill_opacity,
        stroke_width=stroke_width,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151621.510">def next_section(self, name: str, type_: str, skip_animations: bool) -&gt; None:
    """Create segmentation cut here."""
    self.finish_last_section()

    # images don't support sections
    section_video: str | None = None
    # don't save when None
    if (
        not config.dry_run
        and write_to_movie()
        and config.save_sections
        and not skip_animations
    ):
        # relative to index file
        section_video = f"{self.output_name}_{len(self.sections):04}_{name}{config.movie_file_extension}"

    self.sections.append(
        Section(
            type_,
            section_video,
            name,
            skip_animations,
        ),
    )

</t>
<t tx="ekr.20250122151621.511">def add_partial_movie_file(self, hash_animation: str):
    """Adds a new partial movie file path to `scene.partial_movie_files` and current section from a hash.
    This method will compute the path from the hash. In addition to that it adds the new animation to the current section.

    Parameters
    ----------
    hash_animation
        Hash of the animation.
    """
    if not hasattr(self, "partial_movie_directory") or not write_to_movie():
        return

    # None has to be added to partial_movie_files to keep the right index with scene.num_plays.
    # i.e if an animation is skipped, scene.num_plays is still incremented and we add an element to partial_movie_file be even with num_plays.
    if hash_animation is None:
        self.partial_movie_files.append(None)
        self.sections[-1].partial_movie_files.append(None)
    else:
        new_partial_movie_file = str(
            self.partial_movie_directory
            / f"{hash_animation}{config['movie_file_extension']}"
        )
        self.partial_movie_files.append(new_partial_movie_file)
        self.sections[-1].partial_movie_files.append(new_partial_movie_file)

</t>
<t tx="ekr.20250122151621.512">def get_resolution_directory(self):
    """Get the name of the resolution directory directly containing
    the video file.

    This method gets the name of the directory that immediately contains the
    video file. This name is ``&lt;height_in_pixels_of_video&gt;p&lt;frame_rate&gt;``.
    For example, if you are rendering an 854x480 px animation at 15fps,
    the name of the directory that immediately contains the video,  file
    will be ``480p15``.

    The file structure should look something like::

        MEDIA_DIR
            |--Tex
            |--texts
            |--videos
            |--&lt;name_of_file_containing_scene&gt;
                |--&lt;height_in_pixels_of_video&gt;p&lt;frame_rate&gt;
                    |--&lt;scene_name&gt;.mp4

    Returns
    -------
    :class:`str`
        The name of the directory.
    """
    pixel_height = config["pixel_height"]
    frame_rate = config["frame_rate"]
    return f"{pixel_height}p{frame_rate}"

</t>
<t tx="ekr.20250122151621.513"># Sound
def init_audio(self):
    """Preps the writer for adding audio to the movie."""
    self.includes_sound = False

</t>
<t tx="ekr.20250122151621.514">def create_audio_segment(self):
    """Creates an empty, silent, Audio Segment."""
    self.audio_segment = AudioSegment.silent()

</t>
<t tx="ekr.20250122151621.515">def add_audio_segment(
    self,
    new_segment: AudioSegment,
    time: float | None = None,
    gain_to_background: float | None = None,
):
    """
    This method adds an audio segment from an
    AudioSegment type object and suitable parameters.

    Parameters
    ----------
    new_segment
        The audio segment to add

    time
        the timestamp at which the
        sound should be added.

    gain_to_background
        The gain of the segment from the background.
    """
    if not self.includes_sound:
        self.includes_sound = True
        self.create_audio_segment()
    segment = self.audio_segment
    curr_end = segment.duration_seconds
    if time is None:
        time = curr_end
    if time &lt; 0:
        raise ValueError("Adding sound at timestamp &lt; 0")

    new_end = time + new_segment.duration_seconds
    diff = new_end - curr_end
    if diff &gt; 0:
        segment = segment.append(
            AudioSegment.silent(int(np.ceil(diff * 1000))),
            crossfade=0,
        )
    self.audio_segment = segment.overlay(
        new_segment,
        position=int(1000 * time),
        gain_during_overlay=gain_to_background,
    )

</t>
<t tx="ekr.20250122151621.516">def add_sound(
    self,
    sound_file: str,
    time: float | None = None,
    gain: float | None = None,
    **kwargs,
):
    """
    This method adds an audio segment from a sound file.

    Parameters
    ----------
    sound_file
        The path to the sound file.

    time
        The timestamp at which the audio should be added.

    gain
        The gain of the given audio segment.

    **kwargs
        This method uses add_audio_segment, so any keyword arguments
        used there can be referenced here.

    """
    file_path = get_full_sound_file_path(sound_file)
    # we assume files with .wav / .raw suffix are actually
    # .wav and .raw files, respectively.
    if file_path.suffix not in (".wav", ".raw"):
        # we need to pass delete=False to work on Windows
        # TODO: figure out a way to cache the wav file generated (benchmark needed)
        with NamedTemporaryFile(suffix=".wav", delete=False) as wav_file_path:
            convert_audio(file_path, wav_file_path, "pcm_s16le")
            new_segment = AudioSegment.from_file(wav_file_path.name)
            logger.info(f"Automatically converted {file_path} to .wav")
        Path(wav_file_path.name).unlink()
    else:
        new_segment = AudioSegment.from_file(file_path)

    if gain:
        new_segment = new_segment.apply_gain(gain)
    self.add_audio_segment(new_segment, time, **kwargs)

</t>
<t tx="ekr.20250122151621.517"># Writers
def begin_animation(
    self, allow_write: bool = False, file_path: StrPath | None = None
) -&gt; None:
    """
    Used internally by manim to stream the animation to FFMPEG for
    displaying or writing to a file.

    Parameters
    ----------
    allow_write
        Whether or not to write to a video file.
    """
    if write_to_movie() and allow_write:
        self.open_partial_movie_stream(file_path=file_path)

</t>
<t tx="ekr.20250122151621.518">def end_animation(self, allow_write: bool = False) -&gt; None:
    """
    Internally used by Manim to stop streaming to
    FFMPEG gracefully.

    Parameters
    ----------
    allow_write
        Whether or not to write to a video file.
    """
    if write_to_movie() and allow_write:
        self.close_partial_movie_stream()

</t>
<t tx="ekr.20250122151621.519">def listen_and_write(self):
    """For internal use only: blocks until new frame is available on the queue."""
    while True:
        num_frames, frame_data = self.queue.get()
        if frame_data is None:
            break

        self.encode_and_write_frame(frame_data, num_frames)

</t>
<t tx="ekr.20250122151621.52">def generate_points(self) -&gt; None:
    """Creates the sides of the :class:`Cube`."""
    for vect in IN, OUT, LEFT, RIGHT, UP, DOWN:
        face = Square(
            side_length=self.side_length,
            shade_in_3d=True,
        )
        face.flip()
        face.shift(self.side_length * OUT / 2.0)
        face.apply_matrix(z_to_vector(vect))

        self.add(face)

</t>
<t tx="ekr.20250122151621.520">def encode_and_write_frame(self, frame: PixelArray, num_frames: int) -&gt; None:
    """
    For internal use only: takes a given frame in ``np.ndarray`` format and
    write it to the stream
    """
    for _ in range(num_frames):
        # Notes: precomputing reusing packets does not work!
        # I.e., you cannot do `packets = encode(...)`
        # and reuse it, as it seems that `mux(...)`
        # consumes the packet.
        # The same issue applies for `av_frame`,
        # reusing it renders weird-looking frames.
        av_frame = av.VideoFrame.from_ndarray(frame, format="rgba")
        for packet in self.video_stream.encode(av_frame):
            self.video_container.mux(packet)

</t>
<t tx="ekr.20250122151621.521">def write_frame(
    self, frame_or_renderer: np.ndarray | OpenGLRenderer, num_frames: int = 1
):
    """
    Used internally by Manim to write a frame to
    the FFMPEG input buffer.

    Parameters
    ----------
    frame_or_renderer
        Pixel array of the frame.
    num_frames
        The number of times to write frame.
    """
    if write_to_movie():
        frame: np.ndarray = (
            frame_or_renderer.get_frame()
            if config.renderer == RendererType.OPENGL
            else frame_or_renderer
        )

        msg = (num_frames, frame)
        self.queue.put(msg)

    if is_png_format() and not config["dry_run"]:
        image: Image = (
            frame_or_renderer.get_image()
            if config.renderer == RendererType.OPENGL
            else Image.fromarray(frame_or_renderer)
        )
        target_dir = self.image_file_path.parent / self.image_file_path.stem
        extension = self.image_file_path.suffix
        self.output_image(
            image,
            target_dir,
            extension,
            config["zero_pad"],
        )

</t>
<t tx="ekr.20250122151621.522">def output_image(self, image: Image.Image, target_dir, ext, zero_pad: bool):
    if zero_pad:
        image.save(f"{target_dir}{str(self.frame_count).zfill(zero_pad)}{ext}")
    else:
        image.save(f"{target_dir}{self.frame_count}{ext}")
    self.frame_count += 1

</t>
<t tx="ekr.20250122151621.523">def save_final_image(self, image: np.ndarray):
    """
    The name is a misnomer. This method saves the image
    passed to it as an in the default image directory.

    Parameters
    ----------
    image
        The pixel array of the image to save.
    """
    if config["dry_run"]:
        return
    if not config["output_file"]:
        self.image_file_path = add_version_before_extension(self.image_file_path)

    image.save(self.image_file_path)
    self.print_file_ready_message(self.image_file_path)

</t>
<t tx="ekr.20250122151621.524">def finish(self) -&gt; None:
    """
    Finishes writing to the FFMPEG buffer or writing images
    to output directory.
    Combines the partial movie files into the
    whole scene.
    If save_last_frame is True, saves the last
    frame in the default image directory.
    """
    if write_to_movie():
        self.combine_to_movie()
        if config.save_sections:
            self.combine_to_section_videos()
        if config["flush_cache"]:
            self.flush_cache_directory()
        else:
            self.clean_cache()
    elif is_png_format() and not config["dry_run"]:
        target_dir = self.image_file_path.parent / self.image_file_path.stem
        logger.info("\n%i images ready at %s\n", self.frame_count, str(target_dir))
    if self.subcaptions:
        self.write_subcaption_file()

</t>
<t tx="ekr.20250122151621.525">def open_partial_movie_stream(self, file_path=None) -&gt; None:
    """Open a container holding a video stream.

    This is used internally by Manim initialize the container holding
    the video stream of a partial movie file.
    """
    if file_path is None:
        file_path = self.partial_movie_files[self.renderer.num_plays]
    self.partial_movie_file_path = file_path

    fps = to_av_frame_rate(config.frame_rate)

    partial_movie_file_codec = "libx264"
    partial_movie_file_pix_fmt = "yuv420p"
    av_options = {
        "an": "1",  # ffmpeg: -an, no audio
        "crf": "23",  # ffmpeg: -crf, constant rate factor (improved bitrate)
    }

    if config.movie_file_extension == ".webm":
        partial_movie_file_codec = "libvpx-vp9"
        av_options["-auto-alt-ref"] = "1"
        if config.transparent:
            partial_movie_file_pix_fmt = "yuva420p"

    elif config.transparent:
        partial_movie_file_codec = "qtrle"
        partial_movie_file_pix_fmt = "argb"

    with av.open(file_path, mode="w") as video_container:
        stream = video_container.add_stream(
            partial_movie_file_codec,
            rate=fps,
            options=av_options,
        )
        stream.pix_fmt = partial_movie_file_pix_fmt
        stream.width = config.pixel_width
        stream.height = config.pixel_height

        self.video_container = video_container
        self.video_stream = stream

        self.queue: Queue[tuple[int, PixelArray | None]] = Queue()
        self.writer_thread = Thread(target=self.listen_and_write, args=())
        self.writer_thread.start()

</t>
<t tx="ekr.20250122151621.526">def close_partial_movie_stream(self) -&gt; None:
    """Close the currently opened video container.

    Used internally by Manim to first flush the remaining packages
    in the video stream holding a partial file, and then close
    the corresponding container.
    """
    self.queue.put((-1, None))
    self.writer_thread.join()

    for packet in self.video_stream.encode():
        self.video_container.mux(packet)

    self.video_container.close()

    logger.info(
        f"Animation {self.renderer.num_plays} : Partial movie file written in %(path)s",
        {"path": f"'{self.partial_movie_file_path}'"},
    )

</t>
<t tx="ekr.20250122151621.527">def is_already_cached(self, hash_invocation: str):
    """Will check if a file named with `hash_invocation` exists.

    Parameters
    ----------
    hash_invocation
        The hash corresponding to an invocation to either `scene.play` or `scene.wait`.

    Returns
    -------
    :class:`bool`
        Whether the file exists.
    """
    if not hasattr(self, "partial_movie_directory") or not write_to_movie():
        return False
    path = (
        self.partial_movie_directory
        / f"{hash_invocation}{config['movie_file_extension']}"
    )
    return path.exists()

</t>
<t tx="ekr.20250122151621.528">def combine_files(
    self,
    input_files: list[str],
    output_file: Path,
    create_gif=False,
    includes_sound=False,
):
    file_list = self.partial_movie_directory / "partial_movie_file_list.txt"
    logger.debug(
        f"Partial movie files to combine ({len(input_files)} files): %(p)s",
        {"p": input_files[:5]},
    )
    with file_list.open("w", encoding="utf-8") as fp:
        fp.write("# This file is used internally by FFMPEG.\n")
        for pf_path in input_files:
            pf_path = Path(pf_path).as_posix()
            fp.write(f"file 'file:{pf_path}'\n")

    av_options = {
        "safe": "0",  # needed to read files
    }

    if not includes_sound:
        av_options["an"] = "1"

    partial_movies_input = av.open(
        str(file_list), options=av_options, format="concat"
    )
    partial_movies_stream = partial_movies_input.streams.video[0]
    output_container = av.open(str(output_file), mode="w")
    output_container.metadata["comment"] = (
        f"Rendered with Manim Community v{__version__}"
    )
    output_stream = output_container.add_stream(
        codec_name="gif" if create_gif else None,
        template=partial_movies_stream if not create_gif else None,
    )
    if config.transparent and config.movie_file_extension == ".webm":
        output_stream.pix_fmt = "yuva420p"
    if create_gif:
        """
        The following solution was largely inspired from this comment
        https://github.com/imageio/imageio/issues/995#issuecomment-1580533018,
        and the following code
        https://github.com/imageio/imageio/blob/65d79140018bb7c64c0692ea72cb4093e8d632a0/imageio/plugins/pyav.py#L927-L996.
        """
        output_stream.pix_fmt = "rgb8"
        if config.transparent:
            output_stream.pix_fmt = "pal8"
        output_stream.width = config.pixel_width
        output_stream.height = config.pixel_height
        output_stream.rate = to_av_frame_rate(config.frame_rate)
        graph = av.filter.Graph()
        input_buffer = graph.add_buffer(template=partial_movies_stream)
        split = graph.add("split")
        palettegen = graph.add("palettegen", "stats_mode=diff")
        paletteuse = graph.add(
            "paletteuse", "dither=bayer:bayer_scale=5:diff_mode=rectangle"
        )
        output_sink = graph.add("buffersink")

        input_buffer.link_to(split)
        split.link_to(palettegen, 0, 0)  # 1st input of split -&gt; input of palettegen
        split.link_to(paletteuse, 1, 0)  # 2nd output of split -&gt; 1st input
        palettegen.link_to(paletteuse, 0, 1)  # output of palettegen -&gt; 2nd input
        paletteuse.link_to(output_sink)

        graph.configure()

        for frame in partial_movies_input.decode(video=0):
            graph.push(frame)

        graph.push(None)  # EOF: https://github.com/PyAV-Org/PyAV/issues/886.

        frames_written = 0
        while True:
            try:
                frame = graph.pull()
                if output_stream.codec_context.time_base is not None:
                    frame.time_base = output_stream.codec_context.time_base
                frame.pts = frames_written
                frames_written += 1
                output_container.mux(output_stream.encode(frame))
            except av.error.EOFError:
                break

        for packet in output_stream.encode():
            output_container.mux(packet)

    else:
        for packet in partial_movies_input.demux(partial_movies_stream):
            # We need to skip the "flushing" packets that `demux` generates.
            if packet.dts is None:
                continue

            packet.dts = None  # This seems to be needed, as dts from consecutive
            # files may not be monotically increasing, so we let libav compute it.

            # We need to assign the packet to the new stream.
            packet.stream = output_stream
            output_container.mux(packet)

    partial_movies_input.close()
    output_container.close()

</t>
<t tx="ekr.20250122151621.529">def combine_to_movie(self):
    """Used internally by Manim to combine the separate
    partial movie files that make up a Scene into a single
    video file for that Scene.
    """
    partial_movie_files = [el for el in self.partial_movie_files if el is not None]
    # NOTE: Here we should do a check and raise an exception if partial
    # movie file is empty.  We can't, as a lot of stuff (in particular, in
    # tests) use scene initialization, and this error would be raised as
    # it's just an empty scene initialized.

    # determine output path
    movie_file_path = self.movie_file_path
    if is_gif_format():
        movie_file_path = self.gif_file_path

    if len(partial_movie_files) == 0:  # Prevent calling concat on empty list
        logger.info("No animations are contained in this scene.")
        return

    logger.info("Combining to Movie file.")
    self.combine_files(
        partial_movie_files,
        movie_file_path,
        is_gif_format(),
        self.includes_sound,
    )

    # handle sound
    if self.includes_sound and config.format != "gif":
        sound_file_path = movie_file_path.with_suffix(".wav")
        # Makes sure sound file length will match video file
        self.add_audio_segment(AudioSegment.silent(0))
        self.audio_segment.export(
            sound_file_path,
            format="wav",
            bitrate="312k",
        )
        # Audio added to a VP9 encoded (webm) video file needs
        # to be encoded as vorbis or opus. Directly exporting
        # self.audio_segment with such a codec works in principle,
        # but tries to call ffmpeg via its CLI -- which we want
        # to avoid. This is why we need to do the conversion
        # manually.
        if config.movie_file_extension == ".webm":
            ogg_sound_file_path = sound_file_path.with_suffix(".ogg")
            convert_audio(sound_file_path, ogg_sound_file_path, "libvorbis")
            sound_file_path = ogg_sound_file_path
        elif config.movie_file_extension == ".mp4":
            # Similarly, pyav may reject wav audio in an .mp4 file;
            # convert to AAC.
            aac_sound_file_path = sound_file_path.with_suffix(".aac")
            convert_audio(sound_file_path, aac_sound_file_path, "aac")
            sound_file_path = aac_sound_file_path

        temp_file_path = movie_file_path.with_name(
            f"{movie_file_path.stem}_temp{movie_file_path.suffix}"
        )
        av_options = {
            "shortest": "1",
            "metadata": f"comment=Rendered with Manim Community v{__version__}",
        }

        with (
            av.open(movie_file_path) as video_input,
            av.open(sound_file_path) as audio_input,
        ):
            video_stream = video_input.streams.video[0]
            audio_stream = audio_input.streams.audio[0]
            output_container = av.open(
                str(temp_file_path), mode="w", options=av_options
            )
            output_video_stream = output_container.add_stream(template=video_stream)
            output_audio_stream = output_container.add_stream(template=audio_stream)

            for packet in video_input.demux(video_stream):
                # We need to skip the "flushing" packets that `demux` generates.
                if packet.dts is None:
                    continue

                # We need to assign the packet to the new stream.
                packet.stream = output_video_stream
                output_container.mux(packet)

            for packet in audio_input.demux(audio_stream):
                # We need to skip the "flushing" packets that `demux` generates.
                if packet.dts is None:
                    continue

                # We need to assign the packet to the new stream.
                packet.stream = output_audio_stream
                output_container.mux(packet)

            output_container.close()

        shutil.move(str(temp_file_path), str(movie_file_path))
        sound_file_path.unlink()

    self.print_file_ready_message(str(movie_file_path))
    if write_to_movie():
        for file_path in partial_movie_files:
            # We have to modify the accessed time so if we have to clean the cache we remove the one used the longest.
            modify_atime(file_path)

</t>
<t tx="ekr.20250122151621.53">def __init__(
    self, dimensions: tuple[float, float, float] | np.ndarray = [3, 2, 1], **kwargs
) -&gt; None:
    self.dimensions = dimensions
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151621.530">def combine_to_section_videos(self) -&gt; None:
    """Concatenate partial movie files for each section."""
    self.finish_last_section()
    sections_index: list[dict[str, Any]] = []
    for section in self.sections:
        # only if section does want to be saved
        if section.video is not None:
            logger.info(f"Combining partial files for section '{section.name}'")
            self.combine_files(
                section.get_clean_partial_movie_files(),
                self.sections_output_dir / section.video,
            )
            sections_index.append(section.get_dict(self.sections_output_dir))
    with (self.sections_output_dir / f"{self.output_name}.json").open("w") as file:
        json.dump(sections_index, file, indent=4)

</t>
<t tx="ekr.20250122151621.531">def clean_cache(self):
    """Will clean the cache by removing the oldest partial_movie_files."""
    cached_partial_movies = [
        (self.partial_movie_directory / file_name)
        for file_name in self.partial_movie_directory.iterdir()
        if file_name != "partial_movie_file_list.txt"
    ]
    if len(cached_partial_movies) &gt; config["max_files_cached"]:
        number_files_to_delete = (
            len(cached_partial_movies) - config["max_files_cached"]
        )
        oldest_files_to_delete = sorted(
            cached_partial_movies,
            key=lambda path: path.stat().st_atime,
        )[:number_files_to_delete]
        for file_to_delete in oldest_files_to_delete:
            file_to_delete.unlink()
        logger.info(
            f"The partial movie directory is full (&gt; {config['max_files_cached']} files). Therefore, manim has removed the {number_files_to_delete} oldest file(s)."
            " You can change this behaviour by changing max_files_cached in config.",
        )

</t>
<t tx="ekr.20250122151621.532">def flush_cache_directory(self):
    """Delete all the cached partial movie files"""
    cached_partial_movies = [
        self.partial_movie_directory / file_name
        for file_name in self.partial_movie_directory.iterdir()
        if file_name != "partial_movie_file_list.txt"
    ]
    for f in cached_partial_movies:
        f.unlink()
    logger.info(
        f"Cache flushed. {len(cached_partial_movies)} file(s) deleted in %(par_dir)s.",
        {"par_dir": self.partial_movie_directory},
    )

</t>
<t tx="ekr.20250122151621.533">def write_subcaption_file(self):
    """Writes the subcaption file."""
    if config.output_file is None:
        return
    subcaption_file = Path(config.output_file).with_suffix(".srt")
    subcaption_file.write_text(srt.compose(self.subcaptions), encoding="utf-8")
    logger.info(f"Subcaption file has been written as {subcaption_file}")

</t>
<t tx="ekr.20250122151621.534">def print_file_ready_message(self, file_path):
    """Prints the "File Ready" message to STDOUT."""
    config["output_file"] = file_path
    logger.info("\nFile ready at %(file_path)s\n", {"file_path": f"'{file_path}'"})
</t>
<t tx="ekr.20250122151621.535">"""building blocks of segmented video API"""

from __future__ import annotations

from enum import Enum
from pathlib import Path
from typing import Any

from manim import get_video_metadata

__all__ = ["Section", "DefaultSectionType"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.536">class DefaultSectionType(str, Enum):
    """The type of a section can be used for third party applications.
    A presentation system could for example use the types to created loops.

    Examples
    --------
    This class can be reimplemented for more types::

        class PresentationSectionType(str, Enum):
            # start, end, wait for continuation by user
            NORMAL = "presentation.normal"
            # start, end, immediately continue to next section
            SKIP = "presentation.skip"
            # start, end, restart, immediately continue to next section when continued by user
            LOOP = "presentation.loop"
            # start, end, restart, finish animation first when user continues
            COMPLETE_LOOP = "presentation.complete_loop"
    """

    NORMAL = "default.normal"


</t>
<t tx="ekr.20250122151621.537">class Section:
    @others
</t>
<t tx="ekr.20250122151621.538">r"""A :class:`.Scene` can be segmented into multiple Sections.
Refer to :doc:`the documentation&lt;/tutorials/output_and_config&gt;` for more info.
It consists of multiple animations.

Attributes
----------
    type\_
        Can be used by a third party applications to classify different types of sections.
    video
        Path to video file with animations belonging to section relative to sections directory.
        If ``None``, then the section will not be saved.
    name
        Human readable, non-unique name for this section.
    skip_animations
        Skip rendering the animations in this section when ``True``.
    partial_movie_files
        Animations belonging to this section.

See Also
--------
:class:`.DefaultSectionType`
:meth:`.CairoRenderer.update_skipping_status`
:meth:`.OpenGLRenderer.update_skipping_status`
"""

def __init__(self, type_: str, video: str | None, name: str, skip_animations: bool):
    self.type_ = type_
    # None when not to be saved -&gt; still keeps section alive
    self.video: str | None = video
    self.name = name
    self.skip_animations = skip_animations
    self.partial_movie_files: list[str | None] = []

</t>
<t tx="ekr.20250122151621.539">def is_empty(self) -&gt; bool:
    """Check whether this section is empty.

    Note that animations represented by ``None`` are also counted.
    """
    return len(self.partial_movie_files) == 0

</t>
<t tx="ekr.20250122151621.54">def generate_points(self) -&gt; None:
    """Creates the sides of the :class:`Prism`."""
    super().generate_points()
    for dim, value in enumerate(self.dimensions):
        self.rescale_to_fit(value, dim, stretch=True)


</t>
<t tx="ekr.20250122151621.540">def get_clean_partial_movie_files(self) -&gt; list[str]:
    """Return all partial movie files that are not ``None``."""
    return [el for el in self.partial_movie_files if el is not None]

</t>
<t tx="ekr.20250122151621.541">def get_dict(self, sections_dir: Path) -&gt; dict[str, Any]:
    """Get dictionary representation with metadata of output video.

    The output from this function is used from every section to build the sections index file.
    The output video must have been created in the ``sections_dir`` before executing this method.
    This is the main part of the Segmented Video API.
    """
    if self.video is None:
        raise ValueError(
            f"Section '{self.name}' cannot be exported as dict, it does not have a video path assigned to it"
        )

    video_metadata = get_video_metadata(sections_dir / self.video)
    return dict(
        {
            "name": self.name,
            "type": self.type_,
            "video": self.video,
        },
        **video_metadata,
    )

</t>
<t tx="ekr.20250122151621.542">def __repr__(self):
    return f"&lt;Section '{self.name}' stored in '{self.video}'&gt;"
</t>
<t tx="ekr.20250122151621.543">"""A scene suitable for rendering three-dimensional objects and animations."""

from __future__ import annotations

__all__ = ["ThreeDScene", "SpecialThreeDScene"]


import warnings
from collections.abc import Iterable, Sequence

import numpy as np

from manim.mobject.geometry.line import Line
from manim.mobject.graphing.coordinate_systems import ThreeDAxes
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.mobject.three_d.three_dimensions import Sphere
from manim.mobject.value_tracker import ValueTracker

from .. import config
from ..animation.animation import Animation
from ..animation.transform import Transform
from ..camera.three_d_camera import ThreeDCamera
from ..constants import DEGREES, RendererType
from ..mobject.mobject import Mobject
from ..mobject.types.vectorized_mobject import VectorizedPoint, VGroup
from ..renderer.opengl_renderer import OpenGLCamera
from ..scene.scene import Scene
from ..utils.config_ops import merge_dicts_recursively


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.544">class ThreeDScene(Scene):
    """
    This is a Scene, with special configurations and properties that
    make it suitable for Three Dimensional Scenes.
    """

    @others
</t>
<t tx="ekr.20250122151621.545">class SpecialThreeDScene(ThreeDScene):
    """An extension of :class:`ThreeDScene` with more settings.

    It has some extra configuration for axes, spheres,
    and an override for low quality rendering. Further key differences
    are:

    * The camera shades applicable 3DMobjects by default,
      except if rendering in low quality.
    * Some default params for Spheres and Axes have been added.

    """

    @others
</t>
<t tx="ekr.20250122151621.546">def __init__(
    self,
    camera_class=ThreeDCamera,
    ambient_camera_rotation=None,
    default_angled_camera_orientation_kwargs=None,
    **kwargs,
):
    self.ambient_camera_rotation = ambient_camera_rotation
    if default_angled_camera_orientation_kwargs is None:
        default_angled_camera_orientation_kwargs = {
            "phi": 70 * DEGREES,
            "theta": -135 * DEGREES,
        }
    self.default_angled_camera_orientation_kwargs = (
        default_angled_camera_orientation_kwargs
    )
    super().__init__(camera_class=camera_class, **kwargs)

</t>
<t tx="ekr.20250122151621.547">def set_camera_orientation(
    self,
    phi: float | None = None,
    theta: float | None = None,
    gamma: float | None = None,
    zoom: float | None = None,
    focal_distance: float | None = None,
    frame_center: Mobject | Sequence[float] | None = None,
    **kwargs,
):
    """
    This method sets the orientation of the camera in the scene.

    Parameters
    ----------
    phi
        The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.

    theta
        The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.

    focal_distance
        The focal_distance of the Camera.

    gamma
        The rotation of the camera about the vector from the ORIGIN to the Camera.

    zoom
        The zoom factor of the scene.

    frame_center
        The new center of the camera frame in cartesian coordinates.

    """
    if phi is not None:
        self.renderer.camera.set_phi(phi)
    if theta is not None:
        self.renderer.camera.set_theta(theta)
    if focal_distance is not None:
        self.renderer.camera.set_focal_distance(focal_distance)
    if gamma is not None:
        self.renderer.camera.set_gamma(gamma)
    if zoom is not None:
        self.renderer.camera.set_zoom(zoom)
    if frame_center is not None:
        self.renderer.camera._frame_center.move_to(frame_center)

</t>
<t tx="ekr.20250122151621.548">def begin_ambient_camera_rotation(self, rate: float = 0.02, about: str = "theta"):
    """
    This method begins an ambient rotation of the camera about the Z_AXIS,
    in the anticlockwise direction

    Parameters
    ----------
    rate
        The rate at which the camera should rotate about the Z_AXIS.
        Negative rate means clockwise rotation.
    about
        one of 3 options: ["theta", "phi", "gamma"]. defaults to theta.
    """
    # TODO, use a ValueTracker for rate, so that it
    # can begin and end smoothly
    about: str = about.lower()
    try:
        if config.renderer == RendererType.CAIRO:
            trackers = {
                "theta": self.camera.theta_tracker,
                "phi": self.camera.phi_tracker,
                "gamma": self.camera.gamma_tracker,
            }
            x: ValueTracker = trackers[about]
            x.add_updater(lambda m, dt: x.increment_value(rate * dt))
            self.add(x)
        elif config.renderer == RendererType.OPENGL:
            cam: OpenGLCamera = self.camera
            methods = {
                "theta": cam.increment_theta,
                "phi": cam.increment_phi,
                "gamma": cam.increment_gamma,
            }
            cam.add_updater(lambda m, dt: methods[about](rate * dt))
            self.add(self.camera)
    except Exception as e:
        raise ValueError("Invalid ambient rotation angle.") from e

</t>
<t tx="ekr.20250122151621.549">def stop_ambient_camera_rotation(self, about="theta"):
    """This method stops all ambient camera rotation."""
    about: str = about.lower()
    try:
        if config.renderer == RendererType.CAIRO:
            trackers = {
                "theta": self.camera.theta_tracker,
                "phi": self.camera.phi_tracker,
                "gamma": self.camera.gamma_tracker,
            }
            x: ValueTracker = trackers[about]
            x.clear_updaters()
            self.remove(x)
        elif config.renderer == RendererType.OPENGL:
            self.camera.clear_updaters()
    except Exception as e:
        raise ValueError("Invalid ambient rotation angle.") from e

</t>
<t tx="ekr.20250122151621.55">def __init__(
    self,
    base_radius: float = 1,
    height: float = 1,
    direction: np.ndarray = Z_AXIS,
    show_base: bool = False,
    v_range: Sequence[float] = [0, TAU],
    u_min: float = 0,
    checkerboard_colors: bool = False,
    **kwargs: Any,
) -&gt; None:
    self.direction = direction
    self.theta = PI - np.arctan(base_radius / height)

    super().__init__(
        self.func,
        v_range=v_range,
        u_range=[u_min, np.sqrt(base_radius**2 + height**2)],
        checkerboard_colors=checkerboard_colors,
        **kwargs,
    )
    # used for rotations
    self.new_height = height
    self._current_theta = 0
    self._current_phi = 0
    self.base_circle = Circle(
        radius=base_radius,
        color=self.fill_color,
        fill_opacity=self.fill_opacity,
        stroke_width=0,
    )
    self.base_circle.shift(height * IN)
    self._set_start_and_end_attributes(direction)
    if show_base:
        self.add(self.base_circle)

    self._rotate_to_direction()

</t>
<t tx="ekr.20250122151621.550">def begin_3dillusion_camera_rotation(
    self,
    rate: float = 1,
    origin_phi: float | None = None,
    origin_theta: float | None = None,
):
    """
    This method creates a 3D camera rotation illusion around
    the current camera orientation.

    Parameters
    ----------
    rate
        The rate at which the camera rotation illusion should operate.
    origin_phi
        The polar angle the camera should move around. Defaults
        to the current phi angle.
    origin_theta
        The azimutal angle the camera should move around. Defaults
        to the current theta angle.
    """
    if origin_theta is None:
        origin_theta = self.renderer.camera.theta_tracker.get_value()
    if origin_phi is None:
        origin_phi = self.renderer.camera.phi_tracker.get_value()

    val_tracker_theta = ValueTracker(0)

    def update_theta(m, dt):
        val_tracker_theta.increment_value(dt * rate)
        val_for_left_right = 0.2 * np.sin(val_tracker_theta.get_value())
        return m.set_value(origin_theta + val_for_left_right)

    self.renderer.camera.theta_tracker.add_updater(update_theta)
    self.add(self.renderer.camera.theta_tracker)

    val_tracker_phi = ValueTracker(0)

    def update_phi(m, dt):
        val_tracker_phi.increment_value(dt * rate)
        val_for_up_down = 0.1 * np.cos(val_tracker_phi.get_value()) - 0.1
        return m.set_value(origin_phi + val_for_up_down)

    self.renderer.camera.phi_tracker.add_updater(update_phi)
    self.add(self.renderer.camera.phi_tracker)

</t>
<t tx="ekr.20250122151621.551">def stop_3dillusion_camera_rotation(self):
    """This method stops all illusion camera rotations."""
    self.renderer.camera.theta_tracker.clear_updaters()
    self.remove(self.renderer.camera.theta_tracker)
    self.renderer.camera.phi_tracker.clear_updaters()
    self.remove(self.renderer.camera.phi_tracker)

</t>
<t tx="ekr.20250122151621.552">def move_camera(
    self,
    phi: float | None = None,
    theta: float | None = None,
    gamma: float | None = None,
    zoom: float | None = None,
    focal_distance: float | None = None,
    frame_center: Mobject | Sequence[float] | None = None,
    added_anims: Iterable[Animation] = [],
    **kwargs,
):
    """
    This method animates the movement of the camera
    to the given spherical coordinates.

    Parameters
    ----------
    phi
        The polar angle i.e the angle between Z_AXIS and Camera through ORIGIN in radians.

    theta
        The azimuthal angle i.e the angle that spins the camera around the Z_AXIS.

    focal_distance
        The radial focal_distance between ORIGIN and Camera.

    gamma
        The rotation of the camera about the vector from the ORIGIN to the Camera.

    zoom
        The zoom factor of the camera.

    frame_center
        The new center of the camera frame in cartesian coordinates.

    added_anims
        Any other animations to be played at the same time.

    """
    anims = []

    if config.renderer == RendererType.CAIRO:
        self.camera: ThreeDCamera
        value_tracker_pairs = [
            (phi, self.camera.phi_tracker),
            (theta, self.camera.theta_tracker),
            (focal_distance, self.camera.focal_distance_tracker),
            (gamma, self.camera.gamma_tracker),
            (zoom, self.camera.zoom_tracker),
        ]
        for value, tracker in value_tracker_pairs:
            if value is not None:
                anims.append(tracker.animate.set_value(value))
        if frame_center is not None:
            anims.append(self.camera._frame_center.animate.move_to(frame_center))
    elif config.renderer == RendererType.OPENGL:
        cam: OpenGLCamera = self.camera
        cam2 = cam.copy()
        methods = {
            "theta": cam2.set_theta,
            "phi": cam2.set_phi,
            "gamma": cam2.set_gamma,
            "zoom": cam2.scale,
            "frame_center": cam2.move_to,
        }
        if frame_center is not None:
            if isinstance(frame_center, OpenGLMobject):
                frame_center = frame_center.get_center()
            frame_center = list(frame_center)

        zoom_value = None
        if zoom is not None:
            zoom_value = config.frame_height / (zoom * cam.height)

        for value, method in [
            [theta, "theta"],
            [phi, "phi"],
            [gamma, "gamma"],
            [zoom_value, "zoom"],
            [frame_center, "frame_center"],
        ]:
            if value is not None:
                methods[method](value)

        if focal_distance is not None:
            warnings.warn(
                "focal distance of OpenGLCamera can not be adjusted.",
                stacklevel=2,
            )

        anims += [Transform(cam, cam2)]

    self.play(*anims + added_anims, **kwargs)

    # These lines are added to improve performance. If manim thinks that frame_center is moving,
    # it is required to redraw every object. These lines remove frame_center from the Scene once
    # its animation is done, ensuring that manim does not think that it is moving. Since the
    # frame_center is never actually drawn, this shouldn't break anything.
    if frame_center is not None and config.renderer == RendererType.CAIRO:
        self.remove(self.camera._frame_center)

</t>
<t tx="ekr.20250122151621.553">def get_moving_mobjects(self, *animations: Animation):
    """
    This method returns a list of all of the Mobjects in the Scene that
    are moving, that are also in the animations passed.

    Parameters
    ----------
    *animations
        The animations whose mobjects will be checked.
    """
    moving_mobjects = super().get_moving_mobjects(*animations)
    camera_mobjects = self.renderer.camera.get_value_trackers() + [
        self.renderer.camera._frame_center,
    ]
    if any(cm in moving_mobjects for cm in camera_mobjects):
        return self.mobjects
    return moving_mobjects

</t>
<t tx="ekr.20250122151621.554">def add_fixed_orientation_mobjects(self, *mobjects: Mobject, **kwargs):
    """
    This method is used to prevent the rotation and tilting
    of mobjects as the camera moves around. The mobject can
    still move in the x,y,z directions, but will always be
    at the angle (relative to the camera) that it was at
    when it was passed through this method.)

    Parameters
    ----------
    *mobjects
        The Mobject(s) whose orientation must be fixed.

    **kwargs
        Some valid kwargs are
            use_static_center_func : bool
            center_func : function
    """
    if config.renderer == RendererType.CAIRO:
        self.add(*mobjects)
        self.renderer.camera.add_fixed_orientation_mobjects(*mobjects, **kwargs)
    elif config.renderer == RendererType.OPENGL:
        for mob in mobjects:
            mob: OpenGLMobject
            mob.fix_orientation()
            self.add(mob)

</t>
<t tx="ekr.20250122151621.555">def add_fixed_in_frame_mobjects(self, *mobjects: Mobject):
    """
    This method is used to prevent the rotation and movement
    of mobjects as the camera moves around. The mobject is
    essentially overlaid, and is not impacted by the camera's
    movement in any way.

    Parameters
    ----------
    *mobjects
        The Mobjects whose orientation must be fixed.
    """
    if config.renderer == RendererType.CAIRO:
        self.add(*mobjects)
        self.camera: ThreeDCamera
        self.camera.add_fixed_in_frame_mobjects(*mobjects)
    elif config.renderer == RendererType.OPENGL:
        for mob in mobjects:
            mob: OpenGLMobject
            mob.fix_in_frame()
            self.add(mob)

</t>
<t tx="ekr.20250122151621.556">def remove_fixed_orientation_mobjects(self, *mobjects: Mobject):
    """
    This method "unfixes" the orientation of the mobjects
    passed, meaning they will no longer be at the same angle
    relative to the camera. This only makes sense if the
    mobject was passed through add_fixed_orientation_mobjects first.

    Parameters
    ----------
    *mobjects
        The Mobjects whose orientation must be unfixed.
    """
    if config.renderer == RendererType.CAIRO:
        self.renderer.camera.remove_fixed_orientation_mobjects(*mobjects)
    elif config.renderer == RendererType.OPENGL:
        for mob in mobjects:
            mob: OpenGLMobject
            mob.unfix_orientation()
            self.remove(mob)

</t>
<t tx="ekr.20250122151621.557">def remove_fixed_in_frame_mobjects(self, *mobjects: Mobject):
    """
     This method undoes what add_fixed_in_frame_mobjects does.
     It allows the mobject to be affected by the movement of
     the camera.

    Parameters
    ----------
    *mobjects
        The Mobjects whose position and orientation must be unfixed.
    """
    if config.renderer == RendererType.CAIRO:
        self.renderer.camera.remove_fixed_in_frame_mobjects(*mobjects)
    elif config.renderer == RendererType.OPENGL:
        for mob in mobjects:
            mob: OpenGLMobject
            mob.unfix_from_frame()
            self.remove(mob)

</t>
<t tx="ekr.20250122151621.558">##
def set_to_default_angled_camera_orientation(self, **kwargs):
    """
    This method sets the default_angled_camera_orientation to the
    keyword arguments passed, and sets the camera to that orientation.

    Parameters
    ----------
    **kwargs
        Some recognised kwargs are phi, theta, focal_distance, gamma,
        which have the same meaning as the parameters in set_camera_orientation.
    """
    config = dict(
        self.default_camera_orientation_kwargs,
    )  # Where doe this come from?
    config.update(kwargs)
    self.set_camera_orientation(**config)


</t>
<t tx="ekr.20250122151621.559">def __init__(
    self,
    cut_axes_at_radius=True,
    camera_config={"should_apply_shading": True, "exponential_projection": True},
    three_d_axes_config={
        "num_axis_pieces": 1,
        "axis_config": {
            "unit_size": 2,
            "tick_frequency": 1,
            "numbers_with_elongated_ticks": [0, 1, 2],
            "stroke_width": 2,
        },
    },
    sphere_config={"radius": 2, "resolution": (24, 48)},
    default_angled_camera_position={
        "phi": 70 * DEGREES,
        "theta": -110 * DEGREES,
    },
    # When scene is extracted with -l flag, this
    # configuration will override the above configuration.
    low_quality_config={
        "camera_config": {"should_apply_shading": False},
        "three_d_axes_config": {"num_axis_pieces": 1},
        "sphere_config": {"resolution": (12, 24)},
    },
    **kwargs,
</t>
<t tx="ekr.20250122151621.56">def func(self, u: float, v: float) -&gt; np.ndarray:
    """Converts from spherical coordinates to cartesian.

    Parameters
    ----------
    u
        The radius.
    v
        The azimuthal angle.

    Returns
    -------
    :class:`numpy.array`
        Points defining the :class:`Cone`.
    """
    r = u
    phi = v
    return np.array(
        [
            r * np.sin(self.theta) * np.cos(phi),
            r * np.sin(self.theta) * np.sin(phi),
            r * np.cos(self.theta),
        ],
    )

</t>
<t tx="ekr.20250122151621.560">):
    self.cut_axes_at_radius = cut_axes_at_radius
    self.camera_config = camera_config
    self.three_d_axes_config = three_d_axes_config
    self.sphere_config = sphere_config
    self.default_angled_camera_position = default_angled_camera_position
    self.low_quality_config = low_quality_config
    if self.renderer.camera_config["pixel_width"] == config["pixel_width"]:
        _config = {}
    else:
        _config = self.low_quality_config
    _config = merge_dicts_recursively(_config, kwargs)
    super().__init__(**_config)

def get_axes(self):
    """Return a set of 3D axes.

    Returns
    -------
    :class:`.ThreeDAxes`
        A set of 3D axes.
    """
    axes = ThreeDAxes(**self.three_d_axes_config)
    for axis in axes:
        if self.cut_axes_at_radius:
            p0 = axis.get_start()
            p1 = axis.number_to_point(-1)
            p2 = axis.number_to_point(1)
            p3 = axis.get_end()
            new_pieces = VGroup(Line(p0, p1), Line(p1, p2), Line(p2, p3))
            for piece in new_pieces:
                piece.shade_in_3d = True
            new_pieces.match_style(axis.pieces)
            axis.pieces.submobjects = new_pieces.submobjects
        for tick in axis.tick_marks:
            tick.add(VectorizedPoint(1.5 * tick.get_center()))
    return axes

</t>
<t tx="ekr.20250122151621.561">def get_sphere(self, **kwargs):
    """
    Returns a sphere with the passed keyword arguments as properties.

    Parameters
    ----------
    **kwargs
        Any valid parameter of :class:`~.Sphere` or :class:`~.Surface`.

    Returns
    -------
    :class:`~.Sphere`
        The sphere object.
    """
    config = merge_dicts_recursively(self.sphere_config, kwargs)
    return Sphere(**config)

</t>
<t tx="ekr.20250122151621.562">def get_default_camera_position(self):
    """
    Returns the default_angled_camera position.

    Returns
    -------
    dict
        Dictionary of phi, theta, focal_distance, and gamma.
    """
    return self.default_angled_camera_position

</t>
<t tx="ekr.20250122151621.563">def set_camera_to_default_position(self):
    """Sets the camera to its default position."""
    self.set_camera_orientation(**self.default_angled_camera_position)
</t>
<t tx="ekr.20250122151621.564">"""A scene suitable for vector spaces."""

from __future__ import annotations

__all__ = ["VectorScene", "LinearTransformationScene"]

from typing import Callable

import numpy as np

from manim.mobject.geometry.arc import Dot
from manim.mobject.geometry.line import Arrow, Line, Vector
from manim.mobject.geometry.polygram import Rectangle
from manim.mobject.graphing.coordinate_systems import Axes, NumberPlane
from manim.mobject.opengl.opengl_mobject import OpenGLMobject
from manim.mobject.text.tex_mobject import MathTex, Tex
from manim.utils.config_ops import update_dict_recursively

from .. import config
from ..animation.animation import Animation
from ..animation.creation import Create, Write
from ..animation.fading import FadeOut
from ..animation.growing import GrowArrow
from ..animation.transform import ApplyFunction, ApplyPointwiseFunction, Transform
from ..constants import *
from ..mobject.matrix import Matrix
from ..mobject.mobject import Mobject
from ..mobject.types.vectorized_mobject import VGroup, VMobject
from ..scene.scene import Scene
from ..utils.color import (
    BLACK,
    BLUE_D,
    GREEN_C,
    GREY,
    RED_C,
    WHITE,
    YELLOW,
    ManimColor,
    ParsableManimColor,
)
from ..utils.rate_functions import rush_from, rush_into
from ..utils.space_ops import angle_of_vector

X_COLOR = GREEN_C
Y_COLOR = RED_C
Z_COLOR = BLUE_D


# TODO: Much of this scene type seems dependent on the coordinate system chosen.
# That is, being centered at the origin with grid units corresponding to the
# arbitrary space units.  Change it!
#
# Also, methods I would have thought of as getters, like coords_to_vector, are
# actually doing a lot of animating.
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.565">class VectorScene(Scene):
    @others
</t>
<t tx="ekr.20250122151621.566">class LinearTransformationScene(VectorScene):
    """
    This scene contains special methods that make it
    especially suitable for showing linear transformations.

    Parameters
    ----------
    include_background_plane
        Whether or not to include the background plane in the scene.
    include_foreground_plane
        Whether or not to include the foreground plane in the scene.
    background_plane_kwargs
        Parameters to be passed to :class:`NumberPlane` to adjust the background plane.
    foreground_plane_kwargs
        Parameters to be passed to :class:`NumberPlane` to adjust the foreground plane.
    show_coordinates
        Whether or not to include the coordinates for the background plane.
    show_basis_vectors
        Whether to show the basis x_axis -&gt; ``i_hat`` and y_axis -&gt; ``j_hat`` vectors.
    basis_vector_stroke_width
        The ``stroke_width`` of the basis vectors.
    i_hat_color
        The color of the ``i_hat`` vector.
    j_hat_color
        The color of the ``j_hat`` vector.
    leave_ghost_vectors
        Indicates the previous position of the basis vectors following a transformation.

    Examples
    -------

    .. manim:: LinearTransformationSceneExample

        class LinearTransformationSceneExample(LinearTransformationScene):
            def __init__(self, **kwargs):
                LinearTransformationScene.__init__(
                    self,
                    show_coordinates=True,
                    leave_ghost_vectors=True,
                    **kwargs
                )

            def construct(self):
                matrix = [[1, 1], [0, 1]]
                self.apply_matrix(matrix)
                self.wait()
    """

    @others
</t>
<t tx="ekr.20250122151621.567">def __init__(self, basis_vector_stroke_width=6, **kwargs):
    super().__init__(**kwargs)
    self.basis_vector_stroke_width = basis_vector_stroke_width

</t>
<t tx="ekr.20250122151621.568">def add_plane(self, animate: bool = False, **kwargs):
    """
    Adds a NumberPlane object to the background.

    Parameters
    ----------
    animate
        Whether or not to animate the addition of the plane via Create.
    **kwargs
        Any valid keyword arguments accepted by NumberPlane.

    Returns
    -------
    NumberPlane
        The NumberPlane object.
    """
    plane = NumberPlane(**kwargs)
    if animate:
        self.play(Create(plane, lag_ratio=0.5))
    self.add(plane)
    return plane

</t>
<t tx="ekr.20250122151621.569">def add_axes(self, animate: bool = False, color: bool = WHITE, **kwargs):
    """
    Adds a pair of Axes to the Scene.

    Parameters
    ----------
    animate
        Whether or not to animate the addition of the axes through Create.
    color
        The color of the axes. Defaults to WHITE.
    """
    axes = Axes(color=color, axis_config={"unit_size": 1})
    if animate:
        self.play(Create(axes))
    self.add(axes)
    return axes

</t>
<t tx="ekr.20250122151621.57">def get_start(self) -&gt; np.ndarray:
    return self.start_point.get_center()

</t>
<t tx="ekr.20250122151621.570">def lock_in_faded_grid(self, dimness: float = 0.7, axes_dimness: float = 0.5):
    """
    This method freezes the NumberPlane and Axes that were already
    in the background, and adds new, manipulatable ones to the foreground.

    Parameters
    ----------
    dimness
        The required dimness of the NumberPlane

    axes_dimness
        The required dimness of the Axes.
    """
    plane = self.add_plane()
    axes = plane.get_axes()
    plane.fade(dimness)
    axes.set_color(WHITE)
    axes.fade(axes_dimness)
    self.add(axes)

    self.renderer.update_frame()
    self.renderer.camera = Camera(self.renderer.get_frame())
    self.clear()

</t>
<t tx="ekr.20250122151621.571">def get_vector(self, numerical_vector: np.ndarray | list | tuple, **kwargs):
    """
    Returns an arrow on the Plane given an input numerical vector.

    Parameters
    ----------
    numerical_vector
        The Vector to plot.
    **kwargs
        Any valid keyword argument of Arrow.

    Returns
    -------
    Arrow
        The Arrow representing the Vector.
    """
    return Arrow(
        self.plane.coords_to_point(0, 0),
        self.plane.coords_to_point(*numerical_vector[:2]),
        buff=0,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151621.572">def add_vector(
    self,
    vector: Arrow | list | tuple | np.ndarray,
    color: str = YELLOW,
    animate: bool = True,
    **kwargs,
):
    """
    Returns the Vector after adding it to the Plane.

    Parameters
    ----------
    vector
        It can be a pre-made graphical vector, or the
        coordinates of one.

    color
        The string of the hex color of the vector.
        This is only taken into consideration if
        'vector' is not an Arrow. Defaults to YELLOW.

    animate
        Whether or not to animate the addition of the vector
        by using GrowArrow

    **kwargs
        Any valid keyword argument of Arrow.
        These are only considered if vector is not
        an Arrow.

    Returns
    -------
    Arrow
        The arrow representing the vector.
    """
    if not isinstance(vector, Arrow):
        vector = Vector(vector, color=color, **kwargs)
    if animate:
        self.play(GrowArrow(vector))
    self.add(vector)
    return vector

</t>
<t tx="ekr.20250122151621.573">def write_vector_coordinates(self, vector: Arrow, **kwargs):
    """
    Returns a column matrix indicating the vector coordinates,
    after writing them to the screen.

    Parameters
    ----------
    vector
        The arrow representing the vector.

    **kwargs
        Any valid keyword arguments of :meth:`~.Vector.coordinate_label`:

    Returns
    -------
    :class:`.Matrix`
        The column matrix representing the vector.
    """
    coords = vector.coordinate_label(**kwargs)
    self.play(Write(coords))
    return coords

</t>
<t tx="ekr.20250122151621.574">def get_basis_vectors(self, i_hat_color: str = X_COLOR, j_hat_color: str = Y_COLOR):
    """
    Returns a VGroup of the Basis Vectors (1,0) and (0,1)

    Parameters
    ----------
    i_hat_color
        The hex colour to use for the basis vector in the x direction

    j_hat_color
        The hex colour to use for the basis vector in the y direction

    Returns
    -------
    VGroup
        VGroup of the Vector Mobjects representing the basis vectors.
    """
    return VGroup(
        *(
            Vector(vect, color=color, stroke_width=self.basis_vector_stroke_width)
            for vect, color in [([1, 0], i_hat_color), ([0, 1], j_hat_color)]
        )
    )

</t>
<t tx="ekr.20250122151621.575">def get_basis_vector_labels(self, **kwargs):
    """
    Returns naming labels for the basis vectors.

    Parameters
    ----------
    **kwargs
        Any valid keyword arguments of get_vector_label:
            vector,
            label (str,MathTex)
            at_tip (bool=False),
            direction (str="left"),
            rotate (bool),
            color (str),
            label_scale_factor=VECTOR_LABEL_SCALE_FACTOR (int, float),
    """
    i_hat, j_hat = self.get_basis_vectors()
    return VGroup(
        *(
            self.get_vector_label(
                vect, label, color=color, label_scale_factor=1, **kwargs
            )
            for vect, label, color in [
                (i_hat, "\\hat{\\imath}", X_COLOR),
                (j_hat, "\\hat{\\jmath}", Y_COLOR),
            ]
        )
    )

</t>
<t tx="ekr.20250122151621.576">def get_vector_label(
    self,
    vector: Vector,
    label,
    at_tip: bool = False,
    direction: str = "left",
    rotate: bool = False,
    color: str | None = None,
    label_scale_factor: float = LARGE_BUFF - 0.2,
):
    """
    Returns naming labels for the passed vector.

    Parameters
    ----------
    vector
        Vector Object for which to get the label.

    at_tip
        Whether or not to place the label at the tip of the vector.

    direction
        If the label should be on the "left" or right of the vector.
    rotate
        Whether or not to rotate it to align it with the vector.
    color
        The color to give the label.
    label_scale_factor
        How much to scale the label by.

    Returns
    -------
    MathTex
        The MathTex of the label.
    """
    if not isinstance(label, MathTex):
        if len(label) == 1:
            label = "\\vec{\\textbf{%s}}" % label  # noqa: UP031
        label = MathTex(label)
        if color is None:
            color = vector.get_color()
        label.set_color(color)
    label.scale(label_scale_factor)
    label.add_background_rectangle()

    if at_tip:
        vect = vector.get_vector()
        vect /= np.linalg.norm(vect)
        label.next_to(vector.get_end(), vect, buff=SMALL_BUFF)
    else:
        angle = vector.get_angle()
        if not rotate:
            label.rotate(-angle, about_point=ORIGIN)
        if direction == "left":
            label.shift(-label.get_bottom() + 0.1 * UP)
        else:
            label.shift(-label.get_top() + 0.1 * DOWN)
        label.rotate(angle, about_point=ORIGIN)
        label.shift((vector.get_end() - vector.get_start()) / 2)
    return label

</t>
<t tx="ekr.20250122151621.577">def label_vector(
    self, vector: Vector, label: MathTex | str, animate: bool = True, **kwargs
):
    """
    Shortcut method for creating, and animating the addition of
    a label for the vector.

    Parameters
    ----------
    vector
        The vector for which the label must be added.

    label
        The MathTex/string of the label.

    animate
        Whether or not to animate the labelling w/ Write

    **kwargs
        Any valid keyword argument of get_vector_label

    Returns
    -------
    :class:`~.MathTex`
        The MathTex of the label.
    """
    label = self.get_vector_label(vector, label, **kwargs)
    if animate:
        self.play(Write(label, run_time=1))
    self.add(label)
    return label

</t>
<t tx="ekr.20250122151621.578">def position_x_coordinate(
    self,
    x_coord,
    x_line,
    vector,
):  # TODO Write DocStrings for this.
    x_coord.next_to(x_line, -np.sign(vector[1]) * UP)
    x_coord.set_color(X_COLOR)
    return x_coord

</t>
<t tx="ekr.20250122151621.579">def position_y_coordinate(
    self,
    y_coord,
    y_line,
    vector,
):  # TODO Write DocStrings for this.
    y_coord.next_to(y_line, np.sign(vector[0]) * RIGHT)
    y_coord.set_color(Y_COLOR)
    return y_coord

</t>
<t tx="ekr.20250122151621.58">def get_end(self) -&gt; np.ndarray:
    return self.end_point.get_center()

</t>
<t tx="ekr.20250122151621.580">def coords_to_vector(
    self,
    vector: np.ndarray | list | tuple,
    coords_start: np.ndarray | list | tuple = 2 * RIGHT + 2 * UP,
    clean_up: bool = True,
):
    """
    This method writes the vector as a column matrix (henceforth called the label),
    takes the values in it one by one, and form the corresponding
    lines that make up the x and y components of the vector. Then, an
    Vector() based vector is created between the lines on the Screen.

    Parameters
    ----------
    vector
        The vector to show.

    coords_start
        The starting point of the location of
        the label of the vector that shows it
        numerically.
        Defaults to 2 * RIGHT + 2 * UP or (2,2)

    clean_up
        Whether or not to remove whatever
        this method did after it's done.

    """
    starting_mobjects = list(self.mobjects)
    array = Matrix(vector)
    array.shift(coords_start)
    arrow = Vector(vector)
    x_line = Line(ORIGIN, vector[0] * RIGHT)
    y_line = Line(x_line.get_end(), arrow.get_end())
    x_line.set_color(X_COLOR)
    y_line.set_color(Y_COLOR)
    x_coord, y_coord = array.get_mob_matrix().flatten()

    self.play(Write(array, run_time=1))
    self.wait()
    self.play(
        ApplyFunction(
            lambda x: self.position_x_coordinate(x, x_line, vector),
            x_coord,
        ),
    )
    self.play(Create(x_line))
    animations = [
        ApplyFunction(
            lambda y: self.position_y_coordinate(y, y_line, vector),
            y_coord,
        ),
        FadeOut(array.get_brackets()),
    ]
    self.play(*animations)
    y_coord, _ = (anim.mobject for anim in animations)
    self.play(Create(y_line))
    self.play(Create(arrow))
    self.wait()
    if clean_up:
        self.clear()
        self.add(*starting_mobjects)

</t>
<t tx="ekr.20250122151621.581">def vector_to_coords(
    self,
    vector: np.ndarray | list | tuple,
    integer_labels: bool = True,
    clean_up: bool = True,
):
    """
    This method displays vector as a Vector() based vector, and then shows
    the corresponding lines that make up the x and y components of the vector.
    Then, a column matrix (henceforth called the label) is created near the
    head of the Vector.

    Parameters
    ----------
    vector
        The vector to show.

    integer_labels
        Whether or not to round the value displayed.
        in the vector's label to the nearest integer

    clean_up
        Whether or not to remove whatever
        this method did after it's done.

    """
    starting_mobjects = list(self.mobjects)
    show_creation = False
    if isinstance(vector, Arrow):
        arrow = vector
        vector = arrow.get_end()[:2]
    else:
        arrow = Vector(vector)
        show_creation = True
    array = arrow.coordinate_label(integer_labels=integer_labels)
    x_line = Line(ORIGIN, vector[0] * RIGHT)
    y_line = Line(x_line.get_end(), arrow.get_end())
    x_line.set_color(X_COLOR)
    y_line.set_color(Y_COLOR)
    x_coord, y_coord = array.get_entries()
    x_coord_start = self.position_x_coordinate(x_coord.copy(), x_line, vector)
    y_coord_start = self.position_y_coordinate(y_coord.copy(), y_line, vector)
    brackets = array.get_brackets()

    if show_creation:
        self.play(Create(arrow))
    self.play(Create(x_line), Write(x_coord_start), run_time=1)
    self.play(Create(y_line), Write(y_coord_start), run_time=1)
    self.wait()
    self.play(
        Transform(x_coord_start, x_coord, lag_ratio=0),
        Transform(y_coord_start, y_coord, lag_ratio=0),
        Write(brackets, run_time=1),
    )
    self.wait()

    self.remove(x_coord_start, y_coord_start, brackets)
    self.add(array)
    if clean_up:
        self.clear()
        self.add(*starting_mobjects)
    return array, x_line, y_line

</t>
<t tx="ekr.20250122151621.582">def show_ghost_movement(self, vector: Arrow | list | tuple | np.ndarray):
    """
    This method plays an animation that partially shows the entire plane moving
    in the direction of a particular vector. This is useful when you wish to
    convey the idea of mentally moving the entire plane in a direction, without
    actually moving the plane.

    Parameters
    ----------
    vector
        The vector which indicates the direction of movement.
    """
    if isinstance(vector, Arrow):
        vector = vector.get_end() - vector.get_start()
    elif len(vector) == 2:
        vector = np.append(np.array(vector), 0.0)
    x_max = int(config["frame_x_radius"] + abs(vector[0]))
    y_max = int(config["frame_y_radius"] + abs(vector[1]))
    dots = VMobject(
        *(
            Dot(x * RIGHT + y * UP)
            for x in range(-x_max, x_max)
            for y in range(-y_max, y_max)
        )
    )
    dots.set_fill(BLACK, opacity=0)
    dots_halfway = dots.copy().shift(vector / 2).set_fill(WHITE, 1)
    dots_end = dots.copy().shift(vector)

    self.play(Transform(dots, dots_halfway, rate_func=rush_into))
    self.play(Transform(dots, dots_end, rate_func=rush_from))
    self.remove(dots)


</t>
<t tx="ekr.20250122151621.583">def __init__(
    self,
    include_background_plane: bool = True,
    include_foreground_plane: bool = True,
    background_plane_kwargs: dict | None = None,
    foreground_plane_kwargs: dict | None = None,
    show_coordinates: bool = False,
    show_basis_vectors: bool = True,
    basis_vector_stroke_width: float = 6,
    i_hat_color: ParsableManimColor = X_COLOR,
    j_hat_color: ParsableManimColor = Y_COLOR,
    leave_ghost_vectors: bool = False,
    **kwargs,
):
    super().__init__(**kwargs)

    self.include_background_plane = include_background_plane
    self.include_foreground_plane = include_foreground_plane
    self.show_coordinates = show_coordinates
    self.show_basis_vectors = show_basis_vectors
    self.basis_vector_stroke_width = basis_vector_stroke_width
    self.i_hat_color = ManimColor(i_hat_color)
    self.j_hat_color = ManimColor(j_hat_color)
    self.leave_ghost_vectors = leave_ghost_vectors
    self.background_plane_kwargs = {
        "color": GREY,
        "axis_config": {
            "color": GREY,
        },
        "background_line_style": {
            "stroke_color": GREY,
            "stroke_width": 1,
        },
    }

    self.ghost_vectors = VGroup()

    self.foreground_plane_kwargs = {
        "x_range": np.array([-config["frame_width"], config["frame_width"], 1.0]),
        "y_range": np.array([-config["frame_width"], config["frame_width"], 1.0]),
        "faded_line_ratio": 1,
    }

    self.update_default_configs(
        (self.foreground_plane_kwargs, self.background_plane_kwargs),
        (foreground_plane_kwargs, background_plane_kwargs),
    )

</t>
<t tx="ekr.20250122151621.584">@staticmethod
def update_default_configs(default_configs, passed_configs):
    for default_config, passed_config in zip(default_configs, passed_configs):
        if passed_config is not None:
            update_dict_recursively(default_config, passed_config)

</t>
<t tx="ekr.20250122151621.585">def setup(self):
    # The has_already_setup attr is to not break all the old Scenes
    if hasattr(self, "has_already_setup"):
        return
    self.has_already_setup = True
    self.background_mobjects = []
    self.foreground_mobjects = []
    self.transformable_mobjects = []
    self.moving_vectors = []
    self.transformable_labels = []
    self.moving_mobjects = []

    self.background_plane = NumberPlane(**self.background_plane_kwargs)

    if self.show_coordinates:
        self.background_plane.add_coordinates()
    if self.include_background_plane:
        self.add_background_mobject(self.background_plane)
    if self.include_foreground_plane:
        self.plane = NumberPlane(**self.foreground_plane_kwargs)
        self.add_transformable_mobject(self.plane)
    if self.show_basis_vectors:
        self.basis_vectors = self.get_basis_vectors(
            i_hat_color=self.i_hat_color,
            j_hat_color=self.j_hat_color,
        )
        self.moving_vectors += list(self.basis_vectors)
        self.i_hat, self.j_hat = self.basis_vectors
        self.add(self.basis_vectors)

</t>
<t tx="ekr.20250122151621.586">def add_special_mobjects(self, mob_list: list, *mobs_to_add: Mobject):
    """
    Adds mobjects to a separate list that can be tracked,
    if these mobjects have some extra importance.

    Parameters
    ----------
    mob_list
        The special list to which you want to add
        these mobjects.

    *mobs_to_add
        The mobjects to add.

    """
    for mobject in mobs_to_add:
        if mobject not in mob_list:
            mob_list.append(mobject)
            self.add(mobject)

</t>
<t tx="ekr.20250122151621.587">def add_background_mobject(self, *mobjects: Mobject):
    """
    Adds the mobjects to the special list
    self.background_mobjects.

    Parameters
    ----------
    *mobjects
        The mobjects to add to the list.
    """
    self.add_special_mobjects(self.background_mobjects, *mobjects)

</t>
<t tx="ekr.20250122151621.588"># TODO, this conflicts with Scene.add_fore
def add_foreground_mobject(self, *mobjects: Mobject):
    """
    Adds the mobjects to the special list
    self.foreground_mobjects.

    Parameters
    ----------
    *mobjects
        The mobjects to add to the list
    """
    self.add_special_mobjects(self.foreground_mobjects, *mobjects)

</t>
<t tx="ekr.20250122151621.589">def add_transformable_mobject(self, *mobjects: Mobject):
    """
    Adds the mobjects to the special list
    self.transformable_mobjects.

    Parameters
    ----------
    *mobjects
        The mobjects to add to the list.
    """
    self.add_special_mobjects(self.transformable_mobjects, *mobjects)

</t>
<t tx="ekr.20250122151621.59">def _rotate_to_direction(self) -&gt; None:
    x, y, z = self.direction

    r = np.sqrt(x**2 + y**2 + z**2)
    theta = np.arccos(z / r) if r &gt; 0 else 0

    if x == 0:
        if y == 0:  # along the z axis
            phi = 0
        else:
            phi = np.arctan(np.inf)
            if y &lt; 0:
                phi += PI
    else:
        phi = np.arctan(y / x)
    if x &lt; 0:
        phi += PI

    # Undo old rotation (in reverse order)
    self.rotate(-self._current_phi, Z_AXIS, about_point=ORIGIN)
    self.rotate(-self._current_theta, Y_AXIS, about_point=ORIGIN)

    # Do new rotation
    self.rotate(theta, Y_AXIS, about_point=ORIGIN)
    self.rotate(phi, Z_AXIS, about_point=ORIGIN)

    # Store values
    self._current_theta = theta
    self._current_phi = phi

</t>
<t tx="ekr.20250122151621.590">def add_moving_mobject(
    self, mobject: Mobject, target_mobject: Mobject | None = None
):
    """
    Adds the mobject to the special list
    self.moving_mobject, and adds a property
    to the mobject called mobject.target, which
    keeps track of what the mobject will move to
    or become etc.

    Parameters
    ----------
    mobject
        The mobjects to add to the list

    target_mobject
        What the moving_mobject goes to, etc.
    """
    mobject.target = target_mobject
    self.add_special_mobjects(self.moving_mobjects, mobject)

</t>
<t tx="ekr.20250122151621.591">def get_ghost_vectors(self) -&gt; VGroup:
    """
    Returns all ghost vectors ever added to ``self``. Each element is a ``VGroup`` of
    two ghost vectors.
    """
    return self.ghost_vectors

</t>
<t tx="ekr.20250122151621.592">def get_unit_square(
    self, color: str = YELLOW, opacity: float = 0.3, stroke_width: float = 3
):
    """
    Returns a unit square for the current NumberPlane.

    Parameters
    ----------
    color
        The string of the hex color code of the color wanted.

    opacity
        The opacity of the square

    stroke_width
        The stroke_width in pixels of the border of the square

    Returns
    -------
    Square
    """
    square = self.square = Rectangle(
        color=color,
        width=self.plane.get_x_unit_size(),
        height=self.plane.get_y_unit_size(),
        stroke_color=color,
        stroke_width=stroke_width,
        fill_color=color,
        fill_opacity=opacity,
    )
    square.move_to(self.plane.coords_to_point(0, 0), DL)
    return square

</t>
<t tx="ekr.20250122151621.593">def add_unit_square(self, animate: bool = False, **kwargs):
    """
    Adds a unit square to the scene via
    self.get_unit_square.

    Parameters
    ----------
    animate
        Whether or not to animate the addition
        with DrawBorderThenFill.
    **kwargs
        Any valid keyword arguments of
        self.get_unit_square()

    Returns
    -------
    Square
        The unit square.
    """
    square = self.get_unit_square(**kwargs)
    if animate:
        self.play(
            DrawBorderThenFill(square),
            Animation(Group(*self.moving_vectors)),
        )
    self.add_transformable_mobject(square)
    self.bring_to_front(*self.moving_vectors)
    self.square = square
    return self

</t>
<t tx="ekr.20250122151621.594">def add_vector(
    self, vector: Arrow | list | tuple | np.ndarray, color: str = YELLOW, **kwargs
):
    """
    Adds a vector to the scene, and puts it in the special
    list self.moving_vectors.

    Parameters
    ----------
    vector
        It can be a pre-made graphical vector, or the
        coordinates of one.

    color
        The string of the hex color of the vector.
        This is only taken into consideration if
        'vector' is not an Arrow. Defaults to YELLOW.

    **kwargs
        Any valid keyword argument of VectorScene.add_vector.

    Returns
    -------
    Arrow
        The arrow representing the vector.
    """
    vector = super().add_vector(vector, color=color, **kwargs)
    self.moving_vectors.append(vector)
    return vector

</t>
<t tx="ekr.20250122151621.595">def write_vector_coordinates(self, vector: Arrow, **kwargs):
    """
    Returns a column matrix indicating the vector coordinates,
    after writing them to the screen, and adding them to the
    special list self.foreground_mobjects

    Parameters
    ----------
    vector
        The arrow representing the vector.

    **kwargs
        Any valid keyword arguments of VectorScene.write_vector_coordinates

    Returns
    -------
    Matrix
        The column matrix representing the vector.
    """
    coords = super().write_vector_coordinates(vector, **kwargs)
    self.add_foreground_mobject(coords)
    return coords

</t>
<t tx="ekr.20250122151621.596">def add_transformable_label(
    self,
    vector: Vector,
    label: MathTex | str,
    transformation_name: str | MathTex = "L",
    new_label: str | MathTex | None = None,
    **kwargs,
):
    """
    Method for creating, and animating the addition of
    a transformable label for the vector.

    Parameters
    ----------
    vector
        The vector for which the label must be added.

    label
        The MathTex/string of the label.

    transformation_name
        The name to give the transformation as a label.

    new_label
        What the label should display after a Linear Transformation

    **kwargs
        Any valid keyword argument of get_vector_label

    Returns
    -------
    :class:`~.MathTex`
        The MathTex of the label.
    """
    label_mob = self.label_vector(vector, label, **kwargs)
    if new_label:
        label_mob.target_text = new_label
    else:
        label_mob.target_text = (
            f"{transformation_name}({label_mob.get_tex_string()})"
        )
    label_mob.vector = vector
    label_mob.kwargs = kwargs
    if "animate" in label_mob.kwargs:
        label_mob.kwargs.pop("animate")
    self.transformable_labels.append(label_mob)
    return label_mob

</t>
<t tx="ekr.20250122151621.597">def add_title(
    self,
    title: str | MathTex | Tex,
    scale_factor: float = 1.5,
    animate: bool = False,
):
    """
    Adds a title, after scaling it, adding a background rectangle,
    moving it to the top and adding it to foreground_mobjects adding
    it as a local variable of self. Returns the Scene.

    Parameters
    ----------
    title
        What the title should be.

    scale_factor
        How much the title should be scaled by.

    animate
        Whether or not to animate the addition.

    Returns
    -------
    LinearTransformationScene
        The scene with the title added to it.
    """
    if not isinstance(title, (Mobject, OpenGLMobject)):
        title = Tex(title).scale(scale_factor)
    title.to_edge(UP)
    title.add_background_rectangle()
    if animate:
        self.play(Write(title))
    self.add_foreground_mobject(title)
    self.title = title
    return self

</t>
<t tx="ekr.20250122151621.598">def get_matrix_transformation(self, matrix: np.ndarray | list | tuple):
    """
    Returns a function corresponding to the linear
    transformation represented by the matrix passed.

    Parameters
    ----------
    matrix
        The matrix.
    """
    return self.get_transposed_matrix_transformation(np.array(matrix).T)

</t>
<t tx="ekr.20250122151621.599">def get_transposed_matrix_transformation(
    self, transposed_matrix: np.ndarray | list | tuple
):
    """
    Returns a function corresponding to the linear
    transformation represented by the transposed
    matrix passed.

    Parameters
    ----------
    transposed_matrix
        The matrix.
    """
    transposed_matrix = np.array(transposed_matrix)
    if transposed_matrix.shape == (2, 2):
        new_matrix = np.identity(3)
        new_matrix[:2, :2] = transposed_matrix
        transposed_matrix = new_matrix
    elif transposed_matrix.shape != (3, 3):
        raise ValueError("Matrix has bad dimensions")
    return lambda point: np.dot(point, transposed_matrix)

</t>
<t tx="ekr.20250122151621.6">class Octahedron(Polyhedron):
    """An octahedron, one of the five platonic solids. It has 8 faces, 12 edges and 6 vertices.

    Parameters
    ----------
    edge_length
        The length of an edge between any two vertices.

    Examples
    --------

    .. manim:: OctahedronScene
        :save_last_frame:

        class OctahedronScene(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                obj = Octahedron()
                self.add(obj)
    """

    @others
</t>
<t tx="ekr.20250122151621.60">def set_direction(self, direction: np.ndarray) -&gt; None:
    """Changes the direction of the apex of the :class:`Cone`.

    Parameters
    ----------
    direction
        The direction of the apex.
    """
    self.direction = direction
    self._rotate_to_direction()

</t>
<t tx="ekr.20250122151621.600">def get_piece_movement(self, pieces: list | tuple | np.ndarray):
    """
    This method returns an animation that moves an arbitrary
    mobject in "pieces" to its corresponding .target value.
    If self.leave_ghost_vectors is True, ghosts of the original
    positions/mobjects are left on screen

    Parameters
    ----------
    pieces
        The pieces for which the movement must be shown.

    Returns
    -------
    Animation
        The animation of the movement.
    """
    v_pieces = [piece for piece in pieces if isinstance(piece, VMobject)]
    start = VGroup(*v_pieces)
    target = VGroup(*(mob.target for mob in v_pieces))

    # don't add empty VGroups
    if self.leave_ghost_vectors and start.submobjects:
        # start.copy() gives a VGroup of Vectors
        self.ghost_vectors.add(start.copy().fade(0.7))
        self.add(self.ghost_vectors[-1])
    return Transform(start, target, lag_ratio=0)

</t>
<t tx="ekr.20250122151621.601">def get_moving_mobject_movement(self, func: Callable[[np.ndarray], np.ndarray]):
    """
    This method returns an animation that moves a mobject
    in "self.moving_mobjects"  to its corresponding .target value.
    func is a function that determines where the .target goes.

    Parameters
    ----------

    func
        The function that determines where the .target of
        the moving mobject goes.

    Returns
    -------
    Animation
        The animation of the movement.
    """
    for m in self.moving_mobjects:
        if m.target is None:
            m.target = m.copy()
        target_point = func(m.get_center())
        m.target.move_to(target_point)
    return self.get_piece_movement(self.moving_mobjects)

</t>
<t tx="ekr.20250122151621.602">def get_vector_movement(self, func: Callable[[np.ndarray], np.ndarray]):
    """
    This method returns an animation that moves a mobject
    in "self.moving_vectors"  to its corresponding .target value.
    func is a function that determines where the .target goes.

    Parameters
    ----------

    func
        The function that determines where the .target of
        the moving mobject goes.

    Returns
    -------
    Animation
        The animation of the movement.
    """
    for v in self.moving_vectors:
        v.target = Vector(func(v.get_end()), color=v.get_color())
        norm = np.linalg.norm(v.target.get_end())
        if norm &lt; 0.1:
            v.target.get_tip().scale(norm)
    return self.get_piece_movement(self.moving_vectors)

</t>
<t tx="ekr.20250122151621.603">def get_transformable_label_movement(self):
    """
    This method returns an animation that moves all labels
    in "self.transformable_labels" to its corresponding .target .

    Returns
    -------
    Animation
        The animation of the movement.
    """
    for label in self.transformable_labels:
        label.target = self.get_vector_label(
            label.vector.target, label.target_text, **label.kwargs
        )
    return self.get_piece_movement(self.transformable_labels)

</t>
<t tx="ekr.20250122151621.604">def apply_matrix(self, matrix: np.ndarray | list | tuple, **kwargs):
    """
    Applies the transformation represented by the
    given matrix to the number plane, and each vector/similar
    mobject on it.

    Parameters
    ----------
    matrix
        The matrix.
    **kwargs
        Any valid keyword argument of self.apply_transposed_matrix()
    """
    self.apply_transposed_matrix(np.array(matrix).T, **kwargs)

</t>
<t tx="ekr.20250122151621.605">def apply_inverse(self, matrix: np.ndarray | list | tuple, **kwargs):
    """
    This method applies the linear transformation
    represented by the inverse of the passed matrix
    to the number plane, and each vector/similar mobject on it.

    Parameters
    ----------
    matrix
        The matrix whose inverse is to be applied.
    **kwargs
        Any valid keyword argument of self.apply_matrix()
    """
    self.apply_matrix(np.linalg.inv(matrix), **kwargs)

</t>
<t tx="ekr.20250122151621.606">def apply_transposed_matrix(
    self, transposed_matrix: np.ndarray | list | tuple, **kwargs
):
    """
    Applies the transformation represented by the
    given transposed matrix to the number plane,
    and each vector/similar mobject on it.

    Parameters
    ----------
    transposed_matrix
        The matrix.
    **kwargs
        Any valid keyword argument of self.apply_function()
    """
    func = self.get_transposed_matrix_transformation(transposed_matrix)
    if "path_arc" not in kwargs:
        net_rotation = np.mean(
            [angle_of_vector(func(RIGHT)), angle_of_vector(func(UP)) - np.pi / 2],
        )
        kwargs["path_arc"] = net_rotation
    self.apply_function(func, **kwargs)

</t>
<t tx="ekr.20250122151621.607">def apply_inverse_transpose(self, t_matrix: np.ndarray | list | tuple, **kwargs):
    """
    Applies the inverse of the transformation represented
    by the given transposed matrix to the number plane and each
    vector/similar mobject on it.

    Parameters
    ----------
    t_matrix
        The matrix.
    **kwargs
        Any valid keyword argument of self.apply_transposed_matrix()
    """
    t_inv = np.linalg.inv(np.array(t_matrix).T).T
    self.apply_transposed_matrix(t_inv, **kwargs)

</t>
<t tx="ekr.20250122151621.608">def apply_nonlinear_transformation(
    self, function: Callable[[np.ndarray], np.ndarray], **kwargs
):
    """
    Applies the non-linear transformation represented
    by the given function to the number plane and each
    vector/similar mobject on it.

    Parameters
    ----------
    function
        The function.
    **kwargs
        Any valid keyword argument of self.apply_function()
    """
    self.plane.prepare_for_nonlinear_transform()
    self.apply_function(function, **kwargs)

</t>
<t tx="ekr.20250122151621.609">def apply_function(
    self,
    function: Callable[[np.ndarray], np.ndarray],
    added_anims: list = [],
    **kwargs,
):
    """
    Applies the given function to each of the mobjects in
    self.transformable_mobjects, and plays the animation showing
    this.

    Parameters
    ----------
    function
        The function that affects each point
        of each mobject in self.transformable_mobjects.

    added_anims
        Any other animations that need to be played
        simultaneously with this.

    **kwargs
        Any valid keyword argument of a self.play() call.
    """
    if "run_time" not in kwargs:
        kwargs["run_time"] = 3
    anims = (
        [
            ApplyPointwiseFunction(function, t_mob)
            for t_mob in self.transformable_mobjects
        ]
        + [
            self.get_vector_movement(function),
            self.get_transformable_label_movement(),
            self.get_moving_mobject_movement(function),
        ]
        + [Animation(f_mob) for f_mob in self.foreground_mobjects]
        + added_anims
    )
    self.play(*anims, **kwargs)
</t>
<t tx="ekr.20250122151621.61">def get_direction(self) -&gt; np.ndarray:
    """Returns the current direction of the apex of the :class:`Cone`.

    Returns
    -------
    direction : :class:`numpy.array`
        The direction of the apex.
    """
    return self.direction

</t>
<t tx="ekr.20250122151621.610">"""A scene supporting zooming in on a specified section.


Examples
--------

.. manim:: UseZoomedScene

    class UseZoomedScene(ZoomedScene):
        def construct(self):
            dot = Dot().set_color(GREEN)
            self.add(dot)
            self.wait(1)
            self.activate_zooming(animate=False)
            self.wait(1)
            self.play(dot.animate.shift(LEFT))

.. manim:: ChangingZoomScale

    class ChangingZoomScale(ZoomedScene):
        def __init__(self, **kwargs):
            ZoomedScene.__init__(
                self,
                zoom_factor=0.3,
                zoomed_display_height=1,
                zoomed_display_width=3,
                image_frame_stroke_width=20,
                zoomed_camera_config={
                    "default_frame_stroke_width": 3,
                },
                **kwargs
            )

        def construct(self):
            dot = Dot().set_color(GREEN)
            sq = Circle(fill_opacity=1, radius=0.2).next_to(dot, RIGHT)
            self.add(dot, sq)
            self.wait(1)
            self.activate_zooming(animate=False)
            self.wait(1)
            self.play(dot.animate.shift(LEFT * 0.3))

            self.play(self.zoomed_camera.frame.animate.scale(4))
            self.play(self.zoomed_camera.frame.animate.shift(0.5 * DOWN))

"""

from __future__ import annotations

__all__ = ["ZoomedScene"]


from ..animation.transform import ApplyMethod
from ..camera.moving_camera import MovingCamera
from ..camera.multi_camera import MultiCamera
from ..constants import *
from ..mobject.types.image_mobject import ImageMobjectFromCamera
from ..scene.moving_camera_scene import MovingCameraScene

# Note, any scenes from old videos using ZoomedScene will almost certainly
# break, as it was restructured.


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.611">class ZoomedScene(MovingCameraScene):
    """
    This is a Scene with special configurations made for when
    a particular part of the scene must be zoomed in on and displayed
    separately.
    """

    @others
</t>
<t tx="ekr.20250122151621.612">def __init__(
    self,
    camera_class=MultiCamera,
    zoomed_display_height=3,
    zoomed_display_width=3,
    zoomed_display_center=None,
    zoomed_display_corner=UP + RIGHT,
    zoomed_display_corner_buff=DEFAULT_MOBJECT_TO_EDGE_BUFFER,
    zoomed_camera_config={
        "default_frame_stroke_width": 2,
        "background_opacity": 1,
    },
    zoomed_camera_image_mobject_config={},
    zoomed_camera_frame_starting_position=ORIGIN,
    zoom_factor=0.15,
    image_frame_stroke_width=3,
    zoom_activated=False,
    **kwargs,
):
    self.zoomed_display_height = zoomed_display_height
    self.zoomed_display_width = zoomed_display_width
    self.zoomed_display_center = zoomed_display_center
    self.zoomed_display_corner = zoomed_display_corner
    self.zoomed_display_corner_buff = zoomed_display_corner_buff
    self.zoomed_camera_config = zoomed_camera_config
    self.zoomed_camera_image_mobject_config = zoomed_camera_image_mobject_config
    self.zoomed_camera_frame_starting_position = (
        zoomed_camera_frame_starting_position
    )
    self.zoom_factor = zoom_factor
    self.image_frame_stroke_width = image_frame_stroke_width
    self.zoom_activated = zoom_activated
    super().__init__(camera_class=camera_class, **kwargs)

</t>
<t tx="ekr.20250122151621.613">def setup(self):
    """
    This method is used internally by Manim to
    setup the scene for proper use.
    """
    super().setup()
    # Initialize camera and display
    zoomed_camera = MovingCamera(**self.zoomed_camera_config)
    zoomed_display = ImageMobjectFromCamera(
        zoomed_camera, **self.zoomed_camera_image_mobject_config
    )
    zoomed_display.add_display_frame()
    for mob in zoomed_camera.frame, zoomed_display:
        mob.stretch_to_fit_height(self.zoomed_display_height)
        mob.stretch_to_fit_width(self.zoomed_display_width)
    zoomed_camera.frame.scale(self.zoom_factor)

    # Position camera and display
    zoomed_camera.frame.move_to(self.zoomed_camera_frame_starting_position)
    if self.zoomed_display_center is not None:
        zoomed_display.move_to(self.zoomed_display_center)
    else:
        zoomed_display.to_corner(
            self.zoomed_display_corner,
            buff=self.zoomed_display_corner_buff,
        )

    self.zoomed_camera = zoomed_camera
    self.zoomed_display = zoomed_display

</t>
<t tx="ekr.20250122151621.614">def activate_zooming(self, animate: bool = False):
    """
    This method is used to activate the zooming for
    the zoomed_camera.

    Parameters
    ----------
    animate
        Whether or not to animate the activation
        of the zoomed camera.
    """
    self.zoom_activated = True
    self.renderer.camera.add_image_mobject_from_camera(self.zoomed_display)
    if animate:
        self.play(self.get_zoom_in_animation())
        self.play(self.get_zoomed_display_pop_out_animation())
    self.add_foreground_mobjects(
        self.zoomed_camera.frame,
        self.zoomed_display,
    )

</t>
<t tx="ekr.20250122151621.615">def get_zoom_in_animation(self, run_time: float = 2, **kwargs):
    """
    Returns the animation of camera zooming in.

    Parameters
    ----------
    run_time
        The run_time of the animation of the camera zooming in.
    **kwargs
        Any valid keyword arguments of ApplyMethod()

    Returns
    -------
    ApplyMethod
        The animation of the camera zooming in.
    """
    frame = self.zoomed_camera.frame
    full_frame_height = self.camera.frame_height
    full_frame_width = self.camera.frame_width
    frame.save_state()
    frame.stretch_to_fit_width(full_frame_width)
    frame.stretch_to_fit_height(full_frame_height)
    frame.center()
    frame.set_stroke(width=0)
    return ApplyMethod(frame.restore, run_time=run_time, **kwargs)

</t>
<t tx="ekr.20250122151621.616">def get_zoomed_display_pop_out_animation(self, **kwargs):
    """
    This is the animation of the popping out of the
    mini-display that shows the content of the zoomed
    camera.

    Returns
    -------
    ApplyMethod
        The Animation of the Zoomed Display popping out.
    """
    display = self.zoomed_display
    display.save_state()
    display.replace(self.zoomed_camera.frame, stretch=True)
    return ApplyMethod(display.restore)

</t>
<t tx="ekr.20250122151621.617">def get_zoom_factor(self):
    """
    Returns the Zoom factor of the Zoomed camera.
    Defined as the ratio between the height of the
    zoomed camera and the height of the zoomed mini
    display.
    Returns
    -------
    float
        The zoom factor.
    """
    return self.zoomed_camera.frame.height / self.zoomed_display.height
</t>
<t tx="ekr.20250122151621.618"></t>
<t tx="ekr.20250122151621.619"></t>
<t tx="ekr.20250122151621.62">def _set_start_and_end_attributes(self, direction):
    normalized_direction = direction * np.linalg.norm(direction)

    start = self.base_circle.get_center()
    end = start + normalized_direction * self.new_height
    self.start_point = VectorizedPoint(start)
    self.end_point = VectorizedPoint(end)
    self.add(self.start_point, self.end_point)


</t>
<t tx="ekr.20250122151621.620">"""Utility functions related to Bézier curves."""

from __future__ import annotations

__all__ = [
    "bezier",
    "partial_bezier_points",
    "split_bezier",
    "subdivide_bezier",
    "bezier_remap",
    "interpolate",
    "integer_interpolate",
    "mid",
    "inverse_interpolate",
    "match_interpolate",
    "get_smooth_cubic_bezier_handle_points",
    "is_closed",
    "proportions_along_bezier_curve_for_point",
    "point_lies_on_bezier",
]


from collections.abc import Sequence
from functools import reduce
from typing import TYPE_CHECKING, Callable, overload

import numpy as np

from manim.utils.simple_functions import choose

if TYPE_CHECKING:
    from manim.typing import (
        BezierPoints,
        BezierPoints_Array,
        BezierPointsLike,
        BezierPointsLike_Array,
        ColVector,
        MatrixMN,
        Point3D,
        Point3D_Array,
        Point3DLike,
        Point3DLike_Array,
        QuadraticBezierPath,
        QuadraticSpline,
        Spline,
    )

# l is a commonly used name in linear algebra
# ruff: noqa: E741


@overload
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.621">def bezier(
    points: BezierPointsLike,
) -&gt; Callable[[float | ColVector], Point3D | Point3D_Array]: ...


</t>
<t tx="ekr.20250122151621.622">@overload
def bezier(
    points: Sequence[Point3DLike_Array],
) -&gt; Callable[[float | ColVector], Point3D_Array]: ...


</t>
<t tx="ekr.20250122151621.623">def bezier(
    points: Point3D_Array | Sequence[Point3D_Array],
) -&gt; Callable[[float | ColVector], Point3D_Array]:
    """Classic implementation of a Bézier curve.

    Parameters
    ----------
    points
        :math:`(d+1, 3)`-shaped array of :math:`d+1` control points defining a single Bézier
        curve of degree :math:`d`. Alternatively, for vectorization purposes, ``points`` can
        also be a :math:`(d+1, M, 3)`-shaped sequence of :math:`d+1` arrays of :math:`M`
        control points each, which define `M` Bézier curves instead.

    Returns
    -------
    bezier_func : :class:`typing.Callable` [[:class:`float` | :class:`~.ColVector`], :class:`~.Point3D` | :class:`~.Point3D_Array`]
        Function describing the Bézier curve. The behaviour of this function depends on
        the shape of ``points``:

            *   If ``points`` was a :math:`(d+1, 3)` array representing a single Bézier curve,
                then ``bezier_func`` can receive either:

                *   a :class:`float` ``t``, in which case it returns a
                    single :math:`(1, 3)`-shaped :class:`~.Point3D` representing the evaluation
                    of the Bézier at ``t``, or
                *   an :math:`(n, 1)`-shaped :class:`~.ColVector`
                    containing :math:`n` values to evaluate the Bézier curve at, returning instead
                    an :math:`(n, 3)`-shaped :class:`~.Point3D_Array` containing the points
                    resulting from evaluating the Bézier at each of the :math:`n` values.
                .. warning::
                    If passing a vector of :math:`t`-values to ``bezier_func``, it **must**
                    be a column vector/matrix of shape :math:`(n, 1)`. Passing an 1D array of
                    shape :math:`(n,)` is not supported and **will result in undefined behaviour**.

            *   If ``points`` was a :math:`(d+1, M, 3)` array describing :math:`M` Bézier curves,
                then ``bezier_func`` can receive either:

                *   a :class:`float` ``t``, in which case it returns an
                    :math:`(M, 3)`-shaped :class:`~.Point3D_Array` representing the evaluation
                    of the :math:`M` Bézier curves at the same value ``t``, or
                *   an :math:`(M, 1)`-shaped
                    :class:`~.ColVector` containing :math:`M` values, such that the :math:`i`-th
                    Bézier curve defined by ``points`` is evaluated at the corresponding :math:`i`-th
                    value in ``t``, returning again an :math:`(M, 3)`-shaped :class:`~.Point3D_Array`
                    containing those :math:`M` evaluations.
                .. warning::
                    Unlike the previous case, if you pass a :class:`~.ColVector` to ``bezier_func``,
                    it **must** contain exactly :math:`M` values, each value for each of the :math:`M`
                    Bézier curves defined by ``points``. Any array of shape other than :math:`(M, 1)`
                    **will result in undefined behaviour**.
    """
    P = np.asarray(points)
    degree = P.shape[0] - 1

    if degree == 0:

        def zero_bezier(t: float | ColVector) -&gt; Point3D | Point3D_Array:
            return np.ones_like(t) * P[0]

        return zero_bezier

    if degree == 1:

        def linear_bezier(t: float | ColVector) -&gt; Point3D | Point3D_Array:
            return P[0] + t * (P[1] - P[0])

        return linear_bezier

    if degree == 2:

        def quadratic_bezier(t: float | ColVector) -&gt; Point3D | Point3D_Array:
            t2 = t * t
            mt = 1 - t
            mt2 = mt * mt
            return mt2 * P[0] + 2 * t * mt * P[1] + t2 * P[2]

        return quadratic_bezier

    if degree == 3:

        def cubic_bezier(t: float | ColVector) -&gt; Point3D | Point3D_Array:
            t2 = t * t
            t3 = t2 * t
            mt = 1 - t
            mt2 = mt * mt
            mt3 = mt2 * mt
            return mt3 * P[0] + 3 * t * mt2 * P[1] + 3 * t2 * mt * P[2] + t3 * P[3]

        return cubic_bezier

    def nth_grade_bezier(t: float | ColVector) -&gt; Point3D | Point3D_Array:
        is_scalar = not isinstance(t, np.ndarray)
        if is_scalar:
            B = np.empty((1, *P.shape))
        else:
            assert isinstance(t, np.ndarray)
            t = t.reshape(-1, *[1 for dim in P.shape])
            B = np.empty((t.shape[0], *P.shape))
        B[:] = P

        for i in range(degree):
            # After the i-th iteration (i in [0, ..., d-1]) there are evaluations at t
            # of (d-i) Bezier curves of grade (i+1), stored in the first d-i slots of B
            B[:, : degree - i] += t * (B[:, 1 : degree - i + 1] - B[:, : degree - i])

        # In the end, there shall be the evaluation at t of a single Bezier curve of
        # grade d, stored in the first slot of B
        if is_scalar:
            val: Point3D = B[0, 0]
            return val
        return B[:, 0]

    return nth_grade_bezier


</t>
<t tx="ekr.20250122151621.624">def partial_bezier_points(points: BezierPointsLike, a: float, b: float) -&gt; BezierPoints:
    r"""Given an array of ``points`` which define a Bézier curve, and two numbers :math:`a, b`
    such that :math:`0 \le a &lt; b \le 1`, return an array of the same size, which describes the
    portion of the original Bézier curve on the interval :math:`[a, b]`.

    :func:`partial_bezier_points` is conceptually equivalent to calling :func:`split_bezier`
    twice and discarding unused Bézier curves, but this is more efficient and doesn't waste
    computations.

    .. seealso::
        See :func:`split_bezier` for an explanation on how to split Bézier curves.

    .. note::
        To find the portion of a Bézier curve with :math:`t` between :math:`a` and :math:`b`:

        1.  Split the curve at :math:`t = a` and extract its 2nd subcurve.
        2.  We cannot evaluate the new subcurve at :math:`t = b` because its range of values for :math:`t` is different.
            To find the correct value, we need to transform the interval :math:`[a, 1]` into :math:`[0, 1]`
            by first subtracting :math:`a` to get :math:`[0, 1-a]` and then dividing by :math:`1-a`. Thus, our new
            value must be :math:`t = \frac{b - a}{1 - a}`. Define :math:`u = \frac{b - a}{1 - a}`.
        3.  Split the subcurve at :math:`t = u` and extract its 1st subcurve.

        The final portion is a linear combination of points, and thus the process can be
        summarized as a linear transformation by some matrix in terms of :math:`a` and :math:`b`.
        This matrix is given explicitly for Bézier curves up to degree 3, which are often used in Manim.
        For higher degrees, the algorithm described previously is used.

        For the case of a quadratic Bézier curve:

        * Step 1:

        .. math::
            H'_1
            =
            \begin{pmatrix}
                (1-a)^2 &amp; 2(1-a)a &amp; a^2 \\
                0 &amp; (1-a) &amp; a \\
                0 &amp; 0 &amp; 1
            \end{pmatrix}
            \begin{pmatrix}
                p_0 \\
                p_1 \\
                p_2
            \end{pmatrix}

        * Step 2:

        .. math::
            H''_0
            &amp;=
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 \\
                (1-u) &amp; u &amp; 0\\
                (1-u)^2 &amp; 2(1-u)u &amp; u^2
            \end{pmatrix}
            H'_1
            \\
            &amp;
            \\
            &amp;=
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 \\
                (1-u) &amp; u &amp; 0\\
                (1-u)^2 &amp; 2(1-u)u &amp; u^2
            \end{pmatrix}
            \begin{pmatrix}
                (1-a)^2 &amp; 2(1-a)a &amp; a^2 \\
                0 &amp; (1-a) &amp; a \\
                0 &amp; 0 &amp; 1
            \end{pmatrix}
            \begin{pmatrix}
                p_0 \\
                p_1 \\
                p_2
            \end{pmatrix}
            \\
            &amp;
            \\
            &amp;=
            \begin{pmatrix}
                (1-a)^2 &amp; 2(1-a)a &amp; a^2 \\
                (1-a)(1-b) &amp; a(1-b) + (1-a)b &amp; ab \\
                (1-b)^2 &amp; 2(1-b)b &amp; b^2
            \end{pmatrix}
            \begin{pmatrix}
                p_0 \\
                p_1 \\
                p_2
            \end{pmatrix}

        from where one can define a :math:`(3, 3)` matrix :math:`P_2` which, when applied over
        the array of ``points``, will return the desired partial quadratic Bézier curve:

        .. math::
            P_2
            =
            \begin{pmatrix}
                (1-a)^2 &amp; 2(1-a)a &amp; a^2 \\
                (1-a)(1-b) &amp; a(1-b) + (1-a)b &amp; ab \\
                (1-b)^2 &amp; 2(1-b)b &amp; b^2
            \end{pmatrix}

        Similarly, for the cubic Bézier curve case, one can define the following
        :math:`(4, 4)` matrix :math:`P_3`:

        .. math::
            P_3
            =
            \begin{pmatrix}
                (1-a)^3 &amp; 3(1-a)^2a &amp; 3(1-a)a^2 &amp; a^3 \\
                (1-a)^2(1-b) &amp; 2(1-a)a(1-b) + (1-a)^2b &amp; a^2(1-b) + 2(1-a)ab &amp; a^2b \\
                (1-a)(1-b)^2 &amp; a(1-b)^2 + 2(1-a)(1-b)b &amp; 2a(1-b)b + (1-a)b^2 &amp; ab^2 \\
                (1-b)^3 &amp; 3(1-b)^2b &amp; 3(1-b)b^2 &amp; b^3
            \end{pmatrix}

    Parameters
    ----------
    points
        set of points defining the bezier curve.
    a
        lower bound of the desired partial bezier curve.
    b
        upper bound of the desired partial bezier curve.

    Returns
    -------
    :class:`~.BezierPoints`
        An array containing the control points defining the partial Bézier curve.
    """
    # Border cases
    if a == 1:
        arr = np.array(points)
        arr[:] = arr[-1]
        return arr
    if b == 0:
        arr = np.array(points)
        arr[:] = arr[0]
        return arr

    points = np.asarray(points)
    degree = points.shape[0] - 1

    if degree == 3:
        ma, mb = 1 - a, 1 - b
        a2, b2, ma2, mb2 = a * a, b * b, ma * ma, mb * mb
        a3, b3, ma3, mb3 = a2 * a, b2 * b, ma2 * ma, mb2 * mb

        portion_matrix = np.array(
            [
                [ma3, 3 * ma2 * a, 3 * ma * a2, a3],
                [ma2 * mb, 2 * ma * a * mb + ma2 * b, a2 * mb + 2 * ma * a * b, a2 * b],
                [ma * mb2, a * mb2 + 2 * ma * mb * b, 2 * a * mb * b + ma * b2, a * b2],
                [mb3, 3 * mb2 * b, 3 * mb * b2, b3],
            ]
        )
        return portion_matrix @ points

    if degree == 2:
        ma, mb = 1 - a, 1 - b

        portion_matrix = np.array(
            [
                [ma * ma, 2 * a * ma, a * a],
                [ma * mb, a * mb + ma * b, a * b],
                [mb * mb, 2 * b * mb, b * b],
            ]
        )
        return portion_matrix @ points

    if degree == 1:
        direction = points[1] - points[0]
        return np.array(
            [
                points[0] + a * direction,
                points[0] + b * direction,
            ]
        )

    if degree == 0:
        return points

    # Fallback case for nth degree Béziers
    # It is convenient that np.array copies points
    arr = np.array(points, dtype=float)
    N = arr.shape[0]

    # Current state for an example Bézier curve C0 = [P0, P1, P2, P3]:
    # arr = [P0, P1, P2, P3]
    if a != 0:
        for i in range(1, N):
            # 1st iter: arr = [L0(a), L1(a), L2(a), P3]
            # 2nd iter: arr = [Q0(a), Q1(a), L2(a), P3]
            # 3rd iter: arr = [C0(a), Q1(a), L2(a), P3]
            arr[: N - i] += a * (arr[1 : N - i + 1] - arr[: N - i])

    # For faster calculations we shall define mu = 1 - u = (1 - b) / (1 - a).
    # This is because:
    # L0'(u) = P0' + u(P1' - P0')
    #        = (1-u)P0' + uP1'
    #        = muP0' + (1-mu)P1'
    #        = P1' + mu(P0' - P1)
    # In this way, one can do something similar to the first loop.
    #
    # Current state:
    # arr = [C0(a), Q1(a), L2(a), P3]
    #     = [P0', P1', P2', P3']
    if b != 1:
        mu = (1 - b) / (1 - a)
        for i in range(1, N):
            # 1st iter: arr = [P0', L0'(u), L1'(u), L2'(u)]
            # 2nd iter: arr = [P0', L0'(u), Q0'(u), Q1'(u)]
            # 3rd iter: arr = [P0', L0'(u), Q0'(u), C0'(u)]
            arr[i:] += mu * (arr[i - 1 : -1] - arr[i:])

    return arr


</t>
<t tx="ekr.20250122151621.625">def split_bezier(points: BezierPointsLike, t: float) -&gt; Spline:
    r"""Split a Bézier curve at argument ``t`` into two curves.

    .. note::

        .. seealso::
            `A Primer on Bézier Curves #10: Splitting curves. Pomax. &lt;https://pomax.github.io/bezierinfo/#splitting&gt;`_

        As an example for a cubic Bézier curve, let :math:`p_0, p_1, p_2, p_3` be the points
        needed for the curve :math:`C_0 = [p_0, \ p_1, \ p_2, \ p_3]`.

        Define the 3 linear Béziers :math:`L_0, L_1, L_2` as interpolations of :math:`p_0, p_1, p_2, p_3`:

        .. math::
            L_0(t) &amp;= p_0 + t(p_1 - p_0) \\
            L_1(t) &amp;= p_1 + t(p_2 - p_1) \\
            L_2(t) &amp;= p_2 + t(p_3 - p_2)

        Define the 2 quadratic Béziers :math:`Q_0, Q_1` as interpolations of :math:`L_0, L_1, L_2`:

        .. math::
            Q_0(t) &amp;= L_0(t) + t(L_1(t) - L_0(t)) \\
            Q_1(t) &amp;= L_1(t) + t(L_2(t) - L_1(t))

        Then :math:`C_0` is the following interpolation of :math:`Q_0` and :math:`Q_1`:

        .. math::
            C_0(t) = Q_0(t) + t(Q_1(t) - Q_0(t))

        Evaluating :math:`C_0` at a value :math:`t=t'` splits :math:`C_0` into two cubic Béziers :math:`H_0`
        and :math:`H_1`, defined by some of the points we calculated earlier:

        .. math::
            H_0 &amp;= [p_0, &amp;\ L_0(t'), &amp;\ Q_0(t'), &amp;\ C_0(t') &amp;] \\
            H_1 &amp;= [p_0(t'), &amp;\ Q_1(t'), &amp;\ L_2(t'), &amp;\ p_3 &amp;]

        As the resulting curves are obtained from linear combinations of ``points``, everything can
        be encoded into a matrix for efficiency, which is done for Bézier curves of degree up to 3.

        .. seealso::
            `A Primer on Bézier Curves #11: Splitting curves using matrices. Pomax. &lt;https://pomax.github.io/bezierinfo/#matrixsplit&gt;`_

        For the simpler case of a quadratic Bézier curve:

        .. math::
            H_0
            &amp;=
            \begin{pmatrix}
                p_0 \\
                (1-t) p_0 + t p_1 \\
                (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\
            \end{pmatrix}
            &amp;=
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 \\
                (1-t) &amp; t &amp; 0\\
                (1-t)^2 &amp; 2(1-t)t &amp; t^2
            \end{pmatrix}
            \begin{pmatrix}
                p_0 \\
                p_1 \\
                p_2
            \end{pmatrix}
            \\
            &amp;
            \\
            H_1
            &amp;=
            \begin{pmatrix}
                (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\
                (1-t) p_1 + t p_2 \\
                p_2
            \end{pmatrix}
            &amp;=
            \begin{pmatrix}
                (1-t)^2 &amp; 2(1-t)t &amp; t^2 \\
                0 &amp; (1-t) &amp; t \\
                0 &amp; 0 &amp; 1
            \end{pmatrix}
            \begin{pmatrix}
                p_0 \\
                p_1 \\
                p_2
            \end{pmatrix}

        from where one can define a :math:`(6, 3)` split matrix :math:`S_2` which can multiply
        the array of ``points`` to compute the return value:

        .. math::
            S_2
            &amp;=
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 \\
                (1-t) &amp; t &amp; 0 \\
                (1-t)^2 &amp; 2(1-t)t &amp; t^2 \\
                (1-t)^2 &amp; 2(1-t)t &amp; t^2 \\
                0 &amp; (1-t) &amp; t \\
                0 &amp; 0 &amp; 1
            \end{pmatrix}
            \\
            &amp;
            \\
            S_2 P
            &amp;=
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 \\
                (1-t) &amp; t &amp; 0 \\
                (1-t)^2 &amp; 2(1-t)t &amp; t^2 \\
                (1-t)^2 &amp; 2(1-t)t &amp; t^2 \\
                0 &amp; (1-t) &amp; t \\
                0 &amp; 0 &amp; 1
            \end{pmatrix}
            \begin{pmatrix}
                p_0 \\
                p_1 \\
                p_2
            \end{pmatrix}
            =
            \begin{pmatrix}
                \vert \\
                H_0 \\
                \vert \\
                \vert \\
                H_1 \\
                \vert
            \end{pmatrix}

        For the previous example with a cubic Bézier curve:

        .. math::
            H_0
            &amp;=
            \begin{pmatrix}
                p_0 \\
                (1-t) p_0 + t p_1 \\
                (1-t)^2 p_0 + 2(1-t)t p_1 + t^2 p_2 \\
                (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3
            \end{pmatrix}
            &amp;=
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 &amp; 0 \\
                (1-t) &amp; t &amp; 0 &amp; 0 \\
                (1-t)^2 &amp; 2(1-t)t &amp; t^2 &amp; 0 \\
                (1-t)^3 &amp; 3(1-t)^2 t &amp; 3(1-t)t^2 &amp; t^3
            \end{pmatrix}
            \begin{pmatrix}
                p_0 \\
                p_1 \\
                p_2 \\
                p_3
            \end{pmatrix}
            \\
            &amp;
            \\
            H_1
            &amp;=
            \begin{pmatrix}
                (1-t)^3 p_0 + 3(1-t)^2 t p_1 + 3(1-t)t^2 p_2 + t^3 p_3 \\
                (1-t)^2 p_1 + 2(1-t)t p_2 + t^2 p_3 \\
                (1-t) p_2 + t p_3 \\
                p_3
            \end{pmatrix}
            &amp;=
            \begin{pmatrix}
                (1-t)^3 &amp; 3(1-t)^2 t &amp; 3(1-t)t^2 &amp; t^3 \\
                0 &amp; (1-t)^2 &amp; 2(1-t)t &amp; t^2 \\
                0 &amp; 0 &amp; (1-t) &amp; t \\
                0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}
            \begin{pmatrix}
                p_0 \\
                p_1 \\
                p_2 \\
                p_3
            \end{pmatrix}

        from where one can define a :math:`(8, 4)` split matrix :math:`S_3` which can multiply
        the array of ``points`` to compute the return value:

        .. math::
            S_3
            &amp;=
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 &amp; 0 \\
                (1-t) &amp; t &amp; 0 &amp; 0 \\
                (1-t)^2 &amp; 2(1-t)t &amp; t^2 &amp; 0 \\
                (1-t)^3 &amp; 3(1-t)^2 t &amp; 3(1-t)t^2 &amp; t^3 \\
                (1-t)^3 &amp; 3(1-t)^2 t &amp; 3(1-t)t^2 &amp; t^3 \\
                0 &amp; (1-t)^2 &amp; 2(1-t)t &amp; t^2 \\
                0 &amp; 0 &amp; (1-t) &amp; t \\
                0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}
            \\
            &amp;
            \\
            S_3 P
            &amp;=
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 &amp; 0 \\
                (1-t) &amp; t &amp; 0 &amp; 0 \\
                (1-t)^2 &amp; 2(1-t)t &amp; t^2 &amp; 0 \\
                (1-t)^3 &amp; 3(1-t)^2 t &amp; 3(1-t)t^2 &amp; t^3 \\
                (1-t)^3 &amp; 3(1-t)^2 t &amp; 3(1-t)t^2 &amp; t^3 \\
                0 &amp; (1-t)^2 &amp; 2(1-t)t &amp; t^2 \\
                0 &amp; 0 &amp; (1-t) &amp; t \\
                0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}
            \begin{pmatrix}
                p_0 \\
                p_1 \\
                p_2 \\
                p_3
            \end{pmatrix}
            =
            \begin{pmatrix}
                \vert \\
                H_0 \\
                \vert \\
                \vert \\
                H_1 \\
                \vert
            \end{pmatrix}

    Parameters
    ----------
    points
        The control points of the Bézier curve.

    t
        The ``t``-value at which to split the Bézier curve.

    Returns
    -------
    :class:`~.Point3D_Array`
        An array containing the control points defining the two Bézier curves.
    """
    points = np.asarray(points)
    N, dim = points.shape
    degree = N - 1

    if degree == 3:
        mt = 1 - t
        mt2 = mt * mt
        mt3 = mt2 * mt
        t2 = t * t
        t3 = t2 * t
        two_mt_t = 2 * mt * t
        three_mt2_t = 3 * mt2 * t
        three_mt_t2 = 3 * mt * t2

        # Split matrix S3 explained in the docstring
        split_matrix = np.array(
            [
                [1, 0, 0, 0],
                [mt, t, 0, 0],
                [mt2, two_mt_t, t2, 0],
                [mt3, three_mt2_t, three_mt_t2, t3],
                [mt3, three_mt2_t, three_mt_t2, t3],
                [0, mt2, two_mt_t, t2],
                [0, 0, mt, t],
                [0, 0, 0, 1],
            ]
        )

        return split_matrix @ points

    if degree == 2:
        mt = 1 - t
        mt2 = mt * mt
        t2 = t * t
        two_tmt = 2 * t * mt

        # Split matrix S2 explained in the docstring
        split_matrix = np.array(
            [
                [1, 0, 0],
                [mt, t, 0],
                [mt2, two_tmt, t2],
                [mt2, two_tmt, t2],
                [0, mt, t],
                [0, 0, 1],
            ]
        )

        return split_matrix @ points

    if degree == 1:
        middle = points[0] + t * (points[1] - points[0])
        return np.array([points[0], middle, middle, points[1]])

    if degree == 0:
        return np.array([points[0], points[0]])

    # Fallback case for nth degree Béziers
    arr = np.empty((2, N, dim))
    arr[1] = points
    arr[0, 0] = points[0]

    # Example for a cubic Bézier
    # arr[0] = [P0 .. .. ..]
    # arr[1] = [P0 P1 P2 P3]
    for i in range(1, N):
        # 1st iter: arr[1] = [L0 L1 L2 P3]
        # 2nd iter: arr[1] = [Q0 Q1 L2 P3]
        # 3rd iter: arr[1] = [C0 Q1 L2 P3]
        arr[1, : N - i] += t * (arr[1, 1 : N - i + 1] - arr[1, : N - i])
        # 1st iter: arr[0] = [P0 L0 .. ..]
        # 2nd iter: arr[0] = [P0 L0 Q0 ..]
        # 3rd iter: arr[0] = [P0 L0 Q0 C0]
        arr[0, i] = arr[1, 0]

    return arr.reshape(2 * N, dim)


</t>
<t tx="ekr.20250122151621.626"># Memos explained in subdivide_bezier docstring
SUBDIVISION_MATRICES: list[dict[int, MatrixMN]] = [{} for i in range(4)]


def _get_subdivision_matrix(n_points: int, n_divisions: int) -&gt; MatrixMN:
    """Gets the matrix which subdivides a Bézier curve of
    ``n_points`` control points into ``n_divisions`` parts.

    Auxiliary function for :func:`subdivide_bezier`. See its
    docstrings for an explanation of the matrix build process.

    Parameters
    ----------
    n_points
        The number of control points of the Bézier curve to
        subdivide. This function only handles up to 4 points.
    n_divisions
        The number of parts to subdivide the Bézier curve into.

    Returns
    -------
    MatrixMN
        The matrix which, upon multiplying the control points of the
        Bézier curve, subdivides it into ``n_divisions`` parts.
    """
    if n_points not in (1, 2, 3, 4):
        raise NotImplementedError(
            "This function does not support subdividing Bézier "
            "curves with 0 or more than 4 control points."
        )

    subdivision_matrix = SUBDIVISION_MATRICES[n_points - 1].get(n_divisions, None)
    if subdivision_matrix is not None:
        return subdivision_matrix

    subdivision_matrix = np.empty((n_points * n_divisions, n_points))

    # Cubic Bézier
    if n_points == 4:
        for i in range(n_divisions):
            i2 = i * i
            i3 = i2 * i
            ip1 = i + 1
            ip12 = ip1 * ip1
            ip13 = ip12 * ip1
            nmi = n_divisions - i
            nmi2 = nmi * nmi
            nmi3 = nmi2 * nmi
            nmim1 = nmi - 1
            nmim12 = nmim1 * nmim1
            nmim13 = nmim12 * nmim1

            subdivision_matrix[4 * i : 4 * (i + 1)] = np.array(
                [
                    [
                        nmi3,
                        3 * nmi2 * i,
                        3 * nmi * i2,
                        i3,
                    ],
                    [
                        nmi2 * nmim1,
                        2 * nmi * nmim1 * i + nmi2 * ip1,
                        nmim1 * i2 + 2 * nmi * i * ip1,
                        i2 * ip1,
                    ],
                    [
                        nmi * nmim12,
                        nmim12 * i + 2 * nmi * nmim1 * ip1,
                        2 * nmim1 * i * ip1 + nmi * ip12,
                        i * ip12,
                    ],
                    [
                        nmim13,
                        3 * nmim12 * ip1,
                        3 * nmim1 * ip12,
                        ip13,
                    ],
                ]
            )
        subdivision_matrix /= n_divisions * n_divisions * n_divisions

    # Quadratic Bézier
    elif n_points == 3:
        for i in range(n_divisions):
            ip1 = i + 1
            nmi = n_divisions - i
            nmim1 = nmi - 1
            subdivision_matrix[3 * i : 3 * (i + 1)] = np.array(
                [
                    [nmi * nmi, 2 * i * nmi, i * i],
                    [nmi * nmim1, i * nmim1 + ip1 * nmi, i * ip1],
                    [nmim1 * nmim1, 2 * ip1 * nmim1, ip1 * ip1],
                ]
            )
        subdivision_matrix /= n_divisions * n_divisions

    # Linear Bézier (straight line)
    elif n_points == 2:
        aux_range = np.arange(n_divisions + 1)
        subdivision_matrix[::2, 1] = aux_range[:-1]
        subdivision_matrix[1::2, 1] = aux_range[1:]
        subdivision_matrix[:, 0] = subdivision_matrix[::-1, 1]
        subdivision_matrix /= n_divisions

    # Zero-degree Bézier (single point)
    elif n_points == 1:
        subdivision_matrix[:] = 1

    SUBDIVISION_MATRICES[n_points - 1][n_divisions] = subdivision_matrix
    return subdivision_matrix


</t>
<t tx="ekr.20250122151621.627">def subdivide_bezier(points: BezierPointsLike, n_divisions: int) -&gt; Spline:
    r"""Subdivide a Bézier curve into :math:`n` subcurves which have the same shape.

    The points at which the curve is split are located at the
    arguments :math:`t = \frac{i}{n}`, for :math:`i \in \{1, ..., n-1\}`.

    .. seealso::

        * See :func:`split_bezier` for an explanation on how to split Bézier curves.
        * See :func:`partial_bezier_points` for an extra understanding of this function.


    .. note::
        The resulting subcurves can be expressed as linear combinations of
        ``points``, which can be encoded in a single matrix that is precalculated
        for 2nd and 3rd degree Bézier curves.

        As an example for a quadratic Bézier curve: taking inspiration from the
        explanation in :func:`partial_bezier_points`, where the following matrix
        :math:`P_2` was defined to extract the portion of a quadratic Bézier
        curve for :math:`t \in [a, b]`:

        .. math::
            P_2
            =
            \begin{pmatrix}
                (1-a)^2 &amp; 2(1-a)a &amp; a^2 \\
                (1-a)(1-b) &amp; a(1-b) + (1-a)b &amp; ab \\
                (1-b)^2 &amp; 2(1-b)b &amp; b^2
            \end{pmatrix}

        the plan is to replace :math:`[a, b]` with
        :math:`\left[ \frac{i-1}{n}, \frac{i}{n} \right], \ \forall i \in \{1, ..., n\}`.

        As an example for :math:`n = 2` divisions, construct :math:`P_1` for
        the interval :math:`\left[ 0, \frac{1}{2} \right]`, and :math:`P_2` for the
        interval :math:`\left[ \frac{1}{2}, 1 \right]`:

        .. math::
            P_1
            =
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 \\
                0.5 &amp; 0.5 &amp; 0 \\
                0.25 &amp; 0.5 &amp; 0.25
            \end{pmatrix}
            ,
            \quad
            P_2
            =
            \begin{pmatrix}
                0.25 &amp; 0.5 &amp; 0.25 \\
                0 &amp; 0.5 &amp; 0.5 \\
                0 &amp; 0 &amp; 1
            \end{pmatrix}

        Therefore, the following :math:`(6, 3)` subdivision matrix :math:`D_2` can be
        constructed, which will subdivide an array of ``points`` into 2 parts:

        .. math::
            D_2
            =
            \begin{pmatrix}
                M_1 \\
                M_2
            \end{pmatrix}
            =
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 \\
                0.5 &amp; 0.5 &amp; 0 \\
                0.25 &amp; 0.5 &amp; 0.25 \\
                0.25 &amp; 0.5 &amp; 0.25 \\
                0 &amp; 0.5 &amp; 0.5 \\
                0 &amp; 0 &amp; 1
            \end{pmatrix}

        For quadratic and cubic Bézier curves, the subdivision matrices are memoized for
        efficiency. For higher degree curves, an iterative algorithm inspired by the
        one from :func:`split_bezier` is used instead.

    .. image:: /_static/bezier_subdivision_example.png

    Parameters
    ----------
    points
        The control points of the Bézier curve.

    n_divisions
        The number of curves to subdivide the Bézier curve into

    Returns
    -------
    :class:`~.Spline`
        An array containing the points defining the new :math:`n` subcurves.
    """
    if n_divisions == 1:
        return points

    points = np.asarray(points)
    N, dim = points.shape

    if N &lt;= 4:
        subdivision_matrix = _get_subdivision_matrix(N, n_divisions)
        return subdivision_matrix @ points

    # Fallback case for an nth degree Bézier: successive splitting
    beziers = np.empty((n_divisions, N, dim))
    beziers[-1] = points
    for curve_num in range(n_divisions - 1, 0, -1):
        curr = beziers[curve_num]
        prev = beziers[curve_num - 1]
        prev[0] = curr[0]
        a = (n_divisions - curve_num) / (n_divisions - curve_num + 1)
        # Current state for an example cubic Bézier curve:
        # prev = [P0 .. .. ..]
        # curr = [P0 P1 P2 P3]
        for i in range(1, N):
            # 1st iter: curr = [L0 L1 L2 P3]
            # 2nd iter: curr = [Q0 Q1 L2 P3]
            # 3rd iter: curr = [C0 Q1 L2 P3]
            curr[: N - i] += a * (curr[1 : N - i + 1] - curr[: N - i])
            # 1st iter: prev = [P0 L0 .. ..]
            # 2nd iter: prev = [P0 L0 Q0 ..]
            # 3rd iter: prev = [P0 L0 Q0 C0]
            prev[i] = curr[0]

    return beziers.reshape(n_divisions * N, dim)


</t>
<t tx="ekr.20250122151621.628">def bezier_remap(
    bezier_tuples: BezierPointsLike_Array,
    new_number_of_curves: int,
) -&gt; BezierPoints_Array:
    """Subdivides each curve in ``bezier_tuples`` into as many parts as necessary, until the final number of
    curves reaches a desired amount, ``new_number_of_curves``.

    Parameters
    ----------
    bezier_tuples
        An array of multiple Bézier curves of degree :math:`d` to be remapped. The shape of this array
        must be ``(current_number_of_curves, nppc, dim)``, where:

        *   ``current_number_of_curves`` is the current amount of curves in the array ``bezier_tuples``,
        *   ``nppc`` is the amount of points per curve, such that their degree is ``nppc-1``, and
        *   ``dim`` is the dimension of the points, usually :math:`3`.

    new_number_of_curves
        The number of curves that the output will contain. This needs to be higher than the current number.

    Returns
    -------
    :class:`~.BezierPoints_Array`
        The new array of shape ``(new_number_of_curves, nppc, dim)``,
        containing the new Bézier curves after the remap.
    """
    bezier_tuples = np.asarray(bezier_tuples)
    current_number_of_curves, nppc, dim = bezier_tuples.shape
    # This is an array with values ranging from 0
    # up to curr_num_curves,  with repeats such that
    # its total length is target_num_curves.  For example,
    # with curr_num_curves = 10, target_num_curves = 15, this
    # would be [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9].
    repeat_indices = (
        np.arange(new_number_of_curves, dtype="i") * current_number_of_curves
    ) // new_number_of_curves

    # If the nth term of this list is k, it means
    # that the nth curve of our path should be split
    # into k pieces.
    # In the above example our array had the following elements
    # [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 8, 8, 9]
    # We have two 0s, one 1, two 2s and so on.
    # The split factors array would hence be:
    # [2, 1, 2, 1, 2, 1, 2, 1, 2, 1]
    split_factors = np.zeros(current_number_of_curves, dtype="i")
    np.add.at(split_factors, repeat_indices, 1)

    new_tuples = np.empty((new_number_of_curves, nppc, dim))
    index = 0
    for curve, sf in zip(bezier_tuples, split_factors):
        new_tuples[index : index + sf] = subdivide_bezier(curve, sf).reshape(
            sf, nppc, dim
        )
        index += sf

    return new_tuples


</t>
<t tx="ekr.20250122151621.629"># Linear interpolation variants


@overload
def interpolate(start: float, end: float, alpha: float) -&gt; float: ...


</t>
<t tx="ekr.20250122151621.63">def __init__(
    self,
    radius: float = 1,
    height: float = 2,
    direction: np.ndarray = Z_AXIS,
    v_range: Sequence[float] = [0, TAU],
    show_ends: bool = True,
    resolution: Sequence[int] = (24, 24),
    **kwargs,
</t>
<t tx="ekr.20250122151621.630">@overload
def interpolate(start: float, end: float, alpha: ColVector) -&gt; ColVector: ...


</t>
<t tx="ekr.20250122151621.631">@overload
def interpolate(start: Point3D, end: Point3D, alpha: float) -&gt; Point3D: ...


</t>
<t tx="ekr.20250122151621.632">@overload
def interpolate(start: Point3D, end: Point3D, alpha: ColVector) -&gt; Point3D_Array: ...


</t>
<t tx="ekr.20250122151621.633">def interpolate(
    start: float | Point3D,
    end: float | Point3D,
    alpha: float | ColVector,
) -&gt; float | ColVector | Point3D | Point3D_Array:
    """Linearly interpolates between two values ``start`` and ``end``.

    Parameters
    ----------
    start
        The start of the range.
    end
        The end of the range.
    alpha
        A float between 0 and 1, or an :math:`(n, 1)` column vector containing
        :math:`n` floats between 0 and 1 to interpolate in a vectorized fashion.

    Returns
    -------
    :class:`float` | :class:`~.ColVector` | :class:`~.Point3D` | :class:`~.Point3D_Array`
        The result of the linear interpolation.

        *   If ``start`` and ``end`` are of type :class:`float`, and:

            * ``alpha`` is also a :class:`float`, the return is simply another :class:`float`.
            * ``alpha`` is a :class:`~.ColVector`, the return is another :class:`~.ColVector`.

        *   If ``start`` and ``end`` are of type :class:`~.Point3D`, and:

            * ``alpha`` is a :class:`float`, the return is another :class:`~.Point3D`.
            * ``alpha`` is a :class:`~.ColVector`, the return is a :class:`~.Point3D_Array`.
    """
    return (1 - alpha) * start + alpha * end


</t>
<t tx="ekr.20250122151621.634">def integer_interpolate(
    start: float,
    end: float,
    alpha: float,
) -&gt; tuple[int, float]:
    """
    This is a variant of interpolate that returns an integer and the residual

    Parameters
    ----------
    start
        The start of the range
    end
        The end of the range
    alpha
        a float between 0 and 1.

    Returns
    -------
    tuple[int, float]
        This returns an integer between start and end (inclusive) representing
        appropriate interpolation between them, along with a
        "residue" representing a new proportion between the
        returned integer and the next one of the
        list.

    Example
    -------

    .. code-block:: pycon

        &gt;&gt;&gt; integer, residue = integer_interpolate(start=0, end=10, alpha=0.46)
        &gt;&gt;&gt; np.allclose((integer, residue), (4, 0.6))
        True
    """
    if alpha &gt;= 1:
        return (int(end - 1), 1.0)
    if alpha &lt;= 0:
        return (int(start), 0)
    value = int(interpolate(start, end, alpha))
    residue = ((end - start) * alpha) % 1
    return (value, residue)


</t>
<t tx="ekr.20250122151621.635">@overload
def mid(start: float, end: float) -&gt; float: ...


</t>
<t tx="ekr.20250122151621.636">@overload
def mid(start: Point3D, end: Point3D) -&gt; Point3D: ...


</t>
<t tx="ekr.20250122151621.637">def mid(start: float | Point3D, end: float | Point3D) -&gt; float | Point3D:
    """Returns the midpoint between two values.

    Parameters
    ----------
    start
        The first value
    end
        The second value

    Returns
    -------
        The midpoint between the two values
    """
    return (start + end) / 2.0


</t>
<t tx="ekr.20250122151621.638">@overload
def inverse_interpolate(start: float, end: float, value: float) -&gt; float: ...


</t>
<t tx="ekr.20250122151621.639">@overload
def inverse_interpolate(start: float, end: float, value: Point3D) -&gt; Point3D: ...


</t>
<t tx="ekr.20250122151621.64">) -&gt; None:
    self._height = height
    self.radius = radius
    super().__init__(
        self.func,
        resolution=resolution,
        u_range=[-self._height / 2, self._height / 2],
        v_range=v_range,
        **kwargs,
    )
    if show_ends:
        self.add_bases()
    self._current_phi = 0
    self._current_theta = 0
    self.set_direction(direction)

def func(self, u: float, v: float) -&gt; np.ndarray:
    """Converts from cylindrical coordinates to cartesian.

    Parameters
    ----------
    u
        The height.
    v
        The azimuthal angle.

    Returns
    -------
    :class:`numpy.ndarray`
        Points defining the :class:`Cylinder`.
    """
    height = u
    phi = v
    r = self.radius
    return np.array([r * np.cos(phi), r * np.sin(phi), height])

</t>
<t tx="ekr.20250122151621.640">@overload
def inverse_interpolate(start: Point3D, end: Point3D, value: Point3D) -&gt; Point3D: ...


</t>
<t tx="ekr.20250122151621.641">def inverse_interpolate(
    start: float | Point3D,
    end: float | Point3D,
    value: float | Point3D,
) -&gt; float | Point3D:
    """Perform inverse interpolation to determine the alpha
    values that would produce the specified ``value``
    given the ``start`` and ``end`` values or points.

    Parameters
    ----------
    start
        The start value or point of the interpolation.
    end
        The end value or point of the interpolation.
    value
        The value or point for which the alpha value
        should be determined.

    Returns
    -------
        The alpha values producing the given input
        when interpolating between ``start`` and ``end``.

    Example
    -------

    .. code-block:: pycon

        &gt;&gt;&gt; inverse_interpolate(start=2, end=6, value=4)
        np.float64(0.5)

        &gt;&gt;&gt; start = np.array([1, 2, 1])
        &gt;&gt;&gt; end = np.array([7, 8, 11])
        &gt;&gt;&gt; value = np.array([4, 5, 5])
        &gt;&gt;&gt; inverse_interpolate(start, end, value)
        array([0.5, 0.5, 0.4])
    """
    return np.true_divide(value - start, end - start)


</t>
<t tx="ekr.20250122151621.642">@overload
def match_interpolate(
    new_start: float,
    new_end: float,
    old_start: float,
    old_end: float,
    old_value: float,
) -&gt; float: ...


</t>
<t tx="ekr.20250122151621.643">@overload
def match_interpolate(
    new_start: float,
    new_end: float,
    old_start: float,
    old_end: float,
    old_value: Point3D,
) -&gt; Point3D: ...


</t>
<t tx="ekr.20250122151621.644">def match_interpolate(
    new_start: float,
    new_end: float,
    old_start: float,
    old_end: float,
    old_value: float | Point3D,
) -&gt; float | Point3D:
    """Interpolate a value from an old range to a new range.

    Parameters
    ----------
    new_start
        The start of the new range.
    new_end
        The end of the new range.
    old_start
        The start of the old range.
    old_end
        The end of the old range.
    old_value
        The value within the old range whose corresponding
        value in the new range (with the same alpha value)
        is desired.

    Returns
    -------
        The interpolated value within the new range.

    Examples
    --------
    &gt;&gt;&gt; match_interpolate(0, 100, 10, 20, 15)
    np.float64(50.0)
    """
    old_alpha = inverse_interpolate(old_start, old_end, old_value)
    return interpolate(
        new_start,
        new_end,
        old_alpha,
    )


</t>
<t tx="ekr.20250122151621.645"># Figuring out which Bézier curves most smoothly connect a sequence of points
def get_smooth_cubic_bezier_handle_points(
    anchors: Point3DLike_Array,
) -&gt; tuple[Point3D_Array, Point3D_Array]:
    """Given an array of anchors for a cubic spline (array of connected cubic
    Bézier curves), compute the 1st and 2nd handle for every curve, so that
    the resulting spline is smooth.

    Parameters
    ----------
    anchors
        Anchors of a cubic spline.

    Returns
    -------
    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]
        A tuple of two arrays: one containing the 1st handle for every curve in
        the cubic spline, and the other containing the 2nd handles.
    """
    anchors = np.asarray(anchors)
    n_anchors = anchors.shape[0]

    # If there's a single anchor, there's no Bézier curve.
    # Return empty arrays.
    if n_anchors == 1:
        dim = anchors.shape[1]
        return np.zeros((0, dim)), np.zeros((0, dim))

    # If there are only two anchors (thus only one pair of handles),
    # they can only be an interpolation of these two anchors with alphas
    # 1/3 and 2/3, which will draw a straight line between the anchors.
    if n_anchors == 2:
        val = interpolate(anchors[0], anchors[1], np.array([[1 / 3], [2 / 3]]))
        return (val[0], val[1])

    # Handle different cases depending on whether the points form a closed
    # curve or not
    curve_is_closed = is_closed(anchors)
    if curve_is_closed:
        return get_smooth_closed_cubic_bezier_handle_points(anchors)
    else:
        return get_smooth_open_cubic_bezier_handle_points(anchors)


</t>
<t tx="ekr.20250122151621.646">CP_CLOSED_MEMO = np.array([1 / 3])
UP_CLOSED_MEMO = np.array([1 / 3])


def get_smooth_closed_cubic_bezier_handle_points(
    anchors: Point3DLike_Array,
) -&gt; tuple[Point3D_Array, Point3D_Array]:
    r"""Special case of :func:`get_smooth_cubic_bezier_handle_points`,
    when the ``anchors`` form a closed loop.

    .. note::
        A system of equations must be solved to get the first handles of
        every Bézier curve (referred to as :math:`H_1`).
        Then :math:`H_2` (the second handles) can be obtained separately.

        .. seealso::
            The equations were obtained from:

            * `Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. &lt;http://www.jacos.nl/jacos_html/spline/theory/theory_2.html&gt;`_

        In general, if there are :math:`N+1` anchors, there will be :math:`N` Bézier curves
        and thus :math:`N` pairs of handles to find. We must solve the following
        system of equations for the 1st handles (example for :math:`N = 5`):

        .. math::
            \begin{pmatrix}
                4 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
                1 &amp; 4 &amp; 1 &amp; 0 &amp; 0 \\
                0 &amp; 1 &amp; 4 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 1 &amp; 4 &amp; 1 \\
                1 &amp; 0 &amp; 0 &amp; 1 &amp; 4
            \end{pmatrix}
            \begin{pmatrix}
                H_{1,0} \\
                H_{1,1} \\
                H_{1,2} \\
                H_{1,3} \\
                H_{1,4}
            \end{pmatrix}
            =
            \begin{pmatrix}
                4A_0 + 2A_1 \\
                4A_1 + 2A_2 \\
                4A_2 + 2A_3 \\
                4A_3 + 2A_4 \\
                4A_4 + 2A_5
            \end{pmatrix}

        which will be expressed as :math:`RH_1 = D`.

        :math:`R` is almost a tridiagonal matrix, so we could use Thomas' algorithm.

        .. seealso::
            `Tridiagonal matrix algorithm. Wikipedia. &lt;https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm&gt;`_

        However, :math:`R` has ones at the opposite corners. A solution to this is
        the first decomposition proposed in the link below, with :math:`\alpha = 1`:

        .. seealso::
            `Tridiagonal matrix algorithm # Variants. Wikipedia. &lt;https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm#Variants&gt;`_

        .. math::
            R
            =
            \begin{pmatrix}
                4 &amp; 1 &amp; 0 &amp; 0 &amp; 1 \\
                1 &amp; 4 &amp; 1 &amp; 0 &amp; 0 \\
                0 &amp; 1 &amp; 4 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 1 &amp; 4 &amp; 1 \\
                1 &amp; 0 &amp; 0 &amp; 1 &amp; 4
            \end{pmatrix}
            &amp;=
            \begin{pmatrix}
                3 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
                1 &amp; 4 &amp; 1 &amp; 0 &amp; 0 \\
                0 &amp; 1 &amp; 4 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 1 &amp; 4 &amp; 1 \\
                0 &amp; 0 &amp; 0 &amp; 1 &amp; 3
            \end{pmatrix}
            +
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 &amp; 0 &amp; 1 \\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
                1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}
            \\
            &amp;
            \\
            &amp;=
            \begin{pmatrix}
                3 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
                1 &amp; 4 &amp; 1 &amp; 0 &amp; 0 \\
                0 &amp; 1 &amp; 4 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 1 &amp; 4 &amp; 1 \\
                0 &amp; 0 &amp; 0 &amp; 1 &amp; 3
            \end{pmatrix}
            +
            \begin{pmatrix}
                1 \\
                0 \\
                0 \\
                0 \\
                1
            \end{pmatrix}
            \begin{pmatrix}
                1 &amp; 0 &amp; 0 &amp; 0 &amp; 1
            \end{pmatrix}
            \\
            &amp;
            \\
            &amp;=
            T + uv^t

        We decompose :math:`R = T + uv^t`, where :math:`T` is a tridiagonal matrix, and
        :math:`u, v` are :math:`N`-D vectors such that :math:`u_0 = u_{N-1} = v_0 = v_{N-1} = 1`,
        and :math:`u_i = v_i = 0, \forall i \in \{1, ..., N-2\}`.

        Thus:

        .. math::
            RH_1 &amp;= D \\
            \Rightarrow (T + uv^t)H_1 &amp;= D

        If we find a vector :math:`q` such that :math:`Tq = u`:

        .. math::
            \Rightarrow (T + Tqv^t)H_1 &amp;= D \\
            \Rightarrow T(I + qv^t)H_1 &amp;= D \\
            \Rightarrow H_1 &amp;= (I + qv^t)^{-1} T^{-1} D

        According to Sherman-Morrison's formula:

        .. seealso::
            `Sherman-Morrison's formula. Wikipedia. &lt;https://en.wikipedia.org/wiki/Sherman%E2%80%93Morrison_formula&gt;`_

        .. math::
            (I + qv^t)^{-1} = I - \frac{1}{1 + v^tq} qv^t

        If we find :math:`Y = T^{-1} D`, or in other words, if we solve for
        :math:`Y` in :math:`TY = D`:

        .. math::
            H_1 &amp;= (I + qv^t)^{-1} T^{-1} D \\
            &amp;= (I + qv^t)^{-1} Y \\
            &amp;= (I - \frac{1}{1 + v^tq} qv^t) Y \\
            &amp;= Y - \frac{1}{1 + v^tq} qv^tY

        Therefore, we must solve for :math:`q` and :math:`Y` in :math:`Tq = u` and :math:`TY = D`.
        As :math:`T` is now tridiagonal, we shall use Thomas' algorithm.

        Define:

        *   :math:`a = [a_0, \ a_1, \ ..., \ a_{N-2}]` as :math:`T`'s lower diagonal of :math:`N-1` elements,
            such that :math:`a_0 = a_1 = ... = a_{N-2} = 1`, so this diagonal is filled with ones;
        *   :math:`b = [b_0, \ b_1, \ ..., \ b_{N-2}, \ b_{N-1}]` as :math:`T`'s main diagonal of :math:`N` elements,
            such that :math:`b_0 = b_{N-1} = 3`, and :math:`b_1 = b_2 = ... = b_{N-2} = 4`;
        *   :math:`c = [c_0, \ c_1, \ ..., \ c_{N-2}]` as :math:`T`'s upper diagonal of :math:`N-1` elements,
            such that :math:`c_0 = c_1 = ... = c_{N-2} = 1`: this diagonal is also filled with ones.

        If, according to Thomas' algorithm, we define:

        .. math::
            c'_0 &amp;= \frac{c_0}{b_0} &amp; \\
            c'_i &amp;= \frac{c_i}{b_i - a_{i-1} c'_{i-1}}, &amp; \quad \forall i \in \{1, ..., N-2\} \\
            &amp; &amp; \\
            u'_0 &amp;= \frac{u_0}{b_0} &amp; \\
            u'_i &amp;= \frac{u_i - a_{i-1} u'_{i-1}}{b_i - a_{i-1} c'_{i-1}}, &amp; \quad \forall i \in \{1, ..., N-1\} \\
            &amp; &amp; \\
            D'_0 &amp;= \frac{1}{b_0} D_0 &amp; \\
            D'_i &amp;= \frac{1}{b_i - a_{i-1} c'_{i-1}} (D_i - a_{i-1} D'_{i-1}), &amp; \quad \forall i \in \{1, ..., N-1\}

        Then:

        .. math::
            c'_0     &amp;= \frac{1}{3} &amp; \\
            c'_i     &amp;= \frac{1}{4 - c'_{i-1}}, &amp; \quad \forall i \in \{1, ..., N-2\} \\
            &amp; &amp; \\
            u'_0     &amp;= \frac{1}{3} &amp; \\
            u'_i     &amp;= \frac{-u'_{i-1}}{4 - c'_{i-1}} = -c'_i u'_{i-1}, &amp; \quad \forall i \in \{1, ..., N-2\} \\
            u'_{N-1} &amp;= \frac{1 - u'_{N-2}}{3 - c'_{N-2}} &amp; \\
            &amp; &amp; \\
            D'_0     &amp;= \frac{1}{3} (4A_0 + 2A_1) &amp; \\
            D'_i     &amp;= \frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) &amp; \\
            &amp;= c_i (4A_i + 2A_{i+1} - D'_{i-1}), &amp; \quad \forall i \in \{1, ..., N-2\} \\
            D'_{N-1} &amp;= \frac{1}{3 - c'_{N-2}} (4A_{N-1} + 2A_N - D'_{N-2}) &amp;

        Finally, we can do Backward Substitution to find :math:`q` and :math:`Y`:

        .. math::
            q_{N-1} &amp;= u'_{N-1} &amp; \\
            q_i     &amp;= u'_{i} - c'_i q_{i+1}, &amp; \quad \forall i \in \{0, ..., N-2\} \\
            &amp; &amp; \\
            Y_{N-1} &amp;= D'_{N-1} &amp; \\
            Y_i     &amp;= D'_i - c'_i Y_{i+1},   &amp; \quad \forall i \in \{0, ..., N-2\}

        With those values, we can finally calculate :math:`H_1 = Y - \frac{1}{1 + v^tq} qv^tY`.
        Given that :math:`v_0 = v_{N-1} = 1`, and :math:`v_1 = v_2 = ... = v_{N-2} = 0`, its dot products
        with :math:`q` and :math:`Y` are respectively :math:`v^tq = q_0 + q_{N-1}` and
        :math:`v^tY = Y_0 + Y_{N-1}`. Thus:

        .. math::
            H_1 = Y - \frac{1}{1 + q_0 + q_{N-1}} q(Y_0 + Y_{N-1})

        Once we have :math:`H_1`, we can get :math:`H_2` (the array of second handles) as follows:

        .. math::
            H_{2, i}   &amp;= 2A_{i+1} - H_{1, i+1}, &amp; \quad \forall i \in \{0, ..., N-2\} \\
            H_{2, N-1} &amp;= 2A_0 - H_{1, 0} &amp;

        Because the matrix :math:`R` always follows the same pattern (and thus :math:`T, u, v` as well),
        we can define a memo list for :math:`c'` and :math:`u'` to avoid recalculation. We cannot
        memoize :math:`D` and :math:`Y`, however, because they are always different matrices. We
        cannot make a memo for :math:`q` either, but we can calculate it faster because :math:`u'`
        can be memoized.

    Parameters
    ----------
    anchors
        Anchors of a closed cubic spline.

    Returns
    -------
    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]
        A tuple of two arrays: one containing the 1st handle for every curve in
        the closed cubic spline, and the other containing the 2nd handles.
    """
    global CP_CLOSED_MEMO
    global UP_CLOSED_MEMO

    A = np.asarray(anchors)
    N = A.shape[0] - 1
    dim = A.shape[1]

    # Calculate cp (c prime) and up (u prime) with help from
    # CP_CLOSED_MEMO and UP_CLOSED_MEMO.
    len_memo = CP_CLOSED_MEMO.size
    if len_memo &lt; N - 1:
        cp = np.empty(N - 1)
        up = np.empty(N - 1)
        cp[:len_memo] = CP_CLOSED_MEMO
        up[:len_memo] = UP_CLOSED_MEMO
        # Forward Substitution 1
        # Calculate up (at the same time we calculate cp).
        for i in range(len_memo, N - 1):
            cp[i] = 1 / (4 - cp[i - 1])
            up[i] = -cp[i] * up[i - 1]
        CP_CLOSED_MEMO = cp
        UP_CLOSED_MEMO = up
    else:
        cp = CP_CLOSED_MEMO[: N - 1]
        up = UP_CLOSED_MEMO[: N - 1]

    # The last element of u' is different
    cp_last_division = 1 / (3 - cp[N - 2])
    up_last = cp_last_division * (1 - up[N - 2])

    # Backward Substitution 1
    # Calculate q.
    q = np.empty((N, dim))
    q[N - 1] = up_last
    for i in range(N - 2, -1, -1):
        q[i] = up[i] - cp[i] * q[i + 1]

    # Forward Substitution 2
    # Calculate Dp (D prime).
    Dp = np.empty((N, dim))
    AUX = 4 * A[:N] + 2 * A[1:]  # Vectorize the sum for efficiency.
    Dp[0] = AUX[0] / 3
    for i in range(1, N - 1):
        Dp[i] = cp[i] * (AUX[i] - Dp[i - 1])
    Dp[N - 1] = cp_last_division * (AUX[N - 1] - Dp[N - 2])

    # Backward Substitution
    # Calculate Y, which is defined as a view of Dp for efficiency
    # and semantic convenience at the same time.
    Y = Dp
    # Y[N-1] = Dp[N-1] (redundant)
    for i in range(N - 2, -1, -1):
        Y[i] = Dp[i] - cp[i] * Y[i + 1]

    # Calculate H1.
    H1 = Y - 1 / (1 + q[0] + q[N - 1]) * q * (Y[0] + Y[N - 1])

    # Calculate H2.
    H2 = np.empty((N, dim))
    H2[0 : N - 1] = 2 * A[1:N] - H1[1:N]
    H2[N - 1] = 2 * A[N] - H1[0]

    return H1, H2


</t>
<t tx="ekr.20250122151621.647">CP_OPEN_MEMO = np.array([0.5])


def get_smooth_open_cubic_bezier_handle_points(
    anchors: Point3DLike_Array,
) -&gt; tuple[Point3D_Array, Point3D_Array]:
    r"""Special case of :func:`get_smooth_cubic_bezier_handle_points`,
    when the ``anchors`` do not form a closed loop.

    .. note::
        A system of equations must be solved to get the first handles of
        every Bèzier curve (referred to as :math:`H_1`).
        Then :math:`H_2` (the second handles) can be obtained separately.

        .. seealso::
            The equations were obtained from:

            * `Smooth Bézier Spline Through Prescribed Points. (2012). Particle in Cell Consulting LLC. &lt;https://www.particleincell.com/2012/bezier-splines/&gt;`_
            * `Conditions on control points for continuous curvature. (2016). Jaco Stuifbergen. &lt;http://www.jacos.nl/jacos_html/spline/theory/theory_2.html&gt;`_

        .. warning::
            The equations in the first webpage have some typos which were corrected in the comments.

        In general, if there are :math:`N+1` anchors, there will be :math:`N` Bézier curves
        and thus :math:`N` pairs of handles to find. We must solve the following
        system of equations for the 1st handles (example for :math:`N = 5`):

        .. math::
            \begin{pmatrix}
                2 &amp; 1 &amp; 0 &amp; 0 &amp; 0 \\
                1 &amp; 4 &amp; 1 &amp; 0 &amp; 0 \\
                0 &amp; 1 &amp; 4 &amp; 1 &amp; 0 \\
                0 &amp; 0 &amp; 1 &amp; 4 &amp; 1 \\
                0 &amp; 0 &amp; 0 &amp; 2 &amp; 7
            \end{pmatrix}
            \begin{pmatrix}
                H_{1,0} \\
                H_{1,1} \\
                H_{1,2} \\
                H_{1,3} \\
                H_{1,4}
            \end{pmatrix}
            =
            \begin{pmatrix}
                A_0 + 2A_1 \\
                4A_1 + 2A_2 \\
                4A_2 + 2A_3 \\
                4A_3 + 2A_4 \\
                8A_4 + A_5
            \end{pmatrix}

        which will be expressed as :math:`TH_1 = D`.
        :math:`T` is a tridiagonal matrix, so the system can be solved in :math:`O(N)`
        operations. Here we shall use Thomas' algorithm or the tridiagonal matrix
        algorithm.

        .. seealso::
            `Tridiagonal matrix algorithm. Wikipedia. &lt;https://en.wikipedia.org/wiki/Tridiagonal_matrix_algorithm&gt;`_

        Define:

        *   :math:`a = [a_0, \ a_1, \ ..., \ a_{N-2}]` as :math:`T`'s lower diagonal of :math:`N-1` elements,
            such that :math:`a_0 = a_1 = ... = a_{N-3} = 1`, and :math:`a_{N-2} = 2`;
        *   :math:`b = [b_0, \ b_1, \ ..., \ b_{N-2}, \ b_{N-1}]` as :math:`T`'s main diagonal of :math:`N` elements,
            such that :math:`b_0 = 2`, :math:`b_1 = b_2 = ... = b_{N-2} = 4`, and :math:`b_{N-1} = 7`;
        *   :math:`c = [c_0, \ c_1, \ ..., \ c_{N-2}]` as :math:`T`'s upper diagonal of :math:`{N-1}` elements,
            such that :math:`c_0 = c_1 = ... = c_{N-2} = 1`: this diagonal is filled with ones.

        If, according to Thomas' algorithm, we define:

        .. math::
            c'_0 &amp;= \frac{c_0}{b_0} &amp; \\
            c'_i &amp;= \frac{c_i}{b_i - a_{i-1} c'_{i-1}}, &amp; \quad \forall i \in \{1, ..., N-2\} \\
            &amp; &amp; \\
            D'_0 &amp;= \frac{1}{b_0} D_0 &amp; \\
            D'_i &amp;= \frac{1}{b_i - a_{i-1} c'{i-1}} (D_i - a_{i-1} D'_{i-1}), &amp; \quad \forall i \in \{1, ..., N-1\}

        Then:

        .. math::
            c'_0     &amp;= 0.5 &amp; \\
            c'_i     &amp;= \frac{1}{4 - c'_{i-1}}, &amp; \quad \forall i \in \{1, ..., N-2\} \\
            &amp; &amp; \\
            D'_0     &amp;= 0.5A_0 + A_1 &amp; \\
            D'_i     &amp;= \frac{1}{4 - c'_{i-1}} (4A_i + 2A_{i+1} - D'_{i-1}) &amp; \\
            &amp;= c_i (4A_i + 2A_{i+1} - D'_{i-1}), &amp; \quad \forall i \in \{1, ..., N-2\} \\
            D'_{N-1} &amp;= \frac{1}{7 - 2c'_{N-2}} (8A_{N-1} + A_N - 2D'_{N-2}) &amp;

        Finally, we can do Backward Substitution to find :math:`H_1`:

        .. math::
            H_{1, N-1} &amp;= D'_{N-1} &amp; \\
            H_{1, i}   &amp;= D'_i - c'_i H_{1, i+1}, &amp; \quad \forall i \in \{0, ..., N-2\}

        Once we have :math:`H_1`, we can get :math:`H_2` (the array of second handles) as follows:

        .. math::
            H_{2, i}   &amp;= 2A_{i+1} - H_{1, i+1}, &amp; \quad \forall i \in \{0, ..., N-2\} \\
            H_{2, N-1} &amp;= 0.5A_N   + 0.5H_{1, N-1} &amp;

        As the matrix :math:`T` always follows the same pattern, we can define a memo list
        for :math:`c'` to avoid recalculation. We cannot do the same for :math:`D`, however,
        because it is always a different matrix.

    Parameters
    ----------
    anchors
        Anchors of an open cubic spline.

    Returns
    -------
    :class:`tuple` [:class:`~.Point3D_Array`, :class:`~.Point3D_Array`]
        A tuple of two arrays: one containing the 1st handle for every curve in
        the open cubic spline, and the other containing the 2nd handles.
    """
    global CP_OPEN_MEMO

    A = np.asarray(anchors)
    N = A.shape[0] - 1
    dim = A.shape[1]

    # Calculate cp (c prime) with help from CP_OPEN_MEMO.
    len_memo = CP_OPEN_MEMO.size
    if len_memo &lt; N - 1:
        cp = np.empty(N - 1)
        cp[:len_memo] = CP_OPEN_MEMO
        for i in range(len_memo, N - 1):
            cp[i] = 1 / (4 - cp[i - 1])
        CP_OPEN_MEMO = cp
    else:
        cp = CP_OPEN_MEMO[: N - 1]

    # Calculate Dp (D prime).
    Dp = np.empty((N, dim))
    Dp[0] = 0.5 * A[0] + A[1]
    AUX = 4 * A[1 : N - 1] + 2 * A[2:N]  # Vectorize the sum for efficiency.
    for i in range(1, N - 1):
        Dp[i] = cp[i] * (AUX[i - 1] - Dp[i - 1])
    Dp[N - 1] = (1 / (7 - 2 * cp[N - 2])) * (8 * A[N - 1] + A[N] - 2 * Dp[N - 2])

    # Backward Substitution.
    # H1 (array of the first handles) is defined as a view of Dp for efficiency
    # and semantic convenience at the same time.
    H1 = Dp
    # H1[N-1] = Dp[N-1] (redundant)
    for i in range(N - 2, -1, -1):
        H1[i] = Dp[i] - cp[i] * H1[i + 1]

    # Calculate H2.
    H2 = np.empty((N, dim))
    H2[0 : N - 1] = 2 * A[1:N] - H1[1:N]
    H2[N - 1] = 0.5 * (A[N] + H1[N - 1])

    return H1, H2


</t>
<t tx="ekr.20250122151621.648">@overload
def get_quadratic_approximation_of_cubic(
    a0: Point3DLike, h0: Point3DLike, h1: Point3DLike, a1: Point3DLike
) -&gt; QuadraticSpline: ...


</t>
<t tx="ekr.20250122151621.649">@overload
def get_quadratic_approximation_of_cubic(
    a0: Point3DLike_Array,
    h0: Point3DLike_Array,
    h1: Point3DLike_Array,
    a1: Point3DLike_Array,
) -&gt; QuadraticBezierPath: ...


</t>
<t tx="ekr.20250122151621.65">def add_bases(self) -&gt; None:
    """Adds the end caps of the cylinder."""
    if config.renderer == RendererType.OPENGL:
        color = self.color
        opacity = self.opacity
    elif config.renderer == RendererType.CAIRO:
        color = self.fill_color
        opacity = self.fill_opacity

    self.base_top = Circle(
        radius=self.radius,
        color=color,
        fill_opacity=opacity,
        shade_in_3d=True,
        stroke_width=0,
    )
    self.base_top.shift(self.u_range[1] * IN)
    self.base_bottom = Circle(
        radius=self.radius,
        color=color,
        fill_opacity=opacity,
        shade_in_3d=True,
        stroke_width=0,
    )
    self.base_bottom.shift(self.u_range[0] * IN)
    self.add(self.base_top, self.base_bottom)

</t>
<t tx="ekr.20250122151621.650">def get_quadratic_approximation_of_cubic(
    a0: Point3D | Point3D_Array,
    h0: Point3D | Point3D_Array,
    h1: Point3D | Point3D_Array,
    a1: Point3D | Point3D_Array,
) -&gt; QuadraticSpline | QuadraticBezierPath:
    r"""If ``a0``, ``h0``, ``h1`` and ``a1`` are the control points of a cubic
    Bézier curve, approximate the curve with two quadratic Bézier curves and
    return an array of 6 points, where the first 3 points represent the first
    quadratic curve and the last 3 represent the second one.

    Otherwise, if ``a0``, ``h0``, ``h1`` and ``a1`` are _arrays_ of :math:`N`
    points representing :math:`N` cubic Bézier curves, return an array of
    :math:`6N` points where each group of :math:`6` consecutive points
    approximates each of the :math:`N` curves in a similar way as above.

    .. note::
        If the cubic spline given by the original cubic Bézier curves is
        smooth, this algorithm will generate a quadratic spline which is also
        smooth.

        If a cubic Bézier is given by

        .. math::
            C(t) = (1-t)^3 A_0 + 3(1-t)^2 t H_0 + 3(1-t)t^2 H_1 + t^3 A_1

        where :math:`A_0`, :math:`H_0`, :math:`H_1` and :math:`A_1` are its
        control points, then this algorithm should generate two quadratic
        Béziers given by

        .. math::
            Q_0(t) &amp;= (1-t)^2 A_0 + 2(1-t)t M_0 + t^2 K \\
            Q_1(t) &amp;= (1-t)^2 K + 2(1-t)t M_1 + t^2 A_1

        where :math:`M_0` and :math:`M_1` are the respective handles to be
        found for both curves, and :math:`K` is the end anchor of the 1st curve
        and the start anchor of the 2nd, which must also be found.

        To solve for :math:`M_0`, :math:`M_1` and :math:`K`, three conditions
        can be imposed:

        1.  :math:`Q_0'(0) = \frac{1}{2}C'(0)`. The derivative of the first
            quadratic curve at :math:`t = 0` should be proportional to that of
            the original cubic curve, also at :math:`t = 0`. Because the cubic
            curve is split into two parts, it is necessary to divide this by
            two: the speed of a point travelling through the curve should be
            half of the original. This gives:

            .. math::
                Q_0'(0) &amp;= \frac{1}{2}C'(0) \\
                2(M_0 - A_0) &amp;= \frac{3}{2}(H_0 - A_0) \\
                2M_0 - 2A_0 &amp;= \frac{3}{2}H_0 - \frac{3}{2}A_0 \\
                2M_0 &amp;= \frac{3}{2}H_0 + \frac{1}{2}A_0 \\
                M_0 &amp;= \frac{1}{4}(3H_0 + A_0)

        2.  :math:`Q_1'(1) = \frac{1}{2}C'(1)`. The derivative of the second
            quadratic curve at :math:`t = 1` should be half of that of the
            original cubic curve for the same reasons as above, also at
            :math:`t = 1`. This gives:

            .. math::
                Q_1'(1) &amp;= \frac{1}{2}C'(1) \\
                2(A_1 - M_1) &amp;= \frac{3}{2}(A_1 - H_1) \\
                2A_1 - 2M_1 &amp;= \frac{3}{2}A_1 - \frac{3}{2}H_1 \\
                -2M_1 &amp;= -\frac{1}{2}A_1 - \frac{3}{2}H_1 \\
                M_1 &amp;= \frac{1}{4}(3H_1 + A_1)

        3.  :math:`Q_0'(1) = Q_1'(0)`. The derivatives of both quadratic curves
            should match at the point :math:`K`, in order for the final spline
            to be smooth. This gives:

            .. math::
                Q_0'(1) &amp;= Q_1'(0) \\
                2(K - M_0) &amp;= 2(M_1 - K) \\
                2K - 2M_0 &amp;= 2M_1 - 2K \\
                4K &amp;= 2M_0 + 2M_1 \\
                K &amp;= \frac{1}{2}(M_0 + M_1)

        This is sufficient to find proper control points for the quadratic
        Bézier curves.

    Parameters
    ----------
    a0
        The start anchor of a single cubic Bézier curve, or an array of
        :math:`N` start anchors for :math:`N` curves.
    h0
        The first handle of a single cubic Bézier curve, or an array of
        :math:`N` first handles for :math:`N` curves.
    h1
        The second handle of a single cubic Bézier curve, or an array of
        :math:`N` second handles for :math:`N` curves.
    a1
        The end anchor of a single cubic Bézier curve, or an array of
        :math:`N` end anchors for :math:`N` curves.

    Returns
    -------
    result
        An array containing either 6 points for 2 quadratic Bézier curves
        approximating the original cubic curve, or :math:`6N` points for
        :math:`2N` quadratic curves approximating :math:`N` cubic curves.

    Raises
    ------
    ValueError
        If ``a0``, ``h0``, ``h1`` and ``a1`` have different dimensions, or
        if their number of dimensions is not 1 or 2.
    """
    a0c = np.asarray(a0)
    h0c = np.asarray(h0)
    h1c = np.asarray(h1)
    a1c = np.asarray(a1)

    if all(arr.ndim == 1 for arr in (a0c, h0c, h1c, a1c)):
        num_curves, dim = 1, a0c.shape[0]
    elif all(arr.ndim == 2 for arr in (a0c, h0c, h1c, a1c)):
        num_curves, dim = a0c.shape
    else:
        raise ValueError("All arguments must be Point3D or Point3D_Array.")

    m0 = 0.25 * (3 * h0c + a0c)
    m1 = 0.25 * (3 * h1c + a1c)
    k = 0.5 * (m0 + m1)

    result = np.empty((6 * num_curves, dim))
    result[0::6] = a0c
    result[1::6] = m0
    result[2::6] = k
    result[3::6] = k
    result[4::6] = m1
    result[5::6] = a1c
    return result


</t>
<t tx="ekr.20250122151621.651">def is_closed(points: Point3D_Array) -&gt; bool:
    """Returns ``True`` if the spline given by ``points`` is closed, by
    checking if its first and last points are close to each other, or``False``
    otherwise.

    .. note::

        This function reimplements :meth:`np.allclose`, because repeated
        calling of :meth:`np.allclose` for only 2 points is inefficient.

    Parameters
    ----------
    points
        An array of points defining a spline.

    Returns
    -------
    :class:`bool`
        Whether the first and last points of the array are close enough or not
        to be considered the same, thus considering the defined spline as
        closed.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; from manim import is_closed
        &gt;&gt;&gt; is_closed(
        ...     np.array(
        ...         [
        ...             [0, 0, 0],
        ...             [1, 2, 3],
        ...             [3, 2, 1],
        ...             [0, 0, 0],
        ...         ]
        ...     )
        ... )
        True
        &gt;&gt;&gt; is_closed(
        ...     np.array(
        ...         [
        ...             [0, 0, 0],
        ...             [1, 2, 3],
        ...             [3, 2, 1],
        ...             [1e-10, 1e-10, 1e-10],
        ...         ]
        ...     )
        ... )
        True
        &gt;&gt;&gt; is_closed(
        ...     np.array(
        ...         [
        ...             [0, 0, 0],
        ...             [1, 2, 3],
        ...             [3, 2, 1],
        ...             [1e-2, 1e-2, 1e-2],
        ...         ]
        ...     )
        ... )
        False
    """
    start, end = points[0], points[-1]
    rtol = 1e-5
    atol = 1e-8
    tolerance = atol + rtol * start
    if abs(end[0] - start[0]) &gt; tolerance[0]:
        return False
    if abs(end[1] - start[1]) &gt; tolerance[1]:
        return False
    return bool(abs(end[2] - start[2]) &lt;= tolerance[2])


</t>
<t tx="ekr.20250122151621.652">def proportions_along_bezier_curve_for_point(
    point: Point3DLike,
    control_points: BezierPointsLike,
    round_to: float = 1e-6,
) -&gt; MatrixMN:
    """Obtains the proportion along the bezier curve corresponding to a given point
    given the bezier curve's control points.

    The bezier polynomial is constructed using the coordinates of the given point
    as well as the bezier curve's control points. On solving the polynomial for each dimension,
    if there are roots common to every dimension, those roots give the proportion along the
    curve the point is at. If there are no real roots, the point does not lie on the curve.

    Parameters
    ----------
    point
        The Cartesian Coordinates of the point whose parameter
        should be obtained.
    control_points
        The Cartesian Coordinates of the ordered control
        points of the bezier curve on which the point may
        or may not lie.
    round_to
        A float whose number of decimal places all values
        such as coordinates of points will be rounded.

    Returns
    -------
        np.ndarray[float]
            List containing possible parameters (the proportions along the bezier curve)
            for the given point on the given bezier curve.
            This usually only contains one or zero elements, but if the
            point is, say, at the beginning/end of a closed loop, may return
            a list with more than 1 value, corresponding to the beginning and
            end etc. of the loop.

    Raises
    ------
    :class:`ValueError`
        When ``point`` and the control points have different shapes.
    """
    # Method taken from
    # http://polymathprogrammer.com/2012/04/03/does-point-lie-on-bezier-curve/

    if not all(np.shape(point) == np.shape(c_p) for c_p in control_points):
        raise ValueError(
            f"Point {point} and Control Points {control_points} have different shapes.",
        )

    control_points = np.array(control_points)
    n = len(control_points) - 1

    roots = []
    for dim, coord in enumerate(point):
        control_coords = control_points[:, dim]
        terms = []
        for term_power in range(n, -1, -1):
            outercoeff = choose(n, term_power)
            term = []
            sign = 1
            for subterm_num in range(term_power, -1, -1):
                innercoeff = choose(term_power, subterm_num) * sign
                subterm = innercoeff * control_coords[subterm_num]
                if term_power == 0:
                    subterm -= coord
                term.append(subterm)
                sign *= -1
            terms.append(outercoeff * sum(np.array(term)))
        if all(term == 0 for term in terms):
            # Then both Bezier curve and Point lie on the same plane.
            # Roots will be none, but in this specific instance, we don't need to consider that.
            continue
        bezier_polynom = np.polynomial.Polynomial(terms[::-1])
        polynom_roots = bezier_polynom.roots()
        if len(polynom_roots) &gt; 0:
            polynom_roots = np.around(polynom_roots, int(np.log10(1 / round_to)))
        roots.append(polynom_roots)

    roots = [[root for root in rootlist if root.imag == 0] for rootlist in roots]
    # Get common roots
    # arg-type: ignore
    roots = reduce(np.intersect1d, roots)
    result = np.asarray([r.real for r in roots if 0 &lt;= r.real &lt;= 1])
    return result


</t>
<t tx="ekr.20250122151621.653">def point_lies_on_bezier(
    point: Point3DLike,
    control_points: BezierPointsLike,
    round_to: float = 1e-6,
) -&gt; bool:
    """Checks if a given point lies on the bezier curves with the given control points.

    This is done by solving the bezier polynomial with the point as the constant term; if
    any real roots exist, the point lies on the bezier curve.

    Parameters
    ----------
    point
        The Cartesian Coordinates of the point to check.
    control_points
        The Cartesian Coordinates of the ordered control
        points of the bezier curve on which the point may
        or may not lie.
    round_to
        A float whose number of decimal places all values
        such as coordinates of points will be rounded.

    Returns
    -------
    bool
        Whether the point lies on the curve.
    """
    roots = proportions_along_bezier_curve_for_point(point, control_points, round_to)

    return len(roots) &gt; 0
</t>
<t tx="ekr.20250122151621.654">from __future__ import annotations

from typing import TYPE_CHECKING, Callable

from .. import config, logger
from ..utils.hashing import get_hash_from_play_call

__all__ = ["handle_caching_play"]

if TYPE_CHECKING:
    from typing import Any

    from manim.renderer.opengl_renderer import OpenGLRenderer
    from manim.scene.scene import Scene


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.655">def handle_caching_play(func: Callable[..., None]) -&gt; Callable[..., None]:
    """Decorator that returns a wrapped version of func that will compute
    the hash of the play invocation.

    The returned function will act according to the computed hash: either skip
    the animation because it's already cached, or let the invoked function
    play normally.

    Parameters
    ----------
    func
        The play like function that has to be written to the video file stream.
        Take the same parameters as `scene.play`.
    """
    # NOTE : This is only kept for OpenGL renderer.
    # The play logic of the cairo renderer as been refactored and does not need this function anymore.
    # When OpenGL renderer will have a proper testing system,
    # the play logic of the latter has to be refactored in the same way the cairo renderer has been, and thus this
    # method has to be deleted.

    def wrapper(self: OpenGLRenderer, scene: Scene, *args: Any, **kwargs: Any) -&gt; None:
        self.skip_animations = self._original_skipping_status
        self.update_skipping_status()
        animations = scene.compile_animations(*args, **kwargs)
        scene.add_mobjects_from_animations(animations)
        if self.skip_animations:
            logger.debug(f"Skipping animation {self.num_plays}")
            func(self, scene, *args, **kwargs)
            # If the animation is skipped, we mark its hash as None.
            # When sceneFileWriter will start combining partial movie files, it won't take into account None hashes.
            self.animations_hashes.append(None)
            self.file_writer.add_partial_movie_file(None)
            return
        if not config["disable_caching"]:
            mobjects_on_scene = scene.mobjects
            # TODO: the first argument seems wrong. Shouldn't it be scene instead?
            hash_play = get_hash_from_play_call(
                self,  # type: ignore[arg-type]
                self.camera,
                animations,
                mobjects_on_scene,
            )
            if self.file_writer.is_already_cached(hash_play):
                logger.info(
                    f"Animation {self.num_plays} : Using cached data (hash : %(hash_play)s)",
                    {"hash_play": hash_play},
                )
                self.skip_animations = True
        else:
            hash_play = f"uncached_{self.num_plays:05}"
        self.animations_hashes.append(hash_play)
        self.file_writer.add_partial_movie_file(hash_play)
        logger.debug(
            "List of the first few animation hashes of the scene: %(h)s",
            {"h": str(self.animations_hashes[:5])},
        )
        func(self, scene, *args, **kwargs)

    return wrapper
</t>
<t tx="ekr.20250122151621.656">from __future__ import annotations

import os
from collections.abc import Generator
from pathlib import Path
from subprocess import run
from typing import TypedDict

import av

from manim.typing import StrOrBytesPath

__all__ = [
    "capture",
    "get_video_metadata",
    "get_dir_layout",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.657">def capture(
    command: str, cwd: StrOrBytesPath | None = None, command_input: str | None = None
) -&gt; tuple[str, str, int]:
    p = run(
        command,
        cwd=cwd,
        input=command_input,
        capture_output=True,
        text=True,
        encoding="utf-8",
    )
    out, err = p.stdout, p.stderr
    return out, err, p.returncode


</t>
<t tx="ekr.20250122151621.658">class VideoMetadata(TypedDict):
    width: int
    height: int
    nb_frames: str
    duration: str
    avg_frame_rate: str
    codec_name: str
    pix_fmt: str


</t>
<t tx="ekr.20250122151621.659">def get_video_metadata(path_to_video: str | os.PathLike) -&gt; VideoMetadata:
    with av.open(str(path_to_video)) as container:
        stream = container.streams.video[0]
        ctxt = stream.codec_context
        rate = stream.average_rate
        if stream.duration is not None:
            duration = float(stream.duration * stream.time_base)
            num_frames = stream.frames
        else:
            num_frames = sum(1 for _ in container.decode(video=0))
            duration = float(num_frames / stream.base_rate)

        return {
            "width": ctxt.width,
            "height": ctxt.height,
            "nb_frames": str(num_frames),
            "duration": f"{duration:.6f}",
            "avg_frame_rate": f"{rate.numerator}/{rate.denominator}",  # Can be a Fraction
            "codec_name": stream.codec_context.name,
            "pix_fmt": stream.codec_context.pix_fmt,
        }


</t>
<t tx="ekr.20250122151621.66">def _rotate_to_direction(self) -&gt; None:
    x, y, z = self.direction

    r = np.sqrt(x**2 + y**2 + z**2)
    theta = np.arccos(z / r) if r &gt; 0 else 0

    if x == 0:
        if y == 0:  # along the z axis
            phi = 0
        else:  # along the x axis
            phi = np.arctan(np.inf)
            if y &lt; 0:
                phi += PI
    else:
        phi = np.arctan(y / x)
    if x &lt; 0:
        phi += PI

    # undo old rotation (in reverse direction)
    self.rotate(-self._current_phi, Z_AXIS, about_point=ORIGIN)
    self.rotate(-self._current_theta, Y_AXIS, about_point=ORIGIN)

    # do new rotation
    self.rotate(theta, Y_AXIS, about_point=ORIGIN)
    self.rotate(phi, Z_AXIS, about_point=ORIGIN)

    # store new values
    self._current_theta = theta
    self._current_phi = phi

</t>
<t tx="ekr.20250122151621.660">def get_dir_layout(dirpath: Path) -&gt; Generator[str, None, None]:
    """Get list of paths relative to dirpath of all files in dir and subdirs recursively."""
    for p in dirpath.iterdir():
        if p.is_dir():
            yield from get_dir_layout(p)
            continue
        yield str(p.relative_to(dirpath))
</t>
<t tx="ekr.20250122151621.661">"""Utilities that might be useful for configuration dictionaries."""

from __future__ import annotations

__all__ = [
    "merge_dicts_recursively",
    "update_dict_recursively",
    "DictAsObject",
]


import itertools as it
from typing import Any

import numpy.typing as npt


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.662">def merge_dicts_recursively(*dicts: dict[Any, Any]) -&gt; dict[Any, Any]:
    """
    Creates a dict whose keyset is the union of all the
    input dictionaries.  The value for each key is based
    on the first dict in the list with that key.

    dicts later in the list have higher priority

    When values are dictionaries, it is applied recursively
    """
    result: dict = {}
    all_items = it.chain(*(d.items() for d in dicts))
    for key, value in all_items:
        if key in result and isinstance(result[key], dict) and isinstance(value, dict):
            result[key] = merge_dicts_recursively(result[key], value)
        else:
            result[key] = value
    return result


</t>
<t tx="ekr.20250122151621.663">def update_dict_recursively(
    current_dict: dict[Any, Any], *others: dict[Any, Any]
) -&gt; None:
    updated_dict = merge_dicts_recursively(current_dict, *others)
    current_dict.update(updated_dict)


</t>
<t tx="ekr.20250122151621.664"># Occasionally convenient in order to write dict.x instead of more laborious
# (and less in keeping with all other attr accesses) dict["x"]


class DictAsObject:
    @others
</t>
<t tx="ekr.20250122151621.665">class _Data:
    """Descriptor that allows _Data variables to be grouped and accessed from self.data["attr"] via self.attr.
    self.data attributes must be arrays.
    """

    @others
</t>
<t tx="ekr.20250122151621.666">class _Uniforms:
    """Descriptor that allows _Uniforms variables to be grouped from self.uniforms["attr"] via self.attr.
    self.uniforms attributes must be floats.
    """

    @others
</t>
<t tx="ekr.20250122151621.667">def __init__(self, dictin: dict[str, Any]):
    self.__dict__ = dictin


</t>
<t tx="ekr.20250122151621.668">def __set_name__(self, obj: Any, name: str) -&gt; None:
    self.name = name

</t>
<t tx="ekr.20250122151621.669">def __get__(self, obj: Any, owner: Any) -&gt; npt.NDArray[Any]:
    value: npt.NDArray[Any] = obj.data[self.name]
    return value

</t>
<t tx="ekr.20250122151621.67">def set_direction(self, direction: np.ndarray) -&gt; None:
    """Sets the direction of the central axis of the :class:`Cylinder`.

    Parameters
    ----------
    direction : :class:`numpy.array`
        The direction of the central axis of the :class:`Cylinder`.
    """
    # if get_norm(direction) is get_norm(self.direction):
    #     pass
    self.direction = direction
    self._rotate_to_direction()

</t>
<t tx="ekr.20250122151621.670">def __set__(self, obj: Any, array: npt.NDArray[Any]) -&gt; None:
    obj.data[self.name] = array


</t>
<t tx="ekr.20250122151621.671">def __set_name__(self, obj: Any, name: str) -&gt; None:
    self.name = name

</t>
<t tx="ekr.20250122151621.672">def __get__(self, obj: Any, owner: Any) -&gt; float:
    val: float = obj.__dict__["uniforms"][self.name]
    return val

</t>
<t tx="ekr.20250122151621.673">def __set__(self, obj: Any, num: float) -&gt; None:
    obj.__dict__["uniforms"][self.name] = num
</t>
<t tx="ekr.20250122151621.674">"""Debugging utilities."""

from __future__ import annotations

__all__ = ["print_family", "index_labels"]


from typing import Any

from manim.mobject.mobject import Mobject
from manim.mobject.text.numbers import Integer
from manim.utils.color import ManimColor

from ..mobject.types.vectorized_mobject import VGroup
from .color import BLACK


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.675">def print_family(mobject: Mobject, n_tabs: int = 0) -&gt; None:
    """For debugging purposes"""
    print("\t" * n_tabs, mobject, id(mobject))
    for submob in mobject.submobjects:
        print_family(submob, n_tabs + 1)


</t>
<t tx="ekr.20250122151621.676">def index_labels(
    mobject: Mobject,
    label_height: float = 0.15,
    background_stroke_width: float = 5,
    background_stroke_color: ManimColor = BLACK,
    **kwargs: Any,
) -&gt; VGroup:
    r"""Returns a :class:`~.VGroup` of :class:`~.Integer` mobjects
    that shows the index of each submobject.

    Useful for working with parts of complicated mobjects.

    Parameters
    ----------
    mobject
        The mobject that will have its submobjects labelled.
    label_height
        The height of the labels, by default 0.15.
    background_stroke_width
        The stroke width of the outline of the labels, by default 5.
    background_stroke_color
        The stroke color of the outline of labels.
    kwargs
        Additional parameters to be passed into the :class`~.Integer`
        mobjects used to construct the labels.

    Examples
    --------
    .. manim:: IndexLabelsExample
        :save_last_frame:

        class IndexLabelsExample(Scene):
            def construct(self):
                text = MathTex(
                    "\\frac{d}{dx}f(x)g(x)=",
                    "f(x)\\frac{d}{dx}g(x)",
                    "+",
                    "g(x)\\frac{d}{dx}f(x)",
                )

                #index the fist term in the MathTex mob
                indices = index_labels(text[0])

                text[0][1].set_color(PURPLE_B)
                text[0][8:12].set_color(DARK_BLUE)

                self.add(text, indices)
    """
    labels = VGroup()
    for n, submob in enumerate(mobject):
        label = Integer(n, **kwargs)
        label.set_stroke(
            background_stroke_color, background_stroke_width, background=True
        )
        label.height = label_height
        label.move_to(submob)
        labels.add(label)
    return labels
</t>
<t tx="ekr.20250122151621.677">"""Decorators for deprecating classes, functions and function parameters."""

from __future__ import annotations

__all__ = ["deprecated", "deprecated_params"]


import inspect
import logging
import re
from collections.abc import Iterable
from typing import Any, Callable, TypeVar, overload

from decorator import decorate, decorator

logger = logging.getLogger("manim")


@others
    return decorator(deprecate_params)  # type: ignore[return-value]
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.678">def _get_callable_info(callable_: Callable[..., Any], /) -&gt; tuple[str, str]:
    """Returns type and name of a callable.

    Parameters
    ----------
    callable
        The callable

    Returns
    -------
    Tuple[str, str]
        The type and name of the callable. Type can can be one of "class", "method" (for
        functions defined in classes) or "function"). For methods, name is Class.method.
    """
    what = type(callable_).__name__
    name = callable_.__qualname__
    if what == "function" and "." in name:
        what = "method"
    elif what != "function":
        what = "class"
    return (what, name)


</t>
<t tx="ekr.20250122151621.679">def _deprecation_text_component(
    since: str | None = None,
    until: str | None = None,
    message: str | None = None,
) -&gt; str:
    """Generates a text component used in deprecation messages.

    Parameters
    ----------
    since
        The version or date since deprecation
    until
        The version or date until removal of the deprecated callable
    message
        The reason for why the callable has been deprecated

    Returns
    -------
    str
        The deprecation message text component.
    """
    since = f"since {since} " if since else ""
    until = (
        f"is expected to be removed after {until}"
        if until
        else "may be removed in a later version"
    )
    msg = " " + message if message else ""
    return f"deprecated {since}and {until}.{msg}"


</t>
<t tx="ekr.20250122151621.68">def get_direction(self) -&gt; np.ndarray:
    """Returns the direction of the central axis of the :class:`Cylinder`.

    Returns
    -------
    direction : :class:`numpy.array`
        The direction of the central axis of the :class:`Cylinder`.
    """
    return self.direction


</t>
<t tx="ekr.20250122151621.680"># TODO: Use ParamSpec to type decorated functions when Python 3.9 is out of life
T = TypeVar("T")


@overload
def deprecated(
    func: Callable[..., T],
    since: str | None = None,
    until: str | None = None,
    replacement: str | None = None,
    message: str | None = "",
) -&gt; Callable[..., T]: ...


</t>
<t tx="ekr.20250122151621.681">@overload
def deprecated(
    func: None = None,
    since: str | None = None,
    until: str | None = None,
    replacement: str | None = None,
    message: str | None = "",
) -&gt; Callable[[Callable[..., T]], Callable[..., T]]: ...


</t>
<t tx="ekr.20250122151621.682">def deprecated(
    func: Callable[..., T] | None = None,
    since: str | None = None,
    until: str | None = None,
    replacement: str | None = None,
    message: str | None = "",
) -&gt; Callable[..., T] | Callable[[Callable[..., T]], Callable[..., T]]:
    """Decorator to mark a callable as deprecated.

    The decorated callable will cause a warning when used. The docstring of the
    deprecated callable is adjusted to indicate that this callable is deprecated.

    Parameters
    ----------
    func
        The function to be decorated. Should not be set by the user.
    since
        The version or date since deprecation.
    until
        The version or date until removal of the deprecated callable.
    replacement
        The identifier of the callable replacing the deprecated one.
    message
        The reason for why the callable has been deprecated.

    Returns
    -------
    Callable
        The decorated callable.

    Examples
    --------
    Basic usage::

        from manim.utils.deprecation import deprecated


        @deprecated
        def foo(**kwargs):
            pass


        @deprecated
        class Bar:
            def __init__(self):
                pass

            @deprecated
            def baz(self):
                pass


        foo()
        # WARNING  The function foo has been deprecated and may be removed in a later version.

        a = Bar()
        # WARNING  The class Bar has been deprecated and may be removed in a later version.

        a.baz()
        # WARNING  The method Bar.baz has been deprecated and may be removed in a later version.

    You can specify additional information for a more precise warning::

        from manim.utils.deprecation import deprecated


        @deprecated(
            since="v0.2", until="v0.4", replacement="bar", message="It is cooler."
        )
        def foo():
            pass


        foo()
        # WARNING  The function foo has been deprecated since v0.2 and is expected to be removed after v0.4. Use bar instead. It is cooler.

    You may also use dates instead of versions::

        from manim.utils.deprecation import deprecated


        @deprecated(since="05/01/2021", until="06/01/2021")
        def foo():
            pass


        foo()
        # WARNING  The function foo has been deprecated since 05/01/2021 and is expected to be removed after 06/01/2021.

    """
    # If used as factory:
    if func is None:
        return lambda func: deprecated(func, since, until, replacement, message)

    what, name = _get_callable_info(func)

    def warning_msg(for_docs: bool = False) -&gt; str:
        """Generate the deprecation warning message.

        Parameters
        ----------
        for_docs
            Whether or not to format the message for use in documentation.

        Returns
        -------
        str
            The deprecation message.
        """
        msg = message
        if replacement is not None:
            repl = replacement
            if for_docs:
                mapper = {"class": "class", "method": "meth", "function": "func"}
                repl = f":{mapper[what]}:`~.{replacement}`"
            msg = f"Use {repl} instead.{' ' + message if message else ''}"
        deprecated = _deprecation_text_component(since, until, msg)
        return f"The {what} {name} has been {deprecated}"

    def deprecate_docs(func: Callable) -&gt; None:
        """Adjust docstring to indicate the deprecation.

        Parameters
        ----------
        func
            The callable whose docstring to adjust.
        """
        warning = warning_msg(True)
        doc_string = func.__doc__ or ""
        func.__doc__ = f"{doc_string}\n\n.. attention:: Deprecated\n  {warning}"

    def deprecate(func: Callable[..., T], *args: Any, **kwargs: Any) -&gt; T:
        """The actual decorator used to extend the callables behavior.

        Logs a warning message.

        Parameters
        ----------
        func
            The callable to decorate.
        args
            The arguments passed to the given callable.
        kwargs
            The keyword arguments passed to the given callable.

        Returns
        -------
        Any
            The return value of the given callable when being passed the given
            arguments.
        """
        logger.warning(warning_msg())
        return func(*args, **kwargs)

    if type(func).__name__ != "function":
        deprecate_docs(func)
        # The following line raises this mypy error:
        # Accessing "__init__" on an instance is unsound, since instance.__init__
        # could be from an incompatible subclass  [misc]&lt;/pre&gt;
        func.__init__ = decorate(func.__init__, deprecate)  # type: ignore[misc]
        return func

    func = decorate(func, deprecate)
    deprecate_docs(func)
    return func


</t>
<t tx="ekr.20250122151621.683">def deprecated_params(
    params: str | Iterable[str] | None = None,
    since: str | None = None,
    until: str | None = None,
    message: str = "",
    redirections: None
    | (Iterable[tuple[str, str] | Callable[..., dict[str, Any]]]) = None,
</t>
<t tx="ekr.20250122151621.684">) -&gt; Callable[..., T]:
    """Decorator to mark parameters of a callable as deprecated.

    It can also be used to automatically redirect deprecated parameter values to their
    replacements.

    Parameters
    ----------
    params
        The parameters to be deprecated. Can consist of:

        * An iterable of strings, with each element representing a parameter to deprecate
        * A single string, with parameter names separated by commas or spaces.
    since
        The version or date since deprecation.
    until
        The version or date until removal of the deprecated callable.
    message
        The reason for why the callable has been deprecated.
    redirections
        A list of parameter redirections. Each redirection can be one of the following:

        * A tuple of two strings. The first string defines the name of the deprecated
          parameter; the second string defines the name of the parameter to redirect to,
          when attempting to use the first string.

        * A function performing the mapping operation. The parameter names of the
          function determine which parameters are used as input. The function must
          return a dictionary which contains the redirected arguments.

        Redirected parameters are also implicitly deprecated.

    Returns
    -------
    Callable
        The decorated callable.

    Raises
    ------
    ValueError
        If no parameters are defined (neither explicitly nor implicitly).
    ValueError
        If defined parameters are invalid python identifiers.

    Examples
    --------
    Basic usage::

        from manim.utils.deprecation import deprecated_params


        @deprecated_params(params="a, b, c")
        def foo(**kwargs):
            pass


        foo(x=2, y=3, z=4)
        # No warning

        foo(a=2, b=3, z=4)
        # WARNING  The parameters a and b of method foo have been deprecated and may be removed in a later version.

    You can also specify additional information for a more precise warning::

        from manim.utils.deprecation import deprecated_params


        @deprecated_params(
            params="a, b, c",
            since="v0.2",
            until="v0.4",
            message="The letters x, y, z are cooler.",
        )
        def foo(**kwargs):
            pass


        foo(a=2)
        # WARNING  The parameter a of method foo has been deprecated since v0.2 and is expected to be removed after v0.4. The letters x, y, z are cooler.

    Basic parameter redirection::

        from manim.utils.deprecation import deprecated_params


        @deprecated_params(
            redirections=[
                # Two ways to redirect one parameter to another:
                ("old_param", "new_param"),
                lambda old_param2: {"new_param22": old_param2},
            ]
        )
        def foo(**kwargs):
            return kwargs


        foo(x=1, old_param=2)
        # WARNING  The parameter old_param of method foo has been deprecated and may be removed in a later version.
        # returns {"x": 1, "new_param": 2}

    Redirecting using a calculated value::

        from manim.utils.deprecation import deprecated_params


        @deprecated_params(
            redirections=[lambda runtime_in_ms: {"run_time": runtime_in_ms / 1000}]
        )
        def foo(**kwargs):
            return kwargs


        foo(runtime_in_ms=500)
        # WARNING  The parameter runtime_in_ms of method foo has been deprecated and may be removed in a later version.
        # returns {"run_time": 0.5}

    Redirecting multiple parameter values to one::

        from manim.utils.deprecation import deprecated_params


        @deprecated_params(
            redirections=[lambda buff_x=1, buff_y=1: {"buff": (buff_x, buff_y)}]
        )
        def foo(**kwargs):
            return kwargs


        foo(buff_x=2)
        # WARNING  The parameter buff_x of method foo has been deprecated and may be removed in a later version.
        # returns {"buff": (2, 1)}

    Redirect one parameter to multiple::

        from manim.utils.deprecation import deprecated_params


        @deprecated_params(
            redirections=[
                lambda buff=1: {"buff_x": buff[0], "buff_y": buff[1]}
                if isinstance(buff, tuple)
                else {"buff_x": buff, "buff_y": buff}
            ]
        )
        def foo(**kwargs):
            return kwargs


        foo(buff=0)
        # WARNING  The parameter buff of method foo has been deprecated and may be removed in a later version.
        # returns {"buff_x": 0, buff_y: 0}

        foo(buff=(1, 2))
        # WARNING  The parameter buff of method foo has been deprecated and may be removed in a later version.
        # returns {"buff_x": 1, buff_y: 2}


    """
    # Check if decorator is used without parenthesis
    if callable(params):
        raise ValueError("deprecate_parameters requires arguments to be specified.")

    if params is None:
        params = []

    # Construct params list
    params = re.split(r"[,\s]+", params) if isinstance(params, str) else list(params)

    # Add params which are only implicitly given via redirections
    if redirections is None:
        redirections = []
    for redirector in redirections:
        if isinstance(redirector, tuple):
            params.append(redirector[0])
        else:
            params.extend(list(inspect.signature(redirector).parameters))
    # Keep ordering of params so that warning message is consistently the same
    # This will also help pass unit testing
    params = list(dict.fromkeys(params))

    # Make sure params only contains valid identifiers
    identifier = re.compile(r"^[^\d\W]\w*\Z", re.UNICODE)
    if not all(re.match(identifier, param) for param in params):
        raise ValueError("Given parameter values are invalid.")

    redirections = list(redirections)

    def warning_msg(func: Callable[..., T], used: list[str]) -&gt; str:
        """Generate the deprecation warning message.

        Parameters
        ----------
        func
            The callable with deprecated parameters.
        used
            The list of deprecated parameters used in a call.

        Returns
        -------
        str
            The deprecation message.
        """
        what, name = _get_callable_info(func)
        plural = len(used) &gt; 1
        parameter_s = "s" if plural else ""
        used_ = ", ".join(used[:-1]) + " and " + used[-1] if plural else used[0]
        has_have_been = "have been" if plural else "has been"
        deprecated = _deprecation_text_component(since, until, message)
        return f"The parameter{parameter_s} {used_} of {what} {name} {has_have_been} {deprecated}"

</t>
<t tx="ekr.20250122151621.685">    def redirect_params(kwargs: dict[str, Any], used: list[str]) -&gt; None:
        """Adjust the keyword arguments as defined by the redirections.

        Parameters
        ----------
        kwargs
            The keyword argument dictionary to be updated.
        used
            The list of deprecated parameters used in a call.
        """
        for redirector in redirections:
            if isinstance(redirector, tuple):
                old_param, new_param = redirector
                if old_param in used:
                    kwargs[new_param] = kwargs.pop(old_param)
            else:
                redirector_params = list(inspect.signature(redirector).parameters)
                redirector_args = {}
                for redirector_param in redirector_params:
                    if redirector_param in used:
                        redirector_args[redirector_param] = kwargs.pop(redirector_param)
                if len(redirector_args) &gt; 0:
                    kwargs.update(redirector(**redirector_args))

</t>
<t tx="ekr.20250122151621.686">    def deprecate_params(func: Callable[..., T], *args: Any, **kwargs: Any) -&gt; T:
        """The actual decorator function used to extend the callables behavior.

        Logs a warning message when a deprecated parameter is used and redirects it if
        specified.

        Parameters
        ----------
        func
            The callable to decorate.
        args
            The arguments passed to the given callable.
        kwargs
            The keyword arguments passed to the given callable.

        Returns
        -------
        Any
            The return value of the given callable when being passed the given
            arguments.

        """
        used = []
        for param in params:
            if param in kwargs:
                used.append(param)

        if len(used) &gt; 0:
            logger.warning(warning_msg(func, used))
            redirect_params(kwargs, used)
        return func(*args, **kwargs)

</t>
<t tx="ekr.20250122151621.687">from __future__ import annotations

__all__ = [
    "EndSceneEarlyException",
    "RerunSceneException",
    "MultiAnimationOverrideException",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.688">class EndSceneEarlyException(Exception):
    pass


</t>
<t tx="ekr.20250122151621.689">class RerunSceneException(Exception):
    pass


</t>
<t tx="ekr.20250122151621.69">def __init__(
    self,
    start: np.ndarray = LEFT,
    end: np.ndarray = RIGHT,
    thickness: float = 0.02,
    color: ParsableManimColor | None = None,
    resolution: int | Sequence[int] = 24,
    **kwargs,
):
    self.thickness = thickness
    self.resolution = (2, resolution) if isinstance(resolution, int) else resolution
    self.set_start_and_end_attrs(start, end, **kwargs)
    if color is not None:
        self.set_color(color)

</t>
<t tx="ekr.20250122151621.690">class MultiAnimationOverrideException(Exception):
    pass
</t>
<t tx="ekr.20250122151621.691">from __future__ import annotations

import itertools as it
from collections.abc import Iterable

from ..mobject.mobject import Mobject
from ..utils.iterables import remove_list_redundancies

__all__ = ["extract_mobject_family_members"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.692">def extract_mobject_family_members(
    mobjects: Iterable[Mobject],
    use_z_index: bool = False,
    only_those_with_points: bool = False,
) -&gt; list[Mobject]:
    """Returns a list of the types of mobjects and their family members present.
    A "family" in this context refers to a mobject, its submobjects, and their
    submobjects, recursively.

    Parameters
    ----------
    mobjects
        The Mobjects currently in the Scene
    only_those_with_points
        Whether or not to only do this for
        those mobjects that have points. By default False

    Returns
    -------
    list
        list of the mobjects and family members.
    """
    if only_those_with_points:
        method = Mobject.family_members_with_points
    else:
        method = Mobject.get_family
    extracted_mobjects = remove_list_redundancies(
        list(it.chain(*(method(m) for m in mobjects))),
    )
    if use_z_index:
        return sorted(extracted_mobjects, key=lambda m: m.z_index)
    return extracted_mobjects
</t>
<t tx="ekr.20250122151621.693">from __future__ import annotations

import itertools as it

from manim.mobject.mobject import Mobject

__all__ = [
    "extract_mobject_family_members",
    "restructure_list_to_exclude_certain_family_members",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.694">def extract_mobject_family_members(
    mobject_list: list[Mobject], only_those_with_points: bool = False
) -&gt; list[Mobject]:
    result = list(it.chain(*(mob.get_family() for mob in mobject_list)))
    if only_those_with_points:
        result = [mob for mob in result if mob.has_points()]
    return result


</t>
<t tx="ekr.20250122151621.695">def restructure_list_to_exclude_certain_family_members(
    mobject_list: list[Mobject], to_remove: list[Mobject]
) -&gt; list[Mobject]:
    """
    Removes anything in to_remove from mobject_list, but in the event that one of
    the items to be removed is a member of the family of an item in mobject_list,
    the other family members are added back into the list.

    This is useful in cases where a scene contains a group, e.g. Group(m1, m2, m3),
    but one of its submobjects is removed, e.g. scene.remove(m1), it's useful
    for the list of mobject_list to be edited to contain other submobjects, but not m1.
    """
    new_list: list[Mobject] = []
    to_remove = extract_mobject_family_members(to_remove)

    def add_safe_mobjects_from_list(
        list_to_examine: list[Mobject], set_to_remove: set[Mobject]
    ) -&gt; None:
        for mob in list_to_examine:
            if mob in set_to_remove:
                continue
            intersect = set_to_remove.intersection(mob.get_family())
            if intersect:
                add_safe_mobjects_from_list(mob.submobjects, intersect)
            else:
                new_list.append(mob)

    add_safe_mobjects_from_list(mobject_list, set(to_remove))
    return new_list
</t>
<t tx="ekr.20250122151621.696">"""Utility functions for interacting with the file system."""

from __future__ import annotations

__all__ = [
    "add_extension_if_not_present",
    "guarantee_existence",
    "guarantee_empty_existence",
    "seek_full_path_from_defaults",
    "modify_atime",
    "open_file",
    "is_mp4_format",
    "is_gif_format",
    "is_png_format",
    "is_webm_format",
    "is_mov_format",
    "write_to_movie",
    "ensure_executable",
]

import os
import platform
import shutil
import subprocess as sp
import time
from pathlib import Path
from shutil import copyfile
from typing import TYPE_CHECKING

if TYPE_CHECKING:
    from manim.typing import StrPath

    from ..scene.scene_file_writer import SceneFileWriter

from manim import __version__, config, logger

from .. import console


@others
) -&gt; None:
    """Copies template files from templates dir to project_dir.

    Parameters
    ----------
        project_dir
            Path to project directory.
        template_name
            Name of template.
    """
    template_cfg_path = Path.resolve(
        Path(__file__).parent.parent / "templates/template.cfg",
    )
    template_scene_path = Path.resolve(
        Path(__file__).parent.parent / f"templates/{template_name}.mtp",
    )

    if not template_cfg_path.exists():
        raise FileNotFoundError(f"{template_cfg_path} : file does not exist")
    if not template_scene_path.exists():
        raise FileNotFoundError(f"{template_scene_path} : file does not exist")

    copyfile(template_cfg_path, Path.resolve(project_dir / "manim.cfg"))
    console.print("\n\t[green]copied[/green] [blue]manim.cfg[/blue]\n")
    copyfile(template_scene_path, Path.resolve(project_dir / "main.py"))
    console.print("\n\t[green]copied[/green] [blue]main.py[/blue]\n")
    add_import_statement(Path.resolve(project_dir / "main.py"))
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.697">def is_mp4_format() -&gt; bool:
    """
    Determines if output format is .mp4

    Returns
    -------
    class:`bool`
        ``True`` if format is set as mp4

    """
    val: bool = config["format"] == "mp4"
    return val


</t>
<t tx="ekr.20250122151621.698">def is_gif_format() -&gt; bool:
    """
    Determines if output format is .gif

    Returns
    -------
    class:`bool`
        ``True`` if format is set as gif

    """
    val: bool = config["format"] == "gif"
    return val


</t>
<t tx="ekr.20250122151621.699">def is_webm_format() -&gt; bool:
    """
    Determines if output format is .webm

    Returns
    -------
    class:`bool`
        ``True`` if format is set as webm

    """
    val: bool = config["format"] == "webm"
    return val


</t>
<t tx="ekr.20250122151621.7">class Icosahedron(Polyhedron):
    """An icosahedron, one of the five platonic solids. It has 20 faces, 30 edges and 12 vertices.

    Parameters
    ----------
    edge_length
        The length of an edge between any two vertices.

    Examples
    --------

    .. manim:: IcosahedronScene
        :save_last_frame:

        class IcosahedronScene(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                obj = Icosahedron()
                self.add(obj)
    """

    @others
</t>
<t tx="ekr.20250122151621.70">def set_start_and_end_attrs(
    self, start: np.ndarray, end: np.ndarray, **kwargs
) -&gt; None:
    """Sets the start and end points of the line.

    If either ``start`` or ``end`` are :class:`Mobjects &lt;.Mobject&gt;`,
    this gives their centers.

    Parameters
    ----------
    start
        Starting point or :class:`Mobject`.
    end
        Ending point or :class:`Mobject`.
    """
    rough_start = self.pointify(start)
    rough_end = self.pointify(end)
    self.vect = rough_end - rough_start
    self.length = np.linalg.norm(self.vect)
    self.direction = normalize(self.vect)
    # Now that we know the direction between them,
    # we can the appropriate boundary point from
    # start and end, if they're mobjects
    self.start = self.pointify(start, self.direction)
    self.end = self.pointify(end, -self.direction)
    super().__init__(
        height=np.linalg.norm(self.vect),
        radius=self.thickness,
        direction=self.direction,
        resolution=self.resolution,
        **kwargs,
    )
    self.shift((self.start + self.end) / 2)

</t>
<t tx="ekr.20250122151621.700">def is_mov_format() -&gt; bool:
    """
    Determines if output format is .mov

    Returns
    -------
    class:`bool`
        ``True`` if format is set as mov

    """
    val: bool = config["format"] == "mov"
    return val


</t>
<t tx="ekr.20250122151621.701">def is_png_format() -&gt; bool:
    """
    Determines if output format is .png

    Returns
    -------
    class:`bool`
        ``True`` if format is set as png

    """
    val: bool = config["format"] == "png"
    return val


</t>
<t tx="ekr.20250122151621.702">def write_to_movie() -&gt; bool:
    """
    Determines from config if the output is a video format such as mp4 or gif, if the --format is set as 'png'
    then it will take precedence event if the write_to_movie flag is set

    Returns
    -------
    class:`bool`
        ``True`` if the output should be written in a movie format

    """
    if is_png_format():
        return False
    return (
        config["write_to_movie"]
        or is_mp4_format()
        or is_gif_format()
        or is_webm_format()
        or is_mov_format()
    )


</t>
<t tx="ekr.20250122151621.703">def ensure_executable(path_to_exe: Path) -&gt; bool:
    if path_to_exe.parent == Path("."):
        executable: StrPath | None = shutil.which(path_to_exe.stem)
        if executable is None:
            return False
    else:
        executable = path_to_exe
    return os.access(executable, os.X_OK)


</t>
<t tx="ekr.20250122151621.704">def add_extension_if_not_present(file_name: Path, extension: str) -&gt; Path:
    if file_name.suffix != extension:
        return file_name.with_suffix(file_name.suffix + extension)
    else:
        return file_name


</t>
<t tx="ekr.20250122151621.705">def add_version_before_extension(file_name: Path) -&gt; Path:
    return file_name.with_name(
        f"{file_name.stem}_ManimCE_v{__version__}{file_name.suffix}"
    )


</t>
<t tx="ekr.20250122151621.706">def guarantee_existence(path: Path) -&gt; Path:
    if not path.exists():
        path.mkdir(parents=True)
    return path.resolve(strict=True)


</t>
<t tx="ekr.20250122151621.707">def guarantee_empty_existence(path: Path) -&gt; Path:
    if path.exists():
        shutil.rmtree(str(path))
    path.mkdir(parents=True)
    return path.resolve(strict=True)


</t>
<t tx="ekr.20250122151621.708">def seek_full_path_from_defaults(
    file_name: StrPath, default_dir: Path, extensions: list[str]
) -&gt; Path:
    possible_paths = [Path(file_name).expanduser()]
    possible_paths += [
        Path(default_dir) / f"{file_name}{extension}" for extension in ["", *extensions]
    ]
    for path in possible_paths:
        if path.exists():
            return path
    error = (
        f"From: {Path.cwd()}, could not find {file_name} at either "
        f"of these locations: {list(map(str, possible_paths))}"
    )
    raise OSError(error)


</t>
<t tx="ekr.20250122151621.709">def modify_atime(file_path: str) -&gt; None:
    """Will manually change the accessed time (called `atime`) of the file, as on a lot of OS the accessed time refresh is disabled by default.

    Parameters
    ----------
    file_path
        The path of the file.
    """
    os.utime(file_path, times=(time.time(), Path(file_path).stat().st_mtime))


</t>
<t tx="ekr.20250122151621.71">def pointify(
    self,
    mob_or_point: Mobject | Point3DLike,
    direction: Vector3D = None,
) -&gt; np.ndarray:
    """Gets a point representing the center of the :class:`Mobjects &lt;.Mobject&gt;`.

    Parameters
    ----------
    mob_or_point
        :class:`Mobjects &lt;.Mobject&gt;` or point whose center should be returned.
    direction
        If an edge of a :class:`Mobjects &lt;.Mobject&gt;` should be returned, the direction of the edge.

    Returns
    -------
    :class:`numpy.array`
        Center of the :class:`Mobjects &lt;.Mobject&gt;` or point, or edge if direction is given.
    """
    if isinstance(mob_or_point, (Mobject, OpenGLMobject)):
        mob = mob_or_point
        if direction is None:
            return mob.get_center()
        else:
            return mob.get_boundary_point(direction)
    return np.array(mob_or_point)

</t>
<t tx="ekr.20250122151621.710">def open_file(file_path: Path, in_browser: bool = False) -&gt; None:
    current_os = platform.system()
    if current_os == "Windows":
        # The method os.startfile is only available in Windows,
        # ignoring type error caused by this.
        os.startfile(file_path if not in_browser else file_path.parent)  # type: ignore[attr-defined]
    else:
        if current_os == "Linux":
            commands = ["xdg-open"]
            file_path = file_path if not in_browser else file_path.parent
        elif current_os.startswith("CYGWIN"):
            commands = ["cygstart"]
            file_path = file_path if not in_browser else file_path.parent
        elif current_os == "Darwin":
            commands = ["open"] if not in_browser else ["open", "-R"]
        else:
            raise OSError("Unable to identify your operating system...")

        # check after so that file path is set correctly
        if config.preview_command:
            commands = [config.preview_command]
        commands.append(str(file_path))
        sp.run(commands)


</t>
<t tx="ekr.20250122151621.711">def open_media_file(file_writer: SceneFileWriter) -&gt; None:
    file_paths = []

    if config["save_last_frame"]:
        file_paths.append(file_writer.image_file_path)
    if write_to_movie() and not is_gif_format():
        file_paths.append(file_writer.movie_file_path)
    if write_to_movie() and is_gif_format():
        file_paths.append(file_writer.gif_file_path)

    for file_path in file_paths:
        if config["show_in_file_browser"]:
            open_file(file_path, True)
        if config["preview"]:
            open_file(file_path, False)

            logger.info(f"Previewed File at: '{file_path}'")


</t>
<t tx="ekr.20250122151621.712">def get_template_names() -&gt; list[str]:
    """Returns template names from the templates directory.

    Returns
    -------
        :class:`list`
    """
    template_path = Path.resolve(Path(__file__).parent.parent / "templates")
    return [template_name.stem for template_name in template_path.glob("*.mtp")]


</t>
<t tx="ekr.20250122151621.713">def get_template_path() -&gt; Path:
    """Returns the Path of templates directory.

    Returns
    -------
        :class:`Path`
    """
    return Path.resolve(Path(__file__).parent.parent / "templates")


</t>
<t tx="ekr.20250122151621.714">def add_import_statement(file: Path) -&gt; None:
    """Prepends an import statement in a file

    Parameters
    ----------
        file
    """
    with file.open("r+") as f:
        import_line = "from manim import *"
        content = f.read()
        f.seek(0)
        f.write(import_line + "\n" + content)


</t>
<t tx="ekr.20250122151621.715">def copy_template_files(
    project_dir: Path = Path("."), template_name: str = "Default"
</t>
<t tx="ekr.20250122151621.716">"""Utilities for scene caching."""

from __future__ import annotations

import collections
import copy
import inspect
import json
import typing
import zlib
from time import perf_counter
from types import FunctionType, MappingProxyType, MethodType, ModuleType
from typing import Any

import numpy as np

from manim._config import config, logger

if typing.TYPE_CHECKING:
    from manim.animation.animation import Animation
    from manim.camera.camera import Camera
    from manim.mobject.mobject import Mobject
    from manim.opengl.opengl_renderer import OpenGLCamera
    from manim.scene.scene import Scene

__all__ = ["KEYS_TO_FILTER_OUT", "get_hash_from_play_call", "get_json"]

# Sometimes there are elements that are not suitable for hashing (too long or
# run-dependent).  This is used to filter them out.
KEYS_TO_FILTER_OUT = {
    "original_id",
    "background",
    "pixel_array",
    "pixel_array_to_cairo_context",
}


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.717">class _Memoizer:
    """Implements the memoization logic to optimize the hashing procedure and prevent
    the circular references within iterable processed.

    Keeps a record of all the processed objects, and handle the logic to return a place
    holder instead of the original object if the object has already been processed
    by the hashing logic (i.e, recursively checked, converted to JSON, etc..).

    This class uses two signatures functions to keep a track of processed objects :
    hash or id. Whenever possible, hash is used to ensure a broader object
    content-equality detection.
    """

    @others
</t>
<t tx="ekr.20250122151621.718">class _CustomEncoder(json.JSONEncoder):
    @others
</t>
<t tx="ekr.20250122151621.719">def get_json(obj: dict):
    """Recursively serialize `object` to JSON using the :class:`CustomEncoder` class.

    Parameters
    ----------
    obj
        The dict to flatten

    Returns
    -------
    :class:`str`
        The flattened object
    """
    return json.dumps(obj, cls=_CustomEncoder)


</t>
<t tx="ekr.20250122151621.72">def get_start(self) -&gt; np.ndarray:
    """Returns the starting point of the :class:`Line3D`.

    Returns
    -------
    start : :class:`numpy.array`
        Starting point of the :class:`Line3D`.
    """
    return self.start

</t>
<t tx="ekr.20250122151621.720">def get_hash_from_play_call(
    scene_object: Scene,
    camera_object: Camera | OpenGLCamera,
    animations_list: typing.Iterable[Animation],
    current_mobjects_list: typing.Iterable[Mobject],
) -&gt; str:
    """Take the list of animations and a list of mobjects and output their hashes. This is meant to be used for `scene.play` function.

    Parameters
    -----------
    scene_object
        The scene object.

    camera_object
        The camera object used in the scene.

    animations_list
        The list of animations.

    current_mobjects_list
        The list of mobjects.

    Returns
    -------
    :class:`str`
        A string concatenation of the respective hashes of `camera_object`, `animations_list` and `current_mobjects_list`, separated by `_`.
    """
    logger.debug("Hashing ...")
    t_start = perf_counter()
    _Memoizer.mark_as_processed(scene_object)
    camera_json = get_json(camera_object)
    animations_list_json = [get_json(x) for x in sorted(animations_list, key=str)]
    current_mobjects_list_json = [get_json(x) for x in current_mobjects_list]
    hash_camera, hash_animations, hash_current_mobjects = (
        zlib.crc32(repr(json_val).encode())
        for json_val in [camera_json, animations_list_json, current_mobjects_list_json]
    )
    hash_complete = f"{hash_camera}_{hash_animations}_{hash_current_mobjects}"
    t_end = perf_counter()
    logger.debug("Hashing done in %(time)s s.", {"time": str(t_end - t_start)[:8]})
    # End of the hashing for the animation, reset all the memoize.
    _Memoizer.reset_already_processed()
    logger.debug("Hash generated :  %(h)s", {"h": hash_complete})
    return hash_complete
</t>
<t tx="ekr.20250122151621.721">_already_processed = set()

# Can be changed to whatever string to help debugging the JSon generation.
ALREADY_PROCESSED_PLACEHOLDER = "AP"
THRESHOLD_WARNING = 170_000

@classmethod
def reset_already_processed(cls):
    cls._already_processed.clear()

</t>
<t tx="ekr.20250122151621.722">@classmethod
def check_already_processed_decorator(cls: _Memoizer, is_method: bool = False):
    """Decorator to handle the arguments that goes through the decorated function.
    Returns _ALREADY_PROCESSED_PLACEHOLDER if the obj has been processed, or lets
    the decorated function call go ahead.

    Parameters
    ----------
    is_method
        Whether the function passed is a method, by default False.
    """

    def layer(func):
        # NOTE : There is probably a better way to separate both case when func is
        # a method or a function.
        if is_method:
            return lambda self, obj: cls._handle_already_processed(
                obj,
                default_function=lambda obj: func(self, obj),
            )
        return lambda obj: cls._handle_already_processed(obj, default_function=func)

    return layer

</t>
<t tx="ekr.20250122151621.723">@classmethod
def check_already_processed(cls, obj: Any) -&gt; Any:
    """Checks if obj has been already processed. Returns itself if it has not been,
    or the value of _ALREADY_PROCESSED_PLACEHOLDER if it has.
    Marks the object as processed in the second case.

    Parameters
    ----------
    obj
        The object to check.

    Returns
    -------
    Any
        Either the object itself or the placeholder.
    """
    # When the object is not memoized, we return the object itself.
    return cls._handle_already_processed(obj, lambda x: x)

</t>
<t tx="ekr.20250122151621.724">@classmethod
def mark_as_processed(cls, obj: Any) -&gt; None:
    """Marks an object as processed.

    Parameters
    ----------
    obj
        The object to mark as processed.
    """
    cls._handle_already_processed(obj, lambda x: x)
    return cls._return(obj, id, lambda x: x, memoizing=False)

</t>
<t tx="ekr.20250122151621.725">@classmethod
def _handle_already_processed(
    cls,
    obj,
    default_function: typing.Callable[[Any], Any],
):
    if isinstance(
        obj,
        (
            int,
            float,
            str,
            complex,
        ),
    ) and obj not in [None, cls.ALREADY_PROCESSED_PLACEHOLDER]:
        # It makes no sense (and it'd slower) to memoize objects of these primitive
        # types.  Hence, we simply return the object.
        return obj
    if isinstance(obj, collections.abc.Hashable):
        try:
            return cls._return(obj, hash, default_function)
        except TypeError:
            # In case of an error with the hash (eg an object is marked as hashable
            # but contains a non hashable within it)
            # Fallback to use the built-in function id instead.
            pass
    return cls._return(obj, id, default_function)

</t>
<t tx="ekr.20250122151621.726">@classmethod
def _return(
    cls,
    obj: typing.Any,
    obj_to_membership_sign: typing.Callable[[Any], int],
    default_func,
    memoizing=True,
) -&gt; str | Any:
    obj_membership_sign = obj_to_membership_sign(obj)
    if obj_membership_sign in cls._already_processed:
        return cls.ALREADY_PROCESSED_PLACEHOLDER
    if memoizing:
        if (
            not config.disable_caching_warning
            and len(cls._already_processed) == cls.THRESHOLD_WARNING
        ):
            logger.warning(
                "It looks like the scene contains a lot of sub-mobjects. Caching "
                "is sometimes not suited to handle such large scenes, you might "
                "consider disabling caching with --disable_caching to potentially "
                "speed up the rendering process.",
            )
            logger.warning(
                "You can disable this warning by setting disable_caching_warning "
                "to True in your config file.",
            )

        cls._already_processed.add(obj_membership_sign)
    return default_func(obj)


</t>
<t tx="ekr.20250122151621.727">def default(self, obj: Any):
    """
    This method is used to serialize objects to JSON format.

    If obj is a function, then it will return a dict with two keys : 'code', for
    the code source, and 'nonlocals' for all nonlocalsvalues. (including nonlocals
    functions, that will be serialized as this is recursive.)
    if obj is a np.darray, it converts it into a list.
    if obj is an object with __dict__ attribute, it returns its __dict__.
    Else, will let the JSONEncoder do the stuff, and throw an error if the type is
    not suitable for JSONEncoder.

    Parameters
    ----------
    obj
        Arbitrary object to convert

    Returns
    -------
    Any
        Python object that JSON encoder will recognize

    """
    if not (isinstance(obj, ModuleType)) and isinstance(
        obj,
        (MethodType, FunctionType),
    ):
        cvars = inspect.getclosurevars(obj)
        cvardict = {**copy.copy(cvars.globals), **copy.copy(cvars.nonlocals)}
        for i in list(cvardict):
            # NOTE : All module types objects are removed, because otherwise it
            # throws ValueError: Circular reference detected if not. TODO
            if isinstance(cvardict[i], ModuleType):
                del cvardict[i]
        try:
            code = inspect.getsource(obj)
        except (OSError, TypeError):
            # This happens when rendering videos included in the documentation
            # within doctests and should be replaced by a solution avoiding
            # hash collision (due to the same, empty, code strings) at some point.
            # See https://github.com/ManimCommunity/manim/pull/402.
            code = ""
        return self._cleaned_iterable({"code": code, "nonlocals": cvardict})
    elif isinstance(obj, np.ndarray):
        if obj.size &gt; 1000:
            obj = np.resize(obj, (100, 100))
            return f"TRUNCATED ARRAY: {repr(obj)}"
        # We return the repr and not a list to avoid the JsonEncoder to iterate over it.
        return repr(obj)
    elif hasattr(obj, "__dict__"):
        temp = obj.__dict__
        # MappingProxy is scene-caching nightmare. It contains all of the object methods and attributes. We skip it as the mechanism will at some point process the object, but instantiated.
        # Indeed, there is certainly no case where scene-caching will receive only a non instancied object, as this is never used in the library or encouraged to be used user-side.
        if isinstance(temp, MappingProxyType):
            return "MappingProxy"
        return self._cleaned_iterable(temp)
    elif isinstance(obj, np.uint8):
        return int(obj)
    # Serialize it with only the type of the object. You can change this to whatever string when debugging the serialization process.
    return str(type(obj))

</t>
<t tx="ekr.20250122151621.728">def _cleaned_iterable(self, iterable: typing.Iterable[Any]):
    """Check for circular reference at each iterable that will go through the JSONEncoder, as well as key of the wrong format.

    If a key with a bad format is found (i.e not a int, string, or float), it gets replaced byt its hash using the same process implemented here.
    If a circular reference is found within the iterable, it will be replaced by the string "already processed".

    Parameters
    ----------
    iterable
        The iterable to check.
    """

    def _key_to_hash(key):
        return zlib.crc32(json.dumps(key, cls=_CustomEncoder).encode())

    def _iter_check_list(lst):
        processed_list = [None] * len(lst)
        for i, el in enumerate(lst):
            el = _Memoizer.check_already_processed(el)
            if isinstance(el, (list, tuple)):
                new_value = _iter_check_list(el)
            elif isinstance(el, dict):
                new_value = _iter_check_dict(el)
            else:
                new_value = el
            processed_list[i] = new_value
        return processed_list

    def _iter_check_dict(dct):
        processed_dict = {}
        for k, v in dct.items():
            v = _Memoizer.check_already_processed(v)
            if k in KEYS_TO_FILTER_OUT:
                continue
            # We check if the k is of the right format (supporter by Json)
            if not isinstance(k, (str, int, float, bool)) and k is not None:
                k_new = _key_to_hash(k)
            else:
                k_new = k
            if isinstance(v, dict):
                new_value = _iter_check_dict(v)
            elif isinstance(v, (list, tuple)):
                new_value = _iter_check_list(v)
            else:
                new_value = v
            processed_dict[k_new] = new_value
        return processed_dict

    if isinstance(iterable, (list, tuple)):
        return _iter_check_list(iterable)
    elif isinstance(iterable, dict):
        return _iter_check_dict(iterable)

</t>
<t tx="ekr.20250122151621.729">def encode(self, obj: Any):
    """Overriding of :meth:`JSONEncoder.encode`, to make our own process.

    Parameters
    ----------
    obj
        The object to encode in JSON.

    Returns
    -------
    :class:`str`
       The object encoder with the standard json process.
    """
    _Memoizer.mark_as_processed(obj)
    if isinstance(obj, (dict, list, tuple)):
        return super().encode(self._cleaned_iterable(obj))
    return super().encode(obj)


</t>
<t tx="ekr.20250122151621.73">def get_end(self) -&gt; np.ndarray:
    """Returns the ending point of the :class:`Line3D`.

    Returns
    -------
    end : :class:`numpy.array`
        Ending point of the :class:`Line3D`.
    """
    return self.end

</t>
<t tx="ekr.20250122151621.730">"""Image manipulation utilities."""

from __future__ import annotations

__all__ = [
    "get_full_raster_image_path",
    "drag_pixels",
    "invert_image",
    "change_to_rgba_array",
]

from pathlib import Path, PurePath
from typing import TYPE_CHECKING

import numpy as np
from PIL import Image

from manim.typing import RGBPixelArray

from .. import config
from ..utils.file_ops import seek_full_path_from_defaults

if TYPE_CHECKING:
    pass


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.731">def get_full_raster_image_path(image_file_name: str | PurePath) -&gt; Path:
    return seek_full_path_from_defaults(
        image_file_name,
        default_dir=config.get_dir("assets_dir"),
        extensions=[".jpg", ".jpeg", ".png", ".gif", ".ico"],
    )


</t>
<t tx="ekr.20250122151621.732">def get_full_vector_image_path(image_file_name: str | PurePath) -&gt; Path:
    return seek_full_path_from_defaults(
        image_file_name,
        default_dir=config.get_dir("assets_dir"),
        extensions=[".svg"],
    )


</t>
<t tx="ekr.20250122151621.733">def drag_pixels(frames: list[np.array]) -&gt; list[np.array]:
    curr = frames[0]
    new_frames = []
    for frame in frames:
        curr += (curr == 0) * np.array(frame)
        new_frames.append(np.array(curr))
    return new_frames


</t>
<t tx="ekr.20250122151621.734">def invert_image(image: np.array) -&gt; Image:
    arr = np.array(image)
    arr = (255 * np.ones(arr.shape)).astype(arr.dtype) - arr
    return Image.fromarray(arr)


</t>
<t tx="ekr.20250122151621.735">def change_to_rgba_array(image: RGBPixelArray, dtype: str = "uint8") -&gt; RGBPixelArray:
    """Converts an RGB array into RGBA with the alpha value opacity maxed."""
    pa = image
    if len(pa.shape) == 2:
        pa = pa.reshape(list(pa.shape) + [1])
    if pa.shape[2] == 1:
        pa = pa.repeat(3, axis=2)
    if pa.shape[2] == 3:
        alphas = 255 * np.ones(
            list(pa.shape[:2]) + [1],
            dtype=dtype,
        )
        pa = np.append(pa, alphas, axis=2)
    return pa
</t>
<t tx="ekr.20250122151621.736">"""Utilities for using Manim with IPython (in particular: Jupyter notebooks)"""

from __future__ import annotations

import mimetypes
import shutil
from datetime import datetime
from pathlib import Path
from typing import Any

from manim import config, logger, tempconfig
from manim.__main__ import main
from manim.renderer.shader import shader_program_cache

from ..constants import RendererType

__all__ = ["ManimMagic"]

try:
    from IPython import get_ipython
    from IPython.core.interactiveshell import InteractiveShell
    from IPython.core.magic import (
        Magics,
        line_cell_magic,
        magics_class,
        needs_local_scope,
    )
    from IPython.display import Image, Video, display
except ImportError:
    pass
else:

    @magics_class
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.737">    class ManimMagic(Magics):
        @others
</t>
<t tx="ekr.20250122151621.738">def _generate_file_name() -&gt; str:
    val: str = (
        config["scene_names"][0] + "@" + datetime.now().strftime("%Y-%m-%d@%H-%M-%S")
    )
    return val
</t>
<t tx="ekr.20250122151621.739">def __init__(self, shell: InteractiveShell) -&gt; None:
    super().__init__(shell)
    self.rendered_files: dict[Path, Path] = {}

</t>
<t tx="ekr.20250122151621.74">@classmethod
def parallel_to(
    cls,
    line: Line3D,
    point: Vector3D = ORIGIN,
    length: float = 5,
    **kwargs,
) -&gt; Line3D:
    """Returns a line parallel to another line going through
    a given point.

    Parameters
    ----------
    line
        The line to be parallel to.
    point
        The point to pass through.
    length
        Length of the parallel line.
    kwargs
        Additional parameters to be passed to the class.

    Returns
    -------
    :class:`Line3D`
        Line parallel to ``line``.

    Examples
    --------
    .. manim:: ParallelLineExample
        :save_last_frame:

        class ParallelLineExample(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(PI / 3, -PI / 4)
                ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)
                line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)
                line2 = Line3D.parallel_to(line1, color=YELLOW)
                self.add(ax, line1, line2)
    """
    point = np.array(point)
    vect = normalize(line.vect)
    return cls(
        point + vect * length / 2,
        point - vect * length / 2,
        **kwargs,
    )

</t>
<t tx="ekr.20250122151621.740">@needs_local_scope
@line_cell_magic
def manim(
    self,
    line: str,
    cell: str | None = None,
    local_ns: dict[str, Any] | None = None,
) -&gt; None:
    r"""Render Manim scenes contained in IPython cells.
    Works as a line or cell magic.

    .. hint::

        This line and cell magic works best when used in a JupyterLab
        environment: while all of the functionality is available for
        classic Jupyter notebooks as well, it is possible that videos
        sometimes don't update on repeated execution of the same cell
        if the scene name stays the same.

        This problem does not occur when using JupyterLab.

    Please refer to `&lt;https://jupyter.org/&gt;`_ for more information about JupyterLab
    and Jupyter notebooks.

    Usage in line mode::

        %manim [CLI options] MyAwesomeScene

    Usage in cell mode::

        %%manim [CLI options] MyAwesomeScene

        class MyAweseomeScene(Scene):
            def construct(self):
                ...

    Run ``%manim --help`` and ``%manim render --help`` for possible command line interface options.

    .. note::

        The maximal width of the rendered videos that are displayed in the notebook can be
        configured via the ``media_width`` configuration option. The default is set to ``25vw``,
        which is 25% of your current viewport width. To allow the output to become as large
        as possible, set ``config.media_width = "100%"``.

        The ``media_embed`` option will embed the image/video output in the notebook. This is
        generally undesirable as it makes the notebooks very large, but is required on some
        platforms (notably Google's CoLab, where it is automatically enabled unless suppressed
        by ``config.embed = False``) and needed in cases when the notebook (or converted HTML
        file) will be moved relative to the video locations. Use-cases include building
        documentation with Sphinx and JupyterBook. See also the :mod:`manim directive for Sphinx
        &lt;manim.utils.docbuild.manim_directive&gt;`.

    Examples
    --------

    First make sure to put ``import manim``, or even ``from manim import *``
    in a cell and evaluate it. Then, a typical Jupyter notebook cell for Manim
    could look as follows::

        %%manim -v WARNING --disable_caching -qm BannerExample

        config.media_width = "75%"
        config.media_embed = True

        class BannerExample(Scene):
            def construct(self):
                self.camera.background_color = "#ece6e2"
                banner_large = ManimBanner(dark_theme=False).scale(0.7)
                self.play(banner_large.create())
                self.play(banner_large.expand())

    Evaluating this cell will render and display the ``BannerExample`` scene defined in the body of the cell.

    .. note::

        In case you want to hide the red box containing the output progress bar, the ``progress_bar`` config
        option should be set to ``None``. This can also be done by passing ``--progress_bar None`` as a
        CLI flag.

    """
    if cell:
        exec(cell, local_ns)

    args = line.split()
    if not len(args) or "-h" in args or "--help" in args or "--version" in args:
        main(args, standalone_mode=False, prog_name="manim")
        return

    modified_args = self.add_additional_args(args)
    args = main(modified_args, standalone_mode=False, prog_name="manim")
    assert isinstance(local_ns, dict)
    with tempconfig(local_ns.get("config", {})):
        config.digest_args(args)  # type: ignore[arg-type]

        renderer = None
        if config.renderer == RendererType.OPENGL:
            from manim.renderer.opengl_renderer import OpenGLRenderer

            renderer = OpenGLRenderer()

        try:
            SceneClass = local_ns[config["scene_names"][0]]
            scene = SceneClass(renderer=renderer)
            scene.render()
        finally:
            # Shader cache becomes invalid as the context is destroyed
            shader_program_cache.clear()

            # Close OpenGL window here instead of waiting for the main thread to
            # finish causing the window to stay open and freeze
            if renderer is not None and renderer.window is not None:
                renderer.window.close()

        if config["output_file"] is None:
            logger.info("No output file produced")
            return

        local_path = Path(config["output_file"]).relative_to(Path.cwd())
        tmpfile = (
            Path(config["media_dir"])
            / "jupyter"
            / f"{_generate_file_name()}{local_path.suffix}"
        )

        if local_path in self.rendered_files:
            self.rendered_files[local_path].unlink()
        self.rendered_files[local_path] = tmpfile
        tmpfile.parent.mkdir(parents=True, exist_ok=True)
        shutil.copy(local_path, tmpfile)

        file_type = mimetypes.guess_type(config["output_file"])[0]
        assert isinstance(file_type, str)
        embed = config["media_embed"]
        if not embed:
            # videos need to be embedded when running in google colab.
            # do this automatically in case config.media_embed has not been
            # set explicitly.
            embed = "google.colab" in str(get_ipython())

        if file_type.startswith("image"):
            result = Image(filename=config["output_file"])
        else:
            result = Video(
                tmpfile,
                html_attributes=f'controls autoplay loop style="max-width: {config["media_width"]};"',
                embed=embed,
            )

        display(result)

</t>
<t tx="ekr.20250122151621.741">def add_additional_args(self, args: list[str]) -&gt; list[str]:
    additional_args = ["--jupyter"]
    # Use webm to support transparency
    if "-t" in args and "--format" not in args:
        additional_args += ["--format", "webm"]
    return additional_args + args[:-1] + [""] + [args[-1]]


</t>
<t tx="ekr.20250122151621.742">"""Operations on iterables."""

from __future__ import annotations

__all__ = [
    "adjacent_n_tuples",
    "adjacent_pairs",
    "all_elements_are_instances",
    "concatenate_lists",
    "list_difference_update",
    "list_update",
    "listify",
    "make_even",
    "make_even_by_cycling",
    "remove_list_redundancies",
    "remove_nones",
    "stretch_array_to_length",
    "tuplify",
]

import itertools as it
from collections.abc import (
    Collection,
    Generator,
    Hashable,
    Iterable,
    Reversible,
    Sequence,
)
from typing import TYPE_CHECKING, Callable, TypeVar, overload

import numpy as np

T = TypeVar("T")
U = TypeVar("U")
F = TypeVar("F", np.float64, np.int_)
H = TypeVar("H", bound=Hashable)


if TYPE_CHECKING:
    import numpy.typing as npt


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.743">def adjacent_n_tuples(objects: Sequence[T], n: int) -&gt; zip[tuple[T, ...]]:
    """Returns the Sequence objects cyclically split into n length tuples.

    See Also
    --------
    adjacent_pairs : alias with n=2

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; list(adjacent_n_tuples([1, 2, 3, 4], 2))
        [(1, 2), (2, 3), (3, 4), (4, 1)]
        &gt;&gt;&gt; list(adjacent_n_tuples([1, 2, 3, 4], 3))
        [(1, 2, 3), (2, 3, 4), (3, 4, 1), (4, 1, 2)]
    """
    return zip(*([*objects[k:], *objects[:k]] for k in range(n)))


</t>
<t tx="ekr.20250122151621.744">def adjacent_pairs(objects: Sequence[T]) -&gt; zip[tuple[T, ...]]:
    """Alias for ``adjacent_n_tuples(objects, 2)``.

    See Also
    --------
    adjacent_n_tuples

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; list(adjacent_pairs([1, 2, 3, 4]))
        [(1, 2), (2, 3), (3, 4), (4, 1)]
    """
    return adjacent_n_tuples(objects, 2)


</t>
<t tx="ekr.20250122151621.745">def all_elements_are_instances(iterable: Iterable[object], Class: type[object]) -&gt; bool:
    """Returns ``True`` if all elements of iterable are instances of Class.
    False otherwise.
    """
    return all(isinstance(e, Class) for e in iterable)


</t>
<t tx="ekr.20250122151621.746">def batch_by_property(
    items: Iterable[T], property_func: Callable[[T], U]
) -&gt; list[tuple[list[T], U | None]]:
    """Takes in a Sequence, and returns a list of tuples, (batch, prop)
    such that all items in a batch have the same output when
    put into the Callable property_func, and such that chaining all these
    batches together would give the original Sequence (i.e. order is
    preserved).

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; batch_by_property([(1, 2), (3, 4), (5, 6, 7), (8, 9)], len)
        [([(1, 2), (3, 4)], 2), ([(5, 6, 7)], 3), ([(8, 9)], 2)]
    """
    batch_prop_pairs: list[tuple[list[T], U | None]] = []
    curr_batch: list[T] = []
    curr_prop = None
    for item in items:
        prop = property_func(item)
        if prop != curr_prop:
            # Add current batch
            if len(curr_batch) &gt; 0:
                batch_prop_pairs.append((curr_batch, curr_prop))
            # Redefine curr
            curr_prop = prop
            curr_batch = [item]
        else:
            curr_batch.append(item)
    if len(curr_batch) &gt; 0:
        batch_prop_pairs.append((curr_batch, curr_prop))
    return batch_prop_pairs


</t>
<t tx="ekr.20250122151621.747">def concatenate_lists(*list_of_lists: Iterable[T]) -&gt; list[T]:
    """Combines the Iterables provided as arguments into one list.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; concatenate_lists([1, 2], [3, 4], [5])
        [1, 2, 3, 4, 5]
    """
    return [item for lst in list_of_lists for item in lst]


</t>
<t tx="ekr.20250122151621.748">def list_difference_update(l1: Iterable[T], l2: Iterable[T]) -&gt; list[T]:
    """Returns a list containing all the elements of l1 not in l2.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; list_difference_update([1, 2, 3, 4], [2, 4])
        [1, 3]
    """
    return [e for e in l1 if e not in l2]


</t>
<t tx="ekr.20250122151621.749">def list_update(l1: Iterable[T], l2: Iterable[T]) -&gt; list[T]:
    """Used instead of ``set.update()`` to maintain order,
        making sure duplicates are removed from l1, not l2.
        Removes overlap of l1 and l2 and then concatenates l2 unchanged.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; list_update([1, 2, 3], [2, 4, 4])
        [1, 3, 2, 4, 4]
    """
    return [e for e in l1 if e not in l2] + list(l2)


</t>
<t tx="ekr.20250122151621.75">@classmethod
def perpendicular_to(
    cls,
    line: Line3D,
    point: Vector3D = ORIGIN,
    length: float = 5,
    **kwargs,
) -&gt; Line3D:
    """Returns a line perpendicular to another line going through
    a given point.

    Parameters
    ----------
    line
        The line to be perpendicular to.
    point
        The point to pass through.
    length
        Length of the perpendicular line.
    kwargs
        Additional parameters to be passed to the class.

    Returns
    -------
    :class:`Line3D`
        Line perpendicular to ``line``.

    Examples
    --------
    .. manim:: PerpLineExample
        :save_last_frame:

        class PerpLineExample(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(PI / 3, -PI / 4)
                ax = ThreeDAxes((-5, 5), (-5, 5), (-5, 5), 10, 10, 10)
                line1 = Line3D(RIGHT * 2, UP + OUT, color=RED)
                line2 = Line3D.perpendicular_to(line1, color=BLUE)
                self.add(ax, line1, line2)
    """
    point = np.array(point)

    norm = np.cross(line.vect, point - line.start)
    if all(np.linalg.norm(norm) == np.zeros(3)):
        raise ValueError("Could not find the perpendicular.")

    start, end = perpendicular_bisector([line.start, line.end], norm)
    vect = normalize(end - start)
    return cls(
        point + vect * length / 2,
        point - vect * length / 2,
        **kwargs,
    )


</t>
<t tx="ekr.20250122151621.750">@overload
def listify(obj: str) -&gt; list[str]: ...


</t>
<t tx="ekr.20250122151621.751">@overload
def listify(obj: Iterable[T]) -&gt; list[T]: ...


</t>
<t tx="ekr.20250122151621.752">@overload
def listify(obj: T) -&gt; list[T]: ...


</t>
<t tx="ekr.20250122151621.753">def listify(obj: str | Iterable[T] | T) -&gt; list[str] | list[T]:
    """Converts obj to a list intelligently.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; listify("str")
        ['str']
        &gt;&gt;&gt; listify((1, 2))
        [1, 2]
        &gt;&gt;&gt; listify(len)
        [&lt;built-in function len&gt;]
    """
    if isinstance(obj, str):
        return [obj]
    if isinstance(obj, Iterable):
        return list(obj)
    else:
        return [obj]


</t>
<t tx="ekr.20250122151621.754">def make_even(
    iterable_1: Iterable[T], iterable_2: Iterable[U]
) -&gt; tuple[list[T], list[U]]:
    """Extends the shorter of the two iterables with duplicate values until its
        length is equal to the longer iterable (favours earlier elements).

    See Also
    --------
    make_even_by_cycling : cycles elements instead of favouring earlier ones

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; make_even([1, 2], [3, 4, 5, 6])
        ([1, 1, 2, 2], [3, 4, 5, 6])

        &gt;&gt;&gt; make_even([1, 2], [3, 4, 5, 6, 7])
        ([1, 1, 1, 2, 2], [3, 4, 5, 6, 7])
    """
    list_1, list_2 = list(iterable_1), list(iterable_2)
    len_list_1 = len(list_1)
    len_list_2 = len(list_2)
    length = max(len_list_1, len_list_2)
    return (
        [list_1[(n * len_list_1) // length] for n in range(length)],
        [list_2[(n * len_list_2) // length] for n in range(length)],
    )


</t>
<t tx="ekr.20250122151621.755">def make_even_by_cycling(
    iterable_1: Collection[T], iterable_2: Collection[U]
) -&gt; tuple[list[T], list[U]]:
    """Extends the shorter of the two iterables with duplicate values until its
        length is equal to the longer iterable (cycles over shorter iterable).

    See Also
    --------
    make_even : favours earlier elements instead of cycling them

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; make_even_by_cycling([1, 2], [3, 4, 5, 6])
        ([1, 2, 1, 2], [3, 4, 5, 6])

        &gt;&gt;&gt; make_even_by_cycling([1, 2], [3, 4, 5, 6, 7])
        ([1, 2, 1, 2, 1], [3, 4, 5, 6, 7])
    """
    length = max(len(iterable_1), len(iterable_2))
    cycle1 = it.cycle(iterable_1)
    cycle2 = it.cycle(iterable_2)
    return (
        [next(cycle1) for _ in range(length)],
        [next(cycle2) for _ in range(length)],
    )


</t>
<t tx="ekr.20250122151621.756">def remove_list_redundancies(lst: Reversible[H]) -&gt; list[H]:
    """Used instead of ``list(set(l))`` to maintain order.
    Keeps the last occurrence of each element.
    """
    reversed_result = []
    used = set()
    for x in reversed(lst):
        if x not in used:
            reversed_result.append(x)
            used.add(x)
    reversed_result.reverse()
    return reversed_result


</t>
<t tx="ekr.20250122151621.757">def remove_nones(sequence: Iterable[T | None]) -&gt; list[T]:
    """Removes elements where bool(x) evaluates to False.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; remove_nones(["m", "", "l", 0, 42, False, True])
        ['m', 'l', 42, True]
    """
    # Note this is redundant with it.chain
    return [x for x in sequence if x]


</t>
<t tx="ekr.20250122151621.758">def resize_array(nparray: npt.NDArray[F], length: int) -&gt; npt.NDArray[F]:
    """Extends/truncates nparray so that ``len(result) == length``.
        The elements of nparray are cycled to achieve the desired length.

    See Also
    --------
    resize_preserving_order : favours earlier elements instead of cycling them
    make_even_by_cycling : similar cycling behaviour for balancing 2 iterables

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; points = np.array([[1, 2], [3, 4]])
        &gt;&gt;&gt; resize_array(points, 1)
        array([[1, 2]])
        &gt;&gt;&gt; resize_array(points, 3)
        array([[1, 2],
               [3, 4],
               [1, 2]])
        &gt;&gt;&gt; resize_array(points, 2)
        array([[1, 2],
               [3, 4]])
    """
    if len(nparray) == length:
        return nparray
    return np.resize(nparray, (length, *nparray.shape[1:]))


</t>
<t tx="ekr.20250122151621.759">def resize_preserving_order(
    nparray: npt.NDArray[np.float64], length: int
) -&gt; npt.NDArray[np.float64]:
    """Extends/truncates nparray so that ``len(result) == length``.
        The elements of nparray are duplicated to achieve the desired length
        (favours earlier elements).

        Constructs a zeroes array of length if nparray is empty.

    See Also
    --------
    resize_array : cycles elements instead of favouring earlier ones
    make_even : similar earlier-favouring behaviour for balancing 2 iterables

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; resize_preserving_order(np.array([]), 5)
        array([0., 0., 0., 0., 0.])

        &gt;&gt;&gt; nparray = np.array([[1, 2], [3, 4]])
        &gt;&gt;&gt; resize_preserving_order(nparray, 1)
        array([[1, 2]])

        &gt;&gt;&gt; resize_preserving_order(nparray, 3)
        array([[1, 2],
               [1, 2],
               [3, 4]])
    """
    if len(nparray) == 0:
        return np.zeros((length, *nparray.shape[1:]))
    if len(nparray) == length:
        return nparray
    indices = np.arange(length) * len(nparray) // length
    return nparray[indices]


</t>
<t tx="ekr.20250122151621.76">def __init__(
    self,
    start: np.ndarray = LEFT,
    end: np.ndarray = RIGHT,
    thickness: float = 0.02,
    height: float = 0.3,
    base_radius: float = 0.08,
    color: ParsableManimColor = WHITE,
    resolution: int | Sequence[int] = 24,
    **kwargs,
) -&gt; None:
    super().__init__(
        start=start,
        end=end,
        thickness=thickness,
        color=color,
        resolution=resolution,
        **kwargs,
    )

    self.length = np.linalg.norm(self.vect)
    self.set_start_and_end_attrs(
        self.start,
        self.end - height * self.direction,
        **kwargs,
    )
    self.cone = Cone(
        direction=self.direction,
        base_radius=base_radius,
        height=height,
        **kwargs,
    )
    self.cone.shift(end)
    self.end_point = VectorizedPoint(end)
    self.add(self.end_point, self.cone)
    self.set_color(color)

</t>
<t tx="ekr.20250122151621.760">def resize_with_interpolation(nparray: npt.NDArray[F], length: int) -&gt; npt.NDArray[F]:
    """Extends/truncates nparray so that ``len(result) == length``.
        New elements are interpolated to achieve the desired length.

        Note that if nparray's length changes, its dtype may too
        (e.g. int -&gt; float: see Examples)

    See Also
    --------
    resize_array : cycles elements instead of interpolating
    resize_preserving_order : favours earlier elements instead of interpolating

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; nparray = np.array([[1, 2], [3, 4]])
        &gt;&gt;&gt; resize_with_interpolation(nparray, 1)
        array([[1., 2.]])
        &gt;&gt;&gt; resize_with_interpolation(nparray, 4)
        array([[1.        , 2.        ],
               [1.66666667, 2.66666667],
               [2.33333333, 3.33333333],
               [3.        , 4.        ]])
        &gt;&gt;&gt; nparray = np.array([[[1, 2], [3, 4]]])
        &gt;&gt;&gt; nparray = np.array([[1, 2], [3, 4], [5, 6]])
        &gt;&gt;&gt; resize_with_interpolation(nparray, 4)
        array([[1.        , 2.        ],
               [2.33333333, 3.33333333],
               [3.66666667, 4.66666667],
               [5.        , 6.        ]])
        &gt;&gt;&gt; nparray = np.array([[1, 2], [3, 4], [1, 2]])
        &gt;&gt;&gt; resize_with_interpolation(nparray, 4)
        array([[1.        , 2.        ],
               [2.33333333, 3.33333333],
               [2.33333333, 3.33333333],
               [1.        , 2.        ]])
    """
    if len(nparray) == length:
        return nparray
    cont_indices = np.linspace(0, len(nparray) - 1, length)
    return np.array(
        [
            (1 - a) * nparray[lh] + a * nparray[rh]
            for ci in cont_indices
            for lh, rh, a in [(int(ci), int(np.ceil(ci)), ci % 1)]
        ],
    )


</t>
<t tx="ekr.20250122151621.761">def stretch_array_to_length(nparray: npt.NDArray[F], length: int) -&gt; npt.NDArray[F]:
    # todo: is this the same as resize_preserving_order()?
    curr_len = len(nparray)
    if curr_len &gt; length:
        raise Warning("Trying to stretch array to a length shorter than its own")
    indices = np.arange(length) / float(length)
    indices *= curr_len
    return nparray[indices.astype(int)]


</t>
<t tx="ekr.20250122151621.762">@overload
def tuplify(obj: str) -&gt; tuple[str]: ...


</t>
<t tx="ekr.20250122151621.763">@overload
def tuplify(obj: Iterable[T]) -&gt; tuple[T]: ...


</t>
<t tx="ekr.20250122151621.764">@overload
def tuplify(obj: T) -&gt; tuple[T]: ...


</t>
<t tx="ekr.20250122151621.765">def tuplify(obj: str | Iterable[T] | T) -&gt; tuple[str] | tuple[T]:
    """Converts obj to a tuple intelligently.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; tuplify("str")
        ('str',)
        &gt;&gt;&gt; tuplify([1, 2])
        (1, 2)
        &gt;&gt;&gt; tuplify(len)
        (&lt;built-in function len&gt;,)
    """
    if isinstance(obj, str):
        return (obj,)
    if isinstance(obj, Iterable):
        return tuple(obj)
    else:
        return (obj,)


</t>
<t tx="ekr.20250122151621.766">def uniq_chain(*args: Iterable[T]) -&gt; Generator[T, None, None]:
    """Returns a generator that yields all unique elements of the Iterables
        provided via args in the order provided.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; gen = uniq_chain([1, 2], [2, 3], [1, 4, 4])
        &gt;&gt;&gt; from collections.abc import Generator
        &gt;&gt;&gt; isinstance(gen, Generator)
        True
        &gt;&gt;&gt; tuple(gen)
        (1, 2, 3, 4)
    """
    unique_items = set()
    for x in it.chain(*args):
        if x in unique_items:
            continue
        unique_items.add(x)
        yield x


</t>
<t tx="ekr.20250122151621.767">def hash_obj(obj: object) -&gt; int:
    """Determines a hash, even of potentially mutable objects."""
    if isinstance(obj, dict):
        return hash(tuple(sorted((hash_obj(k), hash_obj(v)) for k, v in obj.items())))

    if isinstance(obj, set):
        return hash(tuple(sorted(hash_obj(e) for e in obj)))

    if isinstance(obj, (tuple, list)):
        return hash(tuple(hash_obj(e) for e in obj))

    return hash(obj)
</t>
<t tx="ekr.20250122151621.768">from __future__ import annotations

import importlib.util
import inspect
import re
import sys
import types
import warnings
from pathlib import Path
from typing import TYPE_CHECKING, Literal, overload

from manim._config import config, console, logger
from manim.constants import (
    CHOOSE_NUMBER_MESSAGE,
    INVALID_NUMBER_MESSAGE,
    NO_SCENE_MESSAGE,
    SCENE_NOT_FOUND_MESSAGE,
)
from manim.scene.scene_file_writer import SceneFileWriter

if TYPE_CHECKING:
    from typing import Any

    from manim.scene.scene import Scene

__all__ = ["scene_classes_from_file"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.769">def get_module(file_name: Path) -&gt; types.ModuleType:
    if str(file_name) == "-":
        module = types.ModuleType("input_scenes")
        logger.info(
            "Enter the animation's code &amp; end with an EOF (CTRL+D on Linux/Unix, CTRL+Z on Windows):",
        )
        code = sys.stdin.read()
        if not code.startswith("from manim import"):
            logger.warning(
                "Didn't find an import statement for Manim. Importing automatically...",
            )
            code = "from manim import *\n" + code
        logger.info("Rendering animation from typed code...")
        try:
            exec(code, module.__dict__)
            return module
        except Exception as e:
            logger.error(f"Failed to render scene: {str(e)}")
            sys.exit(2)
    else:
        if file_name.exists():
            ext = file_name.suffix
            if ext != ".py":
                raise ValueError(f"{file_name} is not a valid Manim python script.")
            module_name = ".".join(file_name.with_suffix("").parts)

            warnings.filterwarnings(
                "default",
                category=DeprecationWarning,
                module=module_name,
            )

            spec = importlib.util.spec_from_file_location(module_name, file_name)
            if isinstance(spec, importlib.machinery.ModuleSpec):
                module = importlib.util.module_from_spec(spec)
                sys.modules[module_name] = module
                sys.path.insert(0, str(file_name.parent.absolute()))
                assert spec.loader
                spec.loader.exec_module(module)
                return module
            raise FileNotFoundError(f"{file_name} not found")
        else:
            raise FileNotFoundError(f"{file_name} not found")


</t>
<t tx="ekr.20250122151621.77">def get_end(self) -&gt; np.ndarray:
    return self.end_point.get_center()


</t>
<t tx="ekr.20250122151621.770">def get_scene_classes_from_module(module: types.ModuleType) -&gt; list[type[Scene]]:
    from ..scene.scene import Scene

    def is_child_scene(obj: Any, module: types.ModuleType) -&gt; bool:
        return (
            inspect.isclass(obj)
            and issubclass(obj, Scene)
            and obj != Scene
            and obj.__module__.startswith(module.__name__)
        )

    return [
        member[1]
        for member in inspect.getmembers(module, lambda x: is_child_scene(x, module))
    ]


</t>
<t tx="ekr.20250122151621.771">def get_scenes_to_render(scene_classes: list[type[Scene]]) -&gt; list[type[Scene]]:
    if not scene_classes:
        logger.error(NO_SCENE_MESSAGE)
        return []
    if config["write_all"]:
        return scene_classes
    result = []
    for scene_name in config["scene_names"]:
        found = False
        for scene_class in scene_classes:
            if scene_class.__name__ == scene_name:
                result.append(scene_class)
                found = True
                break
        if not found and (scene_name != ""):
            logger.error(SCENE_NOT_FOUND_MESSAGE.format(scene_name))
    if result:
        return result
    if len(scene_classes) == 1:
        config["scene_names"] = [scene_classes[0].__name__]
        return [scene_classes[0]]
    return prompt_user_for_choice(scene_classes)


</t>
<t tx="ekr.20250122151621.772">def prompt_user_for_choice(scene_classes: list[type[Scene]]) -&gt; list[type[Scene]]:
    num_to_class = {}
    SceneFileWriter.force_output_as_scene_name = True
    for count, scene_class in enumerate(scene_classes, 1):
        name = scene_class.__name__
        console.print(f"{count}: {name}", style="logging.level.info")
        num_to_class[count] = scene_class
    try:
        user_input = console.input(
            f"[log.message] {CHOOSE_NUMBER_MESSAGE} [/log.message]",
        )
        scene_classes = [
            num_to_class[int(num_str)]
            for num_str in re.split(r"\s*,\s*", user_input.strip())
        ]
        config["scene_names"] = [scene_class.__name__ for scene_class in scene_classes]
        return scene_classes
    except KeyError:
        logger.error(INVALID_NUMBER_MESSAGE)
        sys.exit(2)
    except EOFError:
        sys.exit(1)
    except ValueError:
        logger.error("No scenes were selected. Exiting.")
        sys.exit(1)


</t>
<t tx="ekr.20250122151621.773">@overload
def scene_classes_from_file(
    file_path: Path, require_single_scene: bool, full_list: Literal[True]
) -&gt; list[type[Scene]]: ...


</t>
<t tx="ekr.20250122151621.774">@overload
def scene_classes_from_file(
    file_path: Path,
    require_single_scene: Literal[True],
    full_list: Literal[False] = False,
) -&gt; type[Scene]: ...


</t>
<t tx="ekr.20250122151621.775">@overload
def scene_classes_from_file(
    file_path: Path,
    require_single_scene: Literal[False] = False,
    full_list: Literal[False] = False,
) -&gt; list[type[Scene]]: ...


</t>
<t tx="ekr.20250122151621.776">def scene_classes_from_file(
    file_path: Path, require_single_scene: bool = False, full_list: bool = False
) -&gt; type[Scene] | list[type[Scene]]:
    module = get_module(file_path)
    all_scene_classes = get_scene_classes_from_module(module)
    if full_list:
        return all_scene_classes
    scene_classes_to_render = get_scenes_to_render(all_scene_classes)
    if require_single_scene:
        assert len(scene_classes_to_render) == 1
        return scene_classes_to_render[0]
    return scene_classes_to_render
</t>
<t tx="ekr.20250122151621.777">from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np
import numpy.linalg as linalg

from manim._config import config
from manim.typing import ManimFloat

if TYPE_CHECKING:
    import numpy.typing as npt
    from typing_extensions import TypeAlias

    from manim.typing import MatrixMN, Point3D


if TYPE_CHECKING:
    from typing_extensions import TypeAlias

    from manim.typing import MatrixMN


depth = 20

__all__ = [
    "matrix_to_shader_input",
    "orthographic_projection_matrix",
    "perspective_projection_matrix",
    "translation_matrix",
    "x_rotation_matrix",
    "y_rotation_matrix",
    "z_rotation_matrix",
    "rotate_in_place_matrix",
    "rotation_matrix",
    "scale_matrix",
    "view_matrix",
]

FlattenedMatrix4x4: TypeAlias = tuple[
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
    float,
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.778">def matrix_to_shader_input(matrix: MatrixMN) -&gt; FlattenedMatrix4x4:
    return tuple(matrix.T.ravel())


</t>
<t tx="ekr.20250122151621.779">def orthographic_projection_matrix(
    width: float | None = None,
    height: float | None = None,
    near: float = 1,
    far: float = depth + 1,
    format_: bool = True,
) -&gt; MatrixMN | FlattenedMatrix4x4:
    if width is None:
        width = config["frame_width"]
    if height is None:
        height = config["frame_height"]
    projection_matrix = np.array(
        [
            [2 / width, 0, 0, 0],
            [0, 2 / height, 0, 0],
            [0, 0, -2 / (far - near), -(far + near) / (far - near)],
            [0, 0, 0, 1],
        ],
    )
    if format_:
        return matrix_to_shader_input(projection_matrix)
    else:
        return projection_matrix


</t>
<t tx="ekr.20250122151621.78">def __init__(
    self,
    major_radius: float = 3,
    minor_radius: float = 1,
    u_range: Sequence[float] = (0, TAU),
    v_range: Sequence[float] = (0, TAU),
    resolution: tuple[int, int] | None = None,
    **kwargs,
</t>
<t tx="ekr.20250122151621.780">def perspective_projection_matrix(
    width: float | None = None,
    height: float | None = None,
    near: float = 2,
    far: float = 50,
    format_: bool = True,
) -&gt; MatrixMN | FlattenedMatrix4x4:
    if width is None:
        width = config["frame_width"] / 6
    if height is None:
        height = config["frame_height"] / 6
    projection_matrix = np.array(
        [
            [2 * near / width, 0, 0, 0],
            [0, 2 * near / height, 0, 0],
            [0, 0, (far + near) / (near - far), (2 * far * near) / (near - far)],
            [0, 0, -1, 0],
        ],
    )
    if format_:
        return matrix_to_shader_input(projection_matrix)
    else:
        return projection_matrix


</t>
<t tx="ekr.20250122151621.781">def translation_matrix(x: float = 0, y: float = 0, z: float = 0) -&gt; MatrixMN:
    return np.array(
        [
            [1, 0, 0, x],
            [0, 1, 0, y],
            [0, 0, 1, z],
            [0, 0, 0, 1],
        ],
        dtype=ManimFloat,
    )


</t>
<t tx="ekr.20250122151621.782">def x_rotation_matrix(x: float = 0) -&gt; MatrixMN:
    return np.array(
        [
            [1, 0, 0, 0],
            [0, np.cos(x), -np.sin(x), 0],
            [0, np.sin(x), np.cos(x), 0],
            [0, 0, 0, 1],
        ],
    )


</t>
<t tx="ekr.20250122151621.783">def y_rotation_matrix(y: float = 0) -&gt; MatrixMN:
    return np.array(
        [
            [np.cos(y), 0, np.sin(y), 0],
            [0, 1, 0, 0],
            [-np.sin(y), 0, np.cos(y), 0],
            [0, 0, 0, 1],
        ],
    )


</t>
<t tx="ekr.20250122151621.784">def z_rotation_matrix(z: float = 0) -&gt; MatrixMN:
    return np.array(
        [
            [np.cos(z), -np.sin(z), 0, 0],
            [np.sin(z), np.cos(z), 0, 0],
            [0, 0, 1, 0],
            [0, 0, 0, 1],
        ],
    )


</t>
<t tx="ekr.20250122151621.785"># TODO: When rotating around the x axis, rotation eventually stops.
def rotate_in_place_matrix(
    initial_position: Point3D, x: float = 0, y: float = 0, z: float = 0
) -&gt; MatrixMN:
    return np.matmul(
        translation_matrix(*-initial_position),
        np.matmul(
            rotation_matrix(x, y, z),
            translation_matrix(*initial_position),
        ),
    )


</t>
<t tx="ekr.20250122151621.786">def rotation_matrix(x: float = 0, y: float = 0, z: float = 0) -&gt; MatrixMN:
    return np.matmul(
        np.matmul(x_rotation_matrix(x), y_rotation_matrix(y)),
        z_rotation_matrix(z),
    )


</t>
<t tx="ekr.20250122151621.787">def scale_matrix(scale_factor: float = 1) -&gt; npt.NDArray:
    return np.array(
        [
            [scale_factor, 0, 0, 0],
            [0, scale_factor, 0, 0],
            [0, 0, scale_factor, 0],
            [0, 0, 0, 1],
        ],
        dtype=ManimFloat,
    )


</t>
<t tx="ekr.20250122151621.788">def view_matrix(
    translation: Point3D | None = None,
    x_rotation: float = 0,
    y_rotation: float = 0,
    z_rotation: float = 0,
) -&gt; MatrixMN:
    if translation is None:
        translation = np.array([0, 0, depth / 2 + 1])
    model_matrix = np.matmul(
        np.matmul(
            translation_matrix(*translation),
            rotation_matrix(x=x_rotation, y=y_rotation, z=z_rotation),
        ),
        scale_matrix(),
    )
    return tuple(linalg.inv(model_matrix).T.ravel())
</t>
<t tx="ekr.20250122151621.789">from __future__ import annotations

from collections.abc import Iterable
from types import GeneratorType
from typing import TypeVar

T = TypeVar("T")


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.79">) -&gt; None:
    if config.renderer == RendererType.OPENGL:
        res_value = (101, 101)
    elif config.renderer == RendererType.CAIRO:
        res_value = (24, 24)

    resolution = resolution if resolution is not None else res_value

    self.R = major_radius
    self.r = minor_radius
    super().__init__(
        self.func,
        u_range=u_range,
        v_range=v_range,
        resolution=resolution,
        **kwargs,
    )

def func(self, u: float, v: float) -&gt; np.ndarray:
    """The z values defining the :class:`Torus` being plotted.

    Returns
    -------
    :class:`numpy.ndarray`
        The z values defining the :class:`Torus`.
    """
    P = np.array([np.cos(u), np.sin(u), 0])
    return (self.R - self.r * np.cos(v)) * P - self.r * np.sin(v) * OUT
</t>
<t tx="ekr.20250122151621.790">def flatten_iterable_parameters(
    args: Iterable[T | Iterable[T] | GeneratorType],
) -&gt; list[T]:
    """Flattens an iterable of parameters into a list of parameters.

    Parameters
    ----------
    args
        The iterable of parameters to flatten.
        [(generator), [], (), ...]

    Returns
    -------
    :class:`list`
        The flattened list of parameters.
    """
    flattened_parameters: list[T] = []
    for arg in args:
        if isinstance(arg, (Iterable, GeneratorType)):
            flattened_parameters.extend(arg)
        else:
            flattened_parameters.append(arg)
    return flattened_parameters
</t>
<t tx="ekr.20250122151621.791">"""Functions determining transformation paths between sets of points."""

from __future__ import annotations

__all__ = [
    "straight_path",
    "path_along_arc",
    "clockwise_path",
    "counterclockwise_path",
]


from typing import TYPE_CHECKING

import numpy as np

from ..constants import OUT
from ..utils.bezier import interpolate
from ..utils.space_ops import rotation_matrix

if TYPE_CHECKING:
    from manim.typing import PathFuncType, Point3D_Array, Vector3D


STRAIGHT_PATH_THRESHOLD = 0.01


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.792">def straight_path() -&gt; PathFuncType:
    """Simplest path function. Each point in a set goes in a straight path toward its destination.

    Examples
    --------

    .. manim :: StraightPathExample

        class StraightPathExample(Scene):
            def construct(self):
                colors = [RED, GREEN, BLUE]

                starting_points = VGroup(
                    *[
                        Dot(LEFT + pos, color=color)
                        for pos, color in zip([UP, DOWN, LEFT], colors)
                    ]
                )

                finish_points = VGroup(
                    *[
                        Dot(RIGHT + pos, color=color)
                        for pos, color in zip([ORIGIN, UP, DOWN], colors)
                    ]
                )

                self.add(starting_points)
                self.add(finish_points)
                for dot in starting_points:
                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))

                self.wait()
                self.play(
                    Transform(
                        starting_points,
                        finish_points,
                        path_func=utils.paths.straight_path(),
                        run_time=2,
                    )
                )
                self.wait()

    """
    return interpolate


</t>
<t tx="ekr.20250122151621.793">def path_along_circles(
    arc_angle: float, circles_centers: np.ndarray, axis: Vector3D = OUT
) -&gt; PathFuncType:
    """This function transforms each point by moving it roughly along a circle, each with its own specified center.

    The path may be seen as each point smoothly changing its orbit from its starting position to its destination.

    Parameters
    ----------
    arc_angle
        The angle each point traverses around the quasicircle.
    circles_centers
        The centers of each point's quasicircle to rotate around.
    axis
        The axis of rotation.

    Examples
    --------

    .. manim :: PathAlongCirclesExample

        class PathAlongCirclesExample(Scene):
            def construct(self):
                colors = [RED, GREEN, BLUE]

                starting_points = VGroup(
                    *[
                        Dot(LEFT + pos, color=color)
                        for pos, color in zip([UP, DOWN, LEFT], colors)
                    ]
                )

                finish_points = VGroup(
                    *[
                        Dot(RIGHT + pos, color=color)
                        for pos, color in zip([ORIGIN, UP, DOWN], colors)
                    ]
                )

                self.add(starting_points)
                self.add(finish_points)
                for dot in starting_points:
                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))

                circle_center = Dot(3 * LEFT)
                self.add(circle_center)

                self.wait()
                self.play(
                    Transform(
                        starting_points,
                        finish_points,
                        path_func=utils.paths.path_along_circles(
                            2 * PI, circle_center.get_center()
                        ),
                        run_time=3,
                    )
                )
                self.wait()

    """
    if np.linalg.norm(axis) == 0:
        axis = OUT
    unit_axis = axis / np.linalg.norm(axis)

    def path(
        start_points: Point3D_Array, end_points: Point3D_Array, alpha: float
    ) -&gt; Point3D_Array:
        detransformed_end_points = circles_centers + np.dot(
            end_points - circles_centers, rotation_matrix(-arc_angle, unit_axis).T
        )
        rot_matrix = rotation_matrix(alpha * arc_angle, unit_axis)
        return circles_centers + np.dot(
            interpolate(start_points, detransformed_end_points, alpha)
            - circles_centers,
            rot_matrix.T,
        )

    return path


</t>
<t tx="ekr.20250122151621.794">def path_along_arc(arc_angle: float, axis: Vector3D = OUT) -&gt; PathFuncType:
    """This function transforms each point by moving it along a circular arc.

    Parameters
    ----------
    arc_angle
        The angle each point traverses around a circular arc.
    axis
        The axis of rotation.

    Examples
    --------

    .. manim :: PathAlongArcExample

        class PathAlongArcExample(Scene):
            def construct(self):
                colors = [RED, GREEN, BLUE]

                starting_points = VGroup(
                    *[
                        Dot(LEFT + pos, color=color)
                        for pos, color in zip([UP, DOWN, LEFT], colors)
                    ]
                )

                finish_points = VGroup(
                    *[
                        Dot(RIGHT + pos, color=color)
                        for pos, color in zip([ORIGIN, UP, DOWN], colors)
                    ]
                )

                self.add(starting_points)
                self.add(finish_points)
                for dot in starting_points:
                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))

                self.wait()
                self.play(
                    Transform(
                        starting_points,
                        finish_points,
                        path_func=utils.paths.path_along_arc(TAU * 2 / 3),
                        run_time=3,
                    )
                )
                self.wait()

    """
    if abs(arc_angle) &lt; STRAIGHT_PATH_THRESHOLD:
        return straight_path()
    if np.linalg.norm(axis) == 0:
        axis = OUT
    unit_axis = axis / np.linalg.norm(axis)

    def path(
        start_points: Point3D_Array, end_points: Point3D_Array, alpha: float
    ) -&gt; Point3D_Array:
        vects = end_points - start_points
        centers = start_points + 0.5 * vects
        if arc_angle != np.pi:
            centers += np.cross(unit_axis, vects / 2.0) / np.tan(arc_angle / 2)
        rot_matrix = rotation_matrix(alpha * arc_angle, unit_axis)
        return centers + np.dot(start_points - centers, rot_matrix.T)

    return path


</t>
<t tx="ekr.20250122151621.795">def clockwise_path() -&gt; PathFuncType:
    """This function transforms each point by moving clockwise around a half circle.

    Examples
    --------

    .. manim :: ClockwisePathExample

        class ClockwisePathExample(Scene):
            def construct(self):
                colors = [RED, GREEN, BLUE]

                starting_points = VGroup(
                    *[
                        Dot(LEFT + pos, color=color)
                        for pos, color in zip([UP, DOWN, LEFT], colors)
                    ]
                )

                finish_points = VGroup(
                    *[
                        Dot(RIGHT + pos, color=color)
                        for pos, color in zip([ORIGIN, UP, DOWN], colors)
                    ]
                )

                self.add(starting_points)
                self.add(finish_points)
                for dot in starting_points:
                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))

                self.wait()
                self.play(
                    Transform(
                        starting_points,
                        finish_points,
                        path_func=utils.paths.clockwise_path(),
                        run_time=2,
                    )
                )
                self.wait()

    """
    return path_along_arc(-np.pi)


</t>
<t tx="ekr.20250122151621.796">def counterclockwise_path() -&gt; PathFuncType:
    """This function transforms each point by moving counterclockwise around a half circle.

    Examples
    --------

    .. manim :: CounterclockwisePathExample

        class CounterclockwisePathExample(Scene):
            def construct(self):
                colors = [RED, GREEN, BLUE]

                starting_points = VGroup(
                    *[
                        Dot(LEFT + pos, color=color)
                        for pos, color in zip([UP, DOWN, LEFT], colors)
                    ]
                )

                finish_points = VGroup(
                    *[
                        Dot(RIGHT + pos, color=color)
                        for pos, color in zip([ORIGIN, UP, DOWN], colors)
                    ]
                )

                self.add(starting_points)
                self.add(finish_points)
                for dot in starting_points:
                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))

                self.wait()
                self.play(
                    Transform(
                        starting_points,
                        finish_points,
                        path_func=utils.paths.counterclockwise_path(),
                        run_time=2,
                    )
                )
                self.wait()

    """
    return path_along_arc(np.pi)


</t>
<t tx="ekr.20250122151621.797">def spiral_path(angle: float, axis: Vector3D = OUT) -&gt; PathFuncType:
    """This function transforms each point by moving along a spiral to its destination.

    Parameters
    ----------
    angle
        The angle each point traverses around a spiral.
    axis
        The axis of rotation.

    Examples
    --------

    .. manim :: SpiralPathExample

        class SpiralPathExample(Scene):
            def construct(self):
                colors = [RED, GREEN, BLUE]

                starting_points = VGroup(
                    *[
                        Dot(LEFT + pos, color=color)
                        for pos, color in zip([UP, DOWN, LEFT], colors)
                    ]
                )

                finish_points = VGroup(
                    *[
                        Dot(RIGHT + pos, color=color)
                        for pos, color in zip([ORIGIN, UP, DOWN], colors)
                    ]
                )

                self.add(starting_points)
                self.add(finish_points)
                for dot in starting_points:
                    self.add(TracedPath(dot.get_center, stroke_color=dot.get_color()))

                self.wait()
                self.play(
                    Transform(
                        starting_points,
                        finish_points,
                        path_func=utils.paths.spiral_path(2 * TAU),
                        run_time=5,
                    )
                )
                self.wait()

    """
    if abs(angle) &lt; STRAIGHT_PATH_THRESHOLD:
        return straight_path()
    if np.linalg.norm(axis) == 0:
        axis = OUT
    unit_axis = axis / np.linalg.norm(axis)

    def path(
        start_points: Point3D_Array, end_points: Point3D_Array, alpha: float
    ) -&gt; Point3D_Array:
        rot_matrix = rotation_matrix((alpha - 1) * angle, unit_axis)
        return start_points + alpha * np.dot(end_points - start_points, rot_matrix.T)

    return path
</t>
<t tx="ekr.20250122151621.798">#!/usr/bin/env python
from __future__ import annotations

from queue import PriorityQueue
from typing import TYPE_CHECKING

import numpy as np

if TYPE_CHECKING:
    from collections.abc import Sequence

    from manim.typing import (
        Point2D,
        Point2D_Array,
        Point2DLike,
        Point2DLike_Array,
        Point3DLike_Array,
    )


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.799">class Polygon:
    """
    Initializes the Polygon with the given rings.

    Parameters
    ----------
    rings
        A collection of closed polygonal ring.
    """

    @others
</t>
<t tx="ekr.20250122151621.8">class Dodecahedron(Polyhedron):
    """A dodecahedron, one of the five platonic solids. It has 12 faces, 30 edges and 20 vertices.

    Parameters
    ----------
    edge_length
        The length of an edge between any two vertices.

    Examples
    --------

    .. manim:: DodecahedronScene
        :save_last_frame:

        class DodecahedronScene(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                obj = Dodecahedron()
                self.add(obj)
    """

    @others
</t>
<t tx="ekr.20250122151621.80"></t>
<t tx="ekr.20250122151621.800">class Cell:
    """
    A square in a mesh covering the :class:`~.Polygon` passed as an argument.

    Parameters
    ----------
    c
        Center coordinates of the Cell.
    h
        Half-Size of the Cell.
    polygon
        :class:`~.Polygon` object for which the distance is computed.
    """

    @others
</t>
<t tx="ekr.20250122151621.801">def polylabel(rings: Sequence[Point3DLike_Array], precision: float = 0.01) -&gt; Cell:
    """
    Finds the pole of inaccessibility (the point that is farthest from the edges of the polygon)
    using an iterative grid-based approach.

    Parameters
    ----------
    rings
        A list of lists, where each list is a sequence of points representing the rings of the polygon.
        Typically, multiple rings indicate holes in the polygon.
    precision
        The precision of the result (default is 0.01).

    Returns
    -------
    Cell
        A Cell containing the pole of inaccessibility to a given precision.
    """
    # Precompute Polygon Data
    np_rings: list[Point2D_Array] = [np.asarray(ring)[:, :2] for ring in rings]
    polygon = Polygon(np_rings)

    # Bounding Box
    mins = np.min(polygon.array, axis=0)
    maxs = np.max(polygon.array, axis=0)
    dims = maxs - mins
    s = np.min(dims)
    h = s / 2.0

    # Initial Grid
    queue: PriorityQueue[Cell] = PriorityQueue()
    xv, yv = np.meshgrid(np.arange(mins[0], maxs[0], s), np.arange(mins[1], maxs[1], s))
    for corner in np.vstack([xv.ravel(), yv.ravel()]).T:
        queue.put(Cell(corner + h, h, polygon))

    # Initial Guess
    best = Cell(polygon.centroid, 0, polygon)
    bbox = Cell(mins + (dims / 2), 0, polygon)
    if bbox.d &gt; best.d:
        best = bbox

    # While there are cells to consider...
    directions = np.array([[-1, -1], [1, -1], [-1, 1], [1, 1]])
    while not queue.empty():
        cell = queue.get()
        if cell &gt; best:
            best = cell
        # If a cell is promising, subdivide!
        if cell.p - best.d &gt; precision:
            h = cell.h / 2.0
            offsets = cell.c + directions * h
            queue.put(Cell(offsets[0], h, polygon))
            queue.put(Cell(offsets[1], h, polygon))
            queue.put(Cell(offsets[2], h, polygon))
            queue.put(Cell(offsets[3], h, polygon))
    return best
</t>
<t tx="ekr.20250122151621.802">def __init__(self, rings: Sequence[Point2DLike_Array]) -&gt; None:
    np_rings: list[Point2D_Array] = [np.asarray(ring) for ring in rings]
    # Flatten Array
    csum = np.cumsum([ring.shape[0] for ring in np_rings])
    self.array: Point2D_Array = np.concatenate(np_rings, axis=0)

    # Compute Boundary
    self.start: Point2D_Array = np.delete(self.array, csum - 1, axis=0)
    self.stop: Point2D_Array = np.delete(self.array, csum % csum[-1], axis=0)
    self.diff: Point2D_Array = np.delete(
        np.diff(self.array, axis=0), csum[:-1] - 1, axis=0
    )
    self.norm: Point2D_Array = self.diff / np.einsum(
        "ij,ij-&gt;i", self.diff, self.diff
    ).reshape(-1, 1)

    # Compute Centroid
    x, y = self.start[:, 0], self.start[:, 1]
    xr, yr = self.stop[:, 0], self.stop[:, 1]
    self.area: float = 0.5 * (np.dot(x, yr) - np.dot(xr, y))
    if self.area:
        factor = x * yr - xr * y
        cx = np.sum((x + xr) * factor) / (6.0 * self.area)
        cy = np.sum((y + yr) * factor) / (6.0 * self.area)
        self.centroid = np.array([cx, cy])

</t>
<t tx="ekr.20250122151621.803">def compute_distance(self, point: Point2DLike) -&gt; float:
    """Compute the minimum distance from a point to the polygon."""
    scalars = np.einsum("ij,ij-&gt;i", self.norm, point - self.start)
    clips = np.clip(scalars, 0, 1).reshape(-1, 1)
    d: float = np.min(
        np.linalg.norm(self.start + self.diff * clips - point, axis=1)
    )
    return d if self.inside(point) else -d

</t>
<t tx="ekr.20250122151621.804">def inside(self, point: Point2DLike) -&gt; bool:
    """Check if a point is inside the polygon."""
    # Views
    px, py = point
    x, y = self.start[:, 0], self.start[:, 1]
    xr, yr = self.stop[:, 0], self.stop[:, 1]

    # Count Crossings (enforce short-circuit)
    c = (y &gt; py) != (yr &gt; py)
    c = px &lt; x[c] + (py - y[c]) * (xr[c] - x[c]) / (yr[c] - y[c])
    c_sum: int = np.sum(c)
    return c_sum % 2 == 1


</t>
<t tx="ekr.20250122151621.805">def __init__(self, c: Point2DLike, h: float, polygon: Polygon) -&gt; None:
    self.c: Point2D = np.asarray(c)
    self.h = h
    self.d = polygon.compute_distance(self.c)
    self.p = self.d + self.h * np.sqrt(2)

</t>
<t tx="ekr.20250122151621.806">def __lt__(self, other: Cell) -&gt; bool:
    return self.d &lt; other.d

</t>
<t tx="ekr.20250122151621.807">def __gt__(self, other: Cell) -&gt; bool:
    return self.d &gt; other.d

</t>
<t tx="ekr.20250122151621.808">def __le__(self, other: Cell) -&gt; bool:
    return self.d &lt;= other.d

</t>
<t tx="ekr.20250122151621.809">def __ge__(self, other: Cell) -&gt; bool:
    return self.d &gt;= other.d


</t>
<t tx="ekr.20250122151621.81">"""Specialized mobject base classes.

Modules
=======

.. autosummary::
    :toctree: ../reference

    ~image_mobject
    ~point_cloud_mobject
    ~vectorized_mobject
"""
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.810">#!/usr/bin/env python
from __future__ import annotations

from typing import TYPE_CHECKING

import numpy as np

if TYPE_CHECKING:
    from manim.typing import PointND, PointND_Array


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.811">class QuickHullPoint:
    @others
</t>
<t tx="ekr.20250122151621.812">class SubFacet:
    @others
</t>
<t tx="ekr.20250122151621.813">class Facet:
    @others
</t>
<t tx="ekr.20250122151621.814">class Horizon:
    @others
</t>
<t tx="ekr.20250122151621.815">class QuickHull:
    """
    QuickHull algorithm for constructing a convex hull from a set of points.

    Parameters
    ----------
    tolerance
        A tolerance threshold for determining when points lie on the convex hull (default is 1e-5).

    Attributes
    ----------
    facets
        List of facets considered.
    removed
        Set of internal facets that have been removed from the hull during the construction process.
    outside
        Dictionary mapping each facet to its outside points and eye point.
    neighbors
        Mapping of subfacets to their neighboring facets. Each subfacet links precisely two neighbors.
    unclaimed
        Points that have not yet been classified as inside or outside the current hull.
    internal
        An internal point (i.e., the center of the initial simplex) used as a reference during hull construction.
    tolerance
        The tolerance used to determine if points are considered outside the current hull.
    """

    @others
</t>
<t tx="ekr.20250122151621.816">def __init__(self, coordinates: PointND_Array) -&gt; None:
    self.coordinates = coordinates

</t>
<t tx="ekr.20250122151621.817">def __hash__(self) -&gt; int:
    return hash(self.coordinates.tobytes())

</t>
<t tx="ekr.20250122151621.818">def __eq__(self, other: object) -&gt; bool:
    if not isinstance(other, QuickHullPoint):
        raise ValueError
    are_coordinates_equal: bool = np.array_equal(
        self.coordinates, other.coordinates
    )
    return are_coordinates_equal


</t>
<t tx="ekr.20250122151621.819">def __init__(self, coordinates: PointND_Array) -&gt; None:
    self.coordinates = coordinates
    self.points = frozenset(QuickHullPoint(c) for c in coordinates)

</t>
<t tx="ekr.20250122151621.82">"""Mobjects representing raster images."""

from __future__ import annotations

__all__ = ["AbstractImageMobject", "ImageMobject", "ImageMobjectFromCamera"]

import pathlib
from typing import TYPE_CHECKING

import numpy as np
from PIL import Image
from PIL.Image import Resampling

from manim.mobject.geometry.shape_matchers import SurroundingRectangle

from ... import config
from ...constants import *
from ...mobject.mobject import Mobject
from ...utils.bezier import interpolate
from ...utils.color import WHITE, ManimColor, color_to_int_rgb
from ...utils.images import change_to_rgba_array, get_full_raster_image_path

__all__ = ["ImageMobject", "ImageMobjectFromCamera"]

if TYPE_CHECKING:
    from typing import Any

    import numpy.typing as npt
    from typing_extensions import Self

    from manim.typing import StrPath


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.820">def __hash__(self) -&gt; int:
    return hash(self.points)

</t>
<t tx="ekr.20250122151621.821">def __eq__(self, other: object) -&gt; bool:
    if not isinstance(other, SubFacet):
        raise ValueError
    return self.points == other.points


</t>
<t tx="ekr.20250122151621.822">def __init__(self, coordinates: PointND_Array, internal: PointND) -&gt; None:
    self.coordinates = coordinates
    self.center: PointND = np.mean(coordinates, axis=0)
    self.normal = self.compute_normal(internal)
    self.subfacets = frozenset(
        SubFacet(np.delete(self.coordinates, i, axis=0))
        for i in range(self.coordinates.shape[0])
    )

</t>
<t tx="ekr.20250122151621.823">def compute_normal(self, internal: PointND) -&gt; PointND:
    centered = self.coordinates - self.center
    _, _, vh = np.linalg.svd(centered)
    normal: PointND = vh[-1, :]
    normal /= np.linalg.norm(normal)

    # If the normal points towards the internal point, flip it!
    if np.dot(normal, self.center - internal) &lt; 0:
        normal *= -1

    return normal

</t>
<t tx="ekr.20250122151621.824">def __hash__(self) -&gt; int:
    return hash(self.subfacets)

</t>
<t tx="ekr.20250122151621.825">def __eq__(self, other: object) -&gt; bool:
    if not isinstance(other, Facet):
        raise ValueError
    return self.subfacets == other.subfacets


</t>
<t tx="ekr.20250122151621.826">def __init__(self) -&gt; None:
    self.facets: set[Facet] = set()
    self.boundary: list[SubFacet] = []


</t>
<t tx="ekr.20250122151621.827">def __init__(self, tolerance: float = 1e-5) -&gt; None:
    self.facets: list[Facet] = []
    self.removed: set[Facet] = set()
    self.outside: dict[Facet, tuple[PointND_Array | None, PointND | None]] = {}
    self.neighbors: dict[SubFacet, set[Facet]] = {}
    self.unclaimed: PointND_Array | None = None
    self.internal: PointND | None = None
    self.tolerance = tolerance

</t>
<t tx="ekr.20250122151621.828">def initialize(self, points: PointND_Array) -&gt; None:
    # Sample Points
    simplex = points[
        np.random.choice(points.shape[0], points.shape[1] + 1, replace=False)
    ]
    self.unclaimed = points
    new_internal: PointND = np.mean(simplex, axis=0)
    self.internal = new_internal

    # Build Simplex
    for c in range(simplex.shape[0]):
        facet = Facet(np.delete(simplex, c, axis=0), internal=new_internal)
        self.classify(facet)
        self.facets.append(facet)

    # Attach Neighbors
    for f in self.facets:
        for sf in f.subfacets:
            self.neighbors.setdefault(sf, set()).add(f)

</t>
<t tx="ekr.20250122151621.829">def classify(self, facet: Facet) -&gt; None:
    assert self.unclaimed is not None, (
        "Call .initialize() before using .classify()."
    )

    if not self.unclaimed.size:
        self.outside[facet] = (None, None)
        return

    # Compute Projections
    projections = (self.unclaimed - facet.center) @ facet.normal
    arg = np.argmax(projections)
    mask = projections &gt; self.tolerance

    # Identify Eye and Outside Set
    eye = self.unclaimed[arg] if projections[arg] &gt; self.tolerance else None
    outside = self.unclaimed[mask]
    self.outside[facet] = (outside, eye)
    self.unclaimed = self.unclaimed[~mask]

</t>
<t tx="ekr.20250122151621.83">class AbstractImageMobject(Mobject):
    """
    Automatically filters out black pixels

    Parameters
    ----------
    scale_to_resolution
        At this resolution the image is placed pixel by pixel onto the screen, so it
        will look the sharpest and best.
        This is a custom parameter of ImageMobject so that rendering a scene with
        e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering
        won't effect the position of the image on the screen.
    """

    @others
</t>
<t tx="ekr.20250122151621.830">def compute_horizon(self, eye: PointND, start_facet: Facet) -&gt; Horizon:
    horizon = Horizon()
    self._recursive_horizon(eye, start_facet, horizon)
    return horizon

</t>
<t tx="ekr.20250122151621.831">def _recursive_horizon(self, eye: PointND, facet: Facet, horizon: Horizon) -&gt; bool:
    visible = np.dot(facet.normal, eye - facet.center) &gt; 0
    if not visible:
        return False

    # If the eye is visible from the facet:
    # Label the facet as visible and cross each edge
    horizon.facets.add(facet)
    for subfacet in facet.subfacets:
        neighbor = (self.neighbors[subfacet] - {facet}).pop()
        # If the neighbor is not visible, then the edge shared must be on the boundary
        if neighbor not in horizon.facets and not self._recursive_horizon(
            eye, neighbor, horizon
        ):
            horizon.boundary.append(subfacet)
    return True

</t>
<t tx="ekr.20250122151621.832">def build(self, points: PointND_Array) -&gt; None:
    num, dim = points.shape
    if (dim == 0) or (num &lt; dim + 1):
        raise ValueError("Not enough points supplied to build Convex Hull!")
    if dim == 1:
        raise ValueError("The Convex Hull of 1D data is its min-max!")

    self.initialize(points)

    # This helps the type checker.
    assert self.unclaimed is not None
    assert self.internal is not None

    while True:
        updated = False
        for facet in self.facets:
            if facet in self.removed:
                continue
            outside, eye = self.outside[facet]
            if eye is not None:
                updated = True
                horizon = self.compute_horizon(eye, facet)
                for f in horizon.facets:
                    points_to_append = self.outside[f][0]
                    # TODO: is this always true?
                    assert points_to_append is not None
                    self.unclaimed = np.vstack((self.unclaimed, points_to_append))
                    self.removed.add(f)
                    for sf in f.subfacets:
                        self.neighbors[sf].discard(f)
                        if self.neighbors[sf] == set():
                            del self.neighbors[sf]
                for sf in horizon.boundary:
                    nf = Facet(
                        np.vstack((sf.coordinates, eye)), internal=self.internal
                    )
                    self.classify(nf)
                    self.facets.append(nf)
                    for nsf in nf.subfacets:
                        self.neighbors.setdefault(nsf, set()).add(nf)
        if not updated:
            break
</t>
<t tx="ekr.20250122151621.833">"""A selection of rate functions, i.e., *speed curves* for animations.
Please find a standard list at https://easings.net/. Here is a picture
for the non-standard ones

.. manim:: RateFuncExample
    :save_last_frame:

    class RateFuncExample(Scene):
        def construct(self):
            x = VGroup()
            for k, v in rate_functions.__dict__.items():
                if "function" in str(v):
                    if (
                        not k.startswith("__")
                        and not k.startswith("sqrt")
                        and not k.startswith("bezier")
                    ):
                        try:
                            rate_func = v
                            plot = (
                                ParametricFunction(
                                    lambda x: [x, rate_func(x), 0],
                                    t_range=[0, 1, .01],
                                    use_smoothing=False,
                                    color=YELLOW,
                                )
                                .stretch_to_fit_width(1.5)
                                .stretch_to_fit_height(1)
                            )
                            plot_bg = SurroundingRectangle(plot).set_color(WHITE)
                            plot_title = (
                                Text(rate_func.__name__, weight=BOLD)
                                .scale(0.5)
                                .next_to(plot_bg, UP, buff=0.1)
                            )
                            x.add(VGroup(plot_bg, plot, plot_title))
                        except: # because functions `not_quite_there`, `function squish_rate_func` are not working.
                            pass
            x.arrange_in_grid(cols=8)
            x.height = config.frame_height
            x.width = config.frame_width
            x.move_to(ORIGIN).scale(0.95)
            self.add(x)


There are primarily 3 kinds of standard easing functions:

#. Ease In - The animation has a smooth start.
#. Ease Out - The animation has a smooth end.
#. Ease In Out - The animation has a smooth start as well as smooth end.

.. note:: The standard functions are not exported, so to use them you do something like this:
    rate_func=rate_functions.ease_in_sine
    On the other hand, the non-standard functions, which are used more commonly, are exported and can be used directly.

.. manim:: RateFunctions1Example

    class RateFunctions1Example(Scene):
        def construct(self):
            line1 = Line(3*LEFT, 3*RIGHT).shift(UP).set_color(RED)
            line2 = Line(3*LEFT, 3*RIGHT).set_color(GREEN)
            line3 = Line(3*LEFT, 3*RIGHT).shift(DOWN).set_color(BLUE)

            dot1 = Dot().move_to(line1.get_left())
            dot2 = Dot().move_to(line2.get_left())
            dot3 = Dot().move_to(line3.get_left())

            label1 = Tex("Ease In").next_to(line1, RIGHT)
            label2 = Tex("Ease out").next_to(line2, RIGHT)
            label3 = Tex("Ease In Out").next_to(line3, RIGHT)

            self.play(
                FadeIn(VGroup(line1, line2, line3)),
                FadeIn(VGroup(dot1, dot2, dot3)),
                Write(VGroup(label1, label2, label3)),
            )
            self.play(
                MoveAlongPath(dot1, line1, rate_func=rate_functions.ease_in_sine),
                MoveAlongPath(dot2, line2, rate_func=rate_functions.ease_out_sine),
                MoveAlongPath(dot3, line3, rate_func=rate_functions.ease_in_out_sine),
                run_time=7
            )
            self.wait()
"""

from __future__ import annotations

__all__ = [
    "linear",
    "smooth",
    "smoothstep",
    "smootherstep",
    "smoothererstep",
    "rush_into",
    "rush_from",
    "slow_into",
    "double_smooth",
    "there_and_back",
    "there_and_back_with_pause",
    "running_start",
    "not_quite_there",
    "wiggle",
    "squish_rate_func",
    "lingering",
    "exponential_decay",
]

from functools import wraps
from math import sqrt
from typing import Any, Protocol

import numpy as np

from manim.utils.simple_functions import sigmoid


# TODO: rewrite this to use ParamSpec when Python 3.9 is out of life
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.834">class RateFunction(Protocol):
    @others
</t>
<t tx="ekr.20250122151621.835"># This is a decorator that makes sure any function it's used on will
# return 0 if t&lt;0 and 1 if t&gt;1.
def unit_interval(function: RateFunction) -&gt; RateFunction:
    @wraps(function)
    def wrapper(t: float, *args: Any, **kwargs: Any) -&gt; float:
        if 0 &lt;= t &lt;= 1:
            return function(t, *args, **kwargs)
        elif t &lt; 0:
            return 0
        else:
            return 1

    return wrapper


</t>
<t tx="ekr.20250122151621.836"># This is a decorator that makes sure any function it's used on will
# return 0 if t&lt;0 or t&gt;1.
def zero(function: RateFunction) -&gt; RateFunction:
    @wraps(function)
    def wrapper(t: float, *args: Any, **kwargs: Any) -&gt; float:
        if 0 &lt;= t &lt;= 1:
            return function(t, *args, **kwargs)
        else:
            return 0

    return wrapper


</t>
<t tx="ekr.20250122151621.837">@unit_interval
def linear(t: float) -&gt; float:
    return t


</t>
<t tx="ekr.20250122151621.838">@unit_interval
def smooth(t: float, inflection: float = 10.0) -&gt; float:
    error = sigmoid(-inflection / 2)
    return min(
        max((sigmoid(inflection * (t - 0.5)) - error) / (1 - 2 * error), 0),
        1,
    )


</t>
<t tx="ekr.20250122151621.839">def smoothstep(t: float) -&gt; float:
    """Implementation of the 1st order SmoothStep sigmoid function.
    The 1st derivative (speed) is zero at the endpoints.
    https://en.wikipedia.org/wiki/Smoothstep
    """
    return 0 if t &lt;= 0 else 3 * t**2 - 2 * t**3 if t &lt; 1 else 1


</t>
<t tx="ekr.20250122151621.84">class ImageMobject(AbstractImageMobject):
    """Displays an Image from a numpy array or a file.

    Parameters
    ----------
    scale_to_resolution
        At this resolution the image is placed pixel by pixel onto the screen, so it
        will look the sharpest and best.
        This is a custom parameter of ImageMobject so that rendering a scene with
        e.g. the ``--quality low`` or ``--quality medium`` flag for faster rendering
        won't effect the position of the image on the screen.


    Example
    -------
    .. manim:: ImageFromArray
        :save_last_frame:

        class ImageFromArray(Scene):
            def construct(self):
                image = ImageMobject(np.uint8([[0, 100, 30, 200],
                                               [255, 0, 5, 33]]))
                image.height = 7
                self.add(image)


    Changing interpolation style:

    .. manim:: ImageInterpolationEx
        :save_last_frame:

        class ImageInterpolationEx(Scene):
            def construct(self):
                img = ImageMobject(np.uint8([[63, 0, 0, 0],
                                                [0, 127, 0, 0],
                                                [0, 0, 191, 0],
                                                [0, 0, 0, 255]
                                                ]))

                img.height = 2
                img1 = img.copy()
                img2 = img.copy()
                img3 = img.copy()
                img4 = img.copy()
                img5 = img.copy()

                img1.set_resampling_algorithm(RESAMPLING_ALGORITHMS["nearest"])
                img2.set_resampling_algorithm(RESAMPLING_ALGORITHMS["lanczos"])
                img3.set_resampling_algorithm(RESAMPLING_ALGORITHMS["linear"])
                img4.set_resampling_algorithm(RESAMPLING_ALGORITHMS["cubic"])
                img5.set_resampling_algorithm(RESAMPLING_ALGORITHMS["box"])
                img1.add(Text("nearest").scale(0.5).next_to(img1,UP))
                img2.add(Text("lanczos").scale(0.5).next_to(img2,UP))
                img3.add(Text("linear").scale(0.5).next_to(img3,UP))
                img4.add(Text("cubic").scale(0.5).next_to(img4,UP))
                img5.add(Text("box").scale(0.5).next_to(img5,UP))

                x= Group(img1,img2,img3,img4,img5)
                x.arrange()
                self.add(x)
    """

    @others
</t>
<t tx="ekr.20250122151621.840">def smootherstep(t: float) -&gt; float:
    """Implementation of the 2nd order SmoothStep sigmoid function.
    The 1st and 2nd derivatives (speed and acceleration) are zero at the endpoints.
    https://en.wikipedia.org/wiki/Smoothstep
    """
    return 0 if t &lt;= 0 else 6 * t**5 - 15 * t**4 + 10 * t**3 if t &lt; 1 else 1


</t>
<t tx="ekr.20250122151621.841">def smoothererstep(t: float) -&gt; float:
    """Implementation of the 3rd order SmoothStep sigmoid function.
    The 1st, 2nd and 3rd derivatives (speed, acceleration and jerk) are zero at the endpoints.
    https://en.wikipedia.org/wiki/Smoothstep
    """
    alpha: float = 0
    if 0 &lt; t &lt; 1:
        alpha = 35 * t**4 - 84 * t**5 + 70 * t**6 - 20 * t**7
    elif t &gt;= 1:
        alpha = 1
    return alpha


</t>
<t tx="ekr.20250122151621.842">@unit_interval
def rush_into(t: float, inflection: float = 10.0) -&gt; float:
    return 2 * smooth(t / 2.0, inflection)


</t>
<t tx="ekr.20250122151621.843">@unit_interval
def rush_from(t: float, inflection: float = 10.0) -&gt; float:
    return 2 * smooth(t / 2.0 + 0.5, inflection) - 1


</t>
<t tx="ekr.20250122151621.844">@unit_interval
def slow_into(t: float) -&gt; float:
    val: float = np.sqrt(1 - (1 - t) * (1 - t))
    return val


</t>
<t tx="ekr.20250122151621.845">@unit_interval
def double_smooth(t: float) -&gt; float:
    if t &lt; 0.5:
        return 0.5 * smooth(2 * t)
    else:
        return 0.5 * (1 + smooth(2 * t - 1))


</t>
<t tx="ekr.20250122151621.846">@zero
def there_and_back(t: float, inflection: float = 10.0) -&gt; float:
    new_t = 2 * t if t &lt; 0.5 else 2 * (1 - t)
    return smooth(new_t, inflection)


</t>
<t tx="ekr.20250122151621.847">@zero
def there_and_back_with_pause(t: float, pause_ratio: float = 1.0 / 3) -&gt; float:
    a = 2.0 / (1.0 - pause_ratio)
    if t &lt; 0.5 - pause_ratio / 2:
        return smooth(a * t)
    elif t &lt; 0.5 + pause_ratio / 2:
        return 1
    else:
        return smooth(a - a * t)


</t>
<t tx="ekr.20250122151621.848">@unit_interval
def running_start(
    t: float,
    pull_factor: float = -0.5,
) -&gt; float:
    t2 = t * t
    t3 = t2 * t
    t4 = t3 * t
    t5 = t4 * t
    t6 = t5 * t
    mt = 1 - t
    mt2 = mt * mt
    mt3 = mt2 * mt
    mt4 = mt3 * mt

    # This is equivalent to creating a Bézier with [0, 0, pull_factor, pull_factor, 1, 1, 1]
    # and evaluating it at t.
    return (
        15 * t2 * mt4 * pull_factor
        + 20 * t3 * mt3 * pull_factor
        + 15 * t4 * mt2
        + 6 * t5 * mt
        + t6
    )


</t>
<t tx="ekr.20250122151621.849">def not_quite_there(
    func: RateFunction = smooth,
    proportion: float = 0.7,
) -&gt; RateFunction:
    def result(t: float, *args: Any, **kwargs: Any) -&gt; float:
        return proportion * func(t, *args, **kwargs)

    return result


</t>
<t tx="ekr.20250122151621.85"># TODO, add the ability to have the dimensions/orientation of this
# mobject more strongly tied to the frame of the camera it contains,
# in the case where that's a MovingCamera


class ImageMobjectFromCamera(AbstractImageMobject):
    @others
</t>
<t tx="ekr.20250122151621.850">@zero
def wiggle(t: float, wiggles: float = 2) -&gt; float:
    val: float = np.sin(wiggles * np.pi * t)
    return there_and_back(t) * val


</t>
<t tx="ekr.20250122151621.851">def squish_rate_func(
    func: RateFunction,
    a: float = 0.4,
    b: float = 0.6,
) -&gt; RateFunction:
    def result(t: float, *args: Any, **kwargs: Any) -&gt; float:
        if a == b:
            return a

        if t &lt; a:
            new_t = 0.0
        elif t &gt; b:
            new_t = 1.0
        else:
            new_t = (t - a) / (b - a)
        return func(new_t, *args, **kwargs)

    return result


</t>
<t tx="ekr.20250122151621.852"># Stylistically, should this take parameters (with default values)?
# Ultimately, the functionality is entirely subsumed by squish_rate_func,
# but it may be useful to have a nice name for with nice default params for
# "lingering", different from squish_rate_func's default params


@unit_interval
def lingering(t: float) -&gt; float:
    def identity(t: float) -&gt; float:
        return t

    # TODO: Isn't this just 0.8 * t?
    return squish_rate_func(identity, 0, 0.8)(t)


</t>
<t tx="ekr.20250122151621.853">@unit_interval
def exponential_decay(t: float, half_life: float = 0.1) -&gt; float:
    # The half-life should be rather small to minimize
    # the cut-off error at the end
    val: float = 1 - np.exp(-t / half_life)
    return val


</t>
<t tx="ekr.20250122151621.854">@unit_interval
def ease_in_sine(t: float) -&gt; float:
    val: float = 1 - np.cos((t * np.pi) / 2)
    return val


</t>
<t tx="ekr.20250122151621.855">@unit_interval
def ease_out_sine(t: float) -&gt; float:
    val: float = np.sin((t * np.pi) / 2)
    return val


</t>
<t tx="ekr.20250122151621.856">@unit_interval
def ease_in_out_sine(t: float) -&gt; float:
    val: float = -(np.cos(np.pi * t) - 1) / 2
    return val


</t>
<t tx="ekr.20250122151621.857">@unit_interval
def ease_in_quad(t: float) -&gt; float:
    return t * t


</t>
<t tx="ekr.20250122151621.858">@unit_interval
def ease_out_quad(t: float) -&gt; float:
    return 1 - (1 - t) * (1 - t)


</t>
<t tx="ekr.20250122151621.859">@unit_interval
def ease_in_out_quad(t: float) -&gt; float:
    return 2 * t * t if t &lt; 0.5 else 1 - pow(-2 * t + 2, 2) / 2


</t>
<t tx="ekr.20250122151621.86">def __init__(
    self,
    scale_to_resolution: int,
    pixel_array_dtype: str = "uint8",
    resampling_algorithm: Resampling = Resampling.BICUBIC,
    **kwargs: Any,
) -&gt; None:
    self.pixel_array_dtype = pixel_array_dtype
    self.scale_to_resolution = scale_to_resolution
    self.set_resampling_algorithm(resampling_algorithm)
    super().__init__(**kwargs)

</t>
<t tx="ekr.20250122151621.860">@unit_interval
def ease_in_cubic(t: float) -&gt; float:
    return t * t * t


</t>
<t tx="ekr.20250122151621.861">@unit_interval
def ease_out_cubic(t: float) -&gt; float:
    return 1 - pow(1 - t, 3)


</t>
<t tx="ekr.20250122151621.862">@unit_interval
def ease_in_out_cubic(t: float) -&gt; float:
    return 4 * t * t * t if t &lt; 0.5 else 1 - pow(-2 * t + 2, 3) / 2


</t>
<t tx="ekr.20250122151621.863">@unit_interval
def ease_in_quart(t: float) -&gt; float:
    return t * t * t * t


</t>
<t tx="ekr.20250122151621.864">@unit_interval
def ease_out_quart(t: float) -&gt; float:
    return 1 - pow(1 - t, 4)


</t>
<t tx="ekr.20250122151621.865">@unit_interval
def ease_in_out_quart(t: float) -&gt; float:
    return 8 * t * t * t * t if t &lt; 0.5 else 1 - pow(-2 * t + 2, 4) / 2


</t>
<t tx="ekr.20250122151621.866">@unit_interval
def ease_in_quint(t: float) -&gt; float:
    return t * t * t * t * t


</t>
<t tx="ekr.20250122151621.867">@unit_interval
def ease_out_quint(t: float) -&gt; float:
    return 1 - pow(1 - t, 5)


</t>
<t tx="ekr.20250122151621.868">@unit_interval
def ease_in_out_quint(t: float) -&gt; float:
    return 16 * t * t * t * t * t if t &lt; 0.5 else 1 - pow(-2 * t + 2, 5) / 2


</t>
<t tx="ekr.20250122151621.869">@unit_interval
def ease_in_expo(t: float) -&gt; float:
    return 0 if t == 0 else pow(2, 10 * t - 10)


</t>
<t tx="ekr.20250122151621.87">def get_pixel_array(self) -&gt; None:
    raise NotImplementedError()

</t>
<t tx="ekr.20250122151621.870">@unit_interval
def ease_out_expo(t: float) -&gt; float:
    return 1 if t == 1 else 1 - pow(2, -10 * t)


</t>
<t tx="ekr.20250122151621.871">@unit_interval
def ease_in_out_expo(t: float) -&gt; float:
    if t == 0:
        return 0
    elif t == 1:
        return 1
    elif t &lt; 0.5:
        return pow(2, 20 * t - 10) / 2
    else:
        return (2 - pow(2, -20 * t + 10)) / 2


</t>
<t tx="ekr.20250122151621.872">@unit_interval
def ease_in_circ(t: float) -&gt; float:
    return 1 - sqrt(1 - pow(t, 2))


</t>
<t tx="ekr.20250122151621.873">@unit_interval
def ease_out_circ(t: float) -&gt; float:
    return sqrt(1 - pow(t - 1, 2))


</t>
<t tx="ekr.20250122151621.874">@unit_interval
def ease_in_out_circ(t: float) -&gt; float:
    return (
        (1 - sqrt(1 - pow(2 * t, 2))) / 2
        if t &lt; 0.5
        else (sqrt(1 - pow(-2 * t + 2, 2)) + 1) / 2
    )


</t>
<t tx="ekr.20250122151621.875">@unit_interval
def ease_in_back(t: float) -&gt; float:
    c1 = 1.70158
    c3 = c1 + 1
    return c3 * t * t * t - c1 * t * t


</t>
<t tx="ekr.20250122151621.876">@unit_interval
def ease_out_back(t: float) -&gt; float:
    c1 = 1.70158
    c3 = c1 + 1
    return 1 + c3 * pow(t - 1, 3) + c1 * pow(t - 1, 2)


</t>
<t tx="ekr.20250122151621.877">@unit_interval
def ease_in_out_back(t: float) -&gt; float:
    c1 = 1.70158
    c2 = c1 * 1.525
    return (
        (pow(2 * t, 2) * ((c2 + 1) * 2 * t - c2)) / 2
        if t &lt; 0.5
        else (pow(2 * t - 2, 2) * ((c2 + 1) * (t * 2 - 2) + c2) + 2) / 2
    )


</t>
<t tx="ekr.20250122151621.878">@unit_interval
def ease_in_elastic(t: float) -&gt; float:
    c4 = (2 * np.pi) / 3
    if t == 0:
        return 0
    elif t == 1:
        return 1
    else:
        val: float = -pow(2, 10 * t - 10) * np.sin((t * 10 - 10.75) * c4)
        return val


</t>
<t tx="ekr.20250122151621.879">@unit_interval
def ease_out_elastic(t: float) -&gt; float:
    c4 = (2 * np.pi) / 3
    if t == 0:
        return 0
    elif t == 1:
        return 1
    else:
        val: float = pow(2, -10 * t) * np.sin((t * 10 - 0.75) * c4) + 1
        return val


</t>
<t tx="ekr.20250122151621.88">def set_color(self, color, alpha=None, family=True):
    # Likely to be implemented in subclasses, but no obligation
    pass

</t>
<t tx="ekr.20250122151621.880">@unit_interval
def ease_in_out_elastic(t: float) -&gt; float:
    c5 = (2 * np.pi) / 4.5
    if t == 0:
        return 0
    elif t == 1:
        return 1
    elif t &lt; 0.5:
        val: float = -(pow(2, 20 * t - 10) * np.sin((20 * t - 11.125) * c5)) / 2
        return val
    else:
        val = (pow(2, -20 * t + 10) * np.sin((20 * t - 11.125) * c5)) / 2 + 1
        return val


</t>
<t tx="ekr.20250122151621.881">@unit_interval
def ease_in_bounce(t: float) -&gt; float:
    return 1 - ease_out_bounce(1 - t)


</t>
<t tx="ekr.20250122151621.882">@unit_interval
def ease_out_bounce(t: float) -&gt; float:
    n1 = 7.5625
    d1 = 2.75

    if t &lt; 1 / d1:
        return n1 * t * t
    elif t &lt; 2 / d1:
        return n1 * (t - 1.5 / d1) * (t - 1.5 / d1) + 0.75
    elif t &lt; 2.5 / d1:
        return n1 * (t - 2.25 / d1) * (t - 2.25 / d1) + 0.9375
    else:
        return n1 * (t - 2.625 / d1) * (t - 2.625 / d1) + 0.984375


</t>
<t tx="ekr.20250122151621.883">@unit_interval
def ease_in_out_bounce(t: float) -&gt; float:
    if t &lt; 0.5:
        return (1 - ease_out_bounce(1 - 2 * t)) / 2
    else:
        return (1 + ease_out_bounce(2 * t - 1)) / 2
</t>
<t tx="ekr.20250122151621.884">def __call__(self, t: float, *args: Any, **kwargs: Any) -&gt; float: ...


</t>
<t tx="ekr.20250122151621.885">"""A collection of simple functions."""

from __future__ import annotations

__all__ = [
    "binary_search",
    "choose",
    "clip",
    "sigmoid",
]


from functools import lru_cache
from typing import Any, Callable, Protocol, TypeVar

import numpy as np
from scipy import special


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.886">def binary_search(
    function: Callable[[float], float],
    target: float,
    lower_bound: float,
    upper_bound: float,
    tolerance: float = 1e-4,
) -&gt; float | None:
    """Searches for a value in a range by repeatedly dividing the range in half.

    To be more precise, performs numerical binary search to determine the
    input to ``function``, between the bounds given, that outputs ``target``
    to within ``tolerance`` (default of 0.0001).
    Returns ``None`` if no input can be found within the bounds.

    Examples
    --------

    Consider the polynomial :math:`x^2 + 3x + 1` where we search for
    a target value of :math:`11`. An exact solution is :math:`x = 2`.

    ::

        &gt;&gt;&gt; solution = binary_search(lambda x: x**2 + 3*x + 1, 11, 0, 5)
        &gt;&gt;&gt; bool(abs(solution - 2) &lt; 1e-4)
        True
        &gt;&gt;&gt; solution = binary_search(lambda x: x**2 + 3*x + 1, 11, 0, 5, tolerance=0.01)
        &gt;&gt;&gt; bool(abs(solution - 2) &lt; 0.01)
        True

    Searching in the interval :math:`[0, 5]` for a target value of :math:`71`
    does not yield a solution::

        &gt;&gt;&gt; binary_search(lambda x: x**2 + 3*x + 1, 71, 0, 5) is None
        True
    """
    lh = lower_bound
    rh = upper_bound
    mh: float = np.mean(np.array([lh, rh]))
    while abs(rh - lh) &gt; tolerance:
        mh = np.mean(np.array([lh, rh]))
        lx, mx, rx = (function(h) for h in (lh, mh, rh))
        if lx == target:
            return lh
        if rx == target:
            return rh

        if lx &lt;= target &lt;= rx:
            if mx &gt; target:
                rh = mh
            else:
                lh = mh
        elif lx &gt; target &gt; rx:
            lh, rh = rh, lh
        else:
            return None

    return mh


</t>
<t tx="ekr.20250122151621.887">@lru_cache(maxsize=10)
def choose(n: int, k: int) -&gt; int:
    r"""The binomial coefficient n choose k.

    :math:`\binom{n}{k}` describes the number of possible choices of
    :math:`k` elements from a set of :math:`n` elements.

    References
    ----------
    - https://en.wikipedia.org/wiki/Combination
    - https://docs.scipy.org/doc/scipy/reference/generated/scipy.special.comb.html
    """
    value: int = special.comb(n, k, exact=True)
    return value


</t>
<t tx="ekr.20250122151621.888">class Comparable(Protocol):
    @others
</t>
<t tx="ekr.20250122151621.889">ComparableT = TypeVar("ComparableT", bound=Comparable)  # noqa: Y001


def clip(a: ComparableT, min_a: ComparableT, max_a: ComparableT) -&gt; ComparableT:
    """Clips ``a`` to the interval [``min_a``, ``max_a``].

    Accepts any comparable objects (i.e. those that support &lt;, &gt;).
    Returns ``a`` if it is between ``min_a`` and ``max_a``.
    Otherwise, whichever of ``min_a`` and ``max_a`` is closest.

    Examples
    --------
    ::

        &gt;&gt;&gt; clip(15, 11, 20)
        15
        &gt;&gt;&gt; clip('a', 'h', 'k')
        'h'
    """
    if a &lt; min_a:
        return min_a
    elif a &gt; max_a:
        return max_a
    return a


</t>
<t tx="ekr.20250122151621.89">def set_resampling_algorithm(self, resampling_algorithm: int) -&gt; Self:
    """
    Sets the interpolation method for upscaling the image. By default the image is
    interpolated using bicubic algorithm. This method lets you change it.
    Interpolation is done internally using Pillow, and the function besides the
    string constants describing the algorithm accepts the Pillow integer constants.

    Parameters
    ----------
    resampling_algorithm
        An integer constant described in the Pillow library,
        or one from the RESAMPLING_ALGORITHMS global dictionary,
        under the following keys:

        * 'bicubic' or 'cubic'
        * 'nearest' or 'none'
        * 'box'
        * 'bilinear' or 'linear'
        * 'hamming'
        * 'lanczos' or 'antialias'
    """
    if isinstance(resampling_algorithm, int):
        self.resampling_algorithm = resampling_algorithm
    else:
        raise ValueError(
            "resampling_algorithm has to be an int, one of the values defined in "
            "RESAMPLING_ALGORITHMS or a Pillow resampling filter constant. "
            "Available algorithms: 'bicubic', 'nearest', 'box', 'bilinear', "
            "'hamming', 'lanczos'.",
        )
    return self

</t>
<t tx="ekr.20250122151621.890">def sigmoid(x: float) -&gt; float:
    r"""Returns the output of the logistic function.

    The logistic function, a common example of a sigmoid function, is defined
    as :math:`\frac{1}{1 + e^{-x}}`.

    References
    ----------
    - https://en.wikipedia.org/wiki/Sigmoid_function
    - https://en.wikipedia.org/wiki/Logistic_function
    """
    value: float = 1.0 / (1 + np.exp(-x))
    return value
</t>
<t tx="ekr.20250122151621.891">def __lt__(self, other: Any) -&gt; bool: ...

</t>
<t tx="ekr.20250122151621.892">def __gt__(self, other: Any) -&gt; bool: ...


</t>
<t tx="ekr.20250122151621.893">"""Sound-related utility functions."""

from __future__ import annotations

__all__ = [
    "get_full_sound_file_path",
]

from typing import TYPE_CHECKING

from .. import config
from ..utils.file_ops import seek_full_path_from_defaults

if TYPE_CHECKING:
    from pathlib import Path

    from manim.typing import StrPath


# Still in use by add_sound() function in scene_file_writer.py
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.894">def get_full_sound_file_path(sound_file_name: StrPath) -&gt; Path:
    return seek_full_path_from_defaults(
        sound_file_name,
        default_dir=config.get_dir("assets_dir"),
        extensions=[".wav", ".mp3"],
    )
</t>
<t tx="ekr.20250122151621.895">"""Utility functions for two- and three-dimensional vectors."""

from __future__ import annotations

import itertools as it
from collections.abc import Sequence
from typing import TYPE_CHECKING, Callable

import numpy as np
from mapbox_earcut import triangulate_float32 as earcut
from scipy.spatial.transform import Rotation

from manim.constants import DOWN, OUT, PI, RIGHT, TAU, UP
from manim.utils.iterables import adjacent_pairs

if TYPE_CHECKING:
    import numpy.typing as npt

    from manim.typing import (
        ManimFloat,
        MatrixMN,
        Point2D_Array,
        Point3D,
        Point3DLike,
        Point3DLike_Array,
        PointND,
        PointNDLike_Array,
        Vector2D,
        Vector2D_Array,
        Vector3D,
        Vector3D_Array,
    )

__all__ = [
    "quaternion_mult",
    "quaternion_from_angle_axis",
    "angle_axis_from_quaternion",
    "quaternion_conjugate",
    "rotate_vector",
    "thick_diagonal",
    "rotation_matrix",
    "rotation_about_z",
    "z_to_vector",
    "angle_of_vector",
    "angle_between_vectors",
    "normalize",
    "get_unit_normal",
    "compass_directions",
    "regular_vertices",
    "complex_to_R3",
    "R3_to_complex",
    "complex_func_to_R3_func",
    "center_of_mass",
    "midpoint",
    "find_intersection",
    "line_intersection",
    "get_winding_number",
    "shoelace",
    "shoelace_direction",
    "cross2d",
    "earclip_triangulation",
    "cartesian_to_spherical",
    "spherical_to_cartesian",
    "perpendicular_bisector",
]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.896">def norm_squared(v: float) -&gt; float:
    val: float = np.dot(v, v)
    return val


</t>
<t tx="ekr.20250122151621.897">def cross(v1: Vector3D, v2: Vector3D) -&gt; Vector3D:
    return np.array(
        [
            v1[1] * v2[2] - v1[2] * v2[1],
            v1[2] * v2[0] - v1[0] * v2[2],
            v1[0] * v2[1] - v1[1] * v2[0],
        ]
    )


</t>
<t tx="ekr.20250122151621.898"># Quaternions
# TODO, implement quaternion type


def quaternion_mult(
    *quats: Sequence[float],
) -&gt; np.ndarray | list[float | np.ndarray]:
    """Gets the Hamilton product of the quaternions provided.
    For more information, check `this Wikipedia page
    &lt;https://en.wikipedia.org/wiki/Quaternion&gt;`__.

    Returns
    -------
    Union[np.ndarray, List[Union[float, np.ndarray]]]
        Returns a list of product of two quaternions.
    """
    if len(quats) == 0:
        return [1, 0, 0, 0]
    result = quats[0]
    for next_quat in quats[1:]:
        w1, x1, y1, z1 = result
        w2, x2, y2, z2 = next_quat
        result = [
            w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2,
            w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2,
            w1 * y2 + y1 * w2 + z1 * x2 - x1 * z2,
            w1 * z2 + z1 * w2 + x1 * y2 - y1 * x2,
        ]
    return result


</t>
<t tx="ekr.20250122151621.899">def quaternion_from_angle_axis(
    angle: float,
    axis: np.ndarray,
    axis_normalized: bool = False,
) -&gt; list[float]:
    """Gets a quaternion from an angle and an axis.
    For more information, check `this Wikipedia page
    &lt;https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles&gt;`__.

    Parameters
    ----------
    angle
        The angle for the quaternion.
    axis
        The axis for the quaternion
    axis_normalized
        Checks whether the axis is normalized, by default False

    Returns
    -------
    list[float]
        Gives back a quaternion from the angle and axis
    """
    if not axis_normalized:
        axis = normalize(axis)
    return [np.cos(angle / 2), *(np.sin(angle / 2) * axis)]


</t>
<t tx="ekr.20250122151621.9">class ConvexHull3D(Polyhedron):
    """A convex hull for a set of points

    Parameters
    ----------
    points
        The points to consider.
    tolerance
        The tolerance used for quickhull.
    kwargs
        Forwarded to the parent constructor.

    Examples
    --------
    .. manim:: ConvexHull3DExample
        :save_last_frame:
        :quality: high

        class ConvexHull3DExample(ThreeDScene):
            def construct(self):
                self.set_camera_orientation(phi=75 * DEGREES, theta=30 * DEGREES)
                points = [
                    [ 1.93192757,  0.44134585, -1.52407061],
                    [-0.93302521,  1.23206983,  0.64117067],
                    [-0.44350918, -0.61043677,  0.21723705],
                    [-0.42640268, -1.05260843,  1.61266094],
                    [-1.84449637,  0.91238739, -1.85172623],
                    [ 1.72068132, -0.11880457,  0.51881751],
                    [ 0.41904805,  0.44938012, -1.86440686],
                    [ 0.83864666,  1.66653337,  1.88960123],
                    [ 0.22240514, -0.80986286,  1.34249326],
                    [-1.29585759,  1.01516189,  0.46187522],
                    [ 1.7776499,  -1.59550796, -1.70240747],
                    [ 0.80065226, -0.12530398,  1.70063977],
                    [ 1.28960948, -1.44158255,  1.39938582],
                    [-0.93538943,  1.33617705, -0.24852643],
                    [-1.54868271,  1.7444399,  -0.46170734]
                ]
                hull = ConvexHull3D(
                    *points,
                    faces_config = {"stroke_opacity": 0},
                    graph_config = {
                        "vertex_type": Dot3D,
                        "edge_config": {
                            "stroke_color": BLUE,
                            "stroke_width": 2,
                            "stroke_opacity": 0.05,
                        }
                    }
                )
                dots = VGroup(*[Dot3D(point) for point in points])
                self.add(hull)
                self.add(dots)
    """

    @others
</t>
<t tx="ekr.20250122151621.90">def reset_points(self) -&gt; None:
    """Sets :attr:`points` to be the four image corners."""
    self.points = np.array(
        [
            UP + LEFT,
            UP + RIGHT,
            DOWN + LEFT,
            DOWN + RIGHT,
        ],
    )
    self.center()
    h, w = self.get_pixel_array().shape[:2]
    if self.scale_to_resolution:
        height = h / self.scale_to_resolution * config["frame_height"]
    else:
        height = 3  # this is the case for ImageMobjectFromCamera
    self.stretch_to_fit_height(height)
    self.stretch_to_fit_width(height * w / h)


</t>
<t tx="ekr.20250122151621.900">def angle_axis_from_quaternion(quaternion: Sequence[float]) -&gt; Sequence[float]:
    """Gets angle and axis from a quaternion.

    Parameters
    ----------
    quaternion
        The quaternion from which we get the angle and axis.

    Returns
    -------
    Sequence[float]
        Gives the angle and axis
    """
    axis = normalize(quaternion[1:], fall_back=np.array([1, 0, 0]))
    angle = 2 * np.arccos(quaternion[0])
    if angle &gt; TAU / 2:
        angle = TAU - angle
    return angle, axis


</t>
<t tx="ekr.20250122151621.901">def quaternion_conjugate(quaternion: Sequence[float]) -&gt; np.ndarray:
    """Used for finding the conjugate of the quaternion

    Parameters
    ----------
    quaternion
        The quaternion for which you want to find the conjugate for.

    Returns
    -------
    np.ndarray
        The conjugate of the quaternion.
    """
    result = np.array(quaternion)
    result[1:] *= -1
    return result


</t>
<t tx="ekr.20250122151621.902">def rotate_vector(
    vector: np.ndarray, angle: float, axis: np.ndarray = OUT
) -&gt; np.ndarray:
    """Function for rotating a vector.

    Parameters
    ----------
    vector
        The vector to be rotated.
    angle
        The angle to be rotated by.
    axis
        The axis to be rotated, by default OUT

    Returns
    -------
    np.ndarray
        The rotated vector with provided angle and axis.

    Raises
    ------
    ValueError
        If vector is not of dimension 2 or 3.
    """
    if len(vector) &gt; 3:
        raise ValueError("Vector must have the correct dimensions.")
    if len(vector) == 2:
        vector = np.append(vector, 0)
    return rotation_matrix(angle, axis) @ vector


</t>
<t tx="ekr.20250122151621.903">def thick_diagonal(dim: int, thickness: int = 2) -&gt; MatrixMN:
    row_indices = np.arange(dim).repeat(dim).reshape((dim, dim))
    col_indices = np.transpose(row_indices)
    return (np.abs(row_indices - col_indices) &lt; thickness).astype("uint8")


</t>
<t tx="ekr.20250122151621.904">def rotation_matrix_transpose_from_quaternion(quat: np.ndarray) -&gt; list[np.ndarray]:
    """Converts the quaternion, quat, to an equivalent rotation matrix representation.
    For more information, check `this page
    &lt;https://in.mathworks.com/help/driving/ref/quaternion.rotmat.html&gt;`_.

    Parameters
    ----------
    quat
        The quaternion which is to be converted.

    Returns
    -------
    List[np.ndarray]
        Gives back the Rotation matrix representation, returned as a 3-by-3
        matrix or 3-by-3-by-N multidimensional array.
    """
    quat_inv = quaternion_conjugate(quat)
    return [
        quaternion_mult(quat, [0, *basis], quat_inv)[1:]
        for basis in [
            [1, 0, 0],
            [0, 1, 0],
            [0, 0, 1],
        ]
    ]


</t>
<t tx="ekr.20250122151621.905">def rotation_matrix_from_quaternion(quat: np.ndarray) -&gt; np.ndarray:
    return np.transpose(rotation_matrix_transpose_from_quaternion(quat))


</t>
<t tx="ekr.20250122151621.906">def rotation_matrix_transpose(angle: float, axis: np.ndarray) -&gt; np.ndarray:
    if all(np.array(axis)[:2] == np.zeros(2)):
        return rotation_about_z(angle * np.sign(axis[2])).T
    return rotation_matrix(angle, axis).T


</t>
<t tx="ekr.20250122151621.907">def rotation_matrix(
    angle: float,
    axis: np.ndarray,
    homogeneous: bool = False,
) -&gt; np.ndarray:
    """Rotation in R^3 about a specified axis of rotation."""
    inhomogeneous_rotation_matrix = Rotation.from_rotvec(
        angle * normalize(np.array(axis))
    ).as_matrix()
    if not homogeneous:
        return inhomogeneous_rotation_matrix
    else:
        rotation_matrix = np.eye(4)
        rotation_matrix[:3, :3] = inhomogeneous_rotation_matrix
        return rotation_matrix


</t>
<t tx="ekr.20250122151621.908">def rotation_about_z(angle: float) -&gt; np.ndarray:
    """Returns a rotation matrix for a given angle.

    Parameters
    ----------
    angle
        Angle for the rotation matrix.

    Returns
    -------
    np.ndarray
        Gives back the rotated matrix.
    """
    c, s = np.cos(angle), np.sin(angle)
    return np.array(
        [
            [c, -s, 0],
            [s, c, 0],
            [0, 0, 1],
        ]
    )


</t>
<t tx="ekr.20250122151621.909">def z_to_vector(vector: np.ndarray) -&gt; np.ndarray:
    """
    Returns some matrix in SO(3) which takes the z-axis to the
    (normalized) vector provided as an argument
    """
    axis_z = normalize(vector)
    axis_y = normalize(cross(axis_z, RIGHT))
    axis_x = cross(axis_y, axis_z)
    if np.linalg.norm(axis_y) == 0:
        # the vector passed just so happened to be in the x direction.
        axis_x = normalize(cross(UP, axis_z))
        axis_y = -cross(axis_x, axis_z)

    return np.array([axis_x, axis_y, axis_z]).T


</t>
<t tx="ekr.20250122151621.91">def __init__(
    self,
    filename_or_array: StrPath | npt.NDArray,
    scale_to_resolution: int = QUALITIES[DEFAULT_QUALITY]["pixel_height"],
    invert: bool = False,
    image_mode: str = "RGBA",
    **kwargs: Any,
) -&gt; None:
    self.fill_opacity: float = 1
    self.stroke_opacity: float = 1
    self.invert_image = invert
    self.image_mode = image_mode
    if isinstance(filename_or_array, (str, pathlib.PurePath)):
        path = get_full_raster_image_path(filename_or_array)
        image = Image.open(path).convert(self.image_mode)
        self.pixel_array = np.array(image)
        self.path = path
    else:
        self.pixel_array = np.array(filename_or_array)
    self.pixel_array_dtype = kwargs.get("pixel_array_dtype", "uint8")
    self.pixel_array = change_to_rgba_array(
        self.pixel_array, self.pixel_array_dtype
    )
    if self.invert_image:
        self.pixel_array[:, :, :3] = (
            np.iinfo(self.pixel_array_dtype).max - self.pixel_array[:, :, :3]
        )
    super().__init__(scale_to_resolution, **kwargs)

</t>
<t tx="ekr.20250122151621.910">def angle_of_vector(vector: Sequence[float] | np.ndarray) -&gt; float:
    """Returns polar coordinate theta when vector is projected on xy plane.

    Parameters
    ----------
    vector
        The vector to find the angle for.

    Returns
    -------
    float
        The angle of the vector projected.
    """
    if isinstance(vector, np.ndarray) and len(vector.shape) &gt; 1:
        if vector.shape[0] &lt; 2:
            raise ValueError("Vector must have the correct dimensions. (2, n)")
        c_vec = np.empty(vector.shape[1], dtype=np.complex128)
        c_vec.real = vector[0]
        c_vec.imag = vector[1]
        val1: float = np.angle(c_vec)
        return val1
    val: float = np.angle(complex(*vector[:2]))
    return val


</t>
<t tx="ekr.20250122151621.911">def angle_between_vectors(v1: np.ndarray, v2: np.ndarray) -&gt; float:
    """Returns the angle between two vectors.
    This angle will always be between 0 and pi

    Parameters
    ----------
    v1
        The first vector.
    v2
        The second vector.

    Returns
    -------
    float
        The angle between the vectors.
    """
    val: float = 2 * np.arctan2(
        np.linalg.norm(normalize(v1) - normalize(v2)),
        np.linalg.norm(normalize(v1) + normalize(v2)),
    )

    return val


</t>
<t tx="ekr.20250122151621.912">def normalize(
    vect: np.ndarray | tuple[float], fall_back: np.ndarray | None = None
) -&gt; np.ndarray:
    norm = np.linalg.norm(vect)
    if norm &gt; 0:
        return np.array(vect) / norm
    else:
        return fall_back or np.zeros(len(vect))


</t>
<t tx="ekr.20250122151621.913">def normalize_along_axis(array: np.ndarray, axis: np.ndarray) -&gt; np.ndarray:
    """Normalizes an array with the provided axis.

    Parameters
    ----------
    array
        The array which has to be normalized.
    axis
        The axis to be normalized to.

    Returns
    -------
    np.ndarray
        Array which has been normalized according to the axis.
    """
    norms = np.sqrt((array * array).sum(axis))
    norms[norms == 0] = 1
    buffed_norms = np.repeat(norms, array.shape[axis]).reshape(array.shape)
    array /= buffed_norms
    return array


</t>
<t tx="ekr.20250122151621.914">def get_unit_normal(v1: Vector3D, v2: Vector3D, tol: float = 1e-6) -&gt; Vector3D:
    """Gets the unit normal of the vectors.

    Parameters
    ----------
    v1
        The first vector.
    v2
        The second vector
    tol
        [description], by default 1e-6

    Returns
    -------
    np.ndarray
        The normal of the two vectors.
    """
    # Instead of normalizing v1 and v2, just divide by the greatest
    # of all their absolute components, which is just enough
    div1, div2 = max(np.abs(v1)), max(np.abs(v2))
    if div1 == 0.0:
        if div2 == 0.0:
            return DOWN
        u = v2 / div2
    elif div2 == 0.0:
        u = v1 / div1
    else:
        # Normal scenario: v1 and v2 are both non-null
        u1, u2 = v1 / div1, v2 / div2
        cp = cross(u1, u2)
        cp_norm = np.sqrt(norm_squared(cp))
        if cp_norm &gt; tol:
            return cp / cp_norm
        # Otherwise, v1 and v2 were aligned
        u = u1

    # If you are here, you have an "unique", non-zero, unit-ish vector u
    # If it's also too aligned to the Z axis, just return DOWN
    if abs(u[0]) &lt; tol and abs(u[1]) &lt; tol:
        return DOWN
    # Otherwise rotate u in the plane it shares with the Z axis,
    # 90° TOWARDS the Z axis. This is done via (u x [0, 0, 1]) x u,
    # which gives [-xz, -yz, x²+y²] (slightly scaled as well)
    cp = np.array([-u[0] * u[2], -u[1] * u[2], u[0] * u[0] + u[1] * u[1]])
    cp_norm = np.sqrt(norm_squared(cp))
    # Because the norm(u) == 0 case was filtered in the beginning,
    # there is no need to check if the norm of cp is 0
    return cp / cp_norm


</t>
<t tx="ekr.20250122151621.915">###


def compass_directions(n: int = 4, start_vect: np.ndarray = RIGHT) -&gt; np.ndarray:
    """Finds the cardinal directions using tau.

    Parameters
    ----------
    n
        The amount to be rotated, by default 4
    start_vect
        The direction for the angle to start with, by default RIGHT

    Returns
    -------
    np.ndarray
        The angle which has been rotated.
    """
    angle = TAU / n
    return np.array([rotate_vector(start_vect, k * angle) for k in range(n)])


</t>
<t tx="ekr.20250122151621.916">def regular_vertices(
    n: int, *, radius: float = 1, start_angle: float | None = None
) -&gt; tuple[np.ndarray, float]:
    """Generates regularly spaced vertices around a circle centered at the origin.

    Parameters
    ----------
    n
        The number of vertices
    radius
        The radius of the circle that the vertices are placed on.
    start_angle
        The angle the vertices start at.

        If unspecified, for even ``n`` values, ``0`` will be used.
        For odd ``n`` values, 90 degrees is used.

    Returns
    -------
    vertices : :class:`numpy.ndarray`
        The regularly spaced vertices.
    start_angle : :class:`float`
        The angle the vertices start at.
    """
    if start_angle is None:
        start_angle = 0 if n % 2 == 0 else TAU / 4

    start_vector = rotate_vector(RIGHT * radius, start_angle)
    vertices = compass_directions(n, start_vector)

    return vertices, start_angle


</t>
<t tx="ekr.20250122151621.917">def complex_to_R3(complex_num: complex) -&gt; np.ndarray:
    return np.array((complex_num.real, complex_num.imag, 0))


</t>
<t tx="ekr.20250122151621.918">def R3_to_complex(point: Sequence[float]) -&gt; np.ndarray:
    return complex(*point[:2])


</t>
<t tx="ekr.20250122151621.919">def complex_func_to_R3_func(
    complex_func: Callable[[complex], complex],
) -&gt; Callable[[Point3DLike], Point3D]:
    return lambda p: complex_to_R3(complex_func(R3_to_complex(p)))


</t>
<t tx="ekr.20250122151621.92">def get_pixel_array(self):
    """A simple getter method."""
    return self.pixel_array

</t>
<t tx="ekr.20250122151621.920">def center_of_mass(points: PointNDLike_Array) -&gt; PointND:
    """Gets the center of mass of the points in space.

    Parameters
    ----------
    points
        The points to find the center of mass from.

    Returns
    -------
    np.ndarray
        The center of mass of the points.
    """
    return np.average(points, 0, np.ones(len(points)))


</t>
<t tx="ekr.20250122151621.921">def midpoint(
    point1: Sequence[float],
    point2: Sequence[float],
) -&gt; float | np.ndarray:
    """Gets the midpoint of two points.

    Parameters
    ----------
    point1
        The first point.
    point2
        The second point.

    Returns
    -------
    Union[float, np.ndarray]
        The midpoint of the points
    """
    return center_of_mass([point1, point2])


</t>
<t tx="ekr.20250122151621.922">def line_intersection(
    line1: Sequence[np.ndarray], line2: Sequence[np.ndarray]
) -&gt; np.ndarray:
    """Returns the intersection point of two lines, each defined by
    a pair of distinct points lying on the line.

    Parameters
    ----------
    line1
        A list of two points that determine the first line.
    line2
        A list of two points that determine the second line.

    Returns
    -------
    np.ndarray
        The intersection points of the two lines which are intersecting.

    Raises
    ------
    ValueError
        Error is produced if the two lines don't intersect with each other
        or if the coordinates don't lie on the xy-plane.
    """
    if any(np.array([line1, line2])[:, :, 2].reshape(-1)):
        # checks for z coordinates != 0
        raise ValueError("Coords must be in the xy-plane.")

    # algorithm from https://stackoverflow.com/a/42727584
    padded = (
        np.pad(np.array(i)[:, :2], ((0, 0), (0, 1)), constant_values=1)
        for i in (line1, line2)
    )
    line1, line2 = (cross(*i) for i in padded)
    x, y, z = cross(line1, line2)

    if z == 0:
        raise ValueError(
            "The lines are parallel, there is no unique intersection point."
        )

    return np.array([x / z, y / z, 0])


</t>
<t tx="ekr.20250122151621.923">def find_intersection(
    p0s: Point3DLike_Array,
    v0s: Vector3D_Array,
    p1s: Point3DLike_Array,
    v1s: Vector3D_Array,
    threshold: float = 1e-5,
) -&gt; list[Point3D]:
    """
    Return the intersection of a line passing through p0 in direction v0
    with one passing through p1 in direction v1 (or array of intersections
    from arrays of such points/directions).
    For 3d values, it returns the point on the ray p0 + v0 * t closest to the
    ray p1 + v1 * t
    """
    # algorithm from https://en.wikipedia.org/wiki/Skew_lines#Nearest_points
    result = []

    for p0, v0, p1, v1 in zip(*[p0s, v0s, p1s, v1s]):
        normal = cross(v1, cross(v0, v1))
        denom = max(np.dot(v0, normal), threshold)
        result += [p0 + np.dot(p1 - p0, normal) / denom * v0]
    return result


</t>
<t tx="ekr.20250122151621.924">def get_winding_number(points: Sequence[np.ndarray]) -&gt; float:
    """Determine the number of times a polygon winds around the origin.

    The orientation is measured mathematically positively, i.e.,
    counterclockwise.

    Parameters
    ----------
    points
        The vertices of the polygon being queried.

    Examples
    --------

    &gt;&gt;&gt; from manim import Square, get_winding_number
    &gt;&gt;&gt; polygon = Square()
    &gt;&gt;&gt; get_winding_number(polygon.get_vertices())
    np.float64(1.0)
    &gt;&gt;&gt; polygon.shift(2 * UP)
    Square
    &gt;&gt;&gt; get_winding_number(polygon.get_vertices())
    np.float64(0.0)
    """
    total_angle: float = 0
    for p1, p2 in adjacent_pairs(points):
        d_angle = angle_of_vector(p2) - angle_of_vector(p1)
        d_angle = ((d_angle + PI) % TAU) - PI
        total_angle += d_angle
    val: float = total_angle / TAU
    return val


</t>
<t tx="ekr.20250122151621.925">def shoelace(x_y: Point2D_Array) -&gt; float:
    """2D implementation of the shoelace formula.

    Returns
    -------
    :class:`float`
        Returns signed area.
    """
    x = x_y[:, 0]
    y = x_y[:, 1]
    val: float = np.trapz(y, x)
    return val


</t>
<t tx="ekr.20250122151621.926">def shoelace_direction(x_y: Point2D_Array) -&gt; str:
    """
    Uses the area determined by the shoelace method to determine whether
    the input set of points is directed clockwise or counterclockwise.

    Returns
    -------
    :class:`str`
        Either ``"CW"`` or ``"CCW"``.
    """
    area = shoelace(x_y)
    return "CW" if area &gt; 0 else "CCW"


</t>
<t tx="ekr.20250122151621.927">def cross2d(
    a: Vector2D | Vector2D_Array,
    b: Vector2D | Vector2D_Array,
) -&gt; ManimFloat | npt.NDArray[ManimFloat]:
    """Compute the determinant(s) of the passed
    vector (sequences).

    Parameters
    ----------
    a
        A vector or a sequence of vectors.
    b
        A vector or a sequence of vectors.

    Returns
    -------
    Sequence[float] | float
        The determinant or sequence of determinants
        of the first two components of the specified
        vectors.

    Examples
    --------
    .. code-block:: pycon

        &gt;&gt;&gt; cross2d(np.array([1, 2]), np.array([3, 4]))
        np.int64(-2)
        &gt;&gt;&gt; cross2d(
        ...     np.array([[1, 2, 0], [1, 0, 0]]),
        ...     np.array([[3, 4, 0], [0, 1, 0]]),
        ... )
        array([-2,  1])
    """
    if len(a.shape) == 2:
        return a[:, 0] * b[:, 1] - a[:, 1] * b[:, 0]
    else:
        return a[0] * b[1] - b[0] * a[1]


</t>
<t tx="ekr.20250122151621.928">def earclip_triangulation(verts: np.ndarray, ring_ends: list) -&gt; list:
    """Returns a list of indices giving a triangulation
    of a polygon, potentially with holes.

    Parameters
    ----------
    verts
        verts is a numpy array of points.
    ring_ends
        ring_ends is a list of indices indicating where
        the ends of new paths are.

    Returns
    -------
    list
        A list of indices giving a triangulation of a polygon.
    """
    # First, connect all the rings so that the polygon
    # with holes is instead treated as a (very convex)
    # polygon with one edge.  Do this by drawing connections
    # between rings close to each other
    rings = [list(range(e0, e1)) for e0, e1 in zip([0, *ring_ends], ring_ends)]
    attached_rings = rings[:1]
    detached_rings = rings[1:]
    loop_connections = {}

    while detached_rings:
        i_range, j_range = (
            list(
                filter(
                    # Ignore indices that are already being
                    # used to draw some connection
                    lambda i: i not in loop_connections,
                    it.chain(*ring_group),
                ),
            )
            for ring_group in (attached_rings, detached_rings)
        )

        # Closest point on the attached rings to an estimated midpoint
        # of the detached rings
        tmp_j_vert = midpoint(verts[j_range[0]], verts[j_range[len(j_range) // 2]])
        i = min(i_range, key=lambda i: norm_squared(verts[i] - tmp_j_vert))
        # Closest point of the detached rings to the aforementioned
        # point of the attached rings
        j = min(j_range, key=lambda j: norm_squared(verts[i] - verts[j]))
        # Recalculate i based on new j
        i = min(i_range, key=lambda i: norm_squared(verts[i] - verts[j]))

        # Remember to connect the polygon at these points
        loop_connections[i] = j
        loop_connections[j] = i

        # Move the ring which j belongs to from the
        # attached list to the detached list
        new_ring = next(
            (ring for ring in detached_rings if ring[0] &lt;= j &lt; ring[-1]), None
        )
        if new_ring is not None:
            detached_rings.remove(new_ring)
            attached_rings.append(new_ring)
        else:
            raise Exception("Could not find a ring to attach")

    # Setup linked list
    after: list[int] = []
    end0 = 0
    for end1 in ring_ends:
        after.extend(range(end0 + 1, end1))
        after.append(end0)
        end0 = end1

    # Find an ordering of indices walking around the polygon
    indices = []
    i = 0
    for _ in range(len(verts) + len(ring_ends) - 1):
        # starting = False
        if i in loop_connections:
            j = loop_connections[i]
            indices.extend([i, j])
            i = after[j]
        else:
            indices.append(i)
            i = after[i]
        if i == 0:
            break

    meta_indices = earcut(verts[indices, :2], [len(indices)])
    return [indices[mi] for mi in meta_indices]


</t>
<t tx="ekr.20250122151621.929">def cartesian_to_spherical(vec: Sequence[float]) -&gt; np.ndarray:
    """Returns an array of numbers corresponding to each
    polar coordinate value (distance, phi, theta).

    Parameters
    ----------
    vec
        A numpy array ``[x, y, z]``.
    """
    norm = np.linalg.norm(vec)
    if norm == 0:
        return 0, 0, 0
    r = norm
    phi = np.arccos(vec[2] / r)
    theta = np.arctan2(vec[1], vec[0])
    return np.array([r, theta, phi])


</t>
<t tx="ekr.20250122151621.93">def set_color(self, color, alpha=None, family=True):
    rgb = color_to_int_rgb(color)
    self.pixel_array[:, :, :3] = rgb
    if alpha is not None:
        self.pixel_array[:, :, 3] = int(255 * alpha)
    for submob in self.submobjects:
        submob.set_color(color, alpha, family)
    self.color = color
    return self

</t>
<t tx="ekr.20250122151621.930">def spherical_to_cartesian(spherical: Sequence[float]) -&gt; np.ndarray:
    """Returns a numpy array ``[x, y, z]`` based on the spherical
    coordinates given.

    Parameters
    ----------
    spherical
        A list of three floats that correspond to the following:

        r - The distance between the point and the origin.

        theta - The azimuthal angle of the point to the positive x-axis.

        phi - The vertical angle of the point to the positive z-axis.
    """
    r, theta, phi = spherical
    return np.array(
        [
            r * np.cos(theta) * np.sin(phi),
            r * np.sin(theta) * np.sin(phi),
            r * np.cos(phi),
        ],
    )


</t>
<t tx="ekr.20250122151621.931">def perpendicular_bisector(
    line: Sequence[np.ndarray],
    norm_vector: Vector3D = OUT,
) -&gt; Sequence[np.ndarray]:
    """Returns a list of two points that correspond
    to the ends of the perpendicular bisector of the
    two points given.

    Parameters
    ----------
    line
        a list of two numpy array points (corresponding
        to the ends of a line).
    norm_vector
        the vector perpendicular to both the line given
        and the perpendicular bisector.

    Returns
    -------
    list
        A list of two numpy array points that correspond
        to the ends of the perpendicular bisector
    """
    p1 = line[0]
    p2 = line[1]
    direction = cross(p1 - p2, norm_vector)
    m = midpoint(p1, p2)
    return [m + direction, m - direction]
</t>
<t tx="ekr.20250122151621.932">"""Utilities for processing LaTeX templates."""

from __future__ import annotations

__all__ = [
    "TexTemplate",
]

import copy
import re
import warnings
from dataclasses import dataclass, field
from pathlib import Path
from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    from typing_extensions import Self

    from manim.typing import StrPath

_DEFAULT_PREAMBLE = r"""\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}"""

_BEGIN_DOCUMENT = r"\begin{document}"
_END_DOCUMENT = r"\end{document}"


@dataclass(eq=True)
@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.933">class TexTemplate:
    """TeX templates are used to create ``Tex`` and ``MathTex`` objects."""

    @others
</t>
<t tx="ekr.20250122151621.934">def _texcode_for_environment(environment: str) -&gt; tuple[str, str]:
    r"""Processes the tex_environment string to return the correct ``\begin{environment}[extra]{extra}`` and
    ``\end{environment}`` strings.

    Parameters
    ----------
    environment
        The tex_environment as a string. Acceptable formats include:
        ``{align*}``, ``align*``, ``{tabular}[t]{cccl}``, ``tabular}{cccl``, ``\begin{tabular}[t]{cccl}``.

    Returns
    -------
    Tuple[:class:`str`, :class:`str`]
        A pair of strings representing the opening and closing of the tex environment, e.g.
        ``\begin{tabular}{cccl}`` and ``\end{tabular}``
    """
    environment.removeprefix(r"\begin").removeprefix("{")

    # The \begin command takes everything and closes with a brace
    begin = r"\begin{" + environment
    # If it doesn't end on } or ], assume missing }
    if not begin.endswith(("}", "]")):
        begin += "}"

    # While the \end command terminates at the first closing brace
    split_at_brace = re.split("}", environment, maxsplit=1)
    end = r"\end{" + split_at_brace[0] + "}"

    return begin, end
</t>
<t tx="ekr.20250122151621.935">_body: str = field(default="", init=False)
"""A custom body, can be set from a file."""

tex_compiler: str = "latex"
"""The TeX compiler to be used, e.g. ``latex``, ``pdflatex`` or ``lualatex``."""

description: str = ""
"""A description of the template"""

output_format: str = ".dvi"
"""The output format resulting from compilation, e.g. ``.dvi`` or ``.pdf``."""

documentclass: str = r"\documentclass[preview]{standalone}"
r"""The command defining the documentclass, e.g. ``\documentclass[preview]{standalone}``."""

preamble: str = _DEFAULT_PREAMBLE
r"""The document's preamble, i.e. the part between ``\documentclass`` and ``\begin{document}``."""

placeholder_text: str = "YourTextHere"
"""Text in the document that will be replaced by the expression to be rendered."""

post_doc_commands: str = ""
r"""Text (definitions, commands) to be inserted at right after ``\begin{document}``, e.g. ``\boldmath``."""

@property
def body(self) -&gt; str:
    """The entire TeX template."""
    return self._body or "\n".join(
        filter(
            None,
            [
                self.documentclass,
                self.preamble,
                _BEGIN_DOCUMENT,
                self.post_doc_commands,
                self.placeholder_text,
                _END_DOCUMENT,
            ],
        )
    )

</t>
<t tx="ekr.20250122151621.936">@body.setter
def body(self, value: str) -&gt; None:
    self._body = value

</t>
<t tx="ekr.20250122151621.937">@classmethod
def from_file(cls, file: StrPath = "tex_template.tex", **kwargs: Any) -&gt; Self:
    """Create an instance by reading the content of a file.

    Using the ``add_to_preamble`` and ``add_to_document`` methods on this instance
    will have no effect, as the body is read from the file.
    """
    instance = cls(**kwargs)
    instance.body = Path(file).read_text(encoding="utf-8")
    return instance

</t>
<t tx="ekr.20250122151621.938">def add_to_preamble(self, txt: str, prepend: bool = False) -&gt; Self:
    r"""Adds text to the TeX template's preamble (e.g. definitions, packages). Text can be inserted at the beginning or at the end of the preamble.

    Parameters
    ----------
    txt
        String containing the text to be added, e.g. ``\usepackage{hyperref}``.
    prepend
        Whether the text should be added at the beginning of the preamble, i.e. right after ``\documentclass``.
        Default is to add it at the end of the preamble, i.e. right before ``\begin{document}``.
    """
    if self._body:
        warnings.warn(
            "This TeX template was created with a fixed body, trying to add text the preamble will have no effect.",
            UserWarning,
            stacklevel=2,
        )
    if prepend:
        self.preamble = txt + "\n" + self.preamble
    else:
        self.preamble += "\n" + txt
    return self

</t>
<t tx="ekr.20250122151621.939">def add_to_document(self, txt: str) -&gt; Self:
    r"""Adds text to the TeX template just after \begin{document}, e.g. ``\boldmath``.

    Parameters
    ----------
    txt
        String containing the text to be added.
    """
    if self._body:
        warnings.warn(
            "This TeX template was created with a fixed body, trying to add text the document will have no effect.",
            UserWarning,
            stacklevel=2,
        )
    self.post_doc_commands += txt
    return self

</t>
<t tx="ekr.20250122151621.94">def set_opacity(self, alpha: float) -&gt; Self:
    """Sets the image's opacity.

    Parameters
    ----------
    alpha
        The alpha value of the object, 1 being opaque and 0 being
        transparent.
    """
    self.pixel_array[:, :, 3] = int(255 * alpha)
    self.fill_opacity = alpha
    self.stroke_opacity = alpha
    return self

</t>
<t tx="ekr.20250122151621.940">def get_texcode_for_expression(self, expression: str) -&gt; str:
    r"""Inserts expression verbatim into TeX template.

    Parameters
    ----------
    expression
        The string containing the expression to be typeset, e.g. ``$\sqrt{2}$``

    Returns
    -------
    :class:`str`
        LaTeX code based on current template, containing the given ``expression`` and ready for typesetting
    """
    return self.body.replace(self.placeholder_text, expression)

</t>
<t tx="ekr.20250122151621.941">def get_texcode_for_expression_in_env(
    self, expression: str, environment: str
) -&gt; str:
    r"""Inserts expression into TeX template wrapped in ``\begin{environment}`` and ``\end{environment}``.

    Parameters
    ----------
    expression
        The string containing the expression to be typeset, e.g. ``$\sqrt{2}$``.
    environment
        The string containing the environment in which the expression should be typeset, e.g. ``align*``.

    Returns
    -------
    :class:`str`
        LaTeX code based on template, containing the given expression inside its environment, ready for typesetting
    """
    begin, end = _texcode_for_environment(environment)
    return self.body.replace(
        self.placeholder_text, "\n".join([begin, expression, end])
    )

</t>
<t tx="ekr.20250122151621.942">def copy(self) -&gt; Self:
    """Create a deep copy of the TeX template instance."""
    return copy.deepcopy(self)


</t>
<t tx="ekr.20250122151621.943">"""Interface for writing, compiling, and converting ``.tex`` files.

.. SEEALSO::

    :mod:`.mobject.svg.tex_mobject`

"""

from __future__ import annotations

import hashlib
import re
import subprocess
import unicodedata
from collections.abc import Generator, Iterable, Sequence
from pathlib import Path
from re import Match
from typing import Any

from manim.utils.tex import TexTemplate

from .. import config, logger

__all__ = ["tex_to_svg_file"]


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.944">def tex_hash(expression: Any) -&gt; str:
    id_str = str(expression)
    hasher = hashlib.sha256()
    hasher.update(id_str.encode())
    # Truncating at 16 bytes for cleanliness
    return hasher.hexdigest()[:16]


</t>
<t tx="ekr.20250122151621.945">def tex_to_svg_file(
    expression: str,
    environment: str | None = None,
    tex_template: TexTemplate | None = None,
) -&gt; Path:
    r"""Takes a tex expression and returns the svg version of the compiled tex

    Parameters
    ----------
    expression
        String containing the TeX expression to be rendered, e.g. ``\\sqrt{2}`` or ``foo``
    environment
        The string containing the environment in which the expression should be typeset, e.g. ``align*``
    tex_template
        Template class used to typesetting. If not set, use default template set via `config["tex_template"]`

    Returns
    -------
    :class:`Path`
        Path to generated SVG file.
    """
    if tex_template is None:
        tex_template = config["tex_template"]
    tex_file = generate_tex_file(expression, environment, tex_template)

    # check if svg already exists
    svg_file = tex_file.with_suffix(".svg")
    if svg_file.exists():
        return svg_file

    dvi_file = compile_tex(
        tex_file,
        tex_template.tex_compiler,
        tex_template.output_format,
    )
    svg_file = convert_to_svg(dvi_file, tex_template.output_format)
    if not config["no_latex_cleanup"]:
        delete_nonsvg_files()
    return svg_file


</t>
<t tx="ekr.20250122151621.946">def generate_tex_file(
    expression: str,
    environment: str | None = None,
    tex_template: TexTemplate | None = None,
) -&gt; Path:
    r"""Takes a tex expression (and an optional tex environment),
    and returns a fully formed tex file ready for compilation.

    Parameters
    ----------
    expression
        String containing the TeX expression to be rendered, e.g. ``\\sqrt{2}`` or ``foo``
    environment
        The string containing the environment in which the expression should be typeset, e.g. ``align*``
    tex_template
        Template class used to typesetting. If not set, use default template set via `config["tex_template"]`

    Returns
    -------
    :class:`Path`
        Path to generated TeX file
    """
    if tex_template is None:
        tex_template = config["tex_template"]
    if environment is not None:
        output = tex_template.get_texcode_for_expression_in_env(expression, environment)
    else:
        output = tex_template.get_texcode_for_expression(expression)

    tex_dir = config.get_dir("tex_dir")
    if not tex_dir.exists():
        tex_dir.mkdir()

    result = tex_dir / (tex_hash(output) + ".tex")
    if not result.exists():
        logger.info(
            "Writing %(expression)s to %(path)s",
            {"expression": expression, "path": f"{result}"},
        )
        result.write_text(output, encoding="utf-8")
    return result


</t>
<t tx="ekr.20250122151621.947">def make_tex_compilation_command(
    tex_compiler: str, output_format: str, tex_file: Path, tex_dir: Path
) -&gt; list[str]:
    """Prepares the TeX compilation command, i.e. the TeX compiler name
    and all necessary CLI flags.

    Parameters
    ----------
    tex_compiler
        String containing the compiler to be used, e.g. ``pdflatex`` or ``lualatex``
    output_format
        String containing the output format generated by the compiler, e.g. ``.dvi`` or ``.pdf``
    tex_file
        File name of TeX file to be typeset.
    tex_dir
        Path to the directory where compiler output will be stored.

    Returns
    -------
    :class:`list[str]`
        Compilation command according to given parameters
    """
    if tex_compiler in {"latex", "pdflatex", "luatex", "lualatex"}:
        command = [
            tex_compiler,
            "-interaction=batchmode",
            f"-output-format={output_format[1:]}",
            "-halt-on-error",
            f"-output-directory={tex_dir.as_posix()}",
            f"{tex_file.as_posix()}",
        ]
    elif tex_compiler == "xelatex":
        if output_format == ".xdv":
            outflag = ["-no-pdf"]
        elif output_format == ".pdf":
            outflag = []
        else:
            raise ValueError("xelatex output is either pdf or xdv")
        command = [
            "xelatex",
            *outflag,
            "-interaction=batchmode",
            "-halt-on-error",
            f"-output-directory={tex_dir.as_posix()}",
            f"{tex_file.as_posix()}",
        ]
    else:
        raise ValueError(f"Tex compiler {tex_compiler} unknown.")
    return command


</t>
<t tx="ekr.20250122151621.948">def insight_inputenc_error(matching: Match[str]) -&gt; Generator[str]:
    code_point = chr(int(matching[1], 16))
    name = unicodedata.name(code_point)
    yield f"TexTemplate does not support character '{name}' (U+{matching[1]})."
    yield "See the documentation for manim.mobject.svg.tex_mobject for details on using a custom TexTemplate."


</t>
<t tx="ekr.20250122151621.949">def insight_package_not_found_error(matching: Match[str]) -&gt; Generator[str]:
    yield f"You do not have package {matching[1]} installed."
    yield f"Install {matching[1]} it using your LaTeX package manager, or check for typos."


</t>
<t tx="ekr.20250122151621.95">def fade(self, darkness: float = 0.5, family: bool = True) -&gt; Self:
    """Sets the image's opacity using a 1 - alpha relationship.

    Parameters
    ----------
    darkness
        The alpha value of the object, 1 being transparent and 0 being
        opaque.
    family
        Whether the submobjects of the ImageMobject should be affected.
    """
    self.set_opacity(1 - darkness)
    super().fade(darkness, family)
    return self

</t>
<t tx="ekr.20250122151621.950">def compile_tex(tex_file: Path, tex_compiler: str, output_format: str) -&gt; Path:
    """Compiles a tex_file into a .dvi or a .xdv or a .pdf

    Parameters
    ----------
    tex_file
        File name of TeX file to be typeset.
    tex_compiler
        String containing the compiler to be used, e.g. ``pdflatex`` or ``lualatex``
    output_format
        String containing the output format generated by the compiler, e.g. ``.dvi`` or ``.pdf``

    Returns
    -------
    :class:`Path`
        Path to generated output file in desired format (DVI, XDV or PDF).
    """
    result = tex_file.with_suffix(output_format)
    tex_dir = config.get_dir("tex_dir")
    if not result.exists():
        command = make_tex_compilation_command(
            tex_compiler,
            output_format,
            tex_file,
            tex_dir,
        )
        cp = subprocess.run(command, stdout=subprocess.DEVNULL)
        if cp.returncode != 0:
            log_file = tex_file.with_suffix(".log")
            print_all_tex_errors(log_file, tex_compiler, tex_file)
            raise ValueError(
                f"{tex_compiler} error converting to"
                f" {output_format[1:]}. See log output above or"
                f" the log file: {log_file}",
            )
    return result


</t>
<t tx="ekr.20250122151621.951">def convert_to_svg(dvi_file: Path, extension: str, page: int = 1) -&gt; Path:
    """Converts a .dvi, .xdv, or .pdf file into an svg using dvisvgm.

    Parameters
    ----------
    dvi_file
        File name of the input file to be converted.
    extension
        String containing the file extension and thus indicating the file type, e.g. ``.dvi`` or ``.pdf``
    page
        Page to be converted if input file is multi-page.

    Returns
    -------
    :class:`Path`
        Path to generated SVG file.
    """
    result = dvi_file.with_suffix(".svg")
    if not result.exists():
        command = [
            "dvisvgm",
            *(["--pdf"] if extension == ".pdf" else []),
            f"--page={page}",
            "--no-fonts",
            "--verbosity=0",
            f"--output={result.as_posix()}",
            f"{dvi_file.as_posix()}",
        ]
        subprocess.run(command, stdout=subprocess.DEVNULL)

    # if the file does not exist now, this means conversion failed
    if not result.exists():
        raise ValueError(
            f"Your installation does not support converting {dvi_file.suffix} files to SVG."
            f" Consider updating dvisvgm to at least version 2.4."
            f" If this does not solve the problem, please refer to our troubleshooting guide at:"
            f" https://docs.manim.community/en/stable/faq/general.html#my-installation-"
            f"does-not-support-converting-pdf-to-svg-help",
        )

    return result


</t>
<t tx="ekr.20250122151621.952">def delete_nonsvg_files(additional_endings: Iterable[str] = ()) -&gt; None:
    """Deletes every file that does not have a suffix in ``(".svg", ".tex", *additional_endings)``

    Parameters
    ----------
    additional_endings
        Additional endings to whitelist
    """
    tex_dir = config.get_dir("tex_dir")
    file_suffix_whitelist = {".svg", ".tex", *additional_endings}

    for f in tex_dir.iterdir():
        if f.suffix not in file_suffix_whitelist:
            f.unlink()


</t>
<t tx="ekr.20250122151621.953">def print_all_tex_errors(log_file: Path, tex_compiler: str, tex_file: Path) -&gt; None:
    if not log_file.exists():
        raise RuntimeError(
            f"{tex_compiler} failed but did not produce a log file. "
            "Check your LaTeX installation.",
        )
    with log_file.open(encoding="utf-8") as f:
        tex_compilation_log = f.readlines()
    error_indices = [
        index for index, line in enumerate(tex_compilation_log) if line.startswith("!")
    ]
    if error_indices:
        with tex_file.open() as f:
            tex = f.readlines()
        for error_index in error_indices:
            print_tex_error(tex_compilation_log, error_index, tex)


</t>
<t tx="ekr.20250122151621.954">LATEX_ERROR_INSIGHTS = [
    (
        r"inputenc Error: Unicode character (?:.*) \(U\+([0-9a-fA-F]+)\)",
        insight_inputenc_error,
    ),
    (
        r"LaTeX Error: File `(.*?[clsty])' not found",
        insight_package_not_found_error,
    ),
]


def print_tex_error(
    tex_compilation_log: Sequence[str],
    error_start_index: int,
    tex_source: Sequence[str],
) -&gt; None:
    logger.error(
        f"LaTeX compilation error: {tex_compilation_log[error_start_index][2:]}",
    )

    # TeX errors eventually contain a line beginning 'l.xxx` where xxx is the line number that caused the compilation
    # failure. This code finds the next such line after the error current error message
    line_of_tex_error = (
        int(
            [
                log_line
                for log_line in tex_compilation_log[error_start_index:]
                if log_line.startswith("l.")
            ][0]
            .split(" ")[0]
            .split(".")[1],
        )
        - 1
    )
    # our tex error may be on a line outside our user input because of post-processing
    if line_of_tex_error &gt;= len(tex_source):
        return None

    context = ["Context of error: \n"]
    if line_of_tex_error &lt; 3:
        context += tex_source[: line_of_tex_error + 3]
        context[-4] = "-&gt; " + context[-4]
    elif line_of_tex_error &gt; len(tex_source) - 3:
        context += tex_source[line_of_tex_error - 1 :]
        context[1] = "-&gt; " + context[1]
    else:
        context += tex_source[line_of_tex_error - 3 : line_of_tex_error + 3]
        context[-4] = "-&gt; " + context[-4]

    context_joined = "".join(context)
    logger.error(context_joined)

    for insights in LATEX_ERROR_INSIGHTS:
        prob, get_insight = insights
        matching = re.search(
            prob,
            "".join(tex_compilation_log[error_start_index])[2:],
        )
        if matching is not None:
            for insight in get_insight(matching):
                logger.info(insight)
</t>
<t tx="ekr.20250122151621.955">"""A library of LaTeX templates."""

from __future__ import annotations

__all__ = [
    "TexTemplateLibrary",
    "TexFontTemplates",
]

from .tex import *

# This file makes TexTemplateLibrary and TexFontTemplates available for use in manim Tex and MathTex objects.


@others
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.956">def _new_ams_template() -&gt; TexTemplate:
    """Returns a simple Tex Template with only basic AMS packages"""
    preamble = r"""
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
"""
    return TexTemplate(preamble=preamble)


""" Tex Template preamble used by original upstream 3b1b """
</t>
<t tx="ekr.20250122151621.957">_3b1b_preamble = r"""
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{dsfont}
\usepackage{setspace}
\usepackage{tipa}
\usepackage{relsize}
\usepackage{textcomp}
\usepackage{mathrsfs}
\usepackage{calligra}
\usepackage{wasysym}
\usepackage{ragged2e}
\usepackage{physics}
\usepackage{xcolor}
\usepackage{microtype}
\DisableLigatures{encoding = *, family = * }
\linespread{1}
"""


# TexTemplateLibrary
#
class TexTemplateLibrary:
    """
    A collection of basic TeX template objects

    Examples
    --------
    Normal usage as a value for the keyword argument tex_template of Tex() and MathTex() mobjects::

        ``Tex("My TeX code", tex_template=TexTemplateLibrary.ctex)``

    """

    default = TexTemplate(preamble=_3b1b_preamble)
    """An instance of the default TeX template in manim"""

    threeb1b = TexTemplate(preamble=_3b1b_preamble)
    """ An instance of the default TeX template used by 3b1b """

    ctex = TexTemplate(
        tex_compiler="xelatex",
        output_format=".xdv",
        preamble=_3b1b_preamble.replace(
            r"\DisableLigatures{encoding = *, family = * }",
            r"\usepackage[UTF8]{ctex}",
        ),
    )
    """An instance of the TeX template used by 3b1b when using the use_ctex flag"""

    simple = _new_ams_template()
    """An instance of a simple TeX template with only basic AMS packages loaded"""


</t>
<t tx="ekr.20250122151621.958"># TexFontTemplates
#
# TexFontTemplates takes a font_id and returns the appropriate TexTemplate()
# Usage:
#       my_tex_template = TexFontTemplates.font_id
#
# Note: not all of these will work out-of-the-box.
# They may require specific fonts to be installed on the local system.
# For example TexFontTemplates.comic_sans will only work if the Microsoft font 'Comic Sans'
# is installed on the local system.
#
# More information on these templates, along with example output can be found at
# http://jf.burnol.free.fr/showcase.html"
#
#
# Choices for font_id are:
#
# american_typewriter       : "American Typewriter"
# antykwa                   : "Antykwa Półtawskiego (TX Fonts for Greek and math symbols)"
# apple_chancery            : "Apple Chancery"
# auriocus_kalligraphicus   : "Auriocus Kalligraphicus (Symbol Greek)"
# baskervald_adf_fourier    : "Baskervald ADF with Fourier"
# baskerville_it            : "Baskerville (Italic)"
# biolinum                  : "Biolinum"
# brushscriptx              : "BrushScriptX-Italic (PX math and Greek)"
# chalkboard_se             : "Chalkboard SE"
# chalkduster               : "Chalkduster"
# comfortaa                 : "Comfortaa"
# comic_sans                : "Comic Sans MS"
# droid_sans                : "Droid Sans"
# droid_sans_it             : "Droid Sans (Italic)"
# droid_serif               : "Droid Serif"
# droid_serif_px_it         : "Droid Serif (PX math symbols) (Italic)"
# ecf_augie                 : "ECF Augie (Euler Greek)"
# ecf_jd                    : "ECF JD (with TX fonts)"
# ecf_skeetch               : "ECF Skeetch (CM Greek)"
# ecf_tall_paul             : "ECF Tall Paul (with Symbol font)"
# ecf_webster               : "ECF Webster (with TX fonts)"
# electrum_adf              : "Electrum ADF (CM Greek)"
# epigrafica                : Epigrafica
# fourier_utopia            : "Fourier Utopia (Fourier upright Greek)"
# french_cursive            : "French Cursive (Euler Greek)"
# gfs_bodoni                : "GFS Bodoni"
# gfs_didot                 : "GFS Didot (Italic)"
# gfs_neoHellenic           : "GFS NeoHellenic"
# gnu_freesans_tx           : "GNU FreeSerif (and TX fonts symbols)"
# gnu_freeserif_freesans    : "GNU FreeSerif and FreeSans"
# helvetica_fourier_it      : "Helvetica with Fourier (Italic)"
# latin_modern_tw_it        : "Latin Modern Typewriter Proportional (CM Greek) (Italic)"
# latin_modern_tw           : "Latin Modern Typewriter Proportional"
# libertine                 : "Libertine"
# libris_adf_fourier        : "Libris ADF with Fourier"
# minion_pro_myriad_pro     : "Minion Pro and Myriad Pro (and TX fonts symbols)"
# minion_pro_tx             : "Minion Pro (and TX fonts symbols)"
# new_century_schoolbook    : "New Century Schoolbook (Symbol Greek)"
# new_century_schoolbook_px : "New Century Schoolbook (Symbol Greek, PX math symbols)"
# noteworthy_light          : "Noteworthy Light"
# palatino                  : "Palatino (Symbol Greek)"
# papyrus                   : "Papyrus"
# romande_adf_fourier_it    : "Romande ADF with Fourier (Italic)"
# slitex                    : "SliTeX (Euler Greek)"
# times_fourier_it          : "Times with Fourier (Italic)"
# urw_avant_garde           : "URW Avant Garde (Symbol Greek)"
# urw_zapf_chancery         : "URW Zapf Chancery (CM Greek)"
# venturis_adf_fourier_it   : "Venturis ADF with Fourier (Italic)"
# verdana_it                : "Verdana (Italic)"
# vollkorn_fourier_it       : "Vollkorn with Fourier (Italic)"
# vollkorn                  : "Vollkorn (TX fonts for Greek and math symbols)"
# zapf_chancery             : "Zapf Chancery"
# -----------------------------------------------------------------------------------------
#
#
#
#
#
#
#
#
#
#

# Latin Modern Typewriter Proportional
lmtp = _new_ams_template()
lmtp.description = "Latin Modern Typewriter Proportional"
lmtp.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[variablett]{lmodern}
\renewcommand{\rmdefault}{\ttdefault}
\usepackage[LGRgreek]{mathastext}
\MTgreekfont{lmtt} % no lgr lmvtt, so use lgr lmtt
\Mathastext
\let\varepsilon\epsilon % only \varsigma in LGR
""",
)


# Fourier Utopia (Fourier upright Greek)
fufug = _new_ams_template()
fufug.description = "Fourier Utopia (Fourier upright Greek)"
fufug.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[upright]{fourier}
\usepackage{mathastext}
""",
)


# Droid Serif
droidserif = _new_ams_template()
droidserif.description = "Droid Serif"
droidserif.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[default]{droidserif}
\usepackage[LGRgreek]{mathastext}
\let\varepsilon\epsilon
""",
)


# Droid Sans
droidsans = _new_ams_template()
droidsans.description = "Droid Sans"
droidsans.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[default]{droidsans}
\usepackage[LGRgreek]{mathastext}
\let\varepsilon\epsilon
""",
)


# New Century Schoolbook (Symbol Greek)
ncssg = _new_ams_template()
ncssg.description = "New Century Schoolbook (Symbol Greek)"
ncssg.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{newcent}
\usepackage[symbolgreek]{mathastext}
\linespread{1.1}
""",
)


# French Cursive (Euler Greek)
fceg = _new_ams_template()
fceg.description = "French Cursive (Euler Greek)"
fceg.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[default]{frcursive}
\usepackage[eulergreek,noplusnominus,noequal,nohbar,%
nolessnomore,noasterisk]{mathastext}
""",
)


# Auriocus Kalligraphicus (Symbol Greek)
aksg = _new_ams_template()
aksg.description = "Auriocus Kalligraphicus (Symbol Greek)"
aksg.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{aurical}
\renewcommand{\rmdefault}{AuriocusKalligraphicus}
\usepackage[symbolgreek]{mathastext}
""",
)


# Palatino (Symbol Greek)
palatinosg = _new_ams_template()
palatinosg.description = "Palatino (Symbol Greek)"
palatinosg.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{palatino}
\usepackage[symbolmax,defaultmathsizes]{mathastext}
""",
)


# Comfortaa
comfortaa = _new_ams_template()
comfortaa.description = "Comfortaa"
comfortaa.add_to_preamble(
    r"""
\usepackage[default]{comfortaa}
\usepackage[LGRgreek,defaultmathsizes,noasterisk]{mathastext}
\let\varphi\phi
\linespread{1.06}
""",
)


# ECF Augie (Euler Greek)
ecfaugieeg = _new_ams_template()
ecfaugieeg.description = "ECF Augie (Euler Greek)"
ecfaugieeg.add_to_preamble(
    r"""
\renewcommand\familydefault{fau} % emerald package
\usepackage[defaultmathsizes,eulergreek]{mathastext}
""",
)


# Electrum ADF (CM Greek)
electrumadfcm = _new_ams_template()
electrumadfcm.description = "Electrum ADF (CM Greek)"
electrumadfcm.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[LGRgreek,basic,defaultmathsizes]{mathastext}
\usepackage[lf]{electrum}
\Mathastext
\let\varphi\phi
""",
)


# American Typewriter
americantypewriter = _new_ams_template()
americantypewriter.description = "American Typewriter"
americantypewriter.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{American Typewriter}
\usepackage[defaultmathsizes]{mathastext}
""",
)
americantypewriter.tex_compiler = "xelatex"
americantypewriter.output_format = ".xdv"

# Minion Pro and Myriad Pro (and TX fonts symbols)
mpmptx = _new_ams_template()
mpmptx.description = "Minion Pro and Myriad Pro (and TX fonts symbols)"
mpmptx.add_to_preamble(
    r"""
\usepackage{txfonts}
\usepackage[upright]{txgreeks}
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Minion Pro}
\setsansfont[Mapping=tex-text,Scale=MatchUppercase]{Myriad Pro}
\renewcommand\familydefault\sfdefault
\usepackage[defaultmathsizes]{mathastext}
\renewcommand\familydefault\rmdefault
""",
)
mpmptx.tex_compiler = "xelatex"
mpmptx.output_format = ".xdv"


# New Century Schoolbook (Symbol Greek, PX math symbols)
ncssgpxm = _new_ams_template()
ncssgpxm.description = "New Century Schoolbook (Symbol Greek, PX math symbols)"
ncssgpxm.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{pxfonts}
\usepackage{newcent}
\usepackage[symbolgreek,defaultmathsizes]{mathastext}
\linespread{1.06}
""",
)


# Vollkorn (TX fonts for Greek and math symbols)
vollkorntx = _new_ams_template()
vollkorntx.description = "Vollkorn (TX fonts for Greek and math symbols)"
vollkorntx.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{txfonts}
\usepackage[upright]{txgreeks}
\usepackage{vollkorn}
\usepackage[defaultmathsizes]{mathastext}
""",
)


# Libertine
libertine = _new_ams_template()
libertine.description = "Libertine"
libertine.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{libertine}
\usepackage[greek=n]{libgreek}
\usepackage[noasterisk,defaultmathsizes]{mathastext}
""",
)


# SliTeX (Euler Greek)
slitexeg = _new_ams_template()
slitexeg.description = "SliTeX (Euler Greek)"
slitexeg.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{tpslifonts}
\usepackage[eulergreek,defaultmathsizes]{mathastext}
\MTEulerScale{1.06}
\linespread{1.2}
""",
)


# ECF Webster (with TX fonts)
ecfwebstertx = _new_ams_template()
ecfwebstertx.description = "ECF Webster (with TX fonts)"
ecfwebstertx.add_to_preamble(
    r"""
\usepackage{txfonts}
\usepackage[upright]{txgreeks}
\renewcommand\familydefault{fwb} % emerald package
\usepackage{mathastext}
\renewcommand{\int}{\intop\limits}
\linespread{1.5}
""",
)
ecfwebstertx.add_to_document(
    r"""
\mathversion{bold}
""",
)


# Romande ADF with Fourier (Italic)
italicromandeadff = _new_ams_template()
italicromandeadff.description = "Romande ADF with Fourier (Italic)"
italicromandeadff.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{fourier}
\usepackage{romande}
\usepackage[italic,defaultmathsizes,noasterisk]{mathastext}
\renewcommand{\itshape}{\swashstyle}
""",
)


# Apple Chancery
applechancery = _new_ams_template()
applechancery.description = "Apple Chancery"
applechancery.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Apple Chancery}
\usepackage[defaultmathsizes]{mathastext}
""",
)
applechancery.tex_compiler = "xelatex"
applechancery.output_format = ".xdv"


# Zapf Chancery
zapfchancery = _new_ams_template()
zapfchancery.description = "Zapf Chancery"
zapfchancery.add_to_preamble(
    r"""
\DeclareFontFamily{T1}{pzc}{}
\DeclareFontShape{T1}{pzc}{mb}{it}{&lt;-&gt;s*[1.2] pzcmi8t}{}
\DeclareFontShape{T1}{pzc}{m}{it}{&lt;-&gt;ssub * pzc/mb/it}{}
\usepackage{chancery} % = \renewcommand{\rmdefault}{pzc}
\renewcommand\shapedefault\itdefault
\renewcommand\bfdefault\mddefault
\usepackage[defaultmathsizes]{mathastext}
\linespread{1.05}
""",
)


# Verdana (Italic)
italicverdana = _new_ams_template()
italicverdana.description = "Verdana (Italic)"
italicverdana.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Verdana}
\usepackage[defaultmathsizes,italic]{mathastext}
""",
)
italicverdana.tex_compiler = "xelatex"
italicverdana.output_format = ".xdv"


# URW Zapf Chancery (CM Greek)
urwzccmg = _new_ams_template()
urwzccmg.description = "URW Zapf Chancery (CM Greek)"
urwzccmg.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\DeclareFontFamily{T1}{pzc}{}
\DeclareFontShape{T1}{pzc}{mb}{it}{&lt;-&gt;s*[1.2] pzcmi8t}{}
\DeclareFontShape{T1}{pzc}{m}{it}{&lt;-&gt;ssub * pzc/mb/it}{}
\DeclareFontShape{T1}{pzc}{mb}{sl}{&lt;-&gt;ssub * pzc/mb/it}{}
\DeclareFontShape{T1}{pzc}{m}{sl}{&lt;-&gt;ssub * pzc/mb/sl}{}
\DeclareFontShape{T1}{pzc}{m}{n}{&lt;-&gt;ssub * pzc/mb/it}{}
\usepackage{chancery}
\usepackage{mathastext}
\linespread{1.05}""",
)
urwzccmg.add_to_document(
    r"""
\boldmath
""",
)


# Comic Sans MS
comicsansms = _new_ams_template()
comicsansms.description = "Comic Sans MS"
comicsansms.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Comic Sans MS}
\usepackage[defaultmathsizes]{mathastext}
""",
)
comicsansms.tex_compiler = "xelatex"
comicsansms.output_format = ".xdv"


# GFS Didot (Italic)
italicgfsdidot = _new_ams_template()
italicgfsdidot.description = "GFS Didot (Italic)"
italicgfsdidot.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\renewcommand\rmdefault{udidot}
\usepackage[LGRgreek,defaultmathsizes,italic]{mathastext}
\let\varphi\phi
""",
)


# Chalkduster
chalkduster = _new_ams_template()
chalkduster.description = "Chalkduster"
chalkduster.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Chalkduster}
\usepackage[defaultmathsizes]{mathastext}
""",
)
chalkduster.tex_compiler = "lualatex"
chalkduster.output_format = ".pdf"


# Minion Pro (and TX fonts symbols)
mptx = _new_ams_template()
mptx.description = "Minion Pro (and TX fonts symbols)"
mptx.add_to_preamble(
    r"""
\usepackage{txfonts}
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Minion Pro}
\usepackage[defaultmathsizes]{mathastext}
""",
)
mptx.tex_compiler = "xelatex"
mptx.output_format = ".xdv"


# GNU FreeSerif and FreeSans
gnufsfs = _new_ams_template()
gnufsfs.description = "GNU FreeSerif and FreeSans"
gnufsfs.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[ExternalLocation,
                Mapping=tex-text,
                BoldFont=FreeSerifBold,
                ItalicFont=FreeSerifItalic,
                BoldItalicFont=FreeSerifBoldItalic]{FreeSerif}
\setsansfont[ExternalLocation,
                Mapping=tex-text,
                BoldFont=FreeSansBold,
                ItalicFont=FreeSansOblique,
                BoldItalicFont=FreeSansBoldOblique,
                Scale=MatchLowercase]{FreeSans}
\renewcommand{\familydefault}{lmss}
\usepackage[LGRgreek,defaultmathsizes,noasterisk]{mathastext}
\renewcommand{\familydefault}{\sfdefault}
\Mathastext
\let\varphi\phi % no `var' phi in LGR encoding
\renewcommand{\familydefault}{\rmdefault}
""",
)
gnufsfs.tex_compiler = "xelatex"
gnufsfs.output_format = ".xdv"

# GFS NeoHellenic
gfsneohellenic = _new_ams_template()
gfsneohellenic.description = "GFS NeoHellenic"
gfsneohellenic.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\renewcommand{\rmdefault}{neohellenic}
\usepackage[LGRgreek]{mathastext}
\let\varphi\phi
\linespread{1.06}
""",
)


# ECF Tall Paul (with Symbol font)
ecftallpaul = _new_ams_template()
ecftallpaul.description = "ECF Tall Paul (with Symbol font)"
ecftallpaul.add_to_preamble(
    r"""
\DeclareFontFamily{T1}{ftp}{}
\DeclareFontShape{T1}{ftp}{m}{n}{
    &lt;-&gt;s*[1.4] ftpmw8t
}{} % increase size by factor 1.4
\renewcommand\familydefault{ftp} % emerald package
\usepackage[symbol]{mathastext}
\let\infty\inftypsy
""",
)


# Droid Sans (Italic)
italicdroidsans = _new_ams_template()
italicdroidsans.description = "Droid Sans (Italic)"
italicdroidsans.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[default]{droidsans}
\usepackage[LGRgreek,defaultmathsizes,italic]{mathastext}
\let\varphi\phi
""",
)


# Baskerville (Italic)
italicbaskerville = _new_ams_template()
italicbaskerville.description = "Baskerville (Italic)"
italicbaskerville.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Baskerville}
\usepackage[defaultmathsizes,italic]{mathastext}
""",
)
italicbaskerville.tex_compiler = "xelatex"
italicbaskerville.output_format = ".xdv"


# ECF JD (with TX fonts)
ecfjdtx = _new_ams_template()
ecfjdtx.description = "ECF JD (with TX fonts)"
ecfjdtx.add_to_preamble(
    r"""
\usepackage{txfonts}
\usepackage[upright]{txgreeks}
\renewcommand\familydefault{fjd} % emerald package
\usepackage{mathastext}
""",
)
ecfjdtx.add_to_document(
    r"""\mathversion{bold}
""",
)


# Antykwa Półtawskiego (TX Fonts for Greek and math symbols)
aptxgm = _new_ams_template()
aptxgm.description = "Antykwa Półtawskiego (TX Fonts for Greek and math symbols)"
aptxgm.add_to_preamble(
    r"""
\usepackage[OT4,OT1]{fontenc}
\usepackage{txfonts}
\usepackage[upright]{txgreeks}
\usepackage{antpolt}
\usepackage[defaultmathsizes,nolessnomore]{mathastext}
""",
)


# Papyrus
papyrus = _new_ams_template()
papyrus.description = "Papyrus"
papyrus.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Papyrus}
\usepackage[defaultmathsizes]{mathastext}
""",
)
papyrus.tex_compiler = "xelatex"
papyrus.output_format = ".xdv"


# GNU FreeSerif (and TX fonts symbols)
gnufstx = _new_ams_template()
gnufstx.description = "GNU FreeSerif (and TX fonts symbols)"
gnufstx.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\usepackage{txfonts}  %\let\mathbb=\varmathbb
\setmainfont[ExternalLocation,
                Mapping=tex-text,
                BoldFont=FreeSerifBold,
                ItalicFont=FreeSerifItalic,
                BoldItalicFont=FreeSerifBoldItalic]{FreeSerif}
\usepackage[defaultmathsizes]{mathastext}
""",
)
gnufstx.tex_compiler = "xelatex"
gnufstx.output_format = ".pdf"


# ECF Skeetch (CM Greek)
ecfscmg = _new_ams_template()
ecfscmg.description = "ECF Skeetch (CM Greek)"
ecfscmg.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[T1]{fontenc}
\DeclareFontFamily{T1}{fsk}{}
\DeclareFontShape{T1}{fsk}{m}{n}{&lt;-&gt;s*[1.315] fskmw8t}{}
\renewcommand\rmdefault{fsk}
\usepackage[noendash,defaultmathsizes,nohbar,defaultimath]{mathastext}
""",
)


# Latin Modern Typewriter Proportional (CM Greek) (Italic)
italiclmtpcm = _new_ams_template()
italiclmtpcm.description = "Latin Modern Typewriter Proportional (CM Greek) (Italic)"
italiclmtpcm.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[variablett,nomath]{lmodern}
\renewcommand{\familydefault}{\ttdefault}
\usepackage[frenchmath]{mathastext}
\linespread{1.08}
""",
)


# Baskervald ADF with Fourier
baskervaldadff = _new_ams_template()
baskervaldadff.description = "Baskervald ADF with Fourier"
baskervaldadff.add_to_preamble(
    r"""
\usepackage[upright]{fourier}
\usepackage{baskervald}
\usepackage[defaultmathsizes,noasterisk]{mathastext}
""",
)


# Droid Serif (PX math symbols) (Italic)
italicdroidserifpx = _new_ams_template()
italicdroidserifpx.description = "Droid Serif (PX math symbols) (Italic)"
italicdroidserifpx.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{pxfonts}
\usepackage[default]{droidserif}
\usepackage[LGRgreek,defaultmathsizes,italic,basic]{mathastext}
\let\varphi\phi
""",
)


# Biolinum
biolinum = _new_ams_template()
biolinum.description = "Biolinum"
biolinum.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{libertine}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[greek=n,biolinum]{libgreek}
\usepackage[noasterisk,defaultmathsizes]{mathastext}
""",
)


# Vollkorn with Fourier (Italic)
italicvollkornf = _new_ams_template()
italicvollkornf.description = "Vollkorn with Fourier (Italic)"
italicvollkornf.add_to_preamble(
    r"""
\usepackage{fourier}
\usepackage{vollkorn}
\usepackage[italic,nohbar]{mathastext}
""",
)


# Chalkboard SE
chalkboardse = _new_ams_template()
chalkboardse.description = "Chalkboard SE"
chalkboardse.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Chalkboard SE}
\usepackage[defaultmathsizes]{mathastext}
""",
)
chalkboardse.tex_compiler = "xelatex"
chalkboardse.output_format = ".xdv"


# Noteworthy Light
noteworthylight = _new_ams_template()
noteworthylight.description = "Noteworthy Light"
noteworthylight.add_to_preamble(
    r"""
\usepackage[no-math]{fontspec}
\setmainfont[Mapping=tex-text]{Noteworthy Light}
\usepackage[defaultmathsizes]{mathastext}
""",
)


# Epigrafica
epigrafica = _new_ams_template()
epigrafica.description = "Epigrafica"
epigrafica.add_to_preamble(
    r"""
\usepackage[LGR,OT1]{fontenc}
\usepackage{epigrafica}
\usepackage[basic,LGRgreek,defaultmathsizes]{mathastext}
\let\varphi\phi
\linespread{1.2}
""",
)


# Libris ADF with Fourier
librisadff = _new_ams_template()
librisadff.description = "Libris ADF with Fourier"
librisadff.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[upright]{fourier}
\usepackage{libris}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[noasterisk]{mathastext}
""",
)


# Venturis ADF with Fourier (Italic)
italicvanturisadff = _new_ams_template()
italicvanturisadff.description = "Venturis ADF with Fourier (Italic)"
italicvanturisadff.add_to_preamble(
    r"""
\usepackage{fourier}
\usepackage[lf]{venturis}
\usepackage[italic,defaultmathsizes,noasterisk]{mathastext}
""",
)


# GFS Bodoni
gfsbodoni = _new_ams_template()
gfsbodoni.description = "GFS Bodoni"
gfsbodoni.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\renewcommand{\rmdefault}{bodoni}
\usepackage[LGRgreek]{mathastext}
\let\varphi\phi
\linespread{1.06}
""",
)


# BrushScriptX-Italic (PX math and Greek)
brushscriptxpx = _new_ams_template()
brushscriptxpx.description = "BrushScriptX-Italic (PX math and Greek)"
brushscriptxpx.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{pxfonts}
%\usepackage{pbsi}
\renewcommand{\rmdefault}{pbsi}
\renewcommand{\mddefault}{xl}
\renewcommand{\bfdefault}{xl}
\usepackage[defaultmathsizes,noasterisk]{mathastext}
""",
)
brushscriptxpx.add_to_document(
    r"""\boldmath
""",
)
brushscriptxpx.tex_compiler = "xelatex"
brushscriptxpx.output_format = ".xdv"


# URW Avant Garde (Symbol Greek)
urwagsg = _new_ams_template()
urwagsg.description = "URW Avant Garde (Symbol Greek)"
urwagsg.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage{avant}
\renewcommand{\familydefault}{\sfdefault}
\usepackage[symbolgreek,defaultmathsizes]{mathastext}
""",
)


# Times with Fourier (Italic)
italictimesf = _new_ams_template()
italictimesf.description = "Times with Fourier (Italic)"
italictimesf.add_to_preamble(
    r"""
\usepackage{fourier}
\renewcommand{\rmdefault}{ptm}
\usepackage[italic,defaultmathsizes,noasterisk]{mathastext}
""",
)


# Helvetica with Fourier (Italic)
italichelveticaf = _new_ams_template()
italichelveticaf.description = "Helvetica with Fourier (Italic)"
italichelveticaf.add_to_preamble(
    r"""
\usepackage[T1]{fontenc}
\usepackage[scaled]{helvet}
\usepackage{fourier}
\renewcommand{\rmdefault}{phv}
\usepackage[italic,defaultmathsizes,noasterisk]{mathastext}
""",
)


class TexFontTemplates:
    """
    A collection of TeX templates for the fonts described at http://jf.burnol.free.fr/showcase.html

    These templates are specifically designed to allow you to typeset formulae and mathematics using
    different fonts. They are based on the mathastext LaTeX package.

    Examples
    ---------
    Normal usage as a value for the keyword argument tex_template of Tex() and MathTex() mobjects::

        ``Tex("My TeX code", tex_template=TexFontTemplates.comic_sans)``

    Notes
    ------
    Many of these templates require that specific fonts
    are installed on your local machine.
    For example, choosing the template TexFontTemplates.comic_sans will
    not compile if the Comic Sans Microsoft font is not installed.

    To experiment, try to render the TexFontTemplateLibrary example scene:
         ``manim path/to/manim/example_scenes/advanced_tex_fonts.py TexFontTemplateLibrary -p -ql``
    """

    american_typewriter = americantypewriter
    """American Typewriter"""
    antykwa = aptxgm
    """Antykwa Półtawskiego (TX Fonts for Greek and math symbols)"""
    apple_chancery = applechancery
    """Apple Chancery"""
    auriocus_kalligraphicus = aksg
    """Auriocus Kalligraphicus (Symbol Greek)"""
    baskervald_adf_fourier = baskervaldadff
    """Baskervald ADF with Fourier"""
    baskerville_it = italicbaskerville
    """Baskerville (Italic)"""
    biolinum = biolinum
    """Biolinum"""
    brushscriptx = brushscriptxpx
    """BrushScriptX-Italic (PX math and Greek)"""
    chalkboard_se = chalkboardse
    """Chalkboard SE"""
    chalkduster = chalkduster
    """Chalkduster"""
    comfortaa = comfortaa
    """Comfortaa"""
    comic_sans = comicsansms
    """Comic Sans MS"""
    droid_sans = droidsans
    """Droid Sans"""
    droid_sans_it = italicdroidsans
    """Droid Sans (Italic)"""
    droid_serif = droidserif
    """Droid Serif"""
    droid_serif_px_it = italicdroidserifpx
    """Droid Serif (PX math symbols) (Italic)"""
    ecf_augie = ecfaugieeg
    """ECF Augie (Euler Greek)"""
    ecf_jd = ecfjdtx
    """ECF JD (with TX fonts)"""
    ecf_skeetch = ecfscmg
    """ECF Skeetch (CM Greek)"""
    ecf_tall_paul = ecftallpaul
    """ECF Tall Paul (with Symbol font)"""
    ecf_webster = ecfwebstertx
    """ECF Webster (with TX fonts)"""
    electrum_adf = electrumadfcm
    """Electrum ADF (CM Greek)"""
    epigrafica = epigrafica
    """ Epigrafica """
    fourier_utopia = fufug
    """Fourier Utopia (Fourier upright Greek)"""
    french_cursive = fceg
    """French Cursive (Euler Greek)"""
    gfs_bodoni = gfsbodoni
    """GFS Bodoni"""
    gfs_didot = italicgfsdidot
    """GFS Didot (Italic)"""
    gfs_neoHellenic = gfsneohellenic
    """GFS NeoHellenic"""
    gnu_freesans_tx = gnufstx
    """GNU FreeSerif (and TX fonts symbols)"""
    gnu_freeserif_freesans = gnufsfs
    """GNU FreeSerif and FreeSans"""
    helvetica_fourier_it = italichelveticaf
    """Helvetica with Fourier (Italic)"""
    latin_modern_tw_it = italiclmtpcm
    """Latin Modern Typewriter Proportional (CM Greek) (Italic)"""
    latin_modern_tw = lmtp
    """Latin Modern Typewriter Proportional"""
    libertine = libertine
    """Libertine"""
    libris_adf_fourier = librisadff
    """Libris ADF with Fourier"""
    minion_pro_myriad_pro = mpmptx
    """Minion Pro and Myriad Pro (and TX fonts symbols)"""
    minion_pro_tx = mptx
    """Minion Pro (and TX fonts symbols)"""
    new_century_schoolbook = ncssg
    """New Century Schoolbook (Symbol Greek)"""
    new_century_schoolbook_px = ncssgpxm
    """New Century Schoolbook (Symbol Greek, PX math symbols)"""
    noteworthy_light = noteworthylight
    """Noteworthy Light"""
    palatino = palatinosg
    """Palatino (Symbol Greek)"""
    papyrus = papyrus
    """Papyrus"""
    romande_adf_fourier_it = italicromandeadff
    """Romande ADF with Fourier (Italic)"""
    slitex = slitexeg
    """SliTeX (Euler Greek)"""
    times_fourier_it = italictimesf
    """Times with Fourier (Italic)"""
    urw_avant_garde = urwagsg
    """URW Avant Garde (Symbol Greek)"""
    urw_zapf_chancery = urwzccmg
    """URW Zapf Chancery (CM Greek)"""
    venturis_adf_fourier_it = italicvanturisadff
    """Venturis ADF with Fourier (Italic)"""
    verdana_it = italicverdana
    """Verdana (Italic)"""
    vollkorn_fourier_it = italicvollkornf
    """Vollkorn with Fourier (Italic)"""
    vollkorn = vollkorntx
    """Vollkorn (TX fonts for Greek and math symbols)"""
    zapf_chancery = zapfchancery
    """Zapf Chancery"""
</t>
<t tx="ekr.20250122151621.959">"""Implement the Unit class."""

from __future__ import annotations

import numpy as np

from .. import config, constants
from ..typing import Vector3D

__all__ = ["Pixels", "Degrees", "Munits", "Percent"]


@others
Pixels = _PixelUnits()
Degrees = constants.PI / 180
Munits = 1
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.96">def interpolate_color(
    self, mobject1: ImageMobject, mobject2: ImageMobject, alpha: float
) -&gt; None:
    """Interpolates the array of pixel color values from one ImageMobject
    into an array of equal size in the target ImageMobject.

    Parameters
    ----------
    mobject1
        The ImageMobject to transform from.

    mobject2
        The ImageMobject to transform into.

    alpha
        Used to track the lerp relationship. Not opacity related.
    """
    assert mobject1.pixel_array.shape == mobject2.pixel_array.shape, (
        f"Mobject pixel array shapes incompatible for interpolation.\n"
        f"Mobject 1 ({mobject1}) : {mobject1.pixel_array.shape}\n"
        f"Mobject 2 ({mobject2}) : {mobject2.pixel_array.shape}"
    )
    self.fill_opacity = interpolate(
        mobject1.fill_opacity,
        mobject2.fill_opacity,
        alpha,
    )
    self.stroke_opacity = interpolate(
        mobject1.stroke_opacity,
        mobject2.stroke_opacity,
        alpha,
    )
    self.pixel_array = interpolate(
        mobject1.pixel_array,
        mobject2.pixel_array,
        alpha,
    ).astype(self.pixel_array_dtype)

</t>
<t tx="ekr.20250122151621.960">class _PixelUnits:
    @others
</t>
<t tx="ekr.20250122151621.961">class Percent:
    @others
</t>
<t tx="ekr.20250122151621.962">def __mul__(self, val: float) -&gt; float:
    return val * config.frame_width / config.pixel_width

</t>
<t tx="ekr.20250122151621.963">def __rmul__(self, val: float) -&gt; float:
    return val * config.frame_width / config.pixel_width


</t>
<t tx="ekr.20250122151621.964">def __init__(self, axis: Vector3D) -&gt; None:
    if np.array_equal(axis, constants.X_AXIS):
        self.length = config.frame_width
    if np.array_equal(axis, constants.Y_AXIS):
        self.length = config.frame_height
    if np.array_equal(axis, constants.Z_AXIS):
        raise NotImplementedError("length of Z axis is undefined")

</t>
<t tx="ekr.20250122151621.965">def __mul__(self, val: float) -&gt; float:
    return val / 100 * self.length

</t>
<t tx="ekr.20250122151621.966">def __rmul__(self, val: float) -&gt; float:
    return val / 100 * self.length


</t>
<t tx="ekr.20250122151621.967"></t>
<t tx="ekr.20250122151621.968">"""Australian Color Standard

In 1985 the Australian Independent Color Standard AS 2700 was created. In
this standard, all colors can be identified via a category code (one of
B -- Blue, G -- Green, N -- Neutrals (grey), P -- Purple, R -- Red, T -- Blue/Green,
X -- Yellow/Red, Y -- Yellow) and a number. The colors also have (natural) names.

To use the colors from this list, access them directly from the module (which
is exposed to Manim's global name space):

.. code:: pycon

    &gt;&gt;&gt; from manim import AS2700
    &gt;&gt;&gt; AS2700.B23_BRIGHT_BLUE
    ManimColor('#174F90')

List of Color Constants
-----------------------

These hex values (taken from https://www.w3schools.com/colors/colors_australia.asp)
are non official approximate values intended to simulate AS 2700 colors:

.. automanimcolormodule:: manim.utils.color.AS2700

"""

from __future__ import annotations

from .core import ManimColor

B11_RICH_BLUE = ManimColor("#2B3770")
B12_ROYAL_BLUE = ManimColor("#2C3563")
B13_NAVY_BLUE = ManimColor("#28304D")
B14_SAPHHIRE = ManimColor("#28426B")
B15_MID_BLUE = ManimColor("#144B6F")
B21_ULTRAMARINE = ManimColor("#2C5098")
B22_HOMEBUSH_BLUE = ManimColor("#215097")
B23_BRIGHT_BLUE = ManimColor("#174F90")
B24_HARBOUR_BLUE = ManimColor("#1C6293")
B25_AQUA = ManimColor("#5097AC")
B32_POWDER_BLUE = ManimColor("#B7C8DB")
B33_MIST_BLUE = ManimColor("#E0E6E2")
B34_PARADISE_BLUE = ManimColor("#3499BA")
B35_PALE_BLUE = ManimColor("#CDE4E2")
B41_BLUEBELL = ManimColor("#5B94D1")
B42_PURPLE_BLUE = ManimColor("#5E7899")
B43_GREY_BLUE = ManimColor("#627C8D")
B44_LIGHT_GREY_BLUE = ManimColor("#C0C0C1")
B45_SKY_BLUE = ManimColor("#7DB7C7")
B51_PERIWINKLE = ManimColor("#3871AC")
B53_DARK_GREY_BLUE = ManimColor("#4F6572")
B55_STORM_BLUE = ManimColor("#3F7C94")
B61_CORAL_SEA = ManimColor("#2B3873")
B62_MIDNIGHT_BLUE = ManimColor("#292A34")
B64_CHARCOAL = ManimColor("#363E45")
G11_BOTTLE_GREEN = ManimColor("#253A32")
G12_HOLLY = ManimColor("#21432D")
G13_EMERALD = ManimColor("#195F35")
G14_MOSS_GREEN = ManimColor("#33572D")
G15_RAINFOREST_GREEN = ManimColor("#3D492D")
G16_TRAFFIC_GREEN = ManimColor("#305442")
G17_MINT_GREEN = ManimColor("#006B45")
G21_JADE = ManimColor("#127453")
G22_SERPENTINE = ManimColor("#78A681")
G23_SHAMROCK = ManimColor("#336634")
G24_FERN_TREE = ManimColor("#477036")
G25_OLIVE = ManimColor("#595B2A")
G26_APPLE_GREEN = ManimColor("#4E9843")
G27_HOMEBUSH_GREEN = ManimColor("#017F4D")
G31_VERTIGRIS = ManimColor("#468A65")
G32_OPALINE = ManimColor("#AFCBB8")
G33_LETTUCE = ManimColor("#7B9954")
G34_AVOCADO = ManimColor("#757C4C")
G35_LIME_GREEN = ManimColor("#89922E")
G36_KIKUYU = ManimColor("#95B43B")
G37_BEANSTALK = ManimColor("#45A56A")
G41_LAWN_GREEN = ManimColor("#0D875D")
G42_GLACIER = ManimColor("#D5E1D2")
G43_SURF_GREEN = ManimColor("#C8C8A7")
G44_PALM_GREEN = ManimColor("#99B179")
G45_CHARTREUSE = ManimColor("#C7C98D")
G46_CITRONELLA = ManimColor("#BFC83E")
G47_CRYSTAL_GREEN = ManimColor("#ADCCA8")
G51_SPRUCE = ManimColor("#05674F")
G52_EUCALYPTUS = ManimColor("#66755B")
G53_BANKSIA = ManimColor("#929479")
G54_MIST_GREEN = ManimColor("#7A836D")
G55_LICHEN = ManimColor("#A7A98C")
G56_SAGE_GREEN = ManimColor("#677249")
G61_DARK_GREEN = ManimColor("#283533")
G62_RIVERGUM = ManimColor("#617061")
G63_DEEP_BRONZE_GREEN = ManimColor("#333334")
G64_SLATE = ManimColor("#5E6153")
G65_TI_TREE = ManimColor("#5D5F4E")
G66_ENVIRONMENT_GREEN = ManimColor("#484C3F")
G67_ZUCCHINI = ManimColor("#2E443A")
N11_PEARL_GREY = ManimColor("#D8D3C7")
N12_PASTEL_GREY = ManimColor("#CCCCCC")
N14_WHITE = ManimColor("#FFFFFF")
N15_HOMEBUSH_GREY = ManimColor("#A29B93")
N22_CLOUD_GREY = ManimColor("#C4C1B9")
N23_NEUTRAL_GREY = ManimColor("#CCCCCC")
N24_SILVER_GREY = ManimColor("#BDC7C5")
N25_BIRCH_GREY = ManimColor("#ABA498")
N32_GREEN_GREY = ManimColor("#8E9282")
N33_LIGHTBOX_GREY = ManimColor("#ACADAD")
N35_LIGHT_GREY = ManimColor("#A6A7A1")
N41_OYSTER = ManimColor("#998F78")
N42_STORM_GREY = ManimColor("#858F88")
N43_PIPELINE_GREY = ManimColor("#999999")
N44_BRIDGE_GREY = ManimColor("#767779")
N45_KOALA_GREY = ManimColor("#928F88")
N52_MID_GREY = ManimColor("#727A77")
N53_BLUE_GREY = ManimColor("#7C8588")
N54_BASALT = ManimColor("#585C63")
N55_LEAD_GREY = ManimColor("#5E5C58")
N61_BLACK = ManimColor("#2A2A2C")
N63_PEWTER = ManimColor("#596064")
N64_DARK_GREY = ManimColor("#4B5259")
N65_GRAPHITE_GREY = ManimColor("#45474A")
P11_MAGENTA = ManimColor("#7B2B48")
P12_PURPLE = ManimColor("#85467B")
P13_VIOLET = ManimColor("#5D3A61")
P14_BLUEBERRY = ManimColor("#4C4176")
P21_SUNSET_PINK = ManimColor("#E3BBBD")
P22_CYCLAMEN = ManimColor("#83597D")
P23_LILAC = ManimColor("#A69FB1")
P24_JACKARANDA = ManimColor("#795F91")
P31_DUSTY_PINK = ManimColor("#DBBEBC")
P33_RIBBON_PINK = ManimColor("#D1BCC9")
P41_ERICA_PINK = ManimColor("#C55A83")
P42_MULBERRY = ManimColor("#A06574")
P43_WISTERIA = ManimColor("#756D91")
P52_PLUM = ManimColor("#6E3D4B")
R11_INTERNATIONAL_ORANGE = ManimColor("#CE482A")
R12_SCARLET = ManimColor("#CD392A")
R13_SIGNAL_RED = ManimColor("#BA312B")
R14_WARATAH = ManimColor("#AA2429")
R15_CRIMSON = ManimColor("#9E2429")
R21_TANGERINE = ManimColor("#E96957")
R22_HOMEBUSH_RED = ManimColor("#D83A2D")
R23_LOLLIPOP = ManimColor("#CC5058")
R24_STRAWBERRY = ManimColor("#B4292A")
R25_ROSE_PINK = ManimColor("#E8919C")
R32_APPLE_BLOSSOM = ManimColor("#F2E1D8")
R33_GHOST_GUM = ManimColor("#E8DAD4")
R34_MUSHROOM = ManimColor("#D7C0B6")
R35_DEEP_ROSE = ManimColor("#CD6D71")
R41_SHELL_PINK = ManimColor("#F9D9BB")
R42_SALMON_PINK = ManimColor("#D99679")
R43_RED_DUST = ManimColor("#D0674F")
R44_POSSUM = ManimColor("#A18881")
R45_RUBY = ManimColor("#8F3E5C")
R51_BURNT_PINK = ManimColor("#E19B8E")
R52_TERRACOTTA = ManimColor("#A04C36")
R53_RED_GUM = ManimColor("#8D4338")
R54_RASPBERRY = ManimColor("#852F31")
R55_CLARET = ManimColor("#67292D")
R62_VENETIAN_RED = ManimColor("#77372B")
R63_RED_OXIDE = ManimColor("#663334")
R64_DEEP_INDIAN_RED = ManimColor("#542E2B")
R65_MAROON = ManimColor("#3F2B3C")
T11_TROPICAL_BLUE = ManimColor("#006698")
T12_DIAMANTIA = ManimColor("#006C74")
T14_MALACHITE = ManimColor("#105154")
T15_TURQUOISE = ManimColor("#098587")
T22_ORIENTAL_BLUE = ManimColor("#358792")
T24_BLUE_JADE = ManimColor("#427F7E")
T32_HUON_GREEN = ManimColor("#72B3B1")
T33_SMOKE_BLUE = ManimColor("#9EB6B2")
T35_GREEN_ICE = ManimColor("#78AEA2")
T44_BLUE_GUM = ManimColor("#6A8A88")
T45_COOTAMUNDRA = ManimColor("#759E91")
T51_MOUNTAIN_BLUE = ManimColor("#295668")
T53_PEACOCK_BLUE = ManimColor("#245764")
T63_TEAL = ManimColor("#183F4E")
X11_BUTTERSCOTCH = ManimColor("#D38F43")
X12_PUMPKIN = ManimColor("#DD7E1A")
X13_MARIGOLD = ManimColor("#ED7F15")
X14_MANDARIN = ManimColor("#E45427")
X15_ORANGE = ManimColor("#E36C2B")
X21_PALE_OCHRE = ManimColor("#DAA45F")
X22_SAFFRON = ManimColor("#F6AA51")
X23_APRICOT = ManimColor("#FEB56D")
X24_ROCKMELON = ManimColor("#F6894B")
X31_RAFFIA = ManimColor("#EBC695")
X32_MAGNOLIA = ManimColor("#F1DEBE")
X33_WARM_WHITE = ManimColor("#F3E7D4")
X34_DRIFTWOOD = ManimColor("#D5C4AE")
X41_BUFF = ManimColor("#C28A44")
X42_BISCUIT = ManimColor("#DEBA92")
X43_BEIGE = ManimColor("#C9AA8C")
X45_CINNAMON = ManimColor("#AC826D")
X51_TAN = ManimColor("#8F5F32")
X52_COFFEE = ManimColor("#AD7948")
X53_GOLDEN_TAN = ManimColor("#925629")
X54_BROWN = ManimColor("#68452C")
X55_NUT_BROWN = ManimColor("#764832")
X61_WOMBAT = ManimColor("#6E5D52")
X62_DARK_EARTH = ManimColor("#6E5D52")
X63_IRONBARK = ManimColor("#443B36")
X64_CHOCOLATE = ManimColor("#4A3B31")
X65_DARK_BROWN = ManimColor("#4F372D")
Y11_CANARY = ManimColor("#E7BD11")
Y12_WATTLE = ManimColor("#E8AF01")
Y13_VIVID_YELLOW = ManimColor("#FCAE01")
Y14_GOLDEN_YELLOW = ManimColor("#F5A601")
Y15_SUNFLOWER = ManimColor("#FFA709")
Y16_INCA_GOLD = ManimColor("#DF8C19")
Y21_PRIMROSE = ManimColor("#F5CF5B")
Y22_CUSTARD = ManimColor("#EFD25C")
Y23_BUTTERCUP = ManimColor("#E0CD41")
Y24_STRAW = ManimColor("#E3C882")
Y25_DEEP_CREAM = ManimColor("#F3C968")
Y26_HOMEBUSH_GOLD = ManimColor("#FCC51A")
Y31_LILY_GREEN = ManimColor("#E3E3CD")
Y32_FLUMMERY = ManimColor("#E6DF9E")
Y33_PALE_PRIMROSE = ManimColor("#F5F3CE")
Y34_CREAM = ManimColor("#EFE3BE")
Y35_OFF_WHITE = ManimColor("#F1E9D5")
Y41_OLIVE_YELLOW = ManimColor("#8E7426")
Y42_MUSTARD = ManimColor("#C4A32E")
Y43_PARCHMENT = ManimColor("#D4C9A3")
Y44_SAND = ManimColor("#DCC18B")
Y45_MANILLA = ManimColor("#E5D0A7")
Y51_BRONZE_OLIVE = ManimColor("#695D3E")
Y52_CHAMOIS = ManimColor("#BEA873")
Y53_SANDSTONE = ManimColor("#D5BF8E")
Y54_OATMEAL = ManimColor("#CAAE82")
Y55_DEEP_STONE = ManimColor("#BC9969")
Y56_MERINO = ManimColor("#C9B79E")
Y61_BLACK_OLIVE = ManimColor("#47473B")
Y62_SUGAR_CANE = ManimColor("#BCA55C")
Y63_KHAKI = ManimColor("#826843")
Y65_MUSHROOM = ManimColor("#A39281")
Y66_MUDSTONE = ManimColor("#574E45")
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.969">"""British Color Standard

This module contains colors defined in one of the British Standards
for colors, BS381C. This standard specifies colors used in identification,
coding, and other special purposes. See https://www.britishstandardcolour.com/
for more information.

To use the colors from this list, access them directly from the module (which
is exposed to Manim's global name space):

.. code:: pycon

    &gt;&gt;&gt; from manim import BS381
    &gt;&gt;&gt; BS381.OXFORD_BLUE
    ManimColor('#1F3057')

List of Color Constants
-----------------------

These hex values (taken from https://www.w3schools.com/colors/colors_british.asp)
are non official approximate values intended to simulate the ones defined
in the standard:

.. automanimcolormodule:: manim.utils.color.BS381

"""

from __future__ import annotations

from .core import ManimColor

BS381_101 = ManimColor("#94BFAC")
SKY_BLUE = ManimColor("#94BFAC")
BS381_102 = ManimColor("#5B9291")
TURQUOISE_BLUE = ManimColor("#5B9291")
BS381_103 = ManimColor("#3B6879")
PEACOCK_BLUE = ManimColor("#3B6879")
BS381_104 = ManimColor("#264D7E")
AZURE_BLUE = ManimColor("#264D7E")
BS381_105 = ManimColor("#1F3057")
OXFORD_BLUE = ManimColor("#1F3057")
BS381_106 = ManimColor("#2A283D")
ROYAL_BLUE = ManimColor("#2A283D")
BS381_107 = ManimColor("#3A73A9")
STRONG_BLUE = ManimColor("#3A73A9")
BS381_108 = ManimColor("#173679")
AIRCRAFT_BLUE = ManimColor("#173679")
BS381_109 = ManimColor("#1C5680")
MIDDLE_BLUE = ManimColor("#1C5680")
BS381_110 = ManimColor("#2C3E75")
ROUNDEL_BLUE = ManimColor("#2C3E75")
BS381_111 = ManimColor("#8CC5BB")
PALE_BLUE = ManimColor("#8CC5BB")
BS381_112 = ManimColor("#78ADC2")
ARCTIC_BLUE = ManimColor("#78ADC2")
FIESTA_BLUE = ManimColor("#78ADC2")
BS381_113 = ManimColor("#3F687D")
DEEP_SAXE_BLUE = ManimColor("#3F687D")
BS381_114 = ManimColor("#1F4B61")
RAIL_BLUE = ManimColor("#1F4B61")
BS381_115 = ManimColor("#5F88C1")
COBALT_BLUE = ManimColor("#5F88C1")
BS381_166 = ManimColor("#2458AF")
FRENCH_BLUE = ManimColor("#2458AF")
BS381_169 = ManimColor("#135B75")
TRAFFIC_BLUE = ManimColor("#135B75")
BS381_172 = ManimColor("#A7C6EB")
PALE_ROUNDEL_BLUE = ManimColor("#A7C6EB")
BS381_174 = ManimColor("#64A0AA")
ORIENT_BLUE = ManimColor("#64A0AA")
BS381_175 = ManimColor("#4F81C5")
LIGHT_FRENCH_BLUE = ManimColor("#4F81C5")
BS381_210 = ManimColor("#BBC9A5")
SKY = ManimColor("#BBC9A5")
BS381_216 = ManimColor("#BCD890")
EAU_DE_NIL = ManimColor("#BCD890")
BS381_217 = ManimColor("#96BF65")
SEA_GREEN = ManimColor("#96BF65")
BS381_218 = ManimColor("#698B47")
GRASS_GREEN = ManimColor("#698B47")
BS381_219 = ManimColor("#757639")
SAGE_GREEN = ManimColor("#757639")
BS381_220 = ManimColor("#4B5729")
OLIVE_GREEN = ManimColor("#4B5729")
BS381_221 = ManimColor("#507D3A")
BRILLIANT_GREEN = ManimColor("#507D3A")
BS381_222 = ManimColor("#6A7031")
LIGHT_BRONZE_GREEN = ManimColor("#6A7031")
BS381_223 = ManimColor("#49523A")
MIDDLE_BRONZE_GREEN = ManimColor("#49523A")
BS381_224 = ManimColor("#3E4630")
DEEP_BRONZE_GREEN = ManimColor("#3E4630")
BS381_225 = ManimColor("#406A28")
LIGHT_BRUNSWICK_GREEN = ManimColor("#406A28")
BS381_226 = ManimColor("#33533B")
MID_BRUNSWICK_GREEN = ManimColor("#33533B")
BS381_227 = ManimColor("#254432")
DEEP_BRUNSWICK_GREEN = ManimColor("#254432")
BS381_228 = ManimColor("#428B64")
EMERALD_GREEN = ManimColor("#428B64")
BS381_241 = ManimColor("#4F5241")
DARK_GREEN = ManimColor("#4F5241")
BS381_262 = ManimColor("#44945E")
BOLD_GREEN = ManimColor("#44945E")
BS381_267 = ManimColor("#476A4C")
DEEP_CHROME_GREEN = ManimColor("#476A4C")
TRAFFIC_GREEN = ManimColor("#476A4C")
BS381_275 = ManimColor("#8FC693")
OPALINE_GREEN = ManimColor("#8FC693")
BS381_276 = ManimColor("#2E4C1E")
LINCON_GREEN = ManimColor("#2E4C1E")
BS381_277 = ManimColor("#364A20")
CYPRESS_GREEN = ManimColor("#364A20")
BS381_278 = ManimColor("#87965A")
LIGHT_OLIVE_GREEN = ManimColor("#87965A")
BS381_279 = ManimColor("#3B3629")
STEEL_FURNITURE_GREEN = ManimColor("#3B3629")
BS381_280 = ManimColor("#68AB77")
VERDIGRIS_GREEN = ManimColor("#68AB77")
BS381_282 = ManimColor("#506B52")
FOREST_GREEN = ManimColor("#506B52")
BS381_283 = ManimColor("#7E8F6E")
AIRCRAFT_GREY_GREEN = ManimColor("#7E8F6E")
BS381_284 = ManimColor("#6B6F5A")
SPRUCE_GREEN = ManimColor("#6B6F5A")
BS381_285 = ManimColor("#5F5C4B")
NATO_GREEN = ManimColor("#5F5C4B")
BS381_298 = ManimColor("#4F5138")
OLIVE_DRAB = ManimColor("#4F5138")
BS381_309 = ManimColor("#FEEC04")
CANARY_YELLOW = ManimColor("#FEEC04")
BS381_310 = ManimColor("#FEF963")
PRIMROSE = ManimColor("#FEF963")
BS381_315 = ManimColor("#FEF96A")
GRAPEFRUIT = ManimColor("#FEF96A")
BS381_320 = ManimColor("#9E7339")
LIGHT_BROWN = ManimColor("#9E7339")
BS381_337 = ManimColor("#4C4A3C")
VERY_DARK_DRAB = ManimColor("#4C4A3C")
BS381_350 = ManimColor("#7B6B4F")
DARK_EARTH = ManimColor("#7B6B4F")
BS381_352 = ManimColor("#FCED96")
PALE_CREAM = ManimColor("#FCED96")
BS381_353 = ManimColor("#FDF07A")
DEEP_CREAM = ManimColor("#FDF07A")
BS381_354 = ManimColor("#E9BB43")
PRIMROSE_2 = ManimColor("#E9BB43")
BS381_355 = ManimColor("#FDD906")
LEMON = ManimColor("#FDD906")
BS381_356 = ManimColor("#FCC808")
GOLDEN_YELLOW = ManimColor("#FCC808")
BS381_358 = ManimColor("#F6C870")
LIGHT_BUFF = ManimColor("#F6C870")
BS381_359 = ManimColor("#DBAC50")
MIDDLE_BUFF = ManimColor("#DBAC50")
BS381_361 = ManimColor("#D4B97D")
LIGHT_STONE = ManimColor("#D4B97D")
BS381_362 = ManimColor("#AC7C42")
MIDDLE_STONE = ManimColor("#AC7C42")
BS381_363 = ManimColor("#FDE706")
BOLD_YELLOW = ManimColor("#FDE706")
BS381_364 = ManimColor("#CEC093")
PORTLAND_STONE = ManimColor("#CEC093")
BS381_365 = ManimColor("#F4F0BD")
VELLUM = ManimColor("#F4F0BD")
BS381_366 = ManimColor("#F5E7A1")
LIGHT_BEIGE = ManimColor("#F5E7A1")
BS381_367 = ManimColor("#FEF6BF")
MANILLA = ManimColor("#fef6bf")
BS381_368 = ManimColor("#DD7B00")
TRAFFIC_YELLOW = ManimColor("#DD7B00")
BS381_369 = ManimColor("#FEEBA8")
BISCUIT = ManimColor("#feeba8")
BS381_380 = ManimColor("#BBA38A")
CAMOUFLAGE_DESERT_SAND = ManimColor("#BBA38A")
BS381_384 = ManimColor("#EEDFA5")
LIGHT_STRAW = ManimColor("#EEDFA5")
BS381_385 = ManimColor("#E8C88F")
LIGHT_BISCUIT = ManimColor("#E8C88F")
BS381_386 = ManimColor("#E6C18D")
CHAMPAGNE = ManimColor("#e6c18d")
BS381_387 = ManimColor("#CFB48A")
SUNRISE = ManimColor("#cfb48a")
SUNSHINE = ManimColor("#cfb48a")
BS381_388 = ManimColor("#E4CF93")
BEIGE = ManimColor("#e4cf93")
BS381_389 = ManimColor("#B2A788")
CAMOUFLAGE_BEIGE = ManimColor("#B2A788")
BS381_397 = ManimColor("#F3D163")
JASMINE_YELLOW = ManimColor("#F3D163")
BS381_411 = ManimColor("#74542F")
MIDDLE_BROWN = ManimColor("#74542F")
BS381_412 = ManimColor("#5C422E")
DARK_BROWN = ManimColor("#5C422E")
BS381_413 = ManimColor("#402D21")
NUT_BROWN = ManimColor("#402D21")
BS381_414 = ManimColor("#A86C29")
GOLDEN_BROWN = ManimColor("#A86C29")
BS381_415 = ManimColor("#61361E")
IMPERIAL_BROWN = ManimColor("#61361E")
BS381_420 = ManimColor("#A89177")
DARK_CAMOUFLAGE_DESERT_SAND = ManimColor("#A89177")
BS381_435 = ManimColor("#845B4D")
CAMOUFLAGE_RED = ManimColor("#845B4D")
BS381_436 = ManimColor("#564B47")
DARK_CAMOUFLAGE_BROWN = ManimColor("#564B47")
BS381_439 = ManimColor("#753B1E")
ORANGE_BROWN = ManimColor("#753B1E")
BS381_443 = ManimColor("#C98A71")
SALMON = ManimColor("#c98a71")
BS381_444 = ManimColor("#A65341")
TERRACOTTA = ManimColor("#a65341")
BS381_445 = ManimColor("#83422B")
VENETIAN_RED = ManimColor("#83422B")
BS381_446 = ManimColor("#774430")
RED_OXIDE = ManimColor("#774430")
BS381_447 = ManimColor("#F3B28B")
SALMON_PINK = ManimColor("#F3B28B")
BS381_448 = ManimColor("#67403A")
DEEP_INDIAN_RED = ManimColor("#67403A")
BS381_449 = ManimColor("#693B3F")
LIGHT_PURPLE_BROWN = ManimColor("#693B3F")
BS381_452 = ManimColor("#613339")
DARK_CRIMSON = ManimColor("#613339")
BS381_453 = ManimColor("#FBDED6")
SHELL_PINK = ManimColor("#FBDED6")
BS381_454 = ManimColor("#E8A1A2")
PALE_ROUNDEL_RED = ManimColor("#E8A1A2")
BS381_460 = ManimColor("#BD8F56")
DEEP_BUFF = ManimColor("#BD8F56")
BS381_473 = ManimColor("#793932")
GULF_RED = ManimColor("#793932")
BS381_489 = ManimColor("#8D5B41")
LEAF_BROWN = ManimColor("#8D5B41")
BS381_490 = ManimColor("#573320")
BEECH_BROWN = ManimColor("#573320")
BS381_499 = ManimColor("#59493E")
SERVICE_BROWN = ManimColor("#59493E")
BS381_536 = ManimColor("#BB3016")
POPPY = ManimColor("#bb3016")
BS381_537 = ManimColor("#DD3420")
SIGNAL_RED = ManimColor("#DD3420")
BS381_538 = ManimColor("#C41C22")
POST_OFFICE_RED = ManimColor("#C41C22")
CHERRY = ManimColor("#c41c22")
BS381_539 = ManimColor("#D21E2B")
CURRANT_RED = ManimColor("#D21E2B")
BS381_540 = ManimColor("#8B1A32")
CRIMSON = ManimColor("#8b1a32")
BS381_541 = ManimColor("#471B21")
MAROON = ManimColor("#471b21")
BS381_542 = ManimColor("#982D57")
RUBY = ManimColor("#982d57")
BS381_557 = ManimColor("#EF841E")
LIGHT_ORANGE = ManimColor("#EF841E")
BS381_564 = ManimColor("#DD3524")
BOLD_RED = ManimColor("#DD3524")
BS381_568 = ManimColor("#FB9C06")
APRICOT = ManimColor("#fb9c06")
BS381_570 = ManimColor("#A83C19")
TRAFFIC_RED = ManimColor("#A83C19")
BS381_591 = ManimColor("#D04E09")
DEEP_ORANGE = ManimColor("#D04E09")
BS381_592 = ManimColor("#E45523")
INTERNATIONAL_ORANGE = ManimColor("#E45523")
BS381_593 = ManimColor("#F24816")
RAIL_RED = ManimColor("#F24816")
AZO_ORANGE = ManimColor("#F24816")
BS381_626 = ManimColor("#A0A9AA")
CAMOUFLAGE_GREY = ManimColor("#A0A9AA")
BS381_627 = ManimColor("#BEC0B8")
LIGHT_AIRCRAFT_GREY = ManimColor("#BEC0B8")
BS381_628 = ManimColor("#9D9D7E")
SILVER_GREY = ManimColor("#9D9D7E")
BS381_629 = ManimColor("#7A838B")
DARK_CAMOUFLAGE_GREY = ManimColor("#7A838B")
BS381_630 = ManimColor("#A5AD98")
FRENCH_GREY = ManimColor("#A5AD98")
BS381_631 = ManimColor("#9AAA9F")
LIGHT_GREY = ManimColor("#9AAA9F")
BS381_632 = ManimColor("#6B7477")
DARK_ADMIRALTY_GREY = ManimColor("#6B7477")
BS381_633 = ManimColor("#424C53")
RAF_BLUE_GREY = ManimColor("#424C53")
BS381_634 = ManimColor("#6F7264")
SLATE = ManimColor("#6f7264")
BS381_635 = ManimColor("#525B55")
LEAD = ManimColor("#525b55")
BS381_636 = ManimColor("#5F7682")
PRU_BLUE = ManimColor("#5F7682")
BS381_637 = ManimColor("#8E9B9C")
MEDIUM_SEA_GREY = ManimColor("#8E9B9C")
BS381_638 = ManimColor("#6C7377")
DARK_SEA_GREY = ManimColor("#6C7377")
BS381_639 = ManimColor("#667563")
LIGHT_SLATE_GREY = ManimColor("#667563")
BS381_640 = ManimColor("#566164")
EXTRA_DARK_SEA_GREY = ManimColor("#566164")
BS381_642 = ManimColor("#282B2F")
NIGHT = ManimColor("#282b2f")
BS381_671 = ManimColor("#4E5355")
MIDDLE_GRAPHITE = ManimColor("#4E5355")
BS381_676 = ManimColor("#A9B7B9")
LIGHT_WEATHERWORK_GREY = ManimColor("#A9B7B9")
BS381_677 = ManimColor("#676F76")
DARK_WEATHERWORK_GREY = ManimColor("#676F76")
BS381_692 = ManimColor("#7B93A3")
SMOKE_GREY = ManimColor("#7B93A3")
BS381_693 = ManimColor("#88918D")
AIRCRAFT_GREY = ManimColor("#88918D")
BS381_694 = ManimColor("#909A92")
DOVE_GREY = ManimColor("#909A92")
BS381_697 = ManimColor("#B6D3CC")
LIGHT_ADMIRALTY_GREY = ManimColor("#B6D3CC")
BS381_796 = ManimColor("#6E4A75")
DARK_VIOLET = ManimColor("#6E4A75")
BS381_797 = ManimColor("#C9A8CE")
LIGHT_VIOLET = ManimColor("#C9A8CE")
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.97">def get_style(self) -&gt; dict[str, Any]:
    return {
        "fill_color": ManimColor(self.color.get_rgb()).to_hex(),
        "fill_opacity": self.fill_opacity,
    }


</t>
<t tx="ekr.20250122151621.970">r"""dvips Colors

This module contains the colors defined in the dvips driver, which are commonly accessed
as named colors in LaTeX via the ``\usepackage[dvipsnames]{xcolor}`` package.

To use the colors from this list, access them directly from the module (which
is exposed to Manim's global name space):

.. code:: pycon

    &gt;&gt;&gt; from manim import DVIPSNAMES
    &gt;&gt;&gt; DVIPSNAMES.DARKORCHID
    ManimColor('#A4538A')

List of Color Constants
-----------------------

These hex values are derived from those specified in the ``xcolor`` package
documentation (see https://ctan.org/pkg/xcolor):

.. automanimcolormodule:: manim.utils.color.DVIPSNAMES

"""

from __future__ import annotations

from .core import ManimColor

AQUAMARINE = ManimColor("#00B5BE")
BITTERSWEET = ManimColor("#C04F17")
APRICOT = ManimColor("#FBB982")
BLACK = ManimColor("#221E1F")
BLUE = ManimColor("#2D2F92")
BLUEGREEN = ManimColor("#00B3B8")
BLUEVIOLET = ManimColor("#473992")
BRICKRED = ManimColor("#B6321C")
BROWN = ManimColor("#792500")
BURNTORANGE = ManimColor("#F7921D")
CADETBLUE = ManimColor("#74729A")
CARNATIONPINK = ManimColor("#F282B4")
CERULEAN = ManimColor("#00A2E3")
CORNFLOWERBLUE = ManimColor("#41B0E4")
CYAN = ManimColor("#00AEEF")
DANDELION = ManimColor("#FDBC42")
DARKORCHID = ManimColor("#A4538A")
EMERALD = ManimColor("#00A99D")
FORESTGREEN = ManimColor("#009B55")
FUCHSIA = ManimColor("#8C368C")
GOLDENROD = ManimColor("#FFDF42")
GRAY = ManimColor("#949698")
GREEN = ManimColor("#00A64F")
GREENYELLOW = ManimColor("#DFE674")
JUNGLEGREEN = ManimColor("#00A99A")
LAVENDER = ManimColor("#F49EC4")
LIMEGREEN = ManimColor("#8DC73E")
MAGENTA = ManimColor("#EC008C")
MAHOGANY = ManimColor("#A9341F")
MAROON = ManimColor("#AF3235")
MELON = ManimColor("#F89E7B")
MIDNIGHTBLUE = ManimColor("#006795")
MULBERRY = ManimColor("#A93C93")
NAVYBLUE = ManimColor("#006EB8")
OLIVEGREEN = ManimColor("#3C8031")
ORANGE = ManimColor("#F58137")
ORANGERED = ManimColor("#ED135A")
ORCHID = ManimColor("#AF72B0")
PEACH = ManimColor("#F7965A")
PERIWINKLE = ManimColor("#7977B8")
PINEGREEN = ManimColor("#008B72")
PLUM = ManimColor("#92268F")
PROCESSBLUE = ManimColor("#00B0F0")
PURPLE = ManimColor("#99479B")
RAWSIENNA = ManimColor("#974006")
RED = ManimColor("#ED1B23")
REDORANGE = ManimColor("#F26035")
REDVIOLET = ManimColor("#A1246B")
RHODAMINE = ManimColor("#EF559F")
ROYALBLUE = ManimColor("#0071BC")
ROYALPURPLE = ManimColor("#613F99")
RUBINERED = ManimColor("#ED017D")
SALMON = ManimColor("#F69289")
SEAGREEN = ManimColor("#3FBC9D")
SEPIA = ManimColor("#671800")
SKYBLUE = ManimColor("#46C5DD")
SPRINGGREEN = ManimColor("#C6DC67")
TAN = ManimColor("#DA9D76")
TEALBLUE = ManimColor("#00AEB3")
THISTLE = ManimColor("#D883B7")
TURQUOISE = ManimColor("#00B4CE")
VIOLET = ManimColor("#58429B")
VIOLETRED = ManimColor("#EF58A0")
WHITE = ManimColor("#FFFFFF")
WILDSTRAWBERRY = ManimColor("#EE2967")
YELLOW = ManimColor("#FFF200")
YELLOWGREEN = ManimColor("#98CC70")
YELLOWORANGE = ManimColor("#FAA21A")
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.971">r"""SVG 1.1 Colors

This module contains the colors defined in the SVG 1.1 specification, which are commonly
accessed as named colors in LaTeX via the ``\usepackage[svgnames]{xcolor}`` package.

To use the colors from this list, access them directly from the module (which
is exposed to Manim's global name space):

.. code:: pycon

    &gt;&gt;&gt; from manim import SVGNAMES
    &gt;&gt;&gt; SVGNAMES.LIGHTCORAL
    ManimColor('#EF7F7F')

List of Color Constants
-----------------------

These hex values are derived from those specified in the ``xcolor`` package
documentation (see https://ctan.org/pkg/xcolor):

.. automanimcolormodule:: manim.utils.color.SVGNAMES

"""

from __future__ import annotations

from .core import ManimColor

ALICEBLUE = ManimColor("#EFF7FF")
ANTIQUEWHITE = ManimColor("#F9EAD7")
AQUA = ManimColor("#00FFFF")
AQUAMARINE = ManimColor("#7EFFD3")
AZURE = ManimColor("#EFFFFF")
BEIGE = ManimColor("#F4F4DC")
BISQUE = ManimColor("#FFE3C4")
BLACK = ManimColor("#000000")
BLANCHEDALMOND = ManimColor("#FFEACD")
BLUE = ManimColor("#0000FF")
BLUEVIOLET = ManimColor("#892BE2")
BROWN = ManimColor("#A52A2A")
BURLYWOOD = ManimColor("#DDB787")
CADETBLUE = ManimColor("#5E9EA0")
CHARTREUSE = ManimColor("#7EFF00")
CHOCOLATE = ManimColor("#D2681D")
CORAL = ManimColor("#FF7E4F")
CORNFLOWERBLUE = ManimColor("#6395ED")
CORNSILK = ManimColor("#FFF7DC")
CRIMSON = ManimColor("#DC143B")
CYAN = ManimColor("#00FFFF")
DARKBLUE = ManimColor("#00008A")
DARKCYAN = ManimColor("#008A8A")
DARKGOLDENROD = ManimColor("#B7850B")
DARKGRAY = ManimColor("#A9A9A9")
DARKGREEN = ManimColor("#006300")
DARKGREY = ManimColor("#A9A9A9")
DARKKHAKI = ManimColor("#BCB66B")
DARKMAGENTA = ManimColor("#8A008A")
DARKOLIVEGREEN = ManimColor("#546B2F")
DARKORANGE = ManimColor("#FF8C00")
DARKORCHID = ManimColor("#9931CC")
DARKRED = ManimColor("#8A0000")
DARKSALMON = ManimColor("#E8967A")
DARKSEAGREEN = ManimColor("#8EBB8E")
DARKSLATEBLUE = ManimColor("#483D8A")
DARKSLATEGRAY = ManimColor("#2F4F4F")
DARKSLATEGREY = ManimColor("#2F4F4F")
DARKTURQUOISE = ManimColor("#00CED1")
DARKVIOLET = ManimColor("#9300D3")
DEEPPINK = ManimColor("#FF1492")
DEEPSKYBLUE = ManimColor("#00BFFF")
DIMGRAY = ManimColor("#686868")
DIMGREY = ManimColor("#686868")
DODGERBLUE = ManimColor("#1D90FF")
FIREBRICK = ManimColor("#B12121")
FLORALWHITE = ManimColor("#FFF9EF")
FORESTGREEN = ManimColor("#218A21")
FUCHSIA = ManimColor("#FF00FF")
GAINSBORO = ManimColor("#DCDCDC")
GHOSTWHITE = ManimColor("#F7F7FF")
GOLD = ManimColor("#FFD700")
GOLDENROD = ManimColor("#DAA51F")
GRAY = ManimColor("#7F7F7F")
GREEN = ManimColor("#007F00")
GREENYELLOW = ManimColor("#ADFF2F")
GREY = ManimColor("#7F7F7F")
HONEYDEW = ManimColor("#EFFFEF")
HOTPINK = ManimColor("#FF68B3")
INDIANRED = ManimColor("#CD5B5B")
INDIGO = ManimColor("#4A0082")
IVORY = ManimColor("#FFFFEF")
KHAKI = ManimColor("#EFE58C")
LAVENDER = ManimColor("#E5E5F9")
LAVENDERBLUSH = ManimColor("#FFEFF4")
LAWNGREEN = ManimColor("#7CFC00")
LEMONCHIFFON = ManimColor("#FFF9CD")
LIGHTBLUE = ManimColor("#ADD8E5")
LIGHTCORAL = ManimColor("#EF7F7F")
LIGHTCYAN = ManimColor("#E0FFFF")
LIGHTGOLDENROD = ManimColor("#EDDD82")
LIGHTGOLDENRODYELLOW = ManimColor("#F9F9D2")
LIGHTGRAY = ManimColor("#D3D3D3")
LIGHTGREEN = ManimColor("#90ED90")
LIGHTGREY = ManimColor("#D3D3D3")
LIGHTPINK = ManimColor("#FFB5C0")
LIGHTSALMON = ManimColor("#FFA07A")
LIGHTSEAGREEN = ManimColor("#1FB1AA")
LIGHTSKYBLUE = ManimColor("#87CEF9")
LIGHTSLATEBLUE = ManimColor("#8470FF")
LIGHTSLATEGRAY = ManimColor("#778799")
LIGHTSLATEGREY = ManimColor("#778799")
LIGHTSTEELBLUE = ManimColor("#AFC4DD")
LIGHTYELLOW = ManimColor("#FFFFE0")
LIME = ManimColor("#00FF00")
LIMEGREEN = ManimColor("#31CD31")
LINEN = ManimColor("#F9EFE5")
MAGENTA = ManimColor("#FF00FF")
MAROON = ManimColor("#7F0000")
MEDIUMAQUAMARINE = ManimColor("#66CDAA")
MEDIUMBLUE = ManimColor("#0000CD")
MEDIUMORCHID = ManimColor("#BA54D3")
MEDIUMPURPLE = ManimColor("#9270DB")
MEDIUMSEAGREEN = ManimColor("#3BB271")
MEDIUMSLATEBLUE = ManimColor("#7B68ED")
MEDIUMSPRINGGREEN = ManimColor("#00F99A")
MEDIUMTURQUOISE = ManimColor("#48D1CC")
MEDIUMVIOLETRED = ManimColor("#C61584")
MIDNIGHTBLUE = ManimColor("#181870")
MINTCREAM = ManimColor("#F4FFF9")
MISTYROSE = ManimColor("#FFE3E1")
MOCCASIN = ManimColor("#FFE3B5")
NAVAJOWHITE = ManimColor("#FFDDAD")
NAVY = ManimColor("#00007F")
NAVYBLUE = ManimColor("#00007F")
OLDLACE = ManimColor("#FCF4E5")
OLIVE = ManimColor("#7F7F00")
OLIVEDRAB = ManimColor("#6B8D22")
ORANGE = ManimColor("#FFA500")
ORANGERED = ManimColor("#FF4400")
ORCHID = ManimColor("#DA70D6")
PALEGOLDENROD = ManimColor("#EDE8AA")
PALEGREEN = ManimColor("#97FB97")
PALETURQUOISE = ManimColor("#AFEDED")
PALEVIOLETRED = ManimColor("#DB7092")
PAPAYAWHIP = ManimColor("#FFEED4")
PEACHPUFF = ManimColor("#FFDAB8")
PERU = ManimColor("#CD843F")
PINK = ManimColor("#FFBFCA")
PLUM = ManimColor("#DDA0DD")
POWDERBLUE = ManimColor("#AFE0E5")
PURPLE = ManimColor("#7F007F")
RED = ManimColor("#FF0000")
ROSYBROWN = ManimColor("#BB8E8E")
ROYALBLUE = ManimColor("#4168E1")
SADDLEBROWN = ManimColor("#8A4413")
SALMON = ManimColor("#F97F72")
SANDYBROWN = ManimColor("#F3A45F")
SEAGREEN = ManimColor("#2D8A56")
SEASHELL = ManimColor("#FFF4ED")
SIENNA = ManimColor("#A0512C")
SILVER = ManimColor("#BFBFBF")
SKYBLUE = ManimColor("#87CEEA")
SLATEBLUE = ManimColor("#6959CD")
SLATEGRAY = ManimColor("#707F90")
SLATEGREY = ManimColor("#707F90")
SNOW = ManimColor("#FFF9F9")
SPRINGGREEN = ManimColor("#00FF7E")
STEELBLUE = ManimColor("#4682B3")
TAN = ManimColor("#D2B38C")
TEAL = ManimColor("#007F7F")
THISTLE = ManimColor("#D8BFD8")
TOMATO = ManimColor("#FF6347")
TURQUOISE = ManimColor("#3FE0CF")
VIOLET = ManimColor("#ED82ED")
VIOLETRED = ManimColor("#D01F90")
WHEAT = ManimColor("#F4DDB2")
WHITE = ManimColor("#FFFFFF")
WHITESMOKE = ManimColor("#F4F4F4")
YELLOW = ManimColor("#FFFF00")
YELLOWGREEN = ManimColor("#9ACD30")
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.972"># from https://www.w3schools.com/colors/colors_x11.asp

"""X11 Colors

These color and their names (taken from
https://www.w3schools.com/colors/colors_x11.asp) were developed at the
Massachusetts Intitute of Technology (MIT) during
the development of color based computer display system.

To use the colors from this list, access them directly from the module (which
is exposed to Manim's global name space):

.. code:: pycon

    &gt;&gt;&gt; from manim import X11
    &gt;&gt;&gt; X11.BEIGE
    ManimColor('#F5F5DC')


List of Color Constants
-----------------------

.. automanimcolormodule:: manim.utils.color.X11
"""

from __future__ import annotations

from .core import ManimColor

ALICEBLUE = ManimColor("#F0F8FF")
ANTIQUEWHITE = ManimColor("#FAEBD7")
ANTIQUEWHITE1 = ManimColor("#FFEFDB")
ANTIQUEWHITE2 = ManimColor("#EEDFCC")
ANTIQUEWHITE3 = ManimColor("#CDC0B0")
ANTIQUEWHITE4 = ManimColor("#8B8378")
AQUAMARINE1 = ManimColor("#7FFFD4")
AQUAMARINE2 = ManimColor("#76EEC6")
AQUAMARINE4 = ManimColor("#458B74")
AZURE1 = ManimColor("#F0FFFF")
AZURE2 = ManimColor("#E0EEEE")
AZURE3 = ManimColor("#C1CDCD")
AZURE4 = ManimColor("#838B8B")
BEIGE = ManimColor("#F5F5DC")
BISQUE1 = ManimColor("#FFE4C4")
BISQUE2 = ManimColor("#EED5B7")
BISQUE3 = ManimColor("#CDB79E")
BISQUE4 = ManimColor("#8B7D6B")
BLACK = ManimColor("#000000")
BLANCHEDALMOND = ManimColor("#FFEBCD")
BLUE1 = ManimColor("#0000FF")
BLUE2 = ManimColor("#0000EE")
BLUE4 = ManimColor("#00008B")
BLUEVIOLET = ManimColor("#8A2BE2")
BROWN = ManimColor("#A52A2A")
BROWN1 = ManimColor("#FF4040")
BROWN2 = ManimColor("#EE3B3B")
BROWN3 = ManimColor("#CD3333")
BROWN4 = ManimColor("#8B2323")
BURLYWOOD = ManimColor("#DEB887")
BURLYWOOD1 = ManimColor("#FFD39B")
BURLYWOOD2 = ManimColor("#EEC591")
BURLYWOOD3 = ManimColor("#CDAA7D")
BURLYWOOD4 = ManimColor("#8B7355")
CADETBLUE = ManimColor("#5F9EA0")
CADETBLUE1 = ManimColor("#98F5FF")
CADETBLUE2 = ManimColor("#8EE5EE")
CADETBLUE3 = ManimColor("#7AC5CD")
CADETBLUE4 = ManimColor("#53868B")
CHARTREUSE1 = ManimColor("#7FFF00")
CHARTREUSE2 = ManimColor("#76EE00")
CHARTREUSE3 = ManimColor("#66CD00")
CHARTREUSE4 = ManimColor("#458B00")
CHOCOLATE = ManimColor("#D2691E")
CHOCOLATE1 = ManimColor("#FF7F24")
CHOCOLATE2 = ManimColor("#EE7621")
CHOCOLATE3 = ManimColor("#CD661D")
CORAL = ManimColor("#FF7F50")
CORAL1 = ManimColor("#FF7256")
CORAL2 = ManimColor("#EE6A50")
CORAL3 = ManimColor("#CD5B45")
CORAL4 = ManimColor("#8B3E2F")
CORNFLOWERBLUE = ManimColor("#6495ED")
CORNSILK1 = ManimColor("#FFF8DC")
CORNSILK2 = ManimColor("#EEE8CD")
CORNSILK3 = ManimColor("#CDC8B1")
CORNSILK4 = ManimColor("#8B8878")
CYAN1 = ManimColor("#00FFFF")
CYAN2 = ManimColor("#00EEEE")
CYAN3 = ManimColor("#00CDCD")
CYAN4 = ManimColor("#008B8B")
DARKGOLDENROD = ManimColor("#B8860B")
DARKGOLDENROD1 = ManimColor("#FFB90F")
DARKGOLDENROD2 = ManimColor("#EEAD0E")
DARKGOLDENROD3 = ManimColor("#CD950C")
DARKGOLDENROD4 = ManimColor("#8B6508")
DARKGREEN = ManimColor("#006400")
DARKKHAKI = ManimColor("#BDB76B")
DARKOLIVEGREEN = ManimColor("#556B2F")
DARKOLIVEGREEN1 = ManimColor("#CAFF70")
DARKOLIVEGREEN2 = ManimColor("#BCEE68")
DARKOLIVEGREEN3 = ManimColor("#A2CD5A")
DARKOLIVEGREEN4 = ManimColor("#6E8B3D")
DARKORANGE = ManimColor("#FF8C00")
DARKORANGE1 = ManimColor("#FF7F00")
DARKORANGE2 = ManimColor("#EE7600")
DARKORANGE3 = ManimColor("#CD6600")
DARKORANGE4 = ManimColor("#8B4500")
DARKORCHID = ManimColor("#9932CC")
DARKORCHID1 = ManimColor("#BF3EFF")
DARKORCHID2 = ManimColor("#B23AEE")
DARKORCHID3 = ManimColor("#9A32CD")
DARKORCHID4 = ManimColor("#68228B")
DARKSALMON = ManimColor("#E9967A")
DARKSEAGREEN = ManimColor("#8FBC8F")
DARKSEAGREEN1 = ManimColor("#C1FFC1")
DARKSEAGREEN2 = ManimColor("#B4EEB4")
DARKSEAGREEN3 = ManimColor("#9BCD9B")
DARKSEAGREEN4 = ManimColor("#698B69")
DARKSLATEBLUE = ManimColor("#483D8B")
DARKSLATEGRAY = ManimColor("#2F4F4F")
DARKSLATEGRAY1 = ManimColor("#97FFFF")
DARKSLATEGRAY2 = ManimColor("#8DEEEE")
DARKSLATEGRAY3 = ManimColor("#79CDCD")
DARKSLATEGRAY4 = ManimColor("#528B8B")
DARKTURQUOISE = ManimColor("#00CED1")
DARKVIOLET = ManimColor("#9400D3")
DEEPPINK1 = ManimColor("#FF1493")
DEEPPINK2 = ManimColor("#EE1289")
DEEPPINK3 = ManimColor("#CD1076")
DEEPPINK4 = ManimColor("#8B0A50")
DEEPSKYBLUE1 = ManimColor("#00BFFF")
DEEPSKYBLUE2 = ManimColor("#00B2EE")
DEEPSKYBLUE3 = ManimColor("#009ACD")
DEEPSKYBLUE4 = ManimColor("#00688B")
DIMGRAY = ManimColor("#696969")
DODGERBLUE1 = ManimColor("#1E90FF")
DODGERBLUE2 = ManimColor("#1C86EE")
DODGERBLUE3 = ManimColor("#1874CD")
DODGERBLUE4 = ManimColor("#104E8B")
FIREBRICK = ManimColor("#B22222")
FIREBRICK1 = ManimColor("#FF3030")
FIREBRICK2 = ManimColor("#EE2C2C")
FIREBRICK3 = ManimColor("#CD2626")
FIREBRICK4 = ManimColor("#8B1A1A")
FLORALWHITE = ManimColor("#FFFAF0")
FORESTGREEN = ManimColor("#228B22")
GAINSBORO = ManimColor("#DCDCDC")
GHOSTWHITE = ManimColor("#F8F8FF")
GOLD1 = ManimColor("#FFD700")
GOLD2 = ManimColor("#EEC900")
GOLD3 = ManimColor("#CDAD00")
GOLD4 = ManimColor("#8B7500")
GOLDENROD = ManimColor("#DAA520")
GOLDENROD1 = ManimColor("#FFC125")
GOLDENROD2 = ManimColor("#EEB422")
GOLDENROD3 = ManimColor("#CD9B1D")
GOLDENROD4 = ManimColor("#8B6914")
GRAY = ManimColor("#BEBEBE")
GRAY1 = ManimColor("#030303")
GRAY2 = ManimColor("#050505")
GRAY3 = ManimColor("#080808")
GRAY4 = ManimColor("#0A0A0A")
GRAY5 = ManimColor("#0D0D0D")
GRAY6 = ManimColor("#0F0F0F")
GRAY7 = ManimColor("#121212")
GRAY8 = ManimColor("#141414")
GRAY9 = ManimColor("#171717")
GRAY10 = ManimColor("#1A1A1A")
GRAY11 = ManimColor("#1C1C1C")
GRAY12 = ManimColor("#1F1F1F")
GRAY13 = ManimColor("#212121")
GRAY14 = ManimColor("#242424")
GRAY15 = ManimColor("#262626")
GRAY16 = ManimColor("#292929")
GRAY17 = ManimColor("#2B2B2B")
GRAY18 = ManimColor("#2E2E2E")
GRAY19 = ManimColor("#303030")
GRAY20 = ManimColor("#333333")
GRAY21 = ManimColor("#363636")
GRAY22 = ManimColor("#383838")
GRAY23 = ManimColor("#3B3B3B")
GRAY24 = ManimColor("#3D3D3D")
GRAY25 = ManimColor("#404040")
GRAY26 = ManimColor("#424242")
GRAY27 = ManimColor("#454545")
GRAY28 = ManimColor("#474747")
GRAY29 = ManimColor("#4A4A4A")
GRAY30 = ManimColor("#4D4D4D")
GRAY31 = ManimColor("#4F4F4F")
GRAY32 = ManimColor("#525252")
GRAY33 = ManimColor("#545454")
GRAY34 = ManimColor("#575757")
GRAY35 = ManimColor("#595959")
GRAY36 = ManimColor("#5C5C5C")
GRAY37 = ManimColor("#5E5E5E")
GRAY38 = ManimColor("#616161")
GRAY39 = ManimColor("#636363")
GRAY40 = ManimColor("#666666")
GRAY41 = ManimColor("#696969")
GRAY42 = ManimColor("#6B6B6B")
GRAY43 = ManimColor("#6E6E6E")
GRAY44 = ManimColor("#707070")
GRAY45 = ManimColor("#737373")
GRAY46 = ManimColor("#757575")
GRAY47 = ManimColor("#787878")
GRAY48 = ManimColor("#7A7A7A")
GRAY49 = ManimColor("#7D7D7D")
GRAY50 = ManimColor("#7F7F7F")
GRAY51 = ManimColor("#828282")
GRAY52 = ManimColor("#858585")
GRAY53 = ManimColor("#878787")
GRAY54 = ManimColor("#8A8A8A")
GRAY55 = ManimColor("#8C8C8C")
GRAY56 = ManimColor("#8F8F8F")
GRAY57 = ManimColor("#919191")
GRAY58 = ManimColor("#949494")
GRAY59 = ManimColor("#969696")
GRAY60 = ManimColor("#999999")
GRAY61 = ManimColor("#9C9C9C")
GRAY62 = ManimColor("#9E9E9E")
GRAY63 = ManimColor("#A1A1A1")
GRAY64 = ManimColor("#A3A3A3")
GRAY65 = ManimColor("#A6A6A6")
GRAY66 = ManimColor("#A8A8A8")
GRAY67 = ManimColor("#ABABAB")
GRAY68 = ManimColor("#ADADAD")
GRAY69 = ManimColor("#B0B0B0")
GRAY70 = ManimColor("#B3B3B3")
GRAY71 = ManimColor("#B5B5B5")
GRAY72 = ManimColor("#B8B8B8")
GRAY73 = ManimColor("#BABABA")
GRAY74 = ManimColor("#BDBDBD")
GRAY75 = ManimColor("#BFBFBF")
GRAY76 = ManimColor("#C2C2C2")
GRAY77 = ManimColor("#C4C4C4")
GRAY78 = ManimColor("#C7C7C7")
GRAY79 = ManimColor("#C9C9C9")
GRAY80 = ManimColor("#CCCCCC")
GRAY81 = ManimColor("#CFCFCF")
GRAY82 = ManimColor("#D1D1D1")
GRAY83 = ManimColor("#D4D4D4")
GRAY84 = ManimColor("#D6D6D6")
GRAY85 = ManimColor("#D9D9D9")
GRAY86 = ManimColor("#DBDBDB")
GRAY87 = ManimColor("#DEDEDE")
GRAY88 = ManimColor("#E0E0E0")
GRAY89 = ManimColor("#E3E3E3")
GRAY90 = ManimColor("#E5E5E5")
GRAY91 = ManimColor("#E8E8E8")
GRAY92 = ManimColor("#EBEBEB")
GRAY93 = ManimColor("#EDEDED")
GRAY94 = ManimColor("#F0F0F0")
GRAY95 = ManimColor("#F2F2F2")
GRAY97 = ManimColor("#F7F7F7")
GRAY98 = ManimColor("#FAFAFA")
GRAY99 = ManimColor("#FCFCFC")
GREEN1 = ManimColor("#00FF00")
GREEN2 = ManimColor("#00EE00")
GREEN3 = ManimColor("#00CD00")
GREEN4 = ManimColor("#008B00")
GREENYELLOW = ManimColor("#ADFF2F")
HONEYDEW1 = ManimColor("#F0FFF0")
HONEYDEW2 = ManimColor("#E0EEE0")
HONEYDEW3 = ManimColor("#C1CDC1")
HONEYDEW4 = ManimColor("#838B83")
HOTPINK = ManimColor("#FF69B4")
HOTPINK1 = ManimColor("#FF6EB4")
HOTPINK2 = ManimColor("#EE6AA7")
HOTPINK3 = ManimColor("#CD6090")
HOTPINK4 = ManimColor("#8B3A62")
INDIANRED = ManimColor("#CD5C5C")
INDIANRED1 = ManimColor("#FF6A6A")
INDIANRED2 = ManimColor("#EE6363")
INDIANRED3 = ManimColor("#CD5555")
INDIANRED4 = ManimColor("#8B3A3A")
IVORY1 = ManimColor("#FFFFF0")
IVORY2 = ManimColor("#EEEEE0")
IVORY3 = ManimColor("#CDCDC1")
IVORY4 = ManimColor("#8B8B83")
KHAKI = ManimColor("#F0E68C")
KHAKI1 = ManimColor("#FFF68F")
KHAKI2 = ManimColor("#EEE685")
KHAKI3 = ManimColor("#CDC673")
KHAKI4 = ManimColor("#8B864E")
LAVENDER = ManimColor("#E6E6FA")
LAVENDERBLUSH1 = ManimColor("#FFF0F5")
LAVENDERBLUSH2 = ManimColor("#EEE0E5")
LAVENDERBLUSH3 = ManimColor("#CDC1C5")
LAVENDERBLUSH4 = ManimColor("#8B8386")
LAWNGREEN = ManimColor("#7CFC00")
LEMONCHIFFON1 = ManimColor("#FFFACD")
LEMONCHIFFON2 = ManimColor("#EEE9BF")
LEMONCHIFFON3 = ManimColor("#CDC9A5")
LEMONCHIFFON4 = ManimColor("#8B8970")
LIGHT = ManimColor("#EEDD82")
LIGHTBLUE = ManimColor("#ADD8E6")
LIGHTBLUE1 = ManimColor("#BFEFFF")
LIGHTBLUE2 = ManimColor("#B2DFEE")
LIGHTBLUE3 = ManimColor("#9AC0CD")
LIGHTBLUE4 = ManimColor("#68838B")
LIGHTCORAL = ManimColor("#F08080")
LIGHTCYAN1 = ManimColor("#E0FFFF")
LIGHTCYAN2 = ManimColor("#D1EEEE")
LIGHTCYAN3 = ManimColor("#B4CDCD")
LIGHTCYAN4 = ManimColor("#7A8B8B")
LIGHTGOLDENROD1 = ManimColor("#FFEC8B")
LIGHTGOLDENROD2 = ManimColor("#EEDC82")
LIGHTGOLDENROD3 = ManimColor("#CDBE70")
LIGHTGOLDENROD4 = ManimColor("#8B814C")
LIGHTGOLDENRODYELLOW = ManimColor("#FAFAD2")
LIGHTGRAY = ManimColor("#D3D3D3")
LIGHTPINK = ManimColor("#FFB6C1")
LIGHTPINK1 = ManimColor("#FFAEB9")
LIGHTPINK2 = ManimColor("#EEA2AD")
LIGHTPINK3 = ManimColor("#CD8C95")
LIGHTPINK4 = ManimColor("#8B5F65")
LIGHTSALMON1 = ManimColor("#FFA07A")
LIGHTSALMON2 = ManimColor("#EE9572")
LIGHTSALMON3 = ManimColor("#CD8162")
LIGHTSALMON4 = ManimColor("#8B5742")
LIGHTSEAGREEN = ManimColor("#20B2AA")
LIGHTSKYBLUE = ManimColor("#87CEFA")
LIGHTSKYBLUE1 = ManimColor("#B0E2FF")
LIGHTSKYBLUE2 = ManimColor("#A4D3EE")
LIGHTSKYBLUE3 = ManimColor("#8DB6CD")
LIGHTSKYBLUE4 = ManimColor("#607B8B")
LIGHTSLATEBLUE = ManimColor("#8470FF")
LIGHTSLATEGRAY = ManimColor("#778899")
LIGHTSTEELBLUE = ManimColor("#B0C4DE")
LIGHTSTEELBLUE1 = ManimColor("#CAE1FF")
LIGHTSTEELBLUE2 = ManimColor("#BCD2EE")
LIGHTSTEELBLUE3 = ManimColor("#A2B5CD")
LIGHTSTEELBLUE4 = ManimColor("#6E7B8B")
LIGHTYELLOW1 = ManimColor("#FFFFE0")
LIGHTYELLOW2 = ManimColor("#EEEED1")
LIGHTYELLOW3 = ManimColor("#CDCDB4")
LIGHTYELLOW4 = ManimColor("#8B8B7A")
LIMEGREEN = ManimColor("#32CD32")
LINEN = ManimColor("#FAF0E6")
MAGENTA = ManimColor("#FF00FF")
MAGENTA2 = ManimColor("#EE00EE")
MAGENTA3 = ManimColor("#CD00CD")
MAGENTA4 = ManimColor("#8B008B")
MAROON = ManimColor("#B03060")
MAROON1 = ManimColor("#FF34B3")
MAROON2 = ManimColor("#EE30A7")
MAROON3 = ManimColor("#CD2990")
MAROON4 = ManimColor("#8B1C62")
MEDIUM = ManimColor("#66CDAA")
MEDIUMAQUAMARINE = ManimColor("#66CDAA")
MEDIUMBLUE = ManimColor("#0000CD")
MEDIUMORCHID = ManimColor("#BA55D3")
MEDIUMORCHID1 = ManimColor("#E066FF")
MEDIUMORCHID2 = ManimColor("#D15FEE")
MEDIUMORCHID3 = ManimColor("#B452CD")
MEDIUMORCHID4 = ManimColor("#7A378B")
MEDIUMPURPLE = ManimColor("#9370DB")
MEDIUMPURPLE1 = ManimColor("#AB82FF")
MEDIUMPURPLE2 = ManimColor("#9F79EE")
MEDIUMPURPLE3 = ManimColor("#8968CD")
MEDIUMPURPLE4 = ManimColor("#5D478B")
MEDIUMSEAGREEN = ManimColor("#3CB371")
MEDIUMSLATEBLUE = ManimColor("#7B68EE")
MEDIUMSPRINGGREEN = ManimColor("#00FA9A")
MEDIUMTURQUOISE = ManimColor("#48D1CC")
MEDIUMVIOLETRED = ManimColor("#C71585")
MIDNIGHTBLUE = ManimColor("#191970")
MINTCREAM = ManimColor("#F5FFFA")
MISTYROSE1 = ManimColor("#FFE4E1")
MISTYROSE2 = ManimColor("#EED5D2")
MISTYROSE3 = ManimColor("#CDB7B5")
MISTYROSE4 = ManimColor("#8B7D7B")
MOCCASIN = ManimColor("#FFE4B5")
NAVAJOWHITE1 = ManimColor("#FFDEAD")
NAVAJOWHITE2 = ManimColor("#EECFA1")
NAVAJOWHITE3 = ManimColor("#CDB38B")
NAVAJOWHITE4 = ManimColor("#8B795E")
NAVYBLUE = ManimColor("#000080")
OLDLACE = ManimColor("#FDF5E6")
OLIVEDRAB = ManimColor("#6B8E23")
OLIVEDRAB1 = ManimColor("#C0FF3E")
OLIVEDRAB2 = ManimColor("#B3EE3A")
OLIVEDRAB4 = ManimColor("#698B22")
ORANGE1 = ManimColor("#FFA500")
ORANGE2 = ManimColor("#EE9A00")
ORANGE3 = ManimColor("#CD8500")
ORANGE4 = ManimColor("#8B5A00")
ORANGERED1 = ManimColor("#FF4500")
ORANGERED2 = ManimColor("#EE4000")
ORANGERED3 = ManimColor("#CD3700")
ORANGERED4 = ManimColor("#8B2500")
ORCHID = ManimColor("#DA70D6")
ORCHID1 = ManimColor("#FF83FA")
ORCHID2 = ManimColor("#EE7AE9")
ORCHID3 = ManimColor("#CD69C9")
ORCHID4 = ManimColor("#8B4789")
PALE = ManimColor("#DB7093")
PALEGOLDENROD = ManimColor("#EEE8AA")
PALEGREEN = ManimColor("#98FB98")
PALEGREEN1 = ManimColor("#9AFF9A")
PALEGREEN2 = ManimColor("#90EE90")
PALEGREEN3 = ManimColor("#7CCD7C")
PALEGREEN4 = ManimColor("#548B54")
PALETURQUOISE = ManimColor("#AFEEEE")
PALETURQUOISE1 = ManimColor("#BBFFFF")
PALETURQUOISE2 = ManimColor("#AEEEEE")
PALETURQUOISE3 = ManimColor("#96CDCD")
PALETURQUOISE4 = ManimColor("#668B8B")
PALEVIOLETRED = ManimColor("#DB7093")
PALEVIOLETRED1 = ManimColor("#FF82AB")
PALEVIOLETRED2 = ManimColor("#EE799F")
PALEVIOLETRED3 = ManimColor("#CD6889")
PALEVIOLETRED4 = ManimColor("#8B475D")
PAPAYAWHIP = ManimColor("#FFEFD5")
PEACHPUFF1 = ManimColor("#FFDAB9")
PEACHPUFF2 = ManimColor("#EECBAD")
PEACHPUFF3 = ManimColor("#CDAF95")
PEACHPUFF4 = ManimColor("#8B7765")
PINK = ManimColor("#FFC0CB")
PINK1 = ManimColor("#FFB5C5")
PINK2 = ManimColor("#EEA9B8")
PINK3 = ManimColor("#CD919E")
PINK4 = ManimColor("#8B636C")
PLUM = ManimColor("#DDA0DD")
PLUM1 = ManimColor("#FFBBFF")
PLUM2 = ManimColor("#EEAEEE")
PLUM3 = ManimColor("#CD96CD")
PLUM4 = ManimColor("#8B668B")
POWDERBLUE = ManimColor("#B0E0E6")
PURPLE = ManimColor("#A020F0")
PURPLE1 = ManimColor("#9B30FF")
PURPLE2 = ManimColor("#912CEE")
PURPLE3 = ManimColor("#7D26CD")
PURPLE4 = ManimColor("#551A8B")
RED1 = ManimColor("#FF0000")
RED2 = ManimColor("#EE0000")
RED3 = ManimColor("#CD0000")
RED4 = ManimColor("#8B0000")
ROSYBROWN = ManimColor("#BC8F8F")
ROSYBROWN1 = ManimColor("#FFC1C1")
ROSYBROWN2 = ManimColor("#EEB4B4")
ROSYBROWN3 = ManimColor("#CD9B9B")
ROSYBROWN4 = ManimColor("#8B6969")
ROYALBLUE = ManimColor("#4169E1")
ROYALBLUE1 = ManimColor("#4876FF")
ROYALBLUE2 = ManimColor("#436EEE")
ROYALBLUE3 = ManimColor("#3A5FCD")
ROYALBLUE4 = ManimColor("#27408B")
SADDLEBROWN = ManimColor("#8B4513")
SALMON = ManimColor("#FA8072")
SALMON1 = ManimColor("#FF8C69")
SALMON2 = ManimColor("#EE8262")
SALMON3 = ManimColor("#CD7054")
SALMON4 = ManimColor("#8B4C39")
SANDYBROWN = ManimColor("#F4A460")
SEAGREEN1 = ManimColor("#54FF9F")
SEAGREEN2 = ManimColor("#4EEE94")
SEAGREEN3 = ManimColor("#43CD80")
SEAGREEN4 = ManimColor("#2E8B57")
SEASHELL1 = ManimColor("#FFF5EE")
SEASHELL2 = ManimColor("#EEE5DE")
SEASHELL3 = ManimColor("#CDC5BF")
SEASHELL4 = ManimColor("#8B8682")
SIENNA = ManimColor("#A0522D")
SIENNA1 = ManimColor("#FF8247")
SIENNA2 = ManimColor("#EE7942")
SIENNA3 = ManimColor("#CD6839")
SIENNA4 = ManimColor("#8B4726")
SKYBLUE = ManimColor("#87CEEB")
SKYBLUE1 = ManimColor("#87CEFF")
SKYBLUE2 = ManimColor("#7EC0EE")
SKYBLUE3 = ManimColor("#6CA6CD")
SKYBLUE4 = ManimColor("#4A708B")
SLATEBLUE = ManimColor("#6A5ACD")
SLATEBLUE1 = ManimColor("#836FFF")
SLATEBLUE2 = ManimColor("#7A67EE")
SLATEBLUE3 = ManimColor("#6959CD")
SLATEBLUE4 = ManimColor("#473C8B")
SLATEGRAY = ManimColor("#708090")
SLATEGRAY1 = ManimColor("#C6E2FF")
SLATEGRAY2 = ManimColor("#B9D3EE")
SLATEGRAY3 = ManimColor("#9FB6CD")
SLATEGRAY4 = ManimColor("#6C7B8B")
SNOW1 = ManimColor("#FFFAFA")
SNOW2 = ManimColor("#EEE9E9")
SNOW3 = ManimColor("#CDC9C9")
SNOW4 = ManimColor("#8B8989")
SPRINGGREEN1 = ManimColor("#00FF7F")
SPRINGGREEN2 = ManimColor("#00EE76")
SPRINGGREEN3 = ManimColor("#00CD66")
SPRINGGREEN4 = ManimColor("#008B45")
STEELBLUE = ManimColor("#4682B4")
STEELBLUE1 = ManimColor("#63B8FF")
STEELBLUE2 = ManimColor("#5CACEE")
STEELBLUE3 = ManimColor("#4F94CD")
STEELBLUE4 = ManimColor("#36648B")
TAN = ManimColor("#D2B48C")
TAN1 = ManimColor("#FFA54F")
TAN2 = ManimColor("#EE9A49")
TAN3 = ManimColor("#CD853F")
TAN4 = ManimColor("#8B5A2B")
THISTLE = ManimColor("#D8BFD8")
THISTLE1 = ManimColor("#FFE1FF")
THISTLE2 = ManimColor("#EED2EE")
THISTLE3 = ManimColor("#CDB5CD")
THISTLE4 = ManimColor("#8B7B8B")
TOMATO1 = ManimColor("#FF6347")
TOMATO2 = ManimColor("#EE5C42")
TOMATO3 = ManimColor("#CD4F39")
TOMATO4 = ManimColor("#8B3626")
TURQUOISE = ManimColor("#40E0D0")
TURQUOISE1 = ManimColor("#00F5FF")
TURQUOISE2 = ManimColor("#00E5EE")
TURQUOISE3 = ManimColor("#00C5CD")
TURQUOISE4 = ManimColor("#00868B")
VIOLET = ManimColor("#EE82EE")
VIOLETRED = ManimColor("#D02090")
VIOLETRED1 = ManimColor("#FF3E96")
VIOLETRED2 = ManimColor("#EE3A8C")
VIOLETRED3 = ManimColor("#CD3278")
VIOLETRED4 = ManimColor("#8B2252")
WHEAT = ManimColor("#F5DEB3")
WHEAT1 = ManimColor("#FFE7BA")
WHEAT2 = ManimColor("#EED8AE")
WHEAT3 = ManimColor("#CDBA96")
WHEAT4 = ManimColor("#8B7E66")
WHITE = ManimColor("#FFFFFF")
WHITESMOKE = ManimColor("#F5F5F5")
YELLOW1 = ManimColor("#FFFF00")
YELLOW2 = ManimColor("#EEEE00")
YELLOW3 = ManimColor("#CDCD00")
YELLOW4 = ManimColor("#8B8B00")
YELLOWGREEN = ManimColor("#9ACD32")
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.973">"""Colors from the XKCD Color Name Survey

XKCD is a popular `web comic &lt;https://xkcd.com/353/&gt;`__ created by Randall Munroe.
His "`Color Name Survey &lt;http://blog.xkcd.com/2010/05/03/color-survey-results/&gt;`__" (with
200000 participants) resulted in a list of nearly 1000 color names.

While the ``XKCD`` module is exposed to Manim's global name space, the colors included
in it are not. This means that in order to use the colors, access them via the module name:

.. code:: pycon

    &gt;&gt;&gt; from manim import XKCD
    &gt;&gt;&gt; XKCD.MANGO
    ManimColor('#FFA62B')


List of Color Constants
-----------------------

These hex values are non official approximate values intended to simulate the colors in HTML,
taken from https://www.w3schools.com/colors/colors_xkcd.asp.

.. automanimcolormodule:: manim.utils.color.XKCD

"""

from __future__ import annotations

from .core import ManimColor

ACIDGREEN = ManimColor("#8FFE09")
ADOBE = ManimColor("#BD6C48")
ALGAE = ManimColor("#54AC68")
ALGAEGREEN = ManimColor("#21C36F")
ALMOSTBLACK = ManimColor("#070D0D")
AMBER = ManimColor("#FEB308")
AMETHYST = ManimColor("#9B5FC0")
APPLE = ManimColor("#6ECB3C")
APPLEGREEN = ManimColor("#76CD26")
APRICOT = ManimColor("#FFB16D")
AQUA = ManimColor("#13EAC9")
AQUABLUE = ManimColor("#02D8E9")
AQUAGREEN = ManimColor("#12E193")
AQUAMARINE = ManimColor("#2EE8BB")
ARMYGREEN = ManimColor("#4B5D16")
ASPARAGUS = ManimColor("#77AB56")
AUBERGINE = ManimColor("#3D0734")
AUBURN = ManimColor("#9A3001")
AVOCADO = ManimColor("#90B134")
AVOCADOGREEN = ManimColor("#87A922")
AZUL = ManimColor("#1D5DEC")
AZURE = ManimColor("#069AF3")
BABYBLUE = ManimColor("#A2CFFE")
BABYGREEN = ManimColor("#8CFF9E")
BABYPINK = ManimColor("#FFB7CE")
BABYPOO = ManimColor("#AB9004")
BABYPOOP = ManimColor("#937C00")
BABYPOOPGREEN = ManimColor("#8F9805")
BABYPUKEGREEN = ManimColor("#B6C406")
BABYPURPLE = ManimColor("#CA9BF7")
BABYSHITBROWN = ManimColor("#AD900D")
BABYSHITGREEN = ManimColor("#889717")
BANANA = ManimColor("#FFFF7E")
BANANAYELLOW = ManimColor("#FAFE4B")
BARBIEPINK = ManimColor("#FE46A5")
BARFGREEN = ManimColor("#94AC02")
BARNEY = ManimColor("#AC1DB8")
BARNEYPURPLE = ManimColor("#A00498")
BATTLESHIPGREY = ManimColor("#6B7C85")
BEIGE = ManimColor("#E6DAA6")
BERRY = ManimColor("#990F4B")
BILE = ManimColor("#B5C306")
BLACK = ManimColor("#000000")
BLAND = ManimColor("#AFA88B")
BLOOD = ManimColor("#770001")
BLOODORANGE = ManimColor("#FE4B03")
BLOODRED = ManimColor("#980002")
BLUE = ManimColor("#0343DF")
BLUEBERRY = ManimColor("#464196")
BLUEBLUE = ManimColor("#2242C7")
BLUEGREEN = ManimColor("#0F9B8E")
BLUEGREY = ManimColor("#85A3B2")
BLUEPURPLE = ManimColor("#5A06EF")
BLUEVIOLET = ManimColor("#5D06E9")
BLUEWITHAHINTOFPURPLE = ManimColor("#533CC6")
BLUEYGREEN = ManimColor("#2BB179")
BLUEYGREY = ManimColor("#89A0B0")
BLUEYPURPLE = ManimColor("#6241C7")
BLUISH = ManimColor("#2976BB")
BLUISHGREEN = ManimColor("#10A674")
BLUISHGREY = ManimColor("#748B97")
BLUISHPURPLE = ManimColor("#703BE7")
BLURPLE = ManimColor("#5539CC")
BLUSH = ManimColor("#F29E8E")
BLUSHPINK = ManimColor("#FE828C")
BOOGER = ManimColor("#9BB53C")
BOOGERGREEN = ManimColor("#96B403")
BORDEAUX = ManimColor("#7B002C")
BORINGGREEN = ManimColor("#63B365")
BOTTLEGREEN = ManimColor("#044A05")
BRICK = ManimColor("#A03623")
BRICKORANGE = ManimColor("#C14A09")
BRICKRED = ManimColor("#8F1402")
BRIGHTAQUA = ManimColor("#0BF9EA")
BRIGHTBLUE = ManimColor("#0165FC")
BRIGHTCYAN = ManimColor("#41FDFE")
BRIGHTGREEN = ManimColor("#01FF07")
BRIGHTLAVENDER = ManimColor("#C760FF")
BRIGHTLIGHTBLUE = ManimColor("#26F7FD")
BRIGHTLIGHTGREEN = ManimColor("#2DFE54")
BRIGHTLILAC = ManimColor("#C95EFB")
BRIGHTLIME = ManimColor("#87FD05")
BRIGHTLIMEGREEN = ManimColor("#65FE08")
BRIGHTMAGENTA = ManimColor("#FF08E8")
BRIGHTOLIVE = ManimColor("#9CBB04")
BRIGHTORANGE = ManimColor("#FF5B00")
BRIGHTPINK = ManimColor("#FE01B1")
BRIGHTPURPLE = ManimColor("#BE03FD")
BRIGHTRED = ManimColor("#FF000D")
BRIGHTSEAGREEN = ManimColor("#05FFA6")
BRIGHTSKYBLUE = ManimColor("#02CCFE")
BRIGHTTEAL = ManimColor("#01F9C6")
BRIGHTTURQUOISE = ManimColor("#0FFEF9")
BRIGHTVIOLET = ManimColor("#AD0AFD")
BRIGHTYELLOW = ManimColor("#FFFD01")
BRIGHTYELLOWGREEN = ManimColor("#9DFF00")
BRITISHRACINGGREEN = ManimColor("#05480D")
BRONZE = ManimColor("#A87900")
BROWN = ManimColor("#653700")
BROWNGREEN = ManimColor("#706C11")
BROWNGREY = ManimColor("#8D8468")
BROWNISH = ManimColor("#9C6D57")
BROWNISHGREEN = ManimColor("#6A6E09")
BROWNISHGREY = ManimColor("#86775F")
BROWNISHORANGE = ManimColor("#CB7723")
BROWNISHPINK = ManimColor("#C27E79")
BROWNISHPURPLE = ManimColor("#76424E")
BROWNISHRED = ManimColor("#9E3623")
BROWNISHYELLOW = ManimColor("#C9B003")
BROWNORANGE = ManimColor("#B96902")
BROWNRED = ManimColor("#922B05")
BROWNYELLOW = ManimColor("#B29705")
BROWNYGREEN = ManimColor("#6F6C0A")
BROWNYORANGE = ManimColor("#CA6B02")
BRUISE = ManimColor("#7E4071")
BUBBLEGUM = ManimColor("#FF6CB5")
BUBBLEGUMPINK = ManimColor("#FF69AF")
BUFF = ManimColor("#FEF69E")
BURGUNDY = ManimColor("#610023")
BURNTORANGE = ManimColor("#C04E01")
BURNTRED = ManimColor("#9F2305")
BURNTSIENA = ManimColor("#B75203")
BURNTSIENNA = ManimColor("#B04E0F")
BURNTUMBER = ManimColor("#A0450E")
BURNTYELLOW = ManimColor("#D5AB09")
BURPLE = ManimColor("#6832E3")
BUTTER = ManimColor("#FFFF81")
BUTTERSCOTCH = ManimColor("#FDB147")
BUTTERYELLOW = ManimColor("#FFFD74")
CADETBLUE = ManimColor("#4E7496")
CAMEL = ManimColor("#C69F59")
CAMO = ManimColor("#7F8F4E")
CAMOGREEN = ManimColor("#526525")
CAMOUFLAGEGREEN = ManimColor("#4B6113")
CANARY = ManimColor("#FDFF63")
CANARYYELLOW = ManimColor("#FFFE40")
CANDYPINK = ManimColor("#FF63E9")
CARAMEL = ManimColor("#AF6F09")
CARMINE = ManimColor("#9D0216")
CARNATION = ManimColor("#FD798F")
CARNATIONPINK = ManimColor("#FF7FA7")
CAROLINABLUE = ManimColor("#8AB8FE")
CELADON = ManimColor("#BEFDB7")
CELERY = ManimColor("#C1FD95")
CEMENT = ManimColor("#A5A391")
CERISE = ManimColor("#DE0C62")
CERULEAN = ManimColor("#0485D1")
CERULEANBLUE = ManimColor("#056EEE")
CHARCOAL = ManimColor("#343837")
CHARCOALGREY = ManimColor("#3C4142")
CHARTREUSE = ManimColor("#C1F80A")
CHERRY = ManimColor("#CF0234")
CHERRYRED = ManimColor("#F7022A")
CHESTNUT = ManimColor("#742802")
CHOCOLATE = ManimColor("#3D1C02")
CHOCOLATEBROWN = ManimColor("#411900")
CINNAMON = ManimColor("#AC4F06")
CLARET = ManimColor("#680018")
CLAY = ManimColor("#B66A50")
CLAYBROWN = ManimColor("#B2713D")
CLEARBLUE = ManimColor("#247AFD")
COBALT = ManimColor("#1E488F")
COBALTBLUE = ManimColor("#030AA7")
COCOA = ManimColor("#875F42")
COFFEE = ManimColor("#A6814C")
COOLBLUE = ManimColor("#4984B8")
COOLGREEN = ManimColor("#33B864")
COOLGREY = ManimColor("#95A3A6")
COPPER = ManimColor("#B66325")
CORAL = ManimColor("#FC5A50")
CORALPINK = ManimColor("#FF6163")
CORNFLOWER = ManimColor("#6A79F7")
CORNFLOWERBLUE = ManimColor("#5170D7")
CRANBERRY = ManimColor("#9E003A")
CREAM = ManimColor("#FFFFC2")
CREME = ManimColor("#FFFFB6")
CRIMSON = ManimColor("#8C000F")
CUSTARD = ManimColor("#FFFD78")
CYAN = ManimColor("#00FFFF")
DANDELION = ManimColor("#FEDF08")
DARK = ManimColor("#1B2431")
DARKAQUA = ManimColor("#05696B")
DARKAQUAMARINE = ManimColor("#017371")
DARKBEIGE = ManimColor("#AC9362")
DARKBLUE = ManimColor("#030764")
DARKBLUEGREEN = ManimColor("#005249")
DARKBLUEGREY = ManimColor("#1F3B4D")
DARKBROWN = ManimColor("#341C02")
DARKCORAL = ManimColor("#CF524E")
DARKCREAM = ManimColor("#FFF39A")
DARKCYAN = ManimColor("#0A888A")
DARKFORESTGREEN = ManimColor("#002D04")
DARKFUCHSIA = ManimColor("#9D0759")
DARKGOLD = ManimColor("#B59410")
DARKGRASSGREEN = ManimColor("#388004")
DARKGREEN = ManimColor("#054907")
DARKGREENBLUE = ManimColor("#1F6357")
DARKGREY = ManimColor("#363737")
DARKGREYBLUE = ManimColor("#29465B")
DARKHOTPINK = ManimColor("#D90166")
DARKINDIGO = ManimColor("#1F0954")
DARKISHBLUE = ManimColor("#014182")
DARKISHGREEN = ManimColor("#287C37")
DARKISHPINK = ManimColor("#DA467D")
DARKISHPURPLE = ManimColor("#751973")
DARKISHRED = ManimColor("#A90308")
DARKKHAKI = ManimColor("#9B8F55")
DARKLAVENDER = ManimColor("#856798")
DARKLILAC = ManimColor("#9C6DA5")
DARKLIME = ManimColor("#84B701")
DARKLIMEGREEN = ManimColor("#7EBD01")
DARKMAGENTA = ManimColor("#960056")
DARKMAROON = ManimColor("#3C0008")
DARKMAUVE = ManimColor("#874C62")
DARKMINT = ManimColor("#48C072")
DARKMINTGREEN = ManimColor("#20C073")
DARKMUSTARD = ManimColor("#A88905")
DARKNAVY = ManimColor("#000435")
DARKNAVYBLUE = ManimColor("#00022E")
DARKOLIVE = ManimColor("#373E02")
DARKOLIVEGREEN = ManimColor("#3C4D03")
DARKORANGE = ManimColor("#C65102")
DARKPASTELGREEN = ManimColor("#56AE57")
DARKPEACH = ManimColor("#DE7E5D")
DARKPERIWINKLE = ManimColor("#665FD1")
DARKPINK = ManimColor("#CB416B")
DARKPLUM = ManimColor("#3F012C")
DARKPURPLE = ManimColor("#35063E")
DARKRED = ManimColor("#840000")
DARKROSE = ManimColor("#B5485D")
DARKROYALBLUE = ManimColor("#02066F")
DARKSAGE = ManimColor("#598556")
DARKSALMON = ManimColor("#C85A53")
DARKSAND = ManimColor("#A88F59")
DARKSEAFOAM = ManimColor("#1FB57A")
DARKSEAFOAMGREEN = ManimColor("#3EAF76")
DARKSEAGREEN = ManimColor("#11875D")
DARKSKYBLUE = ManimColor("#448EE4")
DARKSLATEBLUE = ManimColor("#214761")
DARKTAN = ManimColor("#AF884A")
DARKTAUPE = ManimColor("#7F684E")
DARKTEAL = ManimColor("#014D4E")
DARKTURQUOISE = ManimColor("#045C5A")
DARKVIOLET = ManimColor("#34013F")
DARKYELLOW = ManimColor("#D5B60A")
DARKYELLOWGREEN = ManimColor("#728F02")
DEEPAQUA = ManimColor("#08787F")
DEEPBLUE = ManimColor("#040273")
DEEPBROWN = ManimColor("#410200")
DEEPGREEN = ManimColor("#02590F")
DEEPLAVENDER = ManimColor("#8D5EB7")
DEEPLILAC = ManimColor("#966EBD")
DEEPMAGENTA = ManimColor("#A0025C")
DEEPORANGE = ManimColor("#DC4D01")
DEEPPINK = ManimColor("#CB0162")
DEEPPURPLE = ManimColor("#36013F")
DEEPRED = ManimColor("#9A0200")
DEEPROSE = ManimColor("#C74767")
DEEPSEABLUE = ManimColor("#015482")
DEEPSKYBLUE = ManimColor("#0D75F8")
DEEPTEAL = ManimColor("#00555A")
DEEPTURQUOISE = ManimColor("#017374")
DEEPVIOLET = ManimColor("#490648")
DENIM = ManimColor("#3B638C")
DENIMBLUE = ManimColor("#3B5B92")
DESERT = ManimColor("#CCAD60")
DIARRHEA = ManimColor("#9F8303")
DIRT = ManimColor("#8A6E45")
DIRTBROWN = ManimColor("#836539")
DIRTYBLUE = ManimColor("#3F829D")
DIRTYGREEN = ManimColor("#667E2C")
DIRTYORANGE = ManimColor("#C87606")
DIRTYPINK = ManimColor("#CA7B80")
DIRTYPURPLE = ManimColor("#734A65")
DIRTYYELLOW = ManimColor("#CDC50A")
DODGERBLUE = ManimColor("#3E82FC")
DRAB = ManimColor("#828344")
DRABGREEN = ManimColor("#749551")
DRIEDBLOOD = ManimColor("#4B0101")
DUCKEGGBLUE = ManimColor("#C3FBF4")
DULLBLUE = ManimColor("#49759C")
DULLBROWN = ManimColor("#876E4B")
DULLGREEN = ManimColor("#74A662")
DULLORANGE = ManimColor("#D8863B")
DULLPINK = ManimColor("#D5869D")
DULLPURPLE = ManimColor("#84597E")
DULLRED = ManimColor("#BB3F3F")
DULLTEAL = ManimColor("#5F9E8F")
DULLYELLOW = ManimColor("#EEDC5B")
DUSK = ManimColor("#4E5481")
DUSKBLUE = ManimColor("#26538D")
DUSKYBLUE = ManimColor("#475F94")
DUSKYPINK = ManimColor("#CC7A8B")
DUSKYPURPLE = ManimColor("#895B7B")
DUSKYROSE = ManimColor("#BA6873")
DUST = ManimColor("#B2996E")
DUSTYBLUE = ManimColor("#5A86AD")
DUSTYGREEN = ManimColor("#76A973")
DUSTYLAVENDER = ManimColor("#AC86A8")
DUSTYORANGE = ManimColor("#F0833A")
DUSTYPINK = ManimColor("#D58A94")
DUSTYPURPLE = ManimColor("#825F87")
DUSTYRED = ManimColor("#B9484E")
DUSTYROSE = ManimColor("#C0737A")
DUSTYTEAL = ManimColor("#4C9085")
EARTH = ManimColor("#A2653E")
EASTERGREEN = ManimColor("#8CFD7E")
EASTERPURPLE = ManimColor("#C071FE")
ECRU = ManimColor("#FEFFCA")
EGGPLANT = ManimColor("#380835")
EGGPLANTPURPLE = ManimColor("#430541")
EGGSHELL = ManimColor("#FFFCC4")
EGGSHELLBLUE = ManimColor("#C4FFF7")
ELECTRICBLUE = ManimColor("#0652FF")
ELECTRICGREEN = ManimColor("#21FC0D")
ELECTRICLIME = ManimColor("#A8FF04")
ELECTRICPINK = ManimColor("#FF0490")
ELECTRICPURPLE = ManimColor("#AA23FF")
EMERALD = ManimColor("#01A049")
EMERALDGREEN = ManimColor("#028F1E")
EVERGREEN = ManimColor("#05472A")
FADEDBLUE = ManimColor("#658CBB")
FADEDGREEN = ManimColor("#7BB274")
FADEDORANGE = ManimColor("#F0944D")
FADEDPINK = ManimColor("#DE9DAC")
FADEDPURPLE = ManimColor("#916E99")
FADEDRED = ManimColor("#D3494E")
FADEDYELLOW = ManimColor("#FEFF7F")
FAWN = ManimColor("#CFAF7B")
FERN = ManimColor("#63A950")
FERNGREEN = ManimColor("#548D44")
FIREENGINERED = ManimColor("#FE0002")
FLATBLUE = ManimColor("#3C73A8")
FLATGREEN = ManimColor("#699D4C")
FLUORESCENTGREEN = ManimColor("#08FF08")
FLUROGREEN = ManimColor("#0AFF02")
FOAMGREEN = ManimColor("#90FDA9")
FOREST = ManimColor("#0B5509")
FORESTGREEN = ManimColor("#06470C")
FORRESTGREEN = ManimColor("#154406")
FRENCHBLUE = ManimColor("#436BAD")
FRESHGREEN = ManimColor("#69D84F")
FROGGREEN = ManimColor("#58BC08")
FUCHSIA = ManimColor("#ED0DD9")
GOLD = ManimColor("#DBB40C")
GOLDEN = ManimColor("#F5BF03")
GOLDENBROWN = ManimColor("#B27A01")
GOLDENROD = ManimColor("#F9BC08")
GOLDENYELLOW = ManimColor("#FEC615")
GRAPE = ManimColor("#6C3461")
GRAPEFRUIT = ManimColor("#FD5956")
GRAPEPURPLE = ManimColor("#5D1451")
GRASS = ManimColor("#5CAC2D")
GRASSGREEN = ManimColor("#3F9B0B")
GRASSYGREEN = ManimColor("#419C03")
GREEN = ManimColor("#15B01A")
GREENAPPLE = ManimColor("#5EDC1F")
GREENBLUE = ManimColor("#01C08D")
GREENBROWN = ManimColor("#544E03")
GREENGREY = ManimColor("#77926F")
GREENISH = ManimColor("#40A368")
GREENISHBEIGE = ManimColor("#C9D179")
GREENISHBLUE = ManimColor("#0B8B87")
GREENISHBROWN = ManimColor("#696112")
GREENISHCYAN = ManimColor("#2AFEB7")
GREENISHGREY = ManimColor("#96AE8D")
GREENISHTAN = ManimColor("#BCCB7A")
GREENISHTEAL = ManimColor("#32BF84")
GREENISHTURQUOISE = ManimColor("#00FBB0")
GREENISHYELLOW = ManimColor("#CDFD02")
GREENTEAL = ManimColor("#0CB577")
GREENYBLUE = ManimColor("#42B395")
GREENYBROWN = ManimColor("#696006")
GREENYELLOW = ManimColor("#B5CE08")
GREENYGREY = ManimColor("#7EA07A")
GREENYYELLOW = ManimColor("#C6F808")
GREY = ManimColor("#929591")
GREYBLUE = ManimColor("#647D8E")
GREYBROWN = ManimColor("#7F7053")
GREYGREEN = ManimColor("#86A17D")
GREYISH = ManimColor("#A8A495")
GREYISHBLUE = ManimColor("#5E819D")
GREYISHBROWN = ManimColor("#7A6A4F")
GREYISHGREEN = ManimColor("#82A67D")
GREYISHPINK = ManimColor("#C88D94")
GREYISHPURPLE = ManimColor("#887191")
GREYISHTEAL = ManimColor("#719F91")
GREYPINK = ManimColor("#C3909B")
GREYPURPLE = ManimColor("#826D8C")
GREYTEAL = ManimColor("#5E9B8A")
GROSSGREEN = ManimColor("#A0BF16")
GUNMETAL = ManimColor("#536267")
HAZEL = ManimColor("#8E7618")
HEATHER = ManimColor("#A484AC")
HELIOTROPE = ManimColor("#D94FF5")
HIGHLIGHTERGREEN = ManimColor("#1BFC06")
HOSPITALGREEN = ManimColor("#9BE5AA")
HOTGREEN = ManimColor("#25FF29")
HOTMAGENTA = ManimColor("#F504C9")
HOTPINK = ManimColor("#FF028D")
HOTPURPLE = ManimColor("#CB00F5")
HUNTERGREEN = ManimColor("#0B4008")
ICE = ManimColor("#D6FFFA")
ICEBLUE = ManimColor("#D7FFFE")
ICKYGREEN = ManimColor("#8FAE22")
INDIANRED = ManimColor("#850E04")
INDIGO = ManimColor("#380282")
INDIGOBLUE = ManimColor("#3A18B1")
IRIS = ManimColor("#6258C4")
IRISHGREEN = ManimColor("#019529")
IVORY = ManimColor("#FFFFCB")
JADE = ManimColor("#1FA774")
JADEGREEN = ManimColor("#2BAF6A")
JUNGLEGREEN = ManimColor("#048243")
KELLEYGREEN = ManimColor("#009337")
KELLYGREEN = ManimColor("#02AB2E")
KERMITGREEN = ManimColor("#5CB200")
KEYLIME = ManimColor("#AEFF6E")
KHAKI = ManimColor("#AAA662")
KHAKIGREEN = ManimColor("#728639")
KIWI = ManimColor("#9CEF43")
KIWIGREEN = ManimColor("#8EE53F")
LAVENDER = ManimColor("#C79FEF")
LAVENDERBLUE = ManimColor("#8B88F8")
LAVENDERPINK = ManimColor("#DD85D7")
LAWNGREEN = ManimColor("#4DA409")
LEAF = ManimColor("#71AA34")
LEAFGREEN = ManimColor("#5CA904")
LEAFYGREEN = ManimColor("#51B73B")
LEATHER = ManimColor("#AC7434")
LEMON = ManimColor("#FDFF52")
LEMONGREEN = ManimColor("#ADF802")
LEMONLIME = ManimColor("#BFFE28")
LEMONYELLOW = ManimColor("#FDFF38")
LICHEN = ManimColor("#8FB67B")
LIGHTAQUA = ManimColor("#8CFFDB")
LIGHTAQUAMARINE = ManimColor("#7BFDC7")
LIGHTBEIGE = ManimColor("#FFFEB6")
LIGHTBLUE = ManimColor("#7BC8F6")
LIGHTBLUEGREEN = ManimColor("#7EFBB3")
LIGHTBLUEGREY = ManimColor("#B7C9E2")
LIGHTBLUISHGREEN = ManimColor("#76FDA8")
LIGHTBRIGHTGREEN = ManimColor("#53FE5C")
LIGHTBROWN = ManimColor("#AD8150")
LIGHTBURGUNDY = ManimColor("#A8415B")
LIGHTCYAN = ManimColor("#ACFFFC")
LIGHTEGGPLANT = ManimColor("#894585")
LIGHTERGREEN = ManimColor("#75FD63")
LIGHTERPURPLE = ManimColor("#A55AF4")
LIGHTFORESTGREEN = ManimColor("#4F9153")
LIGHTGOLD = ManimColor("#FDDC5C")
LIGHTGRASSGREEN = ManimColor("#9AF764")
LIGHTGREEN = ManimColor("#76FF7B")
LIGHTGREENBLUE = ManimColor("#56FCA2")
LIGHTGREENISHBLUE = ManimColor("#63F7B4")
LIGHTGREY = ManimColor("#D8DCD6")
LIGHTGREYBLUE = ManimColor("#9DBCD4")
LIGHTGREYGREEN = ManimColor("#B7E1A1")
LIGHTINDIGO = ManimColor("#6D5ACF")
LIGHTISHBLUE = ManimColor("#3D7AFD")
LIGHTISHGREEN = ManimColor("#61E160")
LIGHTISHPURPLE = ManimColor("#A552E6")
LIGHTISHRED = ManimColor("#FE2F4A")
LIGHTKHAKI = ManimColor("#E6F2A2")
LIGHTLAVENDAR = ManimColor("#EFC0FE")
LIGHTLAVENDER = ManimColor("#DFC5FE")
LIGHTLIGHTBLUE = ManimColor("#CAFFFB")
LIGHTLIGHTGREEN = ManimColor("#C8FFB0")
LIGHTLILAC = ManimColor("#EDC8FF")
LIGHTLIME = ManimColor("#AEFD6C")
LIGHTLIMEGREEN = ManimColor("#B9FF66")
LIGHTMAGENTA = ManimColor("#FA5FF7")
LIGHTMAROON = ManimColor("#A24857")
LIGHTMAUVE = ManimColor("#C292A1")
LIGHTMINT = ManimColor("#B6FFBB")
LIGHTMINTGREEN = ManimColor("#A6FBB2")
LIGHTMOSSGREEN = ManimColor("#A6C875")
LIGHTMUSTARD = ManimColor("#F7D560")
LIGHTNAVY = ManimColor("#155084")
LIGHTNAVYBLUE = ManimColor("#2E5A88")
LIGHTNEONGREEN = ManimColor("#4EFD54")
LIGHTOLIVE = ManimColor("#ACBF69")
LIGHTOLIVEGREEN = ManimColor("#A4BE5C")
LIGHTORANGE = ManimColor("#FDAA48")
LIGHTPASTELGREEN = ManimColor("#B2FBA5")
LIGHTPEACH = ManimColor("#FFD8B1")
LIGHTPEAGREEN = ManimColor("#C4FE82")
LIGHTPERIWINKLE = ManimColor("#C1C6FC")
LIGHTPINK = ManimColor("#FFD1DF")
LIGHTPLUM = ManimColor("#9D5783")
LIGHTPURPLE = ManimColor("#BF77F6")
LIGHTRED = ManimColor("#FF474C")
LIGHTROSE = ManimColor("#FFC5CB")
LIGHTROYALBLUE = ManimColor("#3A2EFE")
LIGHTSAGE = ManimColor("#BCECAC")
LIGHTSALMON = ManimColor("#FEA993")
LIGHTSEAFOAM = ManimColor("#A0FEBF")
LIGHTSEAFOAMGREEN = ManimColor("#a7ffb5")
LIGHTSEAGREEN = ManimColor("#98F6B0")
LIGHTSKYBLUE = ManimColor("#C6FCFF")
LIGHTTAN = ManimColor("#FBEEAC")
LIGHTTEAL = ManimColor("#90E4C1")
LIGHTTURQUOISE = ManimColor("#7EF4CC")
LIGHTURPLE = ManimColor("#B36FF6")
LIGHTVIOLET = ManimColor("#D6B4FC")
LIGHTYELLOW = ManimColor("#FFFE7A")
LIGHTYELLOWGREEN = ManimColor("#CCFD7F")
LIGHTYELLOWISHGREEN = ManimColor("#C2FF89")
LILAC = ManimColor("#CEA2FD")
LILIAC = ManimColor("#C48EFD")
LIME = ManimColor("#AAFF32")
LIMEGREEN = ManimColor("#89FE05")
LIMEYELLOW = ManimColor("#D0FE1D")
LIPSTICK = ManimColor("#D5174E")
LIPSTICKRED = ManimColor("#C0022F")
MACARONIANDCHEESE = ManimColor("#EFB435")
MAGENTA = ManimColor("#C20078")
MAHOGANY = ManimColor("#4A0100")
MAIZE = ManimColor("#F4D054")
MANGO = ManimColor("#FFA62B")
MANILLA = ManimColor("#FFFA86")
MARIGOLD = ManimColor("#FCC006")
MARINE = ManimColor("#042E60")
MARINEBLUE = ManimColor("#01386A")
MAROON = ManimColor("#650021")
MAUVE = ManimColor("#AE7181")
MEDIUMBLUE = ManimColor("#2C6FBB")
MEDIUMBROWN = ManimColor("#7F5112")
MEDIUMGREEN = ManimColor("#39AD48")
MEDIUMGREY = ManimColor("#7D7F7C")
MEDIUMPINK = ManimColor("#F36196")
MEDIUMPURPLE = ManimColor("#9E43A2")
MELON = ManimColor("#FF7855")
MERLOT = ManimColor("#730039")
METALLICBLUE = ManimColor("#4F738E")
MIDBLUE = ManimColor("#276AB3")
MIDGREEN = ManimColor("#50A747")
MIDNIGHT = ManimColor("#03012D")
MIDNIGHTBLUE = ManimColor("#020035")
MIDNIGHTPURPLE = ManimColor("#280137")
MILITARYGREEN = ManimColor("#667C3E")
MILKCHOCOLATE = ManimColor("#7F4E1E")
MINT = ManimColor("#9FFEB0")
MINTGREEN = ManimColor("#8FFF9F")
MINTYGREEN = ManimColor("#0BF77D")
MOCHA = ManimColor("#9D7651")
MOSS = ManimColor("#769958")
MOSSGREEN = ManimColor("#658B38")
MOSSYGREEN = ManimColor("#638B27")
MUD = ManimColor("#735C12")
MUDBROWN = ManimColor("#60460F")
MUDDYBROWN = ManimColor("#886806")
MUDDYGREEN = ManimColor("#657432")
MUDDYYELLOW = ManimColor("#BFAC05")
MUDGREEN = ManimColor("#606602")
MULBERRY = ManimColor("#920A4E")
MURKYGREEN = ManimColor("#6C7A0E")
MUSHROOM = ManimColor("#BA9E88")
MUSTARD = ManimColor("#CEB301")
MUSTARDBROWN = ManimColor("#AC7E04")
MUSTARDGREEN = ManimColor("#A8B504")
MUSTARDYELLOW = ManimColor("#D2BD0A")
MUTEDBLUE = ManimColor("#3B719F")
MUTEDGREEN = ManimColor("#5FA052")
MUTEDPINK = ManimColor("#D1768F")
MUTEDPURPLE = ManimColor("#805B87")
NASTYGREEN = ManimColor("#70B23F")
NAVY = ManimColor("#01153E")
NAVYBLUE = ManimColor("#001146")
NAVYGREEN = ManimColor("#35530A")
NEONBLUE = ManimColor("#04D9FF")
NEONGREEN = ManimColor("#0CFF0C")
NEONPINK = ManimColor("#FE019A")
NEONPURPLE = ManimColor("#BC13FE")
NEONRED = ManimColor("#FF073A")
NEONYELLOW = ManimColor("#CFFF04")
NICEBLUE = ManimColor("#107AB0")
NIGHTBLUE = ManimColor("#040348")
OCEAN = ManimColor("#017B92")
OCEANBLUE = ManimColor("#03719C")
OCEANGREEN = ManimColor("#3D9973")
OCHER = ManimColor("#BF9B0C")
OCHRE = ManimColor("#BF9005")
OCRE = ManimColor("#C69C04")
OFFBLUE = ManimColor("#5684AE")
OFFGREEN = ManimColor("#6BA353")
OFFWHITE = ManimColor("#FFFFE4")
OFFYELLOW = ManimColor("#F1F33F")
OLDPINK = ManimColor("#C77986")
OLDROSE = ManimColor("#C87F89")
OLIVE = ManimColor("#6E750E")
OLIVEBROWN = ManimColor("#645403")
OLIVEDRAB = ManimColor("#6F7632")
OLIVEGREEN = ManimColor("#677A04")
OLIVEYELLOW = ManimColor("#C2B709")
ORANGE = ManimColor("#F97306")
ORANGEBROWN = ManimColor("#BE6400")
ORANGEISH = ManimColor("#FD8D49")
ORANGEPINK = ManimColor("#FF6F52")
ORANGERED = ManimColor("#FE420F")
ORANGEYBROWN = ManimColor("#B16002")
ORANGEYELLOW = ManimColor("#FFAD01")
ORANGEYRED = ManimColor("#FA4224")
ORANGEYYELLOW = ManimColor("#FDB915")
ORANGISH = ManimColor("#FC824A")
ORANGISHBROWN = ManimColor("#B25F03")
ORANGISHRED = ManimColor("#F43605")
ORCHID = ManimColor("#C875C4")
PALE = ManimColor("#FFF9D0")
PALEAQUA = ManimColor("#B8FFEB")
PALEBLUE = ManimColor("#D0FEFE")
PALEBROWN = ManimColor("#B1916E")
PALECYAN = ManimColor("#B7FFFA")
PALEGOLD = ManimColor("#FDDE6C")
PALEGREEN = ManimColor("#C7FDB5")
PALEGREY = ManimColor("#FDFDFE")
PALELAVENDER = ManimColor("#EECFFE")
PALELIGHTGREEN = ManimColor("#B1FC99")
PALELILAC = ManimColor("#E4CBFF")
PALELIME = ManimColor("#BEFD73")
PALELIMEGREEN = ManimColor("#B1FF65")
PALEMAGENTA = ManimColor("#D767AD")
PALEMAUVE = ManimColor("#FED0FC")
PALEOLIVE = ManimColor("#B9CC81")
PALEOLIVEGREEN = ManimColor("#B1D27B")
PALEORANGE = ManimColor("#FFA756")
PALEPEACH = ManimColor("#FFE5AD")
PALEPINK = ManimColor("#FFCFDC")
PALEPURPLE = ManimColor("#B790D4")
PALERED = ManimColor("#D9544D")
PALEROSE = ManimColor("#FDC1C5")
PALESALMON = ManimColor("#FFB19A")
PALESKYBLUE = ManimColor("#BDF6FE")
PALETEAL = ManimColor("#82CBB2")
PALETURQUOISE = ManimColor("#A5FBD5")
PALEVIOLET = ManimColor("#CEAEFA")
PALEYELLOW = ManimColor("#FFFF84")
PARCHMENT = ManimColor("#FEFCAF")
PASTELBLUE = ManimColor("#A2BFFE")
PASTELGREEN = ManimColor("#B0FF9D")
PASTELORANGE = ManimColor("#FF964F")
PASTELPINK = ManimColor("#FFBACD")
PASTELPURPLE = ManimColor("#CAA0FF")
PASTELRED = ManimColor("#DB5856")
PASTELYELLOW = ManimColor("#FFFE71")
PEA = ManimColor("#A4BF20")
PEACH = ManimColor("#FFB07C")
PEACHYPINK = ManimColor("#FF9A8A")
PEACOCKBLUE = ManimColor("#016795")
PEAGREEN = ManimColor("#8EAB12")
PEAR = ManimColor("#CBF85F")
PEASOUP = ManimColor("#929901")
PEASOUPGREEN = ManimColor("#94A617")
PERIWINKLE = ManimColor("#8E82FE")
PERIWINKLEBLUE = ManimColor("#8F99FB")
PERRYWINKLE = ManimColor("#8F8CE7")
PETROL = ManimColor("#005F6A")
PIGPINK = ManimColor("#E78EA5")
PINE = ManimColor("#2B5D34")
PINEGREEN = ManimColor("#0A481E")
PINK = ManimColor("#FF81C0")
PINKISH = ManimColor("#D46A7E")
PINKISHBROWN = ManimColor("#B17261")
PINKISHGREY = ManimColor("#C8ACA9")
PINKISHORANGE = ManimColor("#FF724C")
PINKISHPURPLE = ManimColor("#D648D7")
PINKISHRED = ManimColor("#F10C45")
PINKISHTAN = ManimColor("#D99B82")
PINKPURPLE = ManimColor("#EF1DE7")
PINKRED = ManimColor("#F5054F")
PINKY = ManimColor("#FC86AA")
PINKYPURPLE = ManimColor("#C94CBE")
PINKYRED = ManimColor("#FC2647")
PISSYELLOW = ManimColor("#DDD618")
PISTACHIO = ManimColor("#C0FA8B")
PLUM = ManimColor("#580F41")
PLUMPURPLE = ManimColor("#4E0550")
POISONGREEN = ManimColor("#40FD14")
POO = ManimColor("#8F7303")
POOBROWN = ManimColor("#885F01")
POOP = ManimColor("#7F5E00")
POOPBROWN = ManimColor("#7A5901")
POOPGREEN = ManimColor("#6F7C00")
POWDERBLUE = ManimColor("#B1D1FC")
POWDERPINK = ManimColor("#FFB2D0")
PRIMARYBLUE = ManimColor("#0804F9")
PRUSSIANBLUE = ManimColor("#004577")
PUCE = ManimColor("#A57E52")
PUKE = ManimColor("#A5A502")
PUKEBROWN = ManimColor("#947706")
PUKEGREEN = ManimColor("#9AAE07")
PUKEYELLOW = ManimColor("#C2BE0E")
PUMPKIN = ManimColor("#E17701")
PUMPKINORANGE = ManimColor("#FB7D07")
PUREBLUE = ManimColor("#0203E2")
PURPLE = ManimColor("#7E1E9C")
PURPLEBLUE = ManimColor("#5D21D0")
PURPLEBROWN = ManimColor("#673A3F")
PURPLEGREY = ManimColor("#866F85")
PURPLEISH = ManimColor("#98568D")
PURPLEISHBLUE = ManimColor("#6140EF")
PURPLEISHPINK = ManimColor("#DF4EC8")
PURPLEPINK = ManimColor("#D725DE")
PURPLERED = ManimColor("#990147")
PURPLEY = ManimColor("#8756E4")
PURPLEYBLUE = ManimColor("#5F34E7")
PURPLEYGREY = ManimColor("#947E94")
PURPLEYPINK = ManimColor("#C83CB9")
PURPLISH = ManimColor("#94568C")
PURPLISHBLUE = ManimColor("#601EF9")
PURPLISHBROWN = ManimColor("#6B4247")
PURPLISHGREY = ManimColor("#7A687F")
PURPLISHPINK = ManimColor("#CE5DAE")
PURPLISHRED = ManimColor("#B0054B")
PURPLY = ManimColor("#983FB2")
PURPLYBLUE = ManimColor("#661AEE")
PURPLYPINK = ManimColor("#F075E6")
PUTTY = ManimColor("#BEAE8A")
RACINGGREEN = ManimColor("#014600")
RADIOACTIVEGREEN = ManimColor("#2CFA1F")
RASPBERRY = ManimColor("#B00149")
RAWSIENNA = ManimColor("#9A6200")
RAWUMBER = ManimColor("#A75E09")
REALLYLIGHTBLUE = ManimColor("#D4FFFF")
RED = ManimColor("#E50000")
REDBROWN = ManimColor("#8B2E16")
REDDISH = ManimColor("#C44240")
REDDISHBROWN = ManimColor("#7F2B0A")
REDDISHGREY = ManimColor("#997570")
REDDISHORANGE = ManimColor("#F8481C")
REDDISHPINK = ManimColor("#FE2C54")
REDDISHPURPLE = ManimColor("#910951")
REDDYBROWN = ManimColor("#6E1005")
REDORANGE = ManimColor("#FD3C06")
REDPINK = ManimColor("#FA2A55")
REDPURPLE = ManimColor("#820747")
REDVIOLET = ManimColor("#9E0168")
REDWINE = ManimColor("#8C0034")
RICHBLUE = ManimColor("#021BF9")
RICHPURPLE = ManimColor("#720058")
ROBINEGGBLUE = ManimColor("#8AF1FE")
ROBINSEGG = ManimColor("#6DEDFD")
ROBINSEGGBLUE = ManimColor("#98EFF9")
ROSA = ManimColor("#FE86A4")
ROSE = ManimColor("#CF6275")
ROSEPINK = ManimColor("#F7879A")
ROSERED = ManimColor("#BE013C")
ROSYPINK = ManimColor("#F6688E")
ROGUE = ManimColor("#AB1239")
ROYAL = ManimColor("#0C1793")
ROYALBLUE = ManimColor("#0504AA")
ROYALPURPLE = ManimColor("#4B006E")
RUBY = ManimColor("#CA0147")
RUSSET = ManimColor("#A13905")
RUST = ManimColor("#A83C09")
RUSTBROWN = ManimColor("#8B3103")
RUSTORANGE = ManimColor("#C45508")
RUSTRED = ManimColor("#AA2704")
RUSTYORANGE = ManimColor("#CD5909")
RUSTYRED = ManimColor("#AF2F0D")
SAFFRON = ManimColor("#FEB209")
SAGE = ManimColor("#87AE73")
SAGEGREEN = ManimColor("#88B378")
SALMON = ManimColor("#FF796C")
SALMONPINK = ManimColor("#FE7B7C")
SAND = ManimColor("#E2CA76")
SANDBROWN = ManimColor("#CBA560")
SANDSTONE = ManimColor("#C9AE74")
SANDY = ManimColor("#F1DA7A")
SANDYBROWN = ManimColor("#C4A661")
SANDYELLOW = ManimColor("#FCE166")
SANDYYELLOW = ManimColor("#FDEE73")
SAPGREEN = ManimColor("#5C8B15")
SAPPHIRE = ManimColor("#2138AB")
SCARLET = ManimColor("#BE0119")
SEA = ManimColor("#3C9992")
SEABLUE = ManimColor("#047495")
SEAFOAM = ManimColor("#80F9AD")
SEAFOAMBLUE = ManimColor("#78D1B6")
SEAFOAMGREEN = ManimColor("#7AF9AB")
SEAGREEN = ManimColor("#53FCA1")
SEAWEED = ManimColor("#18D17B")
SEAWEEDGREEN = ManimColor("#35AD6B")
SEPIA = ManimColor("#985E2B")
SHAMROCK = ManimColor("#01B44C")
SHAMROCKGREEN = ManimColor("#02C14D")
SHIT = ManimColor("#7F5F00")
SHITBROWN = ManimColor("#7B5804")
SHITGREEN = ManimColor("#758000")
SHOCKINGPINK = ManimColor("#FE02A2")
SICKGREEN = ManimColor("#9DB92C")
SICKLYGREEN = ManimColor("#94B21C")
SICKLYYELLOW = ManimColor("#D0E429")
SIENNA = ManimColor("#A9561E")
SILVER = ManimColor("#C5C9C7")
SKY = ManimColor("#82CAFC")
SKYBLUE = ManimColor("#75BBFD")
SLATE = ManimColor("#516572")
SLATEBLUE = ManimColor("#5B7C99")
SLATEGREEN = ManimColor("#658D6D")
SLATEGREY = ManimColor("#59656D")
SLIMEGREEN = ManimColor("#99CC04")
SNOT = ManimColor("#ACBB0D")
SNOTGREEN = ManimColor("#9DC100")
SOFTBLUE = ManimColor("#6488EA")
SOFTGREEN = ManimColor("#6FC276")
SOFTPINK = ManimColor("#FDB0C0")
SOFTPURPLE = ManimColor("#A66FB5")
SPEARMINT = ManimColor("#1EF876")
SPRINGGREEN = ManimColor("#A9F971")
SPRUCE = ManimColor("#0A5F38")
SQUASH = ManimColor("#F2AB15")
STEEL = ManimColor("#738595")
STEELBLUE = ManimColor("#5A7D9A")
STEELGREY = ManimColor("#6F828A")
STONE = ManimColor("#ADA587")
STORMYBLUE = ManimColor("#507B9C")
STRAW = ManimColor("#FCF679")
STRAWBERRY = ManimColor("#FB2943")
STRONGBLUE = ManimColor("#0C06F7")
STRONGPINK = ManimColor("#FF0789")
SUNFLOWER = ManimColor("#FFC512")
SUNFLOWERYELLOW = ManimColor("#FFDA03")
SUNNYYELLOW = ManimColor("#FFF917")
SUNSHINEYELLOW = ManimColor("#FFFD37")
SUNYELLOW = ManimColor("#FFDF22")
SWAMP = ManimColor("#698339")
SWAMPGREEN = ManimColor("#748500")
TAN = ManimColor("#D1B26F")
TANBROWN = ManimColor("#AB7E4C")
TANGERINE = ManimColor("#FF9408")
TANGREEN = ManimColor("#A9BE70")
TAUPE = ManimColor("#B9A281")
TEA = ManimColor("#65AB7C")
TEAGREEN = ManimColor("#BDF8A3")
TEAL = ManimColor("#029386")
TEALBLUE = ManimColor("#01889F")
TEALGREEN = ManimColor("#25A36F")
TEALISH = ManimColor("#24BCA8")
TEALISHGREEN = ManimColor("#0CDC73")
TERRACOTA = ManimColor("#CB6843")
TERRACOTTA = ManimColor("#C9643B")
TIFFANYBLUE = ManimColor("#7BF2DA")
TOMATO = ManimColor("#EF4026")
TOMATORED = ManimColor("#EC2D01")
TOPAZ = ManimColor("#13BBAF")
TOUPE = ManimColor("#C7AC7D")
TOXICGREEN = ManimColor("#61DE2A")
TREEGREEN = ManimColor("#2A7E19")
TRUEBLUE = ManimColor("#010FCC")
TRUEGREEN = ManimColor("#089404")
TURQUOISE = ManimColor("#06C2AC")
TURQUOISEBLUE = ManimColor("#06B1C4")
TURQUOISEGREEN = ManimColor("#04F489")
TURTLEGREEN = ManimColor("#75B84F")
TWILIGHT = ManimColor("#4E518B")
TWILIGHTBLUE = ManimColor("#0A437A")
UGLYBLUE = ManimColor("#31668A")
UGLYBROWN = ManimColor("#7D7103")
UGLYGREEN = ManimColor("#7A9703")
UGLYPINK = ManimColor("#CD7584")
UGLYPURPLE = ManimColor("#A442A0")
UGLYYELLOW = ManimColor("#D0C101")
ULTRAMARINE = ManimColor("#2000B1")
ULTRAMARINEBLUE = ManimColor("#1805DB")
UMBER = ManimColor("#B26400")
VELVET = ManimColor("#750851")
VERMILION = ManimColor("#F4320C")
VERYDARKBLUE = ManimColor("#000133")
VERYDARKBROWN = ManimColor("#1D0200")
VERYDARKGREEN = ManimColor("#062E03")
VERYDARKPURPLE = ManimColor("#2A0134")
VERYLIGHTBLUE = ManimColor("#D5FFFF")
VERYLIGHTBROWN = ManimColor("#D3B683")
VERYLIGHTGREEN = ManimColor("#D1FFBD")
VERYLIGHTPINK = ManimColor("#FFF4F2")
VERYLIGHTPURPLE = ManimColor("#F6CEFC")
VERYPALEBLUE = ManimColor("#D6FFFE")
VERYPALEGREEN = ManimColor("#CFFDBC")
VIBRANTBLUE = ManimColor("#0339F8")
VIBRANTGREEN = ManimColor("#0ADD08")
VIBRANTPURPLE = ManimColor("#AD03DE")
VIOLET = ManimColor("#9A0EEA")
VIOLETBLUE = ManimColor("#510AC9")
VIOLETPINK = ManimColor("#FB5FFC")
VIOLETRED = ManimColor("#A50055")
VIRIDIAN = ManimColor("#1E9167")
VIVIDBLUE = ManimColor("#152EFF")
VIVIDGREEN = ManimColor("#2FEF10")
VIVIDPURPLE = ManimColor("#9900FA")
VOMIT = ManimColor("#A2A415")
VOMITGREEN = ManimColor("#89A203")
VOMITYELLOW = ManimColor("#C7C10C")
WARMBLUE = ManimColor("#4B57DB")
WARMBROWN = ManimColor("#964E02")
WARMGREY = ManimColor("#978A84")
WARMPINK = ManimColor("#FB5581")
WARMPURPLE = ManimColor("#952E8F")
WASHEDOUTGREEN = ManimColor("#BCF5A6")
WATERBLUE = ManimColor("#0E87CC")
WATERMELON = ManimColor("#FD4659")
WEIRDGREEN = ManimColor("#3AE57F")
WHEAT = ManimColor("#FBDD7E")
WHITE = ManimColor("#FFFFFF")
WINDOWSBLUE = ManimColor("#3778BF")
WINE = ManimColor("#80013F")
WINERED = ManimColor("#7B0323")
WINTERGREEN = ManimColor("#20F986")
WISTERIA = ManimColor("#A87DC2")
YELLOW = ManimColor("#FFFF14")
YELLOWBROWN = ManimColor("#B79400")
YELLOWGREEN = ManimColor("#BBF90F")
YELLOWISH = ManimColor("#FAEE66")
YELLOWISHBROWN = ManimColor("#9B7A01")
YELLOWISHGREEN = ManimColor("#B0DD16")
YELLOWISHORANGE = ManimColor("#FFAB0F")
YELLOWISHTAN = ManimColor("#FCFC81")
YELLOWOCHRE = ManimColor("#CB9D06")
YELLOWORANGE = ManimColor("#FCB001")
YELLOWTAN = ManimColor("#FFE36E")
YELLOWYBROWN = ManimColor("#AE8B0C")
YELLOWYGREEN = ManimColor("#BFF128")
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.974">"""Utilities for working with colors and predefined color constants.

Color data structure
--------------------

.. autosummary::
   :toctree: ../reference

   core


Predefined colors
-----------------

There are several predefined colors available in Manim:

- The colors listed in :mod:`.color.manim_colors` are loaded into
  Manim's global name space.
- The colors in :mod:`.color.AS2700`, :mod:`.color.BS381`,
  :mod:`.color.DVIPSNAMES`, :mod:`.color.SVGNAMES`, :mod:`.color.X11` and
  :mod:`.color.XKCD` need to be accessed via their module (which are available
  in Manim's global name space), or imported separately. For example:

  .. code:: pycon

     &gt;&gt;&gt; from manim import XKCD
     &gt;&gt;&gt; XKCD.AVOCADO
     ManimColor('#90B134')

  Or, alternatively:

  .. code:: pycon

     &gt;&gt;&gt; from manim.utils.color.XKCD import AVOCADO
     &gt;&gt;&gt; AVOCADO
     ManimColor('#90B134')

The following modules contain the predefined color constants:

.. autosummary::
   :toctree: ../reference

   manim_colors
   AS2700
   BS381
   DVIPSNAMES
   SVGNAMES
   XKCD
   X11

"""

from __future__ import annotations

from . import AS2700, BS381, DVIPSNAMES, SVGNAMES, X11, XKCD
from .core import *
from .manim_colors import *

_all_color_dict: dict[str, ManimColor] = {
    k: v for k, v in globals().items() if isinstance(v, ManimColor)
}
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.975">"""Manim's (internal) color data structure and some utilities for color conversion.

This module contains the implementation of :class:`.ManimColor`, the data structure
internally used to represent colors.

The preferred way of using these colors is by importing their constants from Manim:

.. code-block:: pycon

    &gt;&gt;&gt; from manim import RED, GREEN, BLUE
    &gt;&gt;&gt; print(RED)
    #FC6255

Note that this way uses the name of the colors in UPPERCASE.

.. note::

    The colors with a ``_C`` suffix have an alias equal to the colorname without a
    letter. For example, ``GREEN = GREEN_C``.

===================
Custom Color Spaces
===================

Hello, dear visitor. You seem to be interested in implementing a custom color class for
a color space we don't currently support.

The current system is using a few indirections for ensuring a consistent behavior with
all other color types in Manim.

To implement a custom color space, you must subclass :class:`ManimColor` and implement
three important methods:

  - :attr:`~.ManimColor._internal_value`: a ``@property`` implemented on
    :class:`ManimColor` with the goal of keeping a consistent internal representation
    which can be referenced by other functions in :class:`ManimColor`. This property acts
    as a proxy to whatever representation you need in your class.

      - The getter should always return a NumPy array in the format ``[r,g,b,a]``, in
        accordance with the type :class:`ManimColorInternal`.

      - The setter should always accept a value in the format ``[r,g,b,a]`` which can be
        converted to whatever attributes you need.

  - :attr:`~ManimColor._internal_space`: a read-only ``@property`` implemented on
    :class:`ManimColor` with the goal of providing a useful representation which can be
    used by operators, interpolation and color transform functions.

    The only constraints on this value are:

      - It must be a NumPy array.

      - The last value must be the opacity in a range ``0.0`` to ``1.0``.

    Additionally, your ``__init__`` must support this format as an initialization value
    without additional parameters to ensure correct functionality of all other methods in
    :class:`ManimColor`.

  - :meth:`~ManimColor._from_internal`: a ``@classmethod`` which converts an
    ``[r,g,b,a]`` value into suitable parameters for your ``__init__`` method and calls
    the ``cls`` parameter.
"""

from __future__ import annotations

import colorsys

# logger = _config.logger
import random
import re
from collections.abc import Sequence
from typing import TypeVar, Union, overload

import numpy as np
import numpy.typing as npt
from typing_extensions import Self, TypeAlias, TypeIs, override

from manim.typing import (
    HSL_Array_Float,
    HSL_Tuple_Float,
    HSV_Array_Float,
    HSV_Tuple_Float,
    HSVA_Array_Float,
    HSVA_Tuple_Float,
    ManimColorDType,
    ManimColorInternal,
    ManimFloat,
    Point3D,
    RGB_Array_Float,
    RGB_Array_Int,
    RGB_Tuple_Float,
    RGB_Tuple_Int,
    RGBA_Array_Float,
    RGBA_Array_Int,
    RGBA_Tuple_Float,
    RGBA_Tuple_Int,
    Vector3D,
)

from ...utils.space_ops import normalize

# import manim._config as _config

re_hex = re.compile("((?&lt;=#)|(?&lt;=0x))[A-F0-9]{3,8}", re.IGNORECASE)


@others
__all__ = [
    "ManimColor",
    "ManimColorDType",
    "ParsableManimColor",
    "color_to_rgb",
    "color_to_rgba",
    "color_to_int_rgb",
    "color_to_int_rgba",
    "rgb_to_color",
    "rgba_to_color",
    "rgb_to_hex",
    "hex_to_rgb",
    "invert_color",
    "color_gradient",
    "interpolate_color",
    "average_color",
    "random_bright_color",
    "random_color",
    "get_shaded_rgb",
    "HSV",
    "RGBA",
]
@language python
@tabwidth -4
</t>
<t tx="ekr.20250122151621.976">class ManimColor:
    """Internal representation of a color.

    The :class:`ManimColor` class is the main class for the representation of a color.
    Its internal representation is an array of 4 floats corresponding to a ``[r,g,b,a]``
    value where ``r,g,b,a`` can be between 0.0 and 1.0.

    This is done in order to reduce the amount of color inconsistencies by constantly
    casting between integers and floats which introduces errors.

    The class can accept any value of type :class:`ParsableManimColor` i.e.

    ``ManimColor, int, str, RGB_Tuple_Int, RGB_Tuple_Float, RGBA_Tuple_Int, RGBA_Tuple_Float, RGB_Array_Int,
    RGB_Array_Float, RGBA_Array_Int, RGBA_Array_Float``

    :class:`ManimColor` itself only accepts singular values and will directly interpret
    them into a single color if possible. Be careful when passing strings to
    :class:`ManimColor`: it can create a big overhead for the color processing.

    If you want to parse a list of colors, use the :meth:`parse` method, which assumes
    that you're going to pass a list of colors so that arrays will not be interpreted as
    a single color.

    .. warning::
        If you pass an array of numbers to :meth:`parse`, it will interpret the
        ``r,g,b,a`` numbers in that array as colors: Instead of the expected
        singular color, you will get an array with 4 colors.

    For conversion behaviors, see the ``_internal`` functions for further documentation.

    You can create a :class:`ManimColor` instance via its classmethods. See the
    respective methods for more info.

    .. code-block:: python

        mycolor = ManimColor.from_rgb((0, 1, 0.4, 0.5))
        myothercolor = ManimColor.from_rgb((153, 255, 255))

    You can also convert between different color spaces:

    .. code-block:: python

        mycolor_hex = mycolor.to_hex()
        myoriginalcolor = ManimColor.from_hex(mycolor_hex).to_hsv()

    Parameters
    ----------
    value
        Some representation of a color (e.g., a string or
        a suitable tuple). The default ``None`` is ``BLACK``.
    alpha
        The opacity of the color. By default, colors are
        fully opaque (value 1.0).
    """

    @others
</t>
<t tx="ekr.20250122151621.977">RGBA = ManimColor
"""RGBA Color Space"""


class HSV(ManimColor):
    """HSV Color Space"""

    @others
</t>
<t tx="ekr.20250122151621.978">ParsableManimColor: TypeAlias = Union[
    ManimColor,
    int,
    str,
    RGB_Tuple_Int,
    RGB_Tuple_Float,
    RGBA_Tuple_Int,
    RGBA_Tuple_Float,
    RGB_Array_Int,
    RGB_Array_Float,
    RGBA_Array_Int,
    RGBA_Array_Float,
]
"""`ParsableManimColor` represents all the types which can be parsed
to a :class:`ManimColor` in Manim.
"""


ManimColorT = TypeVar("ManimColorT", bound=ManimColor)


def color_to_rgb(color: ParsableManimColor) -&gt; RGB_Array_Float:
    """Helper function for use in functional style programming.
    Refer to :meth:`ManimColor.to_rgb`.

    Parameters
    ----------
    color
        A color to convert to an RGB float array.

    Returns
    -------
    RGB_Array_Float
        The corresponding RGB float array.
    """
    return ManimColor(color).to_rgb()


</t>
<t tx="ekr.20250122151621.979">def color_to_rgba(color: ParsableManimColor, alpha: float = 1.0) -&gt; RGBA_Array_Float:
    """Helper function for use in functional style programming. Refer to
    :meth:`ManimColor.to_rgba_with_alpha`.

    Parameters
    ----------
    color
        A color to convert to an RGBA float array.
    alpha
        An alpha value between 0.0 and 1.0 to be used as opacity in the color. Default is
        1.0.

    Returns
    -------
    RGBA_Array_Float
        The corresponding RGBA float array.
    """
    return ManimColor(color).to_rgba_with_alpha(alpha)


</t>
<t tx="ekr.20250122151621.98">def __init__(
    self,
    camera,
    default_display_frame_config: dict[str, Any] | None = None,
    **kwargs: Any,
) -&gt; None:
    self.camera = camera
    if default_display_frame_config is None:
        default_display_frame_config = {
            "stroke_width": 3,
            "stroke_color": WHITE,
            "buff": 0,
        }
    self.default_display_frame_config = default_display_frame_config
    self.pixel_array = self.camera.pixel_array
    super().__init__(scale_to_resolution=False, **kwargs)

</t>
<t tx="ekr.20250122151621.980">def color_to_int_rgb(color: ParsableManimColor) -&gt; RGB_Array_Int:
    """Helper function for use in functional style programming. Refer to
    :meth:`ManimColor.to_int_rgb`.

    Parameters
    ----------
    color
        A color to convert to an RGB integer array.

    Returns
    -------
    RGB_Array_Int
        The corresponding RGB integer array.
    """
    return ManimColor(color).to_int_rgb()


</t>
<t tx="ekr.20250122151621.981">def color_to_int_rgba(color: ParsableManimColor, alpha: float = 1.0) -&gt; RGBA_Array_Int:
    """Helper function for use in functional style programming. Refer to
    :meth:`ManimColor.to_int_rgba_with_alpha`.

    Parameters
    ----------
    color
        A color to convert to an RGBA integer array.
    alpha
        An alpha value between 0.0 and 1.0 to be used as opacity in the color. Default is
        1.0.

    Returns
    -------
    RGBA_Array_Int
        The corresponding RGBA integer array.
    """
    return ManimColor(color).to_int_rgba_with_alpha(alpha)


</t>
<t tx="ekr.20250122151621.982">def rgb_to_color(
    rgb: RGB_Array_Float | RGB_Tuple_Float | RGB_Array_Int | RGB_Tuple_Int,
) -&gt; ManimColor:
    """Helper function for use in functional style programming. Refer to
    :meth:`ManimColor.from_rgb`.

    Parameters
    ----------
    rgb
        A 3 element iterable.

    Returns
    -------
    ManimColor
        A ManimColor with the corresponding value.
    """
    return ManimColor.from_rgb(rgb)


</t>
<t tx="ekr.20250122151621.983">def rgba_to_color(
    rgba: RGBA_Array_Float | RGBA_Tuple_Float | RGBA_Array_Int | RGBA_Tuple_Int,
) -&gt; ManimColor:
    """Helper function for use in functional style programming. Refer to
    :meth:`ManimColor.from_rgba`.

    Parameters
    ----------
    rgba
        A 4 element iterable.

    Returns
    -------
    ManimColor
        A ManimColor with the corresponding value
    """
    return ManimColor.from_rgba(rgba)


</t>
<t tx="ekr.20250122151621.984">def rgb_to_hex(
    rgb: RGB_Array_Float | RGB_Tuple_Float | RGB_Array_Int | RGB_Tuple_Int,
) -&gt; str:
    """Helper function for use in functional style programming. Refer to
    :meth:`ManimColor.from_rgb` and :meth:`ManimColor.to_hex`.

    Parameters
    ----------
    rgb
        A 3 element iterable.

    Returns
    -------
    str
        A hex representation of the color.
    """
    return ManimColor.from_rgb(rgb).to_hex()


</t>
<t tx="ekr.20250122151621.985">def hex_to_rgb(hex_code: str) -&gt; RGB_Array_Float:
    """Helper function for use in functional style programming. Refer to
    :meth:`ManimColor.to_rgb`.

    Parameters
    ----------
    hex_code
        A hex string representing a color.

    Returns
    -------
    RGB_Array_Float
        An RGB array representing the color.
    """
    return ManimColor(hex_code).to_rgb()


</t>
<t tx="ekr.20250122151621.986">def invert_color(color: ManimColorT) -&gt; ManimColorT:
    """Helper function for use in functional style programming. Refer to
    :meth:`ManimColor.invert`

    Parameters
    ----------
    color
        The :class:`ManimColor` to invert.

    Returns
    -------
    ManimColor
        The linearly inverted :class:`ManimColor`.
    """
    return color.invert()


</t>
<t tx="ekr.20250122151621.987">def color_gradient(
    reference_colors: Sequence[ParsableManimColor],
    length_of_output: int,
) -&gt; list[ManimColor] | ManimColor:
    """Create a list of colors interpolated between the input array of colors with a
    specific number of colors.

    Parameters
    ----------
    reference_colors
        The colors to be interpolated between or spread apart.
    length_of_output
        The number of colors that the output should have, ideally more than the input.

    Returns
    -------
    list[ManimColor] | ManimColor
        A :class:`ManimColor` or a list of interpolated :class:`ManimColor`'s.
    """
    if length_of_output == 0:
        return ManimColor(reference_colors[0])
    if len(reference_colors) == 1:
        return [ManimColor(reference_colors[0])] * length_of_output
    rgbs = [color_to_rgb(color) for color in reference_colors]
    alphas = np.linspace(0, (len(rgbs) - 1), length_of_output)
    floors = alphas.astype("int")
    alphas_mod1 = alphas % 1
    # End edge case
    alphas_mod1[-1] = 1
    floors[-1] = len(rgbs) - 2
    return [
        rgb_to_color((rgbs[i] * (1 - alpha)) + (rgbs[i + 1] * alpha))
        for i, alpha in zip(floors, alphas_mod1)
    ]


</t>
<t tx="ekr.20250122151621.988">def interpolate_color(
    color1: ManimColorT, color2: ManimColorT, alpha: float
) -&gt; ManimColorT:
    """Standalone function to interpolate two ManimColors and get the result. Refer to
    :meth:`ManimColor.interpolate`.

    Parameters
    ----------
    color1
        The first :class:`ManimColor`.
    color2
        The second :class:`ManimColor`.
    alpha
        The alpha value determining the point of interpolation between the colors.

    Returns
    -------
    ManimColor
        The interpolated ManimColor.
    """
    return color1.interpolate(color2, alpha)


</t>
<t tx="ekr.20250122151621.989">def average_color(*colors: ParsableManimColor) -&gt; ManimColor:
    """Determine the average color between the given parameters.

    .. note::
        This operation does not consider the alphas (opacities) of the colors. The
        generated color has an alpha or opacity of 1.0.

    Returns
    -------
    ManimColor
        The average color of the input.
    """
    rgbs = np.array([color_to_rgb(color) for color in colors])
    mean_rgb = np.apply_along_axis(np.mean, 0, rgbs)
    return rgb_to_color(mean_rgb)


</t>
<t tx="ekr.20250122151621.99"># TODO: Get rid of this.
def get_pixel_array(self):
    self.pixel_array = self.camera.pixel_array
    return self.pixel_array

</t>
<t tx="ekr.20250122151621.990">def random_bright_color() -&gt; ManimColor:
    """Return a random bright color: a random color averaged with ``WHITE``.

    .. warning::
        This operation is very expensive. Please keep in mind the performance loss.

    Returns
    -------
    ManimColor
        A random bright :class:`ManimColor`.
    """
    curr_rgb = color_to_rgb(random_color())
    new_rgb = 0.5 * (curr_rgb + np.ones(3))
    return ManimColor(new_rgb)


</t>
<t tx="ekr.20250122151621.991">def random_color() -&gt; ManimColor:
    """Return a random :class:`ManimColor`.

    .. warning::
        This operation is very expensive. Please keep in mind the performance loss.

    Returns
    -------
    ManimColor
        A random :class:`ManimColor`.
    """
    import manim.utils.color.manim_colors as manim_colors

    return random.choice(manim_colors._all_manim_colors)


</t>
<t tx="ekr.20250122151621.992">def get_shaded_rgb(
    rgb: RGB_Array_Float,
    point: Point3D,
    unit_normal_vect: Vector3D,
    light_source: Point3D,
) -&gt; RGB_Array_Float:
    """Add light or shadow to the ``rgb`` color of some surface which is located at a
    given ``point`` in space and facing in the direction of ``unit_normal_vect``,
    depending on whether the surface is facing a ``light_source`` or away from it.

    Parameters
    ----------
    rgb
        An RGB array of floats.
    point
        The location of the colored surface.
    unit_normal_vect
        The direction in which the colored surface is facing.
    light_source
        The location of a light source which might illuminate the surface.

    Returns
    -------
    RGB_Array_Float
        The color with added light or shadow, depending on the direction of the colored
        surface.
    """
    to_sun = normalize(light_source - point)
    light = 0.5 * np.dot(unit_normal_vect, to_sun) ** 3
    if light &lt; 0:
        light *= 0.5
    shaded_rgb: RGB_Array_Float = rgb + light
    return shaded_rgb


</t>
<t tx="ekr.20250122151621.993">def __init__(
    self,
    value: ParsableManimColor | None,
    alpha: float = 1.0,
) -&gt; None:
    if value is None:
        self._internal_value = np.array((0, 0, 0, alpha), dtype=ManimColorDType)
    elif isinstance(value, ManimColor):
        # logger.info(
        #     "ManimColor was passed another ManimColor. This is probably not what "
        #     "you want. Created a copy of the passed ManimColor instead."
        # )
        self._internal_value = value._internal_value
    elif isinstance(value, int):
        self._internal_value = ManimColor._internal_from_integer(value, alpha)
    elif isinstance(value, str):
        result = re_hex.search(value)
        if result is not None:
            self._internal_value = ManimColor._internal_from_hex_string(
                result.group(), alpha
            )
        else:
            # This is not expected to be called on module initialization time
            # It can be horribly slow to convert a string to a color because
            # it has to access the dictionary of colors and find the right color
            self._internal_value = ManimColor._internal_from_string(value, alpha)
    elif isinstance(value, (list, tuple, np.ndarray)):
        length = len(value)
        if all(isinstance(x, float) for x in value):
            if length == 3:
                self._internal_value = ManimColor._internal_from_rgb(value, alpha)  # type: ignore[arg-type]
            elif length == 4:
                self._internal_value = ManimColor._internal_from_rgba(value)  # type: ignore[arg-type]
            else:
                raise ValueError(
                    f"ManimColor only accepts lists/tuples/arrays of length 3 or 4, not {length}"
                )
        else:
            if length == 3:
                self._internal_value = ManimColor._internal_from_int_rgb(
                    value,  # type: ignore[arg-type]
                    alpha,
                )
            elif length == 4:
                self._internal_value = ManimColor._internal_from_int_rgba(value)  # type: ignore[arg-type]
            else:
                raise ValueError(
                    f"ManimColor only accepts lists/tuples/arrays of length 3 or 4, not {length}"
                )
    elif hasattr(value, "get_hex") and callable(value.get_hex):
        result = re_hex.search(value.get_hex())
        if result is None:
            raise ValueError(f"Failed to parse a color from {value}")
        self._internal_value = ManimColor._internal_from_hex_string(
            result.group(), alpha
        )
    else:
        # logger.error(f"Invalid color value: {value}")
        raise TypeError(
            "ManimColor only accepts int, str, list[int, int, int], "
            "list[int, int, int, int], list[float, float, float], "
            f"list[float, float, float, float], not {type(value)}"
        )

</t>
<t tx="ekr.20250122151621.994">@property
def _internal_space(self) -&gt; npt.NDArray[ManimFloat]:
    """This is a readonly property which is a custom representation for color space
    operations. It is used for operators and can be used when implementing a custom
    color space.
    """
    return self._internal_value

</t>
<t tx="ekr.20250122151621.995">@property
def _internal_value(self) -&gt; ManimColorInternal:
    """Return the internal value of the current Manim color ``[r,g,b,a]`` float
    array.

    Returns
    -------
    ManimColorInternal
        Internal color representation.
    """
    return self.__value

</t>
<t tx="ekr.20250122151621.996">@_internal_value.setter
def _internal_value(self, value: ManimColorInternal) -&gt; None:
    """Overwrite the internal color value of this :class:`ManimColor`.

    Parameters
    ----------
    value
        The value which will overwrite the current color.

    Raises
    ------
    TypeError
        If an invalid array is passed.
    """
    if not isinstance(value, np.ndarray):
        raise TypeError("Value must be a NumPy array.")
    if value.shape[0] != 4:
        raise TypeError("Array must have exactly 4 values.")
    self.__value: ManimColorInternal = value

</t>
<t tx="ekr.20250122151621.997">@classmethod
def _construct_from_space(
    cls,
    _space: npt.NDArray[ManimFloat]
    | tuple[float, float, float]
    | tuple[float, float, float, float],
) -&gt; Self:
    """This function is used as a proxy for constructing a color with an internal
    value. This can be used by subclasses to hook into the construction of new
    objects using the internal value format.
    """
    return cls(_space)

</t>
<t tx="ekr.20250122151621.998">@staticmethod
def _internal_from_integer(value: int, alpha: float) -&gt; ManimColorInternal:
    return np.asarray(
        (
            ((value &gt;&gt; 16) &amp; 0xFF) / 255,
            ((value &gt;&gt; 8) &amp; 0xFF) / 255,
            ((value &gt;&gt; 0) &amp; 0xFF) / 255,
            alpha,
        ),
        dtype=ManimColorDType,
    )

</t>
<t tx="ekr.20250122151621.999">@staticmethod
def _internal_from_hex_string(hex_: str, alpha: float) -&gt; ManimColorInternal:
    """Internal function for converting a hex string into the internal representation
    of a :class:`ManimColor`.

    .. warning::
        This does not accept any prefixes like # or similar in front of the hex string.
        This is just intended for the raw hex part.

    *For internal use only*

    Parameters
    ----------
    hex
        Hex string to be parsed.
    alpha
        Alpha value used for the color, if the color is only 3 bytes long. Otherwise,
        if the color is 4 bytes long, this parameter will not be used.

    Returns
    -------
    ManimColorInternal
        Internal color representation
    """
    if len(hex_) in (3, 4):
        hex_ = "".join([x * 2 for x in hex_])
    if len(hex_) == 6:
        hex_ += "FF"
    elif len(hex_) == 8:
        alpha = (int(hex_, 16) &amp; 0xFF) / 255
    else:
        raise ValueError(
            "Hex colors must be specified with either 0x or # as prefix and contain 6 or 8 hexadecimal numbers"
        )
    tmp = int(hex_, 16)
    return np.asarray(
        (
            ((tmp &gt;&gt; 24) &amp; 0xFF) / 255,
            ((tmp &gt;&gt; 16) &amp; 0xFF) / 255,
            ((tmp &gt;&gt; 8) &amp; 0xFF) / 255,
            alpha,
        ),
        dtype=ManimColorDType,
    )

</t>
<t tx="ekr.20250122151915.1"># Don't create large diffs.</t>
<t tx="ekr.20250122152209.1"></t>
<t tx="ekr.20250122152515.1">@nosearch

# Word, Head, Body

# found 3 nodes</t>
</tnodes>
</leo_file>
